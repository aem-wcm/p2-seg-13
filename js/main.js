/**!

 @license
 handlebars v4.0.12

 Copyright (C) 2011-2017 by Yehuda Katz

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 */
(function webpackUniversalModuleDefinition(root, factory) {
    if(typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if(typeof define === 'function' && define.amd)
        define([], factory);
    else if(typeof exports === 'object')
        exports["Handlebars"] = factory();
    else
        root["Handlebars"] = factory();
})(this, function() {
    return /******/ (function(modules) { // webpackBootstrap
        /******/ 	// The module cache
        /******/ 	var installedModules = {};

        /******/ 	// The require function
        /******/ 	function __webpack_require__(moduleId) {

            /******/ 		// Check if module is in cache
            /******/ 		if(installedModules[moduleId])
            /******/ 			return installedModules[moduleId].exports;

            /******/ 		// Create a new module (and put it into the cache)
            /******/ 		var module = installedModules[moduleId] = {
                /******/ 			exports: {},
                /******/ 			id: moduleId,
                /******/ 			loaded: false
                /******/ 		};

            /******/ 		// Execute the module function
            /******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

            /******/ 		// Flag the module as loaded
            /******/ 		module.loaded = true;

            /******/ 		// Return the exports of the module
            /******/ 		return module.exports;
            /******/ 	}


        /******/ 	// expose the modules object (__webpack_modules__)
        /******/ 	__webpack_require__.m = modules;

        /******/ 	// expose the module cache
        /******/ 	__webpack_require__.c = installedModules;

        /******/ 	// __webpack_public_path__
        /******/ 	__webpack_require__.p = "";

        /******/ 	// Load entry module and return exports
        /******/ 	return __webpack_require__(0);
        /******/ })
    /************************************************************************/
    /******/ ([
        /* 0 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _handlebarsRuntime = __webpack_require__(2);

            var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);

            // Compiler imports

            var _handlebarsCompilerAst = __webpack_require__(35);

            var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);

            var _handlebarsCompilerBase = __webpack_require__(36);

            var _handlebarsCompilerCompiler = __webpack_require__(41);

            var _handlebarsCompilerJavascriptCompiler = __webpack_require__(42);

            var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);

            var _handlebarsCompilerVisitor = __webpack_require__(39);

            var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);

            var _handlebarsNoConflict = __webpack_require__(34);

            var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

            var _create = _handlebarsRuntime2['default'].create;
            function create() {
                var hb = _create();

                hb.compile = function (input, options) {
                    return _handlebarsCompilerCompiler.compile(input, options, hb);
                };
                hb.precompile = function (input, options) {
                    return _handlebarsCompilerCompiler.precompile(input, options, hb);
                };

                hb.AST = _handlebarsCompilerAst2['default'];
                hb.Compiler = _handlebarsCompilerCompiler.Compiler;
                hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
                hb.Parser = _handlebarsCompilerBase.parser;
                hb.parse = _handlebarsCompilerBase.parse;

                return hb;
            }

            var inst = create();
            inst.create = create;

            _handlebarsNoConflict2['default'](inst);

            inst.Visitor = _handlebarsCompilerVisitor2['default'];

            inst['default'] = inst;

            exports['default'] = inst;
            module.exports = exports['default'];

            /***/ }),
        /* 1 */
        /***/ (function(module, exports) {

            "use strict";

            exports["default"] = function (obj) {
                return obj && obj.__esModule ? obj : {
                    "default": obj
                };
            };

            exports.__esModule = true;

            /***/ }),
        /* 2 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _handlebarsBase = __webpack_require__(4);

            var base = _interopRequireWildcard(_handlebarsBase);

            // Each of these augment the Handlebars object. No need to setup here.
            // (This is done to easily share code between commonjs and browse envs)

            var _handlebarsSafeString = __webpack_require__(21);

            var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

            var _handlebarsException = __webpack_require__(6);

            var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

            var _handlebarsUtils = __webpack_require__(5);

            var Utils = _interopRequireWildcard(_handlebarsUtils);

            var _handlebarsRuntime = __webpack_require__(22);

            var runtime = _interopRequireWildcard(_handlebarsRuntime);

            var _handlebarsNoConflict = __webpack_require__(34);

            var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

            // For compatibility and usage outside of module systems, make the Handlebars object a namespace
            function create() {
                var hb = new base.HandlebarsEnvironment();

                Utils.extend(hb, base);
                hb.SafeString = _handlebarsSafeString2['default'];
                hb.Exception = _handlebarsException2['default'];
                hb.Utils = Utils;
                hb.escapeExpression = Utils.escapeExpression;

                hb.VM = runtime;
                hb.template = function (spec) {
                    return runtime.template(spec, hb);
                };

                return hb;
            }

            var inst = create();
            inst.create = create;

            _handlebarsNoConflict2['default'](inst);

            inst['default'] = inst;

            exports['default'] = inst;
            module.exports = exports['default'];

            /***/ }),
        /* 3 */
        /***/ (function(module, exports) {

            "use strict";

            exports["default"] = function (obj) {
                if (obj && obj.__esModule) {
                    return obj;
                } else {
                    var newObj = {};

                    if (obj != null) {
                        for (var key in obj) {
                            if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                        }
                    }

                    newObj["default"] = obj;
                    return newObj;
                }
            };

            exports.__esModule = true;

            /***/ }),
        /* 4 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.HandlebarsEnvironment = HandlebarsEnvironment;

            var _utils = __webpack_require__(5);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _helpers = __webpack_require__(10);

            var _decorators = __webpack_require__(18);

            var _logger = __webpack_require__(20);

            var _logger2 = _interopRequireDefault(_logger);

            var VERSION = '4.0.12';
            exports.VERSION = VERSION;
            var COMPILER_REVISION = 7;

            exports.COMPILER_REVISION = COMPILER_REVISION;
            var REVISION_CHANGES = {
                1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
                2: '== 1.0.0-rc.3',
                3: '== 1.0.0-rc.4',
                4: '== 1.x.x',
                5: '== 2.0.0-alpha.x',
                6: '>= 2.0.0-beta.1',
                7: '>= 4.0.0'
            };

            exports.REVISION_CHANGES = REVISION_CHANGES;
            var objectType = '[object Object]';

            function HandlebarsEnvironment(helpers, partials, decorators) {
                this.helpers = helpers || {};
                this.partials = partials || {};
                this.decorators = decorators || {};

                _helpers.registerDefaultHelpers(this);
                _decorators.registerDefaultDecorators(this);
            }

            HandlebarsEnvironment.prototype = {
                constructor: HandlebarsEnvironment,

                logger: _logger2['default'],
                log: _logger2['default'].log,

                registerHelper: function registerHelper(name, fn) {
                    if (_utils.toString.call(name) === objectType) {
                        if (fn) {
                            throw new _exception2['default']('Arg not supported with multiple helpers');
                        }
                        _utils.extend(this.helpers, name);
                    } else {
                        this.helpers[name] = fn;
                    }
                },
                unregisterHelper: function unregisterHelper(name) {
                    delete this.helpers[name];
                },

                registerPartial: function registerPartial(name, partial) {
                    if (_utils.toString.call(name) === objectType) {
                        _utils.extend(this.partials, name);
                    } else {
                        if (typeof partial === 'undefined') {
                            throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
                        }
                        this.partials[name] = partial;
                    }
                },
                unregisterPartial: function unregisterPartial(name) {
                    delete this.partials[name];
                },

                registerDecorator: function registerDecorator(name, fn) {
                    if (_utils.toString.call(name) === objectType) {
                        if (fn) {
                            throw new _exception2['default']('Arg not supported with multiple decorators');
                        }
                        _utils.extend(this.decorators, name);
                    } else {
                        this.decorators[name] = fn;
                    }
                },
                unregisterDecorator: function unregisterDecorator(name) {
                    delete this.decorators[name];
                }
            };

            var log = _logger2['default'].log;

            exports.log = log;
            exports.createFrame = _utils.createFrame;
            exports.logger = _logger2['default'];

            /***/ }),
        /* 5 */
        /***/ (function(module, exports) {

            'use strict';

            exports.__esModule = true;
            exports.extend = extend;
            exports.indexOf = indexOf;
            exports.escapeExpression = escapeExpression;
            exports.isEmpty = isEmpty;
            exports.createFrame = createFrame;
            exports.blockParams = blockParams;
            exports.appendContextPath = appendContextPath;
            var escape = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#x27;',
                '`': '&#x60;',
                '=': '&#x3D;'
            };

            var badChars = /[&<>"'`=]/g,
                possible = /[&<>"'`=]/;

            function escapeChar(chr) {
                return escape[chr];
            }

            function extend(obj /* , ...source */) {
                for (var i = 1; i < arguments.length; i++) {
                    for (var key in arguments[i]) {
                        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                            obj[key] = arguments[i][key];
                        }
                    }
                }

                return obj;
            }

            var toString = Object.prototype.toString;

            exports.toString = toString;
            // Sourced from lodash
            // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
            /* eslint-disable func-style */
            var isFunction = function isFunction(value) {
                return typeof value === 'function';
            };
            // fallback for older versions of Chrome and Safari
            /* istanbul ignore next */
            if (isFunction(/x/)) {
                exports.isFunction = isFunction = function (value) {
                    return typeof value === 'function' && toString.call(value) === '[object Function]';
                };
            }
            exports.isFunction = isFunction;

            /* eslint-enable func-style */

            /* istanbul ignore next */
            var isArray = Array.isArray || function (value) {
                return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
            };

            exports.isArray = isArray;
            // Older IE versions do not directly support indexOf so we must implement our own, sadly.

            function indexOf(array, value) {
                for (var i = 0, len = array.length; i < len; i++) {
                    if (array[i] === value) {
                        return i;
                    }
                }
                return -1;
            }

            function escapeExpression(string) {
                if (typeof string !== 'string') {
                    // don't escape SafeStrings, since they're already safe
                    if (string && string.toHTML) {
                        return string.toHTML();
                    } else if (string == null) {
                        return '';
                    } else if (!string) {
                        return string + '';
                    }

                    // Force a string conversion as this will be done by the append regardless and
                    // the regex test will do this transparently behind the scenes, causing issues if
                    // an object's to string has escaped characters in it.
                    string = '' + string;
                }

                if (!possible.test(string)) {
                    return string;
                }
                return string.replace(badChars, escapeChar);
            }

            function isEmpty(value) {
                if (!value && value !== 0) {
                    return true;
                } else if (isArray(value) && value.length === 0) {
                    return true;
                } else {
                    return false;
                }
            }

            function createFrame(object) {
                var frame = extend({}, object);
                frame._parent = object;
                return frame;
            }

            function blockParams(params, ids) {
                params.path = ids;
                return params;
            }

            function appendContextPath(contextPath, id) {
                return (contextPath ? contextPath + '.' : '') + id;
            }

            /***/ }),
        /* 6 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _Object$defineProperty = __webpack_require__(7)['default'];

            exports.__esModule = true;

            var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

            function Exception(message, node) {
                var loc = node && node.loc,
                    line = undefined,
                    column = undefined;
                if (loc) {
                    line = loc.start.line;
                    column = loc.start.column;

                    message += ' - ' + line + ':' + column;
                }

                var tmp = Error.prototype.constructor.call(this, message);

                // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
                for (var idx = 0; idx < errorProps.length; idx++) {
                    this[errorProps[idx]] = tmp[errorProps[idx]];
                }

                /* istanbul ignore else */
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, Exception);
                }

                try {
                    if (loc) {
                        this.lineNumber = line;

                        // Work around issue under safari where we can't directly set the column value
                        /* istanbul ignore next */
                        if (_Object$defineProperty) {
                            Object.defineProperty(this, 'column', {
                                value: column,
                                enumerable: true
                            });
                        } else {
                            this.column = column;
                        }
                    }
                } catch (nop) {
                    /* Ignore if the browser is very particular */
                }
            }

            Exception.prototype = new Error();

            exports['default'] = Exception;
            module.exports = exports['default'];

            /***/ }),
        /* 7 */
        /***/ (function(module, exports, __webpack_require__) {

            module.exports = { "default": __webpack_require__(8), __esModule: true };

            /***/ }),
        /* 8 */
        /***/ (function(module, exports, __webpack_require__) {

            var $ = __webpack_require__(9);
            module.exports = function defineProperty(it, key, desc){
                return $.setDesc(it, key, desc);
            };

            /***/ }),
        /* 9 */
        /***/ (function(module, exports) {

            var $Object = Object;
            module.exports = {
                create:     $Object.create,
                getProto:   $Object.getPrototypeOf,
                isEnum:     {}.propertyIsEnumerable,
                getDesc:    $Object.getOwnPropertyDescriptor,
                setDesc:    $Object.defineProperty,
                setDescs:   $Object.defineProperties,
                getKeys:    $Object.keys,
                getNames:   $Object.getOwnPropertyNames,
                getSymbols: $Object.getOwnPropertySymbols,
                each:       [].forEach
            };

            /***/ }),
        /* 10 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.registerDefaultHelpers = registerDefaultHelpers;

            var _helpersBlockHelperMissing = __webpack_require__(11);

            var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

            var _helpersEach = __webpack_require__(12);

            var _helpersEach2 = _interopRequireDefault(_helpersEach);

            var _helpersHelperMissing = __webpack_require__(13);

            var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

            var _helpersIf = __webpack_require__(14);

            var _helpersIf2 = _interopRequireDefault(_helpersIf);

            var _helpersLog = __webpack_require__(15);

            var _helpersLog2 = _interopRequireDefault(_helpersLog);

            var _helpersLookup = __webpack_require__(16);

            var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

            var _helpersWith = __webpack_require__(17);

            var _helpersWith2 = _interopRequireDefault(_helpersWith);

            function registerDefaultHelpers(instance) {
                _helpersBlockHelperMissing2['default'](instance);
                _helpersEach2['default'](instance);
                _helpersHelperMissing2['default'](instance);
                _helpersIf2['default'](instance);
                _helpersLog2['default'](instance);
                _helpersLookup2['default'](instance);
                _helpersWith2['default'](instance);
            }

            /***/ }),
        /* 11 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('blockHelperMissing', function (context, options) {
                    var inverse = options.inverse,
                        fn = options.fn;

                    if (context === true) {
                        return fn(this);
                    } else if (context === false || context == null) {
                        return inverse(this);
                    } else if (_utils.isArray(context)) {
                        if (context.length > 0) {
                            if (options.ids) {
                                options.ids = [options.name];
                            }

                            return instance.helpers.each(context, options);
                        } else {
                            return inverse(this);
                        }
                    } else {
                        if (options.data && options.ids) {
                            var data = _utils.createFrame(options.data);
                            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
                            options = { data: data };
                        }

                        return fn(context, options);
                    }
                });
            };

            module.exports = exports['default'];

            /***/ }),
        /* 12 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            exports['default'] = function (instance) {
                instance.registerHelper('each', function (context, options) {
                    if (!options) {
                        throw new _exception2['default']('Must pass iterator to #each');
                    }

                    var fn = options.fn,
                        inverse = options.inverse,
                        i = 0,
                        ret = '',
                        data = undefined,
                        contextPath = undefined;

                    if (options.data && options.ids) {
                        contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
                    }

                    if (_utils.isFunction(context)) {
                        context = context.call(this);
                    }

                    if (options.data) {
                        data = _utils.createFrame(options.data);
                    }

                    function execIteration(field, index, last) {
                        if (data) {
                            data.key = field;
                            data.index = index;
                            data.first = index === 0;
                            data.last = !!last;

                            if (contextPath) {
                                data.contextPath = contextPath + field;
                            }
                        }

                        ret = ret + fn(context[field], {
                            data: data,
                            blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
                        });
                    }

                    if (context && typeof context === 'object') {
                        if (_utils.isArray(context)) {
                            for (var j = context.length; i < j; i++) {
                                if (i in context) {
                                    execIteration(i, i, i === context.length - 1);
                                }
                            }
                        } else {
                            var priorKey = undefined;

                            for (var key in context) {
                                if (context.hasOwnProperty(key)) {
                                    // We're running the iterations one step out of sync so we can detect
                                    // the last iteration without have to scan the object twice and create
                                    // an itermediate keys array.
                                    if (priorKey !== undefined) {
                                        execIteration(priorKey, i - 1);
                                    }
                                    priorKey = key;
                                    i++;
                                }
                            }
                            if (priorKey !== undefined) {
                                execIteration(priorKey, i - 1, true);
                            }
                        }
                    }

                    if (i === 0) {
                        ret = inverse(this);
                    }

                    return ret;
                });
            };

            module.exports = exports['default'];

            /***/ }),
        /* 13 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            exports['default'] = function (instance) {
                instance.registerHelper('helperMissing', function () /* [args, ]options */{
                    if (arguments.length === 1) {
                        // A missing field in a {{foo}} construct.
                        return undefined;
                    } else {
                        // Someone is actually trying to call something, blow up.
                        throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                    }
                });
            };

            module.exports = exports['default'];

            /***/ }),
        /* 14 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('if', function (conditional, options) {
                    if (_utils.isFunction(conditional)) {
                        conditional = conditional.call(this);
                    }

                    // Default behavior is to render the positive path if the value is truthy and not empty.
                    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
                    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
                    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
                        return options.inverse(this);
                    } else {
                        return options.fn(this);
                    }
                });

                instance.registerHelper('unless', function (conditional, options) {
                    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
                });
            };

            module.exports = exports['default'];

            /***/ }),
        /* 15 */
        /***/ (function(module, exports) {

            'use strict';

            exports.__esModule = true;

            exports['default'] = function (instance) {
                instance.registerHelper('log', function () /* message, options */{
                    var args = [undefined],
                        options = arguments[arguments.length - 1];
                    for (var i = 0; i < arguments.length - 1; i++) {
                        args.push(arguments[i]);
                    }

                    var level = 1;
                    if (options.hash.level != null) {
                        level = options.hash.level;
                    } else if (options.data && options.data.level != null) {
                        level = options.data.level;
                    }
                    args[0] = level;

                    instance.log.apply(instance, args);
                });
            };

            module.exports = exports['default'];

            /***/ }),
        /* 16 */
        /***/ (function(module, exports) {

            'use strict';

            exports.__esModule = true;

            exports['default'] = function (instance) {
                instance.registerHelper('lookup', function (obj, field) {
                    return obj && obj[field];
                });
            };

            module.exports = exports['default'];

            /***/ }),
        /* 17 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerHelper('with', function (context, options) {
                    if (_utils.isFunction(context)) {
                        context = context.call(this);
                    }

                    var fn = options.fn;

                    if (!_utils.isEmpty(context)) {
                        var data = options.data;
                        if (options.data && options.ids) {
                            data = _utils.createFrame(options.data);
                            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
                        }

                        return fn(context, {
                            data: data,
                            blockParams: _utils.blockParams([context], [data && data.contextPath])
                        });
                    } else {
                        return options.inverse(this);
                    }
                });
            };

            module.exports = exports['default'];

            /***/ }),
        /* 18 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.registerDefaultDecorators = registerDefaultDecorators;

            var _decoratorsInline = __webpack_require__(19);

            var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

            function registerDefaultDecorators(instance) {
                _decoratorsInline2['default'](instance);
            }

            /***/ }),
        /* 19 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            exports['default'] = function (instance) {
                instance.registerDecorator('inline', function (fn, props, container, options) {
                    var ret = fn;
                    if (!props.partials) {
                        props.partials = {};
                        ret = function (context, options) {
                            // Create a new partials stack frame prior to exec.
                            var original = container.partials;
                            container.partials = _utils.extend({}, original, props.partials);
                            var ret = fn(context, options);
                            container.partials = original;
                            return ret;
                        };
                    }

                    props.partials[options.args[0]] = options.fn;

                    return ret;
                });
            };

            module.exports = exports['default'];

            /***/ }),
        /* 20 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var logger = {
                methodMap: ['debug', 'info', 'warn', 'error'],
                level: 'info',

                // Maps a given level value to the `methodMap` indexes above.
                lookupLevel: function lookupLevel(level) {
                    if (typeof level === 'string') {
                        var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
                        if (levelMap >= 0) {
                            level = levelMap;
                        } else {
                            level = parseInt(level, 10);
                        }
                    }

                    return level;
                },

                // Can be overridden in the host environment
                log: function log(level) {
                    level = logger.lookupLevel(level);

                    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
                        var method = logger.methodMap[level];
                        if (!console[method]) {
                            // eslint-disable-line no-console
                            method = 'log';
                        }

                        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                            message[_key - 1] = arguments[_key];
                        }

                        console[method].apply(console, message); // eslint-disable-line no-console
                    }
                }
            };

            exports['default'] = logger;
            module.exports = exports['default'];

            /***/ }),
        /* 21 */
        /***/ (function(module, exports) {

            // Build out our basic SafeString type
            'use strict';

            exports.__esModule = true;
            function SafeString(string) {
                this.string = string;
            }

            SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
                return '' + this.string;
            };

            exports['default'] = SafeString;
            module.exports = exports['default'];

            /***/ }),
        /* 22 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _Object$seal = __webpack_require__(23)['default'];

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.checkRevision = checkRevision;
            exports.template = template;
            exports.wrapProgram = wrapProgram;
            exports.resolvePartial = resolvePartial;
            exports.invokePartial = invokePartial;
            exports.noop = noop;

            var _utils = __webpack_require__(5);

            var Utils = _interopRequireWildcard(_utils);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _base = __webpack_require__(4);

            function checkRevision(compilerInfo) {
                var compilerRevision = compilerInfo && compilerInfo[0] || 1,
                    currentRevision = _base.COMPILER_REVISION;

                if (compilerRevision !== currentRevision) {
                    if (compilerRevision < currentRevision) {
                        var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
                            compilerVersions = _base.REVISION_CHANGES[compilerRevision];
                        throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
                    } else {
                        // Use the embedded version info since the runtime doesn't know about this revision yet
                        throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
                    }
                }
            }

            function template(templateSpec, env) {
                /* istanbul ignore next */
                if (!env) {
                    throw new _exception2['default']('No environment passed to template');
                }
                if (!templateSpec || !templateSpec.main) {
                    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
                }

                templateSpec.main.decorator = templateSpec.main_d;

                // Note: Using env.VM references rather than local var references throughout this section to allow
                // for external users to override these as psuedo-supported APIs.
                env.VM.checkRevision(templateSpec.compiler);

                function invokePartialWrapper(partial, context, options) {
                    if (options.hash) {
                        context = Utils.extend({}, context, options.hash);
                        if (options.ids) {
                            options.ids[0] = true;
                        }
                    }

                    partial = env.VM.resolvePartial.call(this, partial, context, options);
                    var result = env.VM.invokePartial.call(this, partial, context, options);

                    if (result == null && env.compile) {
                        options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
                        result = options.partials[options.name](context, options);
                    }
                    if (result != null) {
                        if (options.indent) {
                            var lines = result.split('\n');
                            for (var i = 0, l = lines.length; i < l; i++) {
                                if (!lines[i] && i + 1 === l) {
                                    break;
                                }

                                lines[i] = options.indent + lines[i];
                            }
                            result = lines.join('\n');
                        }
                        return result;
                    } else {
                        throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
                    }
                }

                // Just add water
                var container = {
                    strict: function strict(obj, name) {
                        if (!(name in obj)) {
                            throw new _exception2['default']('"' + name + '" not defined in ' + obj);
                        }
                        return obj[name];
                    },
                    lookup: function lookup(depths, name) {
                        var len = depths.length;
                        for (var i = 0; i < len; i++) {
                            if (depths[i] && depths[i][name] != null) {
                                return depths[i][name];
                            }
                        }
                    },
                    lambda: function lambda(current, context) {
                        return typeof current === 'function' ? current.call(context) : current;
                    },

                    escapeExpression: Utils.escapeExpression,
                    invokePartial: invokePartialWrapper,

                    fn: function fn(i) {
                        var ret = templateSpec[i];
                        ret.decorator = templateSpec[i + '_d'];
                        return ret;
                    },

                    programs: [],
                    program: function program(i, data, declaredBlockParams, blockParams, depths) {
                        var programWrapper = this.programs[i],
                            fn = this.fn(i);
                        if (data || depths || blockParams || declaredBlockParams) {
                            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                        } else if (!programWrapper) {
                            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                        }
                        return programWrapper;
                    },

                    data: function data(value, depth) {
                        while (value && depth--) {
                            value = value._parent;
                        }
                        return value;
                    },
                    merge: function merge(param, common) {
                        var obj = param || common;

                        if (param && common && param !== common) {
                            obj = Utils.extend({}, common, param);
                        }

                        return obj;
                    },
                    // An empty object to use as replacement for null-contexts
                    nullContext: _Object$seal({}),

                    noop: env.VM.noop,
                    compilerInfo: templateSpec.compiler
                };

                function ret(context) {
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    var data = options.data;

                    ret._setup(options);
                    if (!options.partial && templateSpec.useData) {
                        data = initData(context, data);
                    }
                    var depths = undefined,
                        blockParams = templateSpec.useBlockParams ? [] : undefined;
                    if (templateSpec.useDepths) {
                        if (options.depths) {
                            depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
                        } else {
                            depths = [context];
                        }
                    }

                    function main(context /*, options*/) {
                        return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
                    }
                    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
                    return main(context, options);
                }
                ret.isTop = true;

                ret._setup = function (options) {
                    if (!options.partial) {
                        container.helpers = container.merge(options.helpers, env.helpers);

                        if (templateSpec.usePartial) {
                            container.partials = container.merge(options.partials, env.partials);
                        }
                        if (templateSpec.usePartial || templateSpec.useDecorators) {
                            container.decorators = container.merge(options.decorators, env.decorators);
                        }
                    } else {
                        container.helpers = options.helpers;
                        container.partials = options.partials;
                        container.decorators = options.decorators;
                    }
                };

                ret._child = function (i, data, blockParams, depths) {
                    if (templateSpec.useBlockParams && !blockParams) {
                        throw new _exception2['default']('must pass block params');
                    }
                    if (templateSpec.useDepths && !depths) {
                        throw new _exception2['default']('must pass parent depths');
                    }

                    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
                };
                return ret;
            }

            function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
                function prog(context) {
                    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                    var currentDepths = depths;
                    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
                        currentDepths = [context].concat(depths);
                    }

                    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
                }

                prog = executeDecorators(fn, prog, container, depths, data, blockParams);

                prog.program = i;
                prog.depth = depths ? depths.length : 0;
                prog.blockParams = declaredBlockParams || 0;
                return prog;
            }

            function resolvePartial(partial, context, options) {
                if (!partial) {
                    if (options.name === '@partial-block') {
                        partial = options.data['partial-block'];
                    } else {
                        partial = options.partials[options.name];
                    }
                } else if (!partial.call && !options.name) {
                    // This is a dynamic partial that returned a string
                    options.name = partial;
                    partial = options.partials[partial];
                }
                return partial;
            }

            function invokePartial(partial, context, options) {
                // Use the current closure context to save the partial-block if this partial
                var currentPartialBlock = options.data && options.data['partial-block'];
                options.partial = true;
                if (options.ids) {
                    options.data.contextPath = options.ids[0] || options.data.contextPath;
                }

                var partialBlock = undefined;
                if (options.fn && options.fn !== noop) {
                    (function () {
                        options.data = _base.createFrame(options.data);
                        // Wrapper function to get access to currentPartialBlock from the closure
                        var fn = options.fn;
                        partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
                            var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

                            // Restore the partial-block from the closure for the execution of the block
                            // i.e. the part inside the block of the partial call.
                            options.data = _base.createFrame(options.data);
                            options.data['partial-block'] = currentPartialBlock;
                            return fn(context, options);
                        };
                        if (fn.partials) {
                            options.partials = Utils.extend({}, options.partials, fn.partials);
                        }
                    })();
                }

                if (partial === undefined && partialBlock) {
                    partial = partialBlock;
                }

                if (partial === undefined) {
                    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
                } else if (partial instanceof Function) {
                    return partial(context, options);
                }
            }

            function noop() {
                return '';
            }

            function initData(context, data) {
                if (!data || !('root' in data)) {
                    data = data ? _base.createFrame(data) : {};
                    data.root = context;
                }
                return data;
            }

            function executeDecorators(fn, prog, container, depths, data, blockParams) {
                if (fn.decorator) {
                    var props = {};
                    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                    Utils.extend(prog, props);
                }
                return prog;
            }

            /***/ }),
        /* 23 */
        /***/ (function(module, exports, __webpack_require__) {

            module.exports = { "default": __webpack_require__(24), __esModule: true };

            /***/ }),
        /* 24 */
        /***/ (function(module, exports, __webpack_require__) {

            __webpack_require__(25);
            module.exports = __webpack_require__(30).Object.seal;

            /***/ }),
        /* 25 */
        /***/ (function(module, exports, __webpack_require__) {

            // 19.1.2.17 Object.seal(O)
            var isObject = __webpack_require__(26);

            __webpack_require__(27)('seal', function($seal){
                return function seal(it){
                    return $seal && isObject(it) ? $seal(it) : it;
                };
            });

            /***/ }),
        /* 26 */
        /***/ (function(module, exports) {

            module.exports = function(it){
                return typeof it === 'object' ? it !== null : typeof it === 'function';
            };

            /***/ }),
        /* 27 */
        /***/ (function(module, exports, __webpack_require__) {

            // most Object methods by ES6 should accept primitives
            var $export = __webpack_require__(28)
                , core    = __webpack_require__(30)
                , fails   = __webpack_require__(33);
            module.exports = function(KEY, exec){
                var fn  = (core.Object || {})[KEY] || Object[KEY]
                    , exp = {};
                exp[KEY] = exec(fn);
                $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
            };

            /***/ }),
        /* 28 */
        /***/ (function(module, exports, __webpack_require__) {

            var global    = __webpack_require__(29)
                , core      = __webpack_require__(30)
                , ctx       = __webpack_require__(31)
                , PROTOTYPE = 'prototype';

            var $export = function(type, name, source){
                var IS_FORCED = type & $export.F
                    , IS_GLOBAL = type & $export.G
                    , IS_STATIC = type & $export.S
                    , IS_PROTO  = type & $export.P
                    , IS_BIND   = type & $export.B
                    , IS_WRAP   = type & $export.W
                    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
                    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
                    , key, own, out;
                if(IS_GLOBAL)source = name;
                for(key in source){
                    // contains in native
                    own = !IS_FORCED && target && key in target;
                    if(own && key in exports)continue;
                    // export native or passed
                    out = own ? target[key] : source[key];
                    // prevent global pollution for namespaces
                    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
                        // bind timers to global for call from export context
                        : IS_BIND && own ? ctx(out, global)
                            // wrap global constructors for prevent change them in library
                            : IS_WRAP && target[key] == out ? (function(C){
                                var F = function(param){
                                    return this instanceof C ? new C(param) : C(param);
                                };
                                F[PROTOTYPE] = C[PROTOTYPE];
                                return F;
                                // make static versions for prototype methods
                            })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
                    if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
                }
            };
            // type bitmap
            $export.F = 1;  // forced
            $export.G = 2;  // global
            $export.S = 4;  // static
            $export.P = 8;  // proto
            $export.B = 16; // bind
            $export.W = 32; // wrap
            module.exports = $export;

            /***/ }),
        /* 29 */
        /***/ (function(module, exports) {

            // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
            var global = module.exports = typeof window != 'undefined' && window.Math == Math
                ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
            if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

            /***/ }),
        /* 30 */
        /***/ (function(module, exports) {

            var core = module.exports = {version: '1.2.6'};
            if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

            /***/ }),
        /* 31 */
        /***/ (function(module, exports, __webpack_require__) {

            // optional / simple context binding
            var aFunction = __webpack_require__(32);
            module.exports = function(fn, that, length){
                aFunction(fn);
                if(that === undefined)return fn;
                switch(length){
                    case 1: return function(a){
                        return fn.call(that, a);
                    };
                    case 2: return function(a, b){
                        return fn.call(that, a, b);
                    };
                    case 3: return function(a, b, c){
                        return fn.call(that, a, b, c);
                    };
                }
                return function(/* ...args */){
                    return fn.apply(that, arguments);
                };
            };

            /***/ }),
        /* 32 */
        /***/ (function(module, exports) {

            module.exports = function(it){
                if(typeof it != 'function')throw TypeError(it + ' is not a function!');
                return it;
            };

            /***/ }),
        /* 33 */
        /***/ (function(module, exports) {

            module.exports = function(exec){
                try {
                    return !!exec();
                } catch(e){
                    return true;
                }
            };

            /***/ }),
        /* 34 */
        /***/ (function(module, exports) {

            /* WEBPACK VAR INJECTION */(function(global) {/* global window */
                'use strict';

                exports.__esModule = true;

                exports['default'] = function (Handlebars) {
                    /* istanbul ignore next */
                    var root = typeof global !== 'undefined' ? global : window,
                        $Handlebars = root.Handlebars;
                    /* istanbul ignore next */
                    Handlebars.noConflict = function () {
                        if (root.Handlebars === Handlebars) {
                            root.Handlebars = $Handlebars;
                        }
                        return Handlebars;
                    };
                };

                module.exports = exports['default'];
                /* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

            /***/ }),
        /* 35 */
        /***/ (function(module, exports) {

            'use strict';

            exports.__esModule = true;
            var AST = {
                // Public API used to evaluate derived attributes regarding AST nodes
                helpers: {
                    // a mustache is definitely a helper if:
                    // * it is an eligible helper, and
                    // * it has at least one parameter or hash segment
                    helperExpression: function helperExpression(node) {
                        return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
                    },

                    scopedId: function scopedId(path) {
                        return (/^\.|this\b/.test(path.original)
                        );
                    },

                    // an ID is simple if it only has one part, and that part is not
                    // `..` or `this`.
                    simpleId: function simpleId(path) {
                        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
                    }
                }
            };

            // Must be exported as an object rather than the root of the module as the jison lexer
            // must modify the object to operate properly.
            exports['default'] = AST;
            module.exports = exports['default'];

            /***/ }),
        /* 36 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            var _interopRequireWildcard = __webpack_require__(3)['default'];

            exports.__esModule = true;
            exports.parse = parse;

            var _parser = __webpack_require__(37);

            var _parser2 = _interopRequireDefault(_parser);

            var _whitespaceControl = __webpack_require__(38);

            var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);

            var _helpers = __webpack_require__(40);

            var Helpers = _interopRequireWildcard(_helpers);

            var _utils = __webpack_require__(5);

            exports.parser = _parser2['default'];

            var yy = {};
            _utils.extend(yy, Helpers);

            function parse(input, options) {
                // Just return if an already-compiled AST was passed in.
                if (input.type === 'Program') {
                    return input;
                }

                _parser2['default'].yy = yy;

                // Altering the shared object here, but this is ok as parser is a sync operation
                yy.locInfo = function (locInfo) {
                    return new yy.SourceLocation(options && options.srcName, locInfo);
                };

                var strip = new _whitespaceControl2['default'](options);
                return strip.accept(_parser2['default'].parse(input));
            }

            /***/ }),
        /* 37 */
        /***/ (function(module, exports) {

            // File ignored in coverage tests via setting in .istanbul.yml
            /* Jison generated parser */
            "use strict";

            exports.__esModule = true;
            var handlebars = (function () {
                var parser = { trace: function trace() {},
                    yy: {},
                    symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
                    terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
                    productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
                    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
                                                      /**/) {

                        var $0 = $$.length - 1;
                        switch (yystate) {
                            case 1:
                                return $$[$0 - 1];
                                break;
                            case 2:
                                this.$ = yy.prepareProgram($$[$0]);
                                break;
                            case 3:
                                this.$ = $$[$0];
                                break;
                            case 4:
                                this.$ = $$[$0];
                                break;
                            case 5:
                                this.$ = $$[$0];
                                break;
                            case 6:
                                this.$ = $$[$0];
                                break;
                            case 7:
                                this.$ = $$[$0];
                                break;
                            case 8:
                                this.$ = $$[$0];
                                break;
                            case 9:
                                this.$ = {
                                    type: 'CommentStatement',
                                    value: yy.stripComment($$[$0]),
                                    strip: yy.stripFlags($$[$0], $$[$0]),
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 10:
                                this.$ = {
                                    type: 'ContentStatement',
                                    original: $$[$0],
                                    value: $$[$0],
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 11:
                                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                break;
                            case 12:
                                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                                break;
                            case 13:
                                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                                break;
                            case 14:
                                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                                break;
                            case 15:
                                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                break;
                            case 16:
                                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                break;
                            case 17:
                                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                                break;
                            case 18:
                                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                                break;
                            case 19:
                                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                                    program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                                program.chained = true;

                                this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

                                break;
                            case 20:
                                this.$ = $$[$0];
                                break;
                            case 21:
                                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                                break;
                            case 22:
                                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                break;
                            case 23:
                                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                                break;
                            case 24:
                                this.$ = {
                                    type: 'PartialStatement',
                                    name: $$[$0 - 3],
                                    params: $$[$0 - 2],
                                    hash: $$[$0 - 1],
                                    indent: '',
                                    strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 25:
                                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                                break;
                            case 26:
                                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                                break;
                            case 27:
                                this.$ = $$[$0];
                                break;
                            case 28:
                                this.$ = $$[$0];
                                break;
                            case 29:
                                this.$ = {
                                    type: 'SubExpression',
                                    path: $$[$0 - 3],
                                    params: $$[$0 - 2],
                                    hash: $$[$0 - 1],
                                    loc: yy.locInfo(this._$)
                                };

                                break;
                            case 30:
                                this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
                                break;
                            case 31:
                                this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                                break;
                            case 32:
                                this.$ = yy.id($$[$0 - 1]);
                                break;
                            case 33:
                                this.$ = $$[$0];
                                break;
                            case 34:
                                this.$ = $$[$0];
                                break;
                            case 35:
                                this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                                break;
                            case 36:
                                this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                                break;
                            case 37:
                                this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
                                break;
                            case 38:
                                this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
                                break;
                            case 39:
                                this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
                                break;
                            case 40:
                                this.$ = $$[$0];
                                break;
                            case 41:
                                this.$ = $$[$0];
                                break;
                            case 42:
                                this.$ = yy.preparePath(true, $$[$0], this._$);
                                break;
                            case 43:
                                this.$ = yy.preparePath(false, $$[$0], this._$);
                                break;
                            case 44:
                                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
                                break;
                            case 45:
                                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                                break;
                            case 46:
                                this.$ = [];
                                break;
                            case 47:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 48:
                                this.$ = [$$[$0]];
                                break;
                            case 49:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 50:
                                this.$ = [];
                                break;
                            case 51:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 58:
                                this.$ = [];
                                break;
                            case 59:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 64:
                                this.$ = [];
                                break;
                            case 65:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 70:
                                this.$ = [];
                                break;
                            case 71:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 78:
                                this.$ = [];
                                break;
                            case 79:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 82:
                                this.$ = [];
                                break;
                            case 83:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 86:
                                this.$ = [];
                                break;
                            case 87:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 90:
                                this.$ = [];
                                break;
                            case 91:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 94:
                                this.$ = [];
                                break;
                            case 95:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 98:
                                this.$ = [$$[$0]];
                                break;
                            case 99:
                                $$[$0 - 1].push($$[$0]);
                                break;
                            case 100:
                                this.$ = [$$[$0]];
                                break;
                            case 101:
                                $$[$0 - 1].push($$[$0]);
                                break;
                        }
                    },
                    table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
                    defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
                    parseError: function parseError(str, hash) {
                        throw new Error(str);
                    },
                    parse: function parse(input) {
                        var self = this,
                            stack = [0],
                            vstack = [null],
                            lstack = [],
                            table = this.table,
                            yytext = "",
                            yylineno = 0,
                            yyleng = 0,
                            recovering = 0,
                            TERROR = 2,
                            EOF = 1;
                        this.lexer.setInput(input);
                        this.lexer.yy = this.yy;
                        this.yy.lexer = this.lexer;
                        this.yy.parser = this;
                        if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
                        var yyloc = this.lexer.yylloc;
                        lstack.push(yyloc);
                        var ranges = this.lexer.options && this.lexer.options.ranges;
                        if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
                        function popStack(n) {
                            stack.length = stack.length - 2 * n;
                            vstack.length = vstack.length - n;
                            lstack.length = lstack.length - n;
                        }
                        function lex() {
                            var token;
                            token = self.lexer.lex() || 1;
                            if (typeof token !== "number") {
                                token = self.symbols_[token] || token;
                            }
                            return token;
                        }
                        var symbol,
                            preErrorSymbol,
                            state,
                            action,
                            a,
                            r,
                            yyval = {},
                            p,
                            len,
                            newState,
                            expected;
                        while (true) {
                            state = stack[stack.length - 1];
                            if (this.defaultActions[state]) {
                                action = this.defaultActions[state];
                            } else {
                                if (symbol === null || typeof symbol == "undefined") {
                                    symbol = lex();
                                }
                                action = table[state] && table[state][symbol];
                            }
                            if (typeof action === "undefined" || !action.length || !action[0]) {
                                var errStr = "";
                                if (!recovering) {
                                    expected = [];
                                    for (p in table[state]) if (this.terminals_[p] && p > 2) {
                                        expected.push("'" + this.terminals_[p] + "'");
                                    }
                                    if (this.lexer.showPosition) {
                                        errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                                    } else {
                                        errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                                    }
                                    this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                                }
                            }
                            if (action[0] instanceof Array && action.length > 1) {
                                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                            }
                            switch (action[0]) {
                                case 1:
                                    stack.push(symbol);
                                    vstack.push(this.lexer.yytext);
                                    lstack.push(this.lexer.yylloc);
                                    stack.push(action[1]);
                                    symbol = null;
                                    if (!preErrorSymbol) {
                                        yyleng = this.lexer.yyleng;
                                        yytext = this.lexer.yytext;
                                        yylineno = this.lexer.yylineno;
                                        yyloc = this.lexer.yylloc;
                                        if (recovering > 0) recovering--;
                                    } else {
                                        symbol = preErrorSymbol;
                                        preErrorSymbol = null;
                                    }
                                    break;
                                case 2:
                                    len = this.productions_[action[1]][1];
                                    yyval.$ = vstack[vstack.length - len];
                                    yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                                    if (ranges) {
                                        yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                                    }
                                    r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                                    if (typeof r !== "undefined") {
                                        return r;
                                    }
                                    if (len) {
                                        stack = stack.slice(0, -1 * len * 2);
                                        vstack = vstack.slice(0, -1 * len);
                                        lstack = lstack.slice(0, -1 * len);
                                    }
                                    stack.push(this.productions_[action[1]][0]);
                                    vstack.push(yyval.$);
                                    lstack.push(yyval._$);
                                    newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                                    stack.push(newState);
                                    break;
                                case 3:
                                    return true;
                            }
                        }
                        return true;
                    }
                };
                /* Jison generated lexer */
                var lexer = (function () {
                    var lexer = { EOF: 1,
                        parseError: function parseError(str, hash) {
                            if (this.yy.parser) {
                                this.yy.parser.parseError(str, hash);
                            } else {
                                throw new Error(str);
                            }
                        },
                        setInput: function setInput(input) {
                            this._input = input;
                            this._more = this._less = this.done = false;
                            this.yylineno = this.yyleng = 0;
                            this.yytext = this.matched = this.match = '';
                            this.conditionStack = ['INITIAL'];
                            this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                            if (this.options.ranges) this.yylloc.range = [0, 0];
                            this.offset = 0;
                            return this;
                        },
                        input: function input() {
                            var ch = this._input[0];
                            this.yytext += ch;
                            this.yyleng++;
                            this.offset++;
                            this.match += ch;
                            this.matched += ch;
                            var lines = ch.match(/(?:\r\n?|\n).*/g);
                            if (lines) {
                                this.yylineno++;
                                this.yylloc.last_line++;
                            } else {
                                this.yylloc.last_column++;
                            }
                            if (this.options.ranges) this.yylloc.range[1]++;

                            this._input = this._input.slice(1);
                            return ch;
                        },
                        unput: function unput(ch) {
                            var len = ch.length;
                            var lines = ch.split(/(?:\r\n?|\n)/g);

                            this._input = ch + this._input;
                            this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                            //this.yyleng -= len;
                            this.offset -= len;
                            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                            this.match = this.match.substr(0, this.match.length - 1);
                            this.matched = this.matched.substr(0, this.matched.length - 1);

                            if (lines.length - 1) this.yylineno -= lines.length - 1;
                            var r = this.yylloc.range;

                            this.yylloc = { first_line: this.yylloc.first_line,
                                last_line: this.yylineno + 1,
                                first_column: this.yylloc.first_column,
                                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                            };

                            if (this.options.ranges) {
                                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                            }
                            return this;
                        },
                        more: function more() {
                            this._more = true;
                            return this;
                        },
                        less: function less(n) {
                            this.unput(this.match.slice(n));
                        },
                        pastInput: function pastInput() {
                            var past = this.matched.substr(0, this.matched.length - this.match.length);
                            return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
                        },
                        upcomingInput: function upcomingInput() {
                            var next = this.match;
                            if (next.length < 20) {
                                next += this._input.substr(0, 20 - next.length);
                            }
                            return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
                        },
                        showPosition: function showPosition() {
                            var pre = this.pastInput();
                            var c = new Array(pre.length + 1).join("-");
                            return pre + this.upcomingInput() + "\n" + c + "^";
                        },
                        next: function next() {
                            if (this.done) {
                                return this.EOF;
                            }
                            if (!this._input) this.done = true;

                            var token, match, tempMatch, index, col, lines;
                            if (!this._more) {
                                this.yytext = '';
                                this.match = '';
                            }
                            var rules = this._currentRules();
                            for (var i = 0; i < rules.length; i++) {
                                tempMatch = this._input.match(this.rules[rules[i]]);
                                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                                    match = tempMatch;
                                    index = i;
                                    if (!this.options.flex) break;
                                }
                            }
                            if (match) {
                                lines = match[0].match(/(?:\r\n?|\n).*/g);
                                if (lines) this.yylineno += lines.length;
                                this.yylloc = { first_line: this.yylloc.last_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.last_column,
                                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
                                this.yytext += match[0];
                                this.match += match[0];
                                this.matches = match;
                                this.yyleng = this.yytext.length;
                                if (this.options.ranges) {
                                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
                                }
                                this._more = false;
                                this._input = this._input.slice(match[0].length);
                                this.matched += match[0];
                                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                                if (this.done && this._input) this.done = false;
                                if (token) return token;else return;
                            }
                            if (this._input === "") {
                                return this.EOF;
                            } else {
                                return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
                            }
                        },
                        lex: function lex() {
                            var r = this.next();
                            if (typeof r !== 'undefined') {
                                return r;
                            } else {
                                return this.lex();
                            }
                        },
                        begin: function begin(condition) {
                            this.conditionStack.push(condition);
                        },
                        popState: function popState() {
                            return this.conditionStack.pop();
                        },
                        _currentRules: function _currentRules() {
                            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                        },
                        topState: function topState() {
                            return this.conditionStack[this.conditionStack.length - 2];
                        },
                        pushState: function begin(condition) {
                            this.begin(condition);
                        } };
                    lexer.options = {};
                    lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
                                                             /**/) {

                        function strip(start, end) {
                            return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                        }

                        var YYSTATE = YY_START;
                        switch ($avoiding_name_collisions) {
                            case 0:
                                if (yy_.yytext.slice(-2) === "\\\\") {
                                    strip(0, 1);
                                    this.begin("mu");
                                } else if (yy_.yytext.slice(-1) === "\\") {
                                    strip(0, 1);
                                    this.begin("emu");
                                } else {
                                    this.begin("mu");
                                }
                                if (yy_.yytext) return 15;

                                break;
                            case 1:
                                return 15;
                                break;
                            case 2:
                                this.popState();
                                return 15;

                                break;
                            case 3:
                                this.begin('raw');return 15;
                                break;
                            case 4:
                                this.popState();
                                // Should be using `this.topState()` below, but it currently
                                // returns the second top instead of the first top. Opened an
                                // issue about it at https://github.com/zaach/jison/issues/291
                                if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
                                    return 15;
                                } else {
                                    yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                                    return 'END_RAW_BLOCK';
                                }

                                break;
                            case 5:
                                return 15;
                                break;
                            case 6:
                                this.popState();
                                return 14;

                                break;
                            case 7:
                                return 65;
                                break;
                            case 8:
                                return 68;
                                break;
                            case 9:
                                return 19;
                                break;
                            case 10:
                                this.popState();
                                this.begin('raw');
                                return 23;

                                break;
                            case 11:
                                return 55;
                                break;
                            case 12:
                                return 60;
                                break;
                            case 13:
                                return 29;
                                break;
                            case 14:
                                return 47;
                                break;
                            case 15:
                                this.popState();return 44;
                                break;
                            case 16:
                                this.popState();return 44;
                                break;
                            case 17:
                                return 34;
                                break;
                            case 18:
                                return 39;
                                break;
                            case 19:
                                return 51;
                                break;
                            case 20:
                                return 48;
                                break;
                            case 21:
                                this.unput(yy_.yytext);
                                this.popState();
                                this.begin('com');

                                break;
                            case 22:
                                this.popState();
                                return 14;

                                break;
                            case 23:
                                return 48;
                                break;
                            case 24:
                                return 73;
                                break;
                            case 25:
                                return 72;
                                break;
                            case 26:
                                return 72;
                                break;
                            case 27:
                                return 87;
                                break;
                            case 28:
                                // ignore whitespace
                                break;
                            case 29:
                                this.popState();return 54;
                                break;
                            case 30:
                                this.popState();return 33;
                                break;
                            case 31:
                                yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
                                break;
                            case 32:
                                yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
                                break;
                            case 33:
                                return 85;
                                break;
                            case 34:
                                return 82;
                                break;
                            case 35:
                                return 82;
                                break;
                            case 36:
                                return 83;
                                break;
                            case 37:
                                return 84;
                                break;
                            case 38:
                                return 81;
                                break;
                            case 39:
                                return 75;
                                break;
                            case 40:
                                return 77;
                                break;
                            case 41:
                                return 72;
                                break;
                            case 42:
                                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
                                break;
                            case 43:
                                return 'INVALID';
                                break;
                            case 44:
                                return 5;
                                break;
                        }
                    };
                    lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
                    lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
                    return lexer;
                })();
                parser.lexer = lexer;
                function Parser() {
                    this.yy = {};
                }Parser.prototype = parser;parser.Parser = Parser;
                return new Parser();
            })();exports["default"] = handlebars;
            module.exports = exports["default"];

            /***/ }),
        /* 38 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _visitor = __webpack_require__(39);

            var _visitor2 = _interopRequireDefault(_visitor);

            function WhitespaceControl() {
                var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

                this.options = options;
            }
            WhitespaceControl.prototype = new _visitor2['default']();

            WhitespaceControl.prototype.Program = function (program) {
                var doStandalone = !this.options.ignoreStandalone;

                var isRoot = !this.isRootSeen;
                this.isRootSeen = true;

                var body = program.body;
                for (var i = 0, l = body.length; i < l; i++) {
                    var current = body[i],
                        strip = this.accept(current);

                    if (!strip) {
                        continue;
                    }

                    var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
                        _isNextWhitespace = isNextWhitespace(body, i, isRoot),
                        openStandalone = strip.openStandalone && _isPrevWhitespace,
                        closeStandalone = strip.closeStandalone && _isNextWhitespace,
                        inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

                    if (strip.close) {
                        omitRight(body, i, true);
                    }
                    if (strip.open) {
                        omitLeft(body, i, true);
                    }

                    if (doStandalone && inlineStandalone) {
                        omitRight(body, i);

                        if (omitLeft(body, i)) {
                            // If we are on a standalone node, save the indent info for partials
                            if (current.type === 'PartialStatement') {
                                // Pull out the whitespace from the final line
                                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
                            }
                        }
                    }
                    if (doStandalone && openStandalone) {
                        omitRight((current.program || current.inverse).body);

                        // Strip out the previous content node if it's whitespace only
                        omitLeft(body, i);
                    }
                    if (doStandalone && closeStandalone) {
                        // Always strip the next node
                        omitRight(body, i);

                        omitLeft((current.inverse || current.program).body);
                    }
                }

                return program;
            };

            WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
                this.accept(block.program);
                this.accept(block.inverse);

                // Find the inverse program that is involed with whitespace stripping.
                var program = block.program || block.inverse,
                    inverse = block.program && block.inverse,
                    firstInverse = inverse,
                    lastInverse = inverse;

                if (inverse && inverse.chained) {
                    firstInverse = inverse.body[0].program;

                    // Walk the inverse chain to find the last inverse that is actually in the chain.
                    while (lastInverse.chained) {
                        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
                    }
                }

                var strip = {
                    open: block.openStrip.open,
                    close: block.closeStrip.close,

                    // Determine the standalone candiacy. Basically flag our content as being possibly standalone
                    // so our parent can determine if we actually are standalone
                    openStandalone: isNextWhitespace(program.body),
                    closeStandalone: isPrevWhitespace((firstInverse || program).body)
                };

                if (block.openStrip.close) {
                    omitRight(program.body, null, true);
                }

                if (inverse) {
                    var inverseStrip = block.inverseStrip;

                    if (inverseStrip.open) {
                        omitLeft(program.body, null, true);
                    }

                    if (inverseStrip.close) {
                        omitRight(firstInverse.body, null, true);
                    }
                    if (block.closeStrip.open) {
                        omitLeft(lastInverse.body, null, true);
                    }

                    // Find standalone else statments
                    if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
                        omitLeft(program.body);
                        omitRight(firstInverse.body);
                    }
                } else if (block.closeStrip.open) {
                    omitLeft(program.body, null, true);
                }

                return strip;
            };

            WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
                return mustache.strip;
            };

            WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
                /* istanbul ignore next */
                var strip = node.strip || {};
                return {
                    inlineStandalone: true,
                    open: strip.open,
                    close: strip.close
                };
            };

            function isPrevWhitespace(body, i, isRoot) {
                if (i === undefined) {
                    i = body.length;
                }

                // Nodes that end with newlines are considered whitespace (but are special
                // cased for strip operations)
                var prev = body[i - 1],
                    sibling = body[i - 2];
                if (!prev) {
                    return isRoot;
                }

                if (prev.type === 'ContentStatement') {
                    return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
                }
            }
            function isNextWhitespace(body, i, isRoot) {
                if (i === undefined) {
                    i = -1;
                }

                var next = body[i + 1],
                    sibling = body[i + 2];
                if (!next) {
                    return isRoot;
                }

                if (next.type === 'ContentStatement') {
                    return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
                }
            }

            // Marks the node to the right of the position as omitted.
            // I.e. {{foo}}' ' will mark the ' ' node as omitted.
            //
            // If i is undefined, then the first child will be marked as such.
            //
            // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
            // content is met.
            function omitRight(body, i, multiple) {
                var current = body[i == null ? 0 : i + 1];
                if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
                    return;
                }

                var original = current.value;
                current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
                current.rightStripped = current.value !== original;
            }

            // Marks the node to the left of the position as omitted.
            // I.e. ' '{{foo}} will mark the ' ' node as omitted.
            //
            // If i is undefined then the last child will be marked as such.
            //
            // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
            // content is met.
            function omitLeft(body, i, multiple) {
                var current = body[i == null ? body.length - 1 : i - 1];
                if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
                    return;
                }

                // We omit the last node if it's whitespace only and not preceeded by a non-content node.
                var original = current.value;
                current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
                current.leftStripped = current.value !== original;
                return current.leftStripped;
            }

            exports['default'] = WhitespaceControl;
            module.exports = exports['default'];

            /***/ }),
        /* 39 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            function Visitor() {
                this.parents = [];
            }

            Visitor.prototype = {
                constructor: Visitor,
                mutating: false,

                // Visits a given value. If mutating, will replace the value if necessary.
                acceptKey: function acceptKey(node, name) {
                    var value = this.accept(node[name]);
                    if (this.mutating) {
                        // Hacky sanity check: This may have a few false positives for type for the helper
                        // methods but will generally do the right thing without a lot of overhead.
                        if (value && !Visitor.prototype[value.type]) {
                            throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
                        }
                        node[name] = value;
                    }
                },

                // Performs an accept operation with added sanity check to ensure
                // required keys are not removed.
                acceptRequired: function acceptRequired(node, name) {
                    this.acceptKey(node, name);

                    if (!node[name]) {
                        throw new _exception2['default'](node.type + ' requires ' + name);
                    }
                },

                // Traverses a given array. If mutating, empty respnses will be removed
                // for child elements.
                acceptArray: function acceptArray(array) {
                    for (var i = 0, l = array.length; i < l; i++) {
                        this.acceptKey(array, i);

                        if (!array[i]) {
                            array.splice(i, 1);
                            i--;
                            l--;
                        }
                    }
                },

                accept: function accept(object) {
                    if (!object) {
                        return;
                    }

                    /* istanbul ignore next: Sanity code */
                    if (!this[object.type]) {
                        throw new _exception2['default']('Unknown type: ' + object.type, object);
                    }

                    if (this.current) {
                        this.parents.unshift(this.current);
                    }
                    this.current = object;

                    var ret = this[object.type](object);

                    this.current = this.parents.shift();

                    if (!this.mutating || ret) {
                        return ret;
                    } else if (ret !== false) {
                        return object;
                    }
                },

                Program: function Program(program) {
                    this.acceptArray(program.body);
                },

                MustacheStatement: visitSubExpression,
                Decorator: visitSubExpression,

                BlockStatement: visitBlock,
                DecoratorBlock: visitBlock,

                PartialStatement: visitPartial,
                PartialBlockStatement: function PartialBlockStatement(partial) {
                    visitPartial.call(this, partial);

                    this.acceptKey(partial, 'program');
                },

                ContentStatement: function ContentStatement() /* content */{},
                CommentStatement: function CommentStatement() /* comment */{},

                SubExpression: visitSubExpression,

                PathExpression: function PathExpression() /* path */{},

                StringLiteral: function StringLiteral() /* string */{},
                NumberLiteral: function NumberLiteral() /* number */{},
                BooleanLiteral: function BooleanLiteral() /* bool */{},
                UndefinedLiteral: function UndefinedLiteral() /* literal */{},
                NullLiteral: function NullLiteral() /* literal */{},

                Hash: function Hash(hash) {
                    this.acceptArray(hash.pairs);
                },
                HashPair: function HashPair(pair) {
                    this.acceptRequired(pair, 'value');
                }
            };

            function visitSubExpression(mustache) {
                this.acceptRequired(mustache, 'path');
                this.acceptArray(mustache.params);
                this.acceptKey(mustache, 'hash');
            }
            function visitBlock(block) {
                visitSubExpression.call(this, block);

                this.acceptKey(block, 'program');
                this.acceptKey(block, 'inverse');
            }
            function visitPartial(partial) {
                this.acceptRequired(partial, 'name');
                this.acceptArray(partial.params);
                this.acceptKey(partial, 'hash');
            }

            exports['default'] = Visitor;
            module.exports = exports['default'];

            /***/ }),
        /* 40 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.SourceLocation = SourceLocation;
            exports.id = id;
            exports.stripFlags = stripFlags;
            exports.stripComment = stripComment;
            exports.preparePath = preparePath;
            exports.prepareMustache = prepareMustache;
            exports.prepareRawBlock = prepareRawBlock;
            exports.prepareBlock = prepareBlock;
            exports.prepareProgram = prepareProgram;
            exports.preparePartialBlock = preparePartialBlock;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            function validateClose(open, close) {
                close = close.path ? close.path.original : close;

                if (open.path.original !== close) {
                    var errorNode = { loc: open.path.loc };

                    throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
                }
            }

            function SourceLocation(source, locInfo) {
                this.source = source;
                this.start = {
                    line: locInfo.first_line,
                    column: locInfo.first_column
                };
                this.end = {
                    line: locInfo.last_line,
                    column: locInfo.last_column
                };
            }

            function id(token) {
                if (/^\[.*\]$/.test(token)) {
                    return token.substr(1, token.length - 2);
                } else {
                    return token;
                }
            }

            function stripFlags(open, close) {
                return {
                    open: open.charAt(2) === '~',
                    close: close.charAt(close.length - 3) === '~'
                };
            }

            function stripComment(comment) {
                return comment.replace(/^\{\{~?!-?-?/, '').replace(/-?-?~?\}\}$/, '');
            }

            function preparePath(data, parts, loc) {
                loc = this.locInfo(loc);

                var original = data ? '@' : '',
                    dig = [],
                    depth = 0;

                for (var i = 0, l = parts.length; i < l; i++) {
                    var part = parts[i].part,

                        // If we have [] syntax then we do not treat path references as operators,
                        // i.e. foo.[this] resolves to approximately context.foo['this']
                        isLiteral = parts[i].original !== part;
                    original += (parts[i].separator || '') + part;

                    if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
                        if (dig.length > 0) {
                            throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
                        } else if (part === '..') {
                            depth++;
                        }
                    } else {
                        dig.push(part);
                    }
                }

                return {
                    type: 'PathExpression',
                    data: data,
                    depth: depth,
                    parts: dig,
                    original: original,
                    loc: loc
                };
            }

            function prepareMustache(path, params, hash, open, strip, locInfo) {
                // Must use charAt to support IE pre-10
                var escapeFlag = open.charAt(3) || open.charAt(2),
                    escaped = escapeFlag !== '{' && escapeFlag !== '&';

                var decorator = /\*/.test(open);
                return {
                    type: decorator ? 'Decorator' : 'MustacheStatement',
                    path: path,
                    params: params,
                    hash: hash,
                    escaped: escaped,
                    strip: strip,
                    loc: this.locInfo(locInfo)
                };
            }

            function prepareRawBlock(openRawBlock, contents, close, locInfo) {
                validateClose(openRawBlock, close);

                locInfo = this.locInfo(locInfo);
                var program = {
                    type: 'Program',
                    body: contents,
                    strip: {},
                    loc: locInfo
                };

                return {
                    type: 'BlockStatement',
                    path: openRawBlock.path,
                    params: openRawBlock.params,
                    hash: openRawBlock.hash,
                    program: program,
                    openStrip: {},
                    inverseStrip: {},
                    closeStrip: {},
                    loc: locInfo
                };
            }

            function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
                if (close && close.path) {
                    validateClose(openBlock, close);
                }

                var decorator = /\*/.test(openBlock.open);

                program.blockParams = openBlock.blockParams;

                var inverse = undefined,
                    inverseStrip = undefined;

                if (inverseAndProgram) {
                    if (decorator) {
                        throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
                    }

                    if (inverseAndProgram.chain) {
                        inverseAndProgram.program.body[0].closeStrip = close.strip;
                    }

                    inverseStrip = inverseAndProgram.strip;
                    inverse = inverseAndProgram.program;
                }

                if (inverted) {
                    inverted = inverse;
                    inverse = program;
                    program = inverted;
                }

                return {
                    type: decorator ? 'DecoratorBlock' : 'BlockStatement',
                    path: openBlock.path,
                    params: openBlock.params,
                    hash: openBlock.hash,
                    program: program,
                    inverse: inverse,
                    openStrip: openBlock.strip,
                    inverseStrip: inverseStrip,
                    closeStrip: close && close.strip,
                    loc: this.locInfo(locInfo)
                };
            }

            function prepareProgram(statements, loc) {
                if (!loc && statements.length) {
                    var firstLoc = statements[0].loc,
                        lastLoc = statements[statements.length - 1].loc;

                    /* istanbul ignore else */
                    if (firstLoc && lastLoc) {
                        loc = {
                            source: firstLoc.source,
                            start: {
                                line: firstLoc.start.line,
                                column: firstLoc.start.column
                            },
                            end: {
                                line: lastLoc.end.line,
                                column: lastLoc.end.column
                            }
                        };
                    }
                }

                return {
                    type: 'Program',
                    body: statements,
                    strip: {},
                    loc: loc
                };
            }

            function preparePartialBlock(open, program, close, locInfo) {
                validateClose(open, close);

                return {
                    type: 'PartialBlockStatement',
                    name: open.path,
                    params: open.params,
                    hash: open.hash,
                    program: program,
                    openStrip: open.strip,
                    closeStrip: close && close.strip,
                    loc: this.locInfo(locInfo)
                };
            }

            /***/ }),
        /* 41 */
        /***/ (function(module, exports, __webpack_require__) {

            /* eslint-disable new-cap */

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;
            exports.Compiler = Compiler;
            exports.precompile = precompile;
            exports.compile = compile;

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _utils = __webpack_require__(5);

            var _ast = __webpack_require__(35);

            var _ast2 = _interopRequireDefault(_ast);

            var slice = [].slice;

            function Compiler() {}

            // the foundHelper register will disambiguate helper lookup from finding a
            // function in a context. This is necessary for mustache compatibility, which
            // requires that context functions in blocks are evaluated by blockHelperMissing,
            // and then proceed as if the resulting value was provided to blockHelperMissing.

            Compiler.prototype = {
                compiler: Compiler,

                equals: function equals(other) {
                    var len = this.opcodes.length;
                    if (other.opcodes.length !== len) {
                        return false;
                    }

                    for (var i = 0; i < len; i++) {
                        var opcode = this.opcodes[i],
                            otherOpcode = other.opcodes[i];
                        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
                            return false;
                        }
                    }

                    // We know that length is the same between the two arrays because they are directly tied
                    // to the opcode behavior above.
                    len = this.children.length;
                    for (var i = 0; i < len; i++) {
                        if (!this.children[i].equals(other.children[i])) {
                            return false;
                        }
                    }

                    return true;
                },

                guid: 0,

                compile: function compile(program, options) {
                    this.sourceNode = [];
                    this.opcodes = [];
                    this.children = [];
                    this.options = options;
                    this.stringParams = options.stringParams;
                    this.trackIds = options.trackIds;

                    options.blockParams = options.blockParams || [];

                    // These changes will propagate to the other compiler components
                    var knownHelpers = options.knownHelpers;
                    options.knownHelpers = {
                        'helperMissing': true,
                        'blockHelperMissing': true,
                        'each': true,
                        'if': true,
                        'unless': true,
                        'with': true,
                        'log': true,
                        'lookup': true
                    };
                    if (knownHelpers) {
                        // the next line should use "Object.keys", but the code has been like this a long time and changing it, might
                        // cause backwards-compatibility issues... It's an old library...
                        // eslint-disable-next-line guard-for-in
                        for (var _name in knownHelpers) {
                            this.options.knownHelpers[_name] = knownHelpers[_name];
                        }
                    }

                    return this.accept(program);
                },

                compileProgram: function compileProgram(program) {
                    var childCompiler = new this.compiler(),
                        // eslint-disable-line new-cap
                        result = childCompiler.compile(program, this.options),
                        guid = this.guid++;

                    this.usePartial = this.usePartial || result.usePartial;

                    this.children[guid] = result;
                    this.useDepths = this.useDepths || result.useDepths;

                    return guid;
                },

                accept: function accept(node) {
                    /* istanbul ignore next: Sanity code */
                    if (!this[node.type]) {
                        throw new _exception2['default']('Unknown type: ' + node.type, node);
                    }

                    this.sourceNode.unshift(node);
                    var ret = this[node.type](node);
                    this.sourceNode.shift();
                    return ret;
                },

                Program: function Program(program) {
                    this.options.blockParams.unshift(program.blockParams);

                    var body = program.body,
                        bodyLength = body.length;
                    for (var i = 0; i < bodyLength; i++) {
                        this.accept(body[i]);
                    }

                    this.options.blockParams.shift();

                    this.isSimple = bodyLength === 1;
                    this.blockParams = program.blockParams ? program.blockParams.length : 0;

                    return this;
                },

                BlockStatement: function BlockStatement(block) {
                    transformLiteralToPath(block);

                    var program = block.program,
                        inverse = block.inverse;

                    program = program && this.compileProgram(program);
                    inverse = inverse && this.compileProgram(inverse);

                    var type = this.classifySexpr(block);

                    if (type === 'helper') {
                        this.helperSexpr(block, program, inverse);
                    } else if (type === 'simple') {
                        this.simpleSexpr(block);

                        // now that the simple mustache is resolved, we need to
                        // evaluate it by executing `blockHelperMissing`
                        this.opcode('pushProgram', program);
                        this.opcode('pushProgram', inverse);
                        this.opcode('emptyHash');
                        this.opcode('blockValue', block.path.original);
                    } else {
                        this.ambiguousSexpr(block, program, inverse);

                        // now that the simple mustache is resolved, we need to
                        // evaluate it by executing `blockHelperMissing`
                        this.opcode('pushProgram', program);
                        this.opcode('pushProgram', inverse);
                        this.opcode('emptyHash');
                        this.opcode('ambiguousBlockValue');
                    }

                    this.opcode('append');
                },

                DecoratorBlock: function DecoratorBlock(decorator) {
                    var program = decorator.program && this.compileProgram(decorator.program);
                    var params = this.setupFullMustacheParams(decorator, program, undefined),
                        path = decorator.path;

                    this.useDecorators = true;
                    this.opcode('registerDecorator', params.length, path.original);
                },

                PartialStatement: function PartialStatement(partial) {
                    this.usePartial = true;

                    var program = partial.program;
                    if (program) {
                        program = this.compileProgram(partial.program);
                    }

                    var params = partial.params;
                    if (params.length > 1) {
                        throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
                    } else if (!params.length) {
                        if (this.options.explicitPartialContext) {
                            this.opcode('pushLiteral', 'undefined');
                        } else {
                            params.push({ type: 'PathExpression', parts: [], depth: 0 });
                        }
                    }

                    var partialName = partial.name.original,
                        isDynamic = partial.name.type === 'SubExpression';
                    if (isDynamic) {
                        this.accept(partial.name);
                    }

                    this.setupFullMustacheParams(partial, program, undefined, true);

                    var indent = partial.indent || '';
                    if (this.options.preventIndent && indent) {
                        this.opcode('appendContent', indent);
                        indent = '';
                    }

                    this.opcode('invokePartial', isDynamic, partialName, indent);
                    this.opcode('append');
                },
                PartialBlockStatement: function PartialBlockStatement(partialBlock) {
                    this.PartialStatement(partialBlock);
                },

                MustacheStatement: function MustacheStatement(mustache) {
                    this.SubExpression(mustache);

                    if (mustache.escaped && !this.options.noEscape) {
                        this.opcode('appendEscaped');
                    } else {
                        this.opcode('append');
                    }
                },
                Decorator: function Decorator(decorator) {
                    this.DecoratorBlock(decorator);
                },

                ContentStatement: function ContentStatement(content) {
                    if (content.value) {
                        this.opcode('appendContent', content.value);
                    }
                },

                CommentStatement: function CommentStatement() {},

                SubExpression: function SubExpression(sexpr) {
                    transformLiteralToPath(sexpr);
                    var type = this.classifySexpr(sexpr);

                    if (type === 'simple') {
                        this.simpleSexpr(sexpr);
                    } else if (type === 'helper') {
                        this.helperSexpr(sexpr);
                    } else {
                        this.ambiguousSexpr(sexpr);
                    }
                },
                ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
                    var path = sexpr.path,
                        name = path.parts[0],
                        isBlock = program != null || inverse != null;

                    this.opcode('getContext', path.depth);

                    this.opcode('pushProgram', program);
                    this.opcode('pushProgram', inverse);

                    path.strict = true;
                    this.accept(path);

                    this.opcode('invokeAmbiguous', name, isBlock);
                },

                simpleSexpr: function simpleSexpr(sexpr) {
                    var path = sexpr.path;
                    path.strict = true;
                    this.accept(path);
                    this.opcode('resolvePossibleLambda');
                },

                helperSexpr: function helperSexpr(sexpr, program, inverse) {
                    var params = this.setupFullMustacheParams(sexpr, program, inverse),
                        path = sexpr.path,
                        name = path.parts[0];

                    if (this.options.knownHelpers[name]) {
                        this.opcode('invokeKnownHelper', params.length, name);
                    } else if (this.options.knownHelpersOnly) {
                        throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
                    } else {
                        path.strict = true;
                        path.falsy = true;

                        this.accept(path);
                        this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
                    }
                },

                PathExpression: function PathExpression(path) {
                    this.addDepth(path.depth);
                    this.opcode('getContext', path.depth);

                    var name = path.parts[0],
                        scoped = _ast2['default'].helpers.scopedId(path),
                        blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

                    if (blockParamId) {
                        this.opcode('lookupBlockParam', blockParamId, path.parts);
                    } else if (!name) {
                        // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
                        this.opcode('pushContext');
                    } else if (path.data) {
                        this.options.data = true;
                        this.opcode('lookupData', path.depth, path.parts, path.strict);
                    } else {
                        this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
                    }
                },

                StringLiteral: function StringLiteral(string) {
                    this.opcode('pushString', string.value);
                },

                NumberLiteral: function NumberLiteral(number) {
                    this.opcode('pushLiteral', number.value);
                },

                BooleanLiteral: function BooleanLiteral(bool) {
                    this.opcode('pushLiteral', bool.value);
                },

                UndefinedLiteral: function UndefinedLiteral() {
                    this.opcode('pushLiteral', 'undefined');
                },

                NullLiteral: function NullLiteral() {
                    this.opcode('pushLiteral', 'null');
                },

                Hash: function Hash(hash) {
                    var pairs = hash.pairs,
                        i = 0,
                        l = pairs.length;

                    this.opcode('pushHash');

                    for (; i < l; i++) {
                        this.pushParam(pairs[i].value);
                    }
                    while (i--) {
                        this.opcode('assignToHash', pairs[i].key);
                    }
                    this.opcode('popHash');
                },

                // HELPERS
                opcode: function opcode(name) {
                    this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
                },

                addDepth: function addDepth(depth) {
                    if (!depth) {
                        return;
                    }

                    this.useDepths = true;
                },

                classifySexpr: function classifySexpr(sexpr) {
                    var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

                    var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

                    // a mustache is an eligible helper if:
                    // * its id is simple (a single part, not `this` or `..`)
                    var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

                    // if a mustache is an eligible helper but not a definite
                    // helper, it is ambiguous, and will be resolved in a later
                    // pass or at runtime.
                    var isEligible = !isBlockParam && (isHelper || isSimple);

                    // if ambiguous, we can possibly resolve the ambiguity now
                    // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
                    if (isEligible && !isHelper) {
                        var _name2 = sexpr.path.parts[0],
                            options = this.options;

                        if (options.knownHelpers[_name2]) {
                            isHelper = true;
                        } else if (options.knownHelpersOnly) {
                            isEligible = false;
                        }
                    }

                    if (isHelper) {
                        return 'helper';
                    } else if (isEligible) {
                        return 'ambiguous';
                    } else {
                        return 'simple';
                    }
                },

                pushParams: function pushParams(params) {
                    for (var i = 0, l = params.length; i < l; i++) {
                        this.pushParam(params[i]);
                    }
                },

                pushParam: function pushParam(val) {
                    var value = val.value != null ? val.value : val.original || '';

                    if (this.stringParams) {
                        if (value.replace) {
                            value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
                        }

                        if (val.depth) {
                            this.addDepth(val.depth);
                        }
                        this.opcode('getContext', val.depth || 0);
                        this.opcode('pushStringParam', value, val.type);

                        if (val.type === 'SubExpression') {
                            // SubExpressions get evaluated and passed in
                            // in string params mode.
                            this.accept(val);
                        }
                    } else {
                        if (this.trackIds) {
                            var blockParamIndex = undefined;
                            if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
                                blockParamIndex = this.blockParamIndex(val.parts[0]);
                            }
                            if (blockParamIndex) {
                                var blockParamChild = val.parts.slice(1).join('.');
                                this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
                            } else {
                                value = val.original || value;
                                if (value.replace) {
                                    value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
                                }

                                this.opcode('pushId', val.type, value);
                            }
                        }
                        this.accept(val);
                    }
                },

                setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
                    var params = sexpr.params;
                    this.pushParams(params);

                    this.opcode('pushProgram', program);
                    this.opcode('pushProgram', inverse);

                    if (sexpr.hash) {
                        this.accept(sexpr.hash);
                    } else {
                        this.opcode('emptyHash', omitEmpty);
                    }

                    return params;
                },

                blockParamIndex: function blockParamIndex(name) {
                    for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
                        var blockParams = this.options.blockParams[depth],
                            param = blockParams && _utils.indexOf(blockParams, name);
                        if (blockParams && param >= 0) {
                            return [depth, param];
                        }
                    }
                }
            };

            function precompile(input, options, env) {
                if (input == null || typeof input !== 'string' && input.type !== 'Program') {
                    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
                }

                options = options || {};
                if (!('data' in options)) {
                    options.data = true;
                }
                if (options.compat) {
                    options.useDepths = true;
                }

                var ast = env.parse(input, options),
                    environment = new env.Compiler().compile(ast, options);
                return new env.JavaScriptCompiler().compile(environment, options);
            }

            function compile(input, options, env) {
                if (options === undefined) options = {};

                if (input == null || typeof input !== 'string' && input.type !== 'Program') {
                    throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
                }

                options = _utils.extend({}, options);
                if (!('data' in options)) {
                    options.data = true;
                }
                if (options.compat) {
                    options.useDepths = true;
                }

                var compiled = undefined;

                function compileInput() {
                    var ast = env.parse(input, options),
                        environment = new env.Compiler().compile(ast, options),
                        templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
                    return env.template(templateSpec);
                }

                // Template is only compiled on first use and cached after that point.
                function ret(context, execOptions) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled.call(this, context, execOptions);
                }
                ret._setup = function (setupOptions) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled._setup(setupOptions);
                };
                ret._child = function (i, data, blockParams, depths) {
                    if (!compiled) {
                        compiled = compileInput();
                    }
                    return compiled._child(i, data, blockParams, depths);
                };
                return ret;
            }

            function argEquals(a, b) {
                if (a === b) {
                    return true;
                }

                if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
                    for (var i = 0; i < a.length; i++) {
                        if (!argEquals(a[i], b[i])) {
                            return false;
                        }
                    }
                    return true;
                }
            }

            function transformLiteralToPath(sexpr) {
                if (!sexpr.path.parts) {
                    var literal = sexpr.path;
                    // Casting to string here to make false and 0 literal values play nicely with the rest
                    // of the system.
                    sexpr.path = {
                        type: 'PathExpression',
                        data: false,
                        depth: 0,
                        parts: [literal.original + ''],
                        original: literal.original + '',
                        loc: literal.loc
                    };
                }
            }

            /***/ }),
        /* 42 */
        /***/ (function(module, exports, __webpack_require__) {

            'use strict';

            var _interopRequireDefault = __webpack_require__(1)['default'];

            exports.__esModule = true;

            var _base = __webpack_require__(4);

            var _exception = __webpack_require__(6);

            var _exception2 = _interopRequireDefault(_exception);

            var _utils = __webpack_require__(5);

            var _codeGen = __webpack_require__(43);

            var _codeGen2 = _interopRequireDefault(_codeGen);

            function Literal(value) {
                this.value = value;
            }

            function JavaScriptCompiler() {}

            JavaScriptCompiler.prototype = {
                // PUBLIC API: You can override these methods in a subclass to provide
                // alternative compiled forms for name lookup and buffering semantics
                nameLookup: function nameLookup(parent, name /* , type*/) {
                    if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
                        return [parent, '.', name];
                    } else {
                        return [parent, '[', JSON.stringify(name), ']'];
                    }
                },
                depthedLookup: function depthedLookup(name) {
                    return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
                },

                compilerInfo: function compilerInfo() {
                    var revision = _base.COMPILER_REVISION,
                        versions = _base.REVISION_CHANGES[revision];
                    return [revision, versions];
                },

                appendToBuffer: function appendToBuffer(source, location, explicit) {
                    // Force a source as this simplifies the merge logic.
                    if (!_utils.isArray(source)) {
                        source = [source];
                    }
                    source = this.source.wrap(source, location);

                    if (this.environment.isSimple) {
                        return ['return ', source, ';'];
                    } else if (explicit) {
                        // This is a case where the buffer operation occurs as a child of another
                        // construct, generally braces. We have to explicitly output these buffer
                        // operations to ensure that the emitted code goes in the correct location.
                        return ['buffer += ', source, ';'];
                    } else {
                        source.appendToBuffer = true;
                        return source;
                    }
                },

                initializeBuffer: function initializeBuffer() {
                    return this.quotedString('');
                },
                // END PUBLIC API

                compile: function compile(environment, options, context, asObject) {
                    this.environment = environment;
                    this.options = options;
                    this.stringParams = this.options.stringParams;
                    this.trackIds = this.options.trackIds;
                    this.precompile = !asObject;

                    this.name = this.environment.name;
                    this.isChild = !!context;
                    this.context = context || {
                        decorators: [],
                        programs: [],
                        environments: []
                    };

                    this.preamble();

                    this.stackSlot = 0;
                    this.stackVars = [];
                    this.aliases = {};
                    this.registers = { list: [] };
                    this.hashes = [];
                    this.compileStack = [];
                    this.inlineStack = [];
                    this.blockParams = [];

                    this.compileChildren(environment, options);

                    this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
                    this.useBlockParams = this.useBlockParams || environment.useBlockParams;

                    var opcodes = environment.opcodes,
                        opcode = undefined,
                        firstLoc = undefined,
                        i = undefined,
                        l = undefined;

                    for (i = 0, l = opcodes.length; i < l; i++) {
                        opcode = opcodes[i];

                        this.source.currentLocation = opcode.loc;
                        firstLoc = firstLoc || opcode.loc;
                        this[opcode.opcode].apply(this, opcode.args);
                    }

                    // Flush any trailing content that might be pending.
                    this.source.currentLocation = firstLoc;
                    this.pushSource('');

                    /* istanbul ignore next */
                    if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
                        throw new _exception2['default']('Compile completed with content left on stack');
                    }

                    if (!this.decorators.isEmpty()) {
                        this.useDecorators = true;

                        this.decorators.prepend('var decorators = container.decorators;\n');
                        this.decorators.push('return fn;');

                        if (asObject) {
                            this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
                        } else {
                            this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
                            this.decorators.push('}\n');
                            this.decorators = this.decorators.merge();
                        }
                    } else {
                        this.decorators = undefined;
                    }

                    var fn = this.createFunctionContext(asObject);
                    if (!this.isChild) {
                        var ret = {
                            compiler: this.compilerInfo(),
                            main: fn
                        };

                        if (this.decorators) {
                            ret.main_d = this.decorators; // eslint-disable-line camelcase
                            ret.useDecorators = true;
                        }

                        var _context = this.context;
                        var programs = _context.programs;
                        var decorators = _context.decorators;

                        for (i = 0, l = programs.length; i < l; i++) {
                            if (programs[i]) {
                                ret[i] = programs[i];
                                if (decorators[i]) {
                                    ret[i + '_d'] = decorators[i];
                                    ret.useDecorators = true;
                                }
                            }
                        }

                        if (this.environment.usePartial) {
                            ret.usePartial = true;
                        }
                        if (this.options.data) {
                            ret.useData = true;
                        }
                        if (this.useDepths) {
                            ret.useDepths = true;
                        }
                        if (this.useBlockParams) {
                            ret.useBlockParams = true;
                        }
                        if (this.options.compat) {
                            ret.compat = true;
                        }

                        if (!asObject) {
                            ret.compiler = JSON.stringify(ret.compiler);

                            this.source.currentLocation = { start: { line: 1, column: 0 } };
                            ret = this.objectLiteral(ret);

                            if (options.srcName) {
                                ret = ret.toStringWithSourceMap({ file: options.destName });
                                ret.map = ret.map && ret.map.toString();
                            } else {
                                ret = ret.toString();
                            }
                        } else {
                            ret.compilerOptions = this.options;
                        }

                        return ret;
                    } else {
                        return fn;
                    }
                },

                preamble: function preamble() {
                    // track the last context pushed into place to allow skipping the
                    // getContext opcode when it would be a noop
                    this.lastContext = 0;
                    this.source = new _codeGen2['default'](this.options.srcName);
                    this.decorators = new _codeGen2['default'](this.options.srcName);
                },

                createFunctionContext: function createFunctionContext(asObject) {
                    var varDeclarations = '';

                    var locals = this.stackVars.concat(this.registers.list);
                    if (locals.length > 0) {
                        varDeclarations += ', ' + locals.join(', ');
                    }

                    // Generate minimizer alias mappings
                    //
                    // When using true SourceNodes, this will update all references to the given alias
                    // as the source nodes are reused in situ. For the non-source node compilation mode,
                    // aliases will not be used, but this case is already being run on the client and
                    // we aren't concern about minimizing the template size.
                    var aliasCount = 0;
                    for (var alias in this.aliases) {
                        // eslint-disable-line guard-for-in
                        var node = this.aliases[alias];

                        if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
                            varDeclarations += ', alias' + ++aliasCount + '=' + alias;
                            node.children[0] = 'alias' + aliasCount;
                        }
                    }

                    var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

                    if (this.useBlockParams || this.useDepths) {
                        params.push('blockParams');
                    }
                    if (this.useDepths) {
                        params.push('depths');
                    }

                    // Perform a second pass over the output to merge content when possible
                    var source = this.mergeSource(varDeclarations);

                    if (asObject) {
                        params.push(source);

                        return Function.apply(this, params);
                    } else {
                        return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
                    }
                },
                mergeSource: function mergeSource(varDeclarations) {
                    var isSimple = this.environment.isSimple,
                        appendOnly = !this.forceBuffer,
                        appendFirst = undefined,
                        sourceSeen = undefined,
                        bufferStart = undefined,
                        bufferEnd = undefined;
                    this.source.each(function (line) {
                        if (line.appendToBuffer) {
                            if (bufferStart) {
                                line.prepend('  + ');
                            } else {
                                bufferStart = line;
                            }
                            bufferEnd = line;
                        } else {
                            if (bufferStart) {
                                if (!sourceSeen) {
                                    appendFirst = true;
                                } else {
                                    bufferStart.prepend('buffer += ');
                                }
                                bufferEnd.add(';');
                                bufferStart = bufferEnd = undefined;
                            }

                            sourceSeen = true;
                            if (!isSimple) {
                                appendOnly = false;
                            }
                        }
                    });

                    if (appendOnly) {
                        if (bufferStart) {
                            bufferStart.prepend('return ');
                            bufferEnd.add(';');
                        } else if (!sourceSeen) {
                            this.source.push('return "";');
                        }
                    } else {
                        varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

                        if (bufferStart) {
                            bufferStart.prepend('return buffer + ');
                            bufferEnd.add(';');
                        } else {
                            this.source.push('return buffer;');
                        }
                    }

                    if (varDeclarations) {
                        this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
                    }

                    return this.source.merge();
                },

                // [blockValue]
                //
                // On stack, before: hash, inverse, program, value
                // On stack, after: return value of blockHelperMissing
                //
                // The purpose of this opcode is to take a block of the form
                // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
                // replace it on the stack with the result of properly
                // invoking blockHelperMissing.
                blockValue: function blockValue(name) {
                    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                        params = [this.contextName(0)];
                    this.setupHelperArgs(name, 0, params);

                    var blockName = this.popStack();
                    params.splice(1, 0, blockName);

                    this.push(this.source.functionCall(blockHelperMissing, 'call', params));
                },

                // [ambiguousBlockValue]
                //
                // On stack, before: hash, inverse, program, value
                // Compiler value, before: lastHelper=value of last found helper, if any
                // On stack, after, if no lastHelper: same as [blockValue]
                // On stack, after, if lastHelper: value
                ambiguousBlockValue: function ambiguousBlockValue() {
                    // We're being a bit cheeky and reusing the options value from the prior exec
                    var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
                        params = [this.contextName(0)];
                    this.setupHelperArgs('', 0, params, true);

                    this.flushInline();

                    var current = this.topStack();
                    params.splice(1, 0, current);

                    this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
                },

                // [appendContent]
                //
                // On stack, before: ...
                // On stack, after: ...
                //
                // Appends the string value of `content` to the current buffer
                appendContent: function appendContent(content) {
                    if (this.pendingContent) {
                        content = this.pendingContent + content;
                    } else {
                        this.pendingLocation = this.source.currentLocation;
                    }

                    this.pendingContent = content;
                },

                // [append]
                //
                // On stack, before: value, ...
                // On stack, after: ...
                //
                // Coerces `value` to a String and appends it to the current buffer.
                //
                // If `value` is truthy, or 0, it is coerced into a string and appended
                // Otherwise, the empty string is appended
                append: function append() {
                    if (this.isInline()) {
                        this.replaceStack(function (current) {
                            return [' != null ? ', current, ' : ""'];
                        });

                        this.pushSource(this.appendToBuffer(this.popStack()));
                    } else {
                        var local = this.popStack();
                        this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
                        if (this.environment.isSimple) {
                            this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
                        }
                    }
                },

                // [appendEscaped]
                //
                // On stack, before: value, ...
                // On stack, after: ...
                //
                // Escape `value` and append it to the buffer
                appendEscaped: function appendEscaped() {
                    this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
                },

                // [getContext]
                //
                // On stack, before: ...
                // On stack, after: ...
                // Compiler value, after: lastContext=depth
                //
                // Set the value of the `lastContext` compiler value to the depth
                getContext: function getContext(depth) {
                    this.lastContext = depth;
                },

                // [pushContext]
                //
                // On stack, before: ...
                // On stack, after: currentContext, ...
                //
                // Pushes the value of the current context onto the stack.
                pushContext: function pushContext() {
                    this.pushStackLiteral(this.contextName(this.lastContext));
                },

                // [lookupOnContext]
                //
                // On stack, before: ...
                // On stack, after: currentContext[name], ...
                //
                // Looks up the value of `name` on the current context and pushes
                // it onto the stack.
                lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
                    var i = 0;

                    if (!scoped && this.options.compat && !this.lastContext) {
                        // The depthed query is expected to handle the undefined logic for the root level that
                        // is implemented below, so we evaluate that directly in compat mode
                        this.push(this.depthedLookup(parts[i++]));
                    } else {
                        this.pushContext();
                    }

                    this.resolvePath('context', parts, i, falsy, strict);
                },

                // [lookupBlockParam]
                //
                // On stack, before: ...
                // On stack, after: blockParam[name], ...
                //
                // Looks up the value of `parts` on the given block param and pushes
                // it onto the stack.
                lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
                    this.useBlockParams = true;

                    this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
                    this.resolvePath('context', parts, 1);
                },

                // [lookupData]
                //
                // On stack, before: ...
                // On stack, after: data, ...
                //
                // Push the data lookup operator
                lookupData: function lookupData(depth, parts, strict) {
                    if (!depth) {
                        this.pushStackLiteral('data');
                    } else {
                        this.pushStackLiteral('container.data(data, ' + depth + ')');
                    }

                    this.resolvePath('data', parts, 0, true, strict);
                },

                resolvePath: function resolvePath(type, parts, i, falsy, strict) {
                    // istanbul ignore next

                    var _this = this;

                    if (this.options.strict || this.options.assumeObjects) {
                        this.push(strictLookup(this.options.strict && strict, this, parts, type));
                        return;
                    }

                    var len = parts.length;
                    for (; i < len; i++) {
                        /* eslint-disable no-loop-func */
                        this.replaceStack(function (current) {
                            var lookup = _this.nameLookup(current, parts[i], type);
                            // We want to ensure that zero and false are handled properly if the context (falsy flag)
                            // needs to have the special handling for these values.
                            if (!falsy) {
                                return [' != null ? ', lookup, ' : ', current];
                            } else {
                                // Otherwise we can use generic falsy handling
                                return [' && ', lookup];
                            }
                        });
                        /* eslint-enable no-loop-func */
                    }
                },

                // [resolvePossibleLambda]
                //
                // On stack, before: value, ...
                // On stack, after: resolved value, ...
                //
                // If the `value` is a lambda, replace it on the stack by
                // the return value of the lambda
                resolvePossibleLambda: function resolvePossibleLambda() {
                    this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
                },

                // [pushStringParam]
                //
                // On stack, before: ...
                // On stack, after: string, currentContext, ...
                //
                // This opcode is designed for use in string mode, which
                // provides the string value of a parameter along with its
                // depth rather than resolving it immediately.
                pushStringParam: function pushStringParam(string, type) {
                    this.pushContext();
                    this.pushString(type);

                    // If it's a subexpression, the string result
                    // will be pushed after this opcode.
                    if (type !== 'SubExpression') {
                        if (typeof string === 'string') {
                            this.pushString(string);
                        } else {
                            this.pushStackLiteral(string);
                        }
                    }
                },

                emptyHash: function emptyHash(omitEmpty) {
                    if (this.trackIds) {
                        this.push('{}'); // hashIds
                    }
                    if (this.stringParams) {
                        this.push('{}'); // hashContexts
                        this.push('{}'); // hashTypes
                    }
                    this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
                },
                pushHash: function pushHash() {
                    if (this.hash) {
                        this.hashes.push(this.hash);
                    }
                    this.hash = { values: [], types: [], contexts: [], ids: [] };
                },
                popHash: function popHash() {
                    var hash = this.hash;
                    this.hash = this.hashes.pop();

                    if (this.trackIds) {
                        this.push(this.objectLiteral(hash.ids));
                    }
                    if (this.stringParams) {
                        this.push(this.objectLiteral(hash.contexts));
                        this.push(this.objectLiteral(hash.types));
                    }

                    this.push(this.objectLiteral(hash.values));
                },

                // [pushString]
                //
                // On stack, before: ...
                // On stack, after: quotedString(string), ...
                //
                // Push a quoted version of `string` onto the stack
                pushString: function pushString(string) {
                    this.pushStackLiteral(this.quotedString(string));
                },

                // [pushLiteral]
                //
                // On stack, before: ...
                // On stack, after: value, ...
                //
                // Pushes a value onto the stack. This operation prevents
                // the compiler from creating a temporary variable to hold
                // it.
                pushLiteral: function pushLiteral(value) {
                    this.pushStackLiteral(value);
                },

                // [pushProgram]
                //
                // On stack, before: ...
                // On stack, after: program(guid), ...
                //
                // Push a program expression onto the stack. This takes
                // a compile-time guid and converts it into a runtime-accessible
                // expression.
                pushProgram: function pushProgram(guid) {
                    if (guid != null) {
                        this.pushStackLiteral(this.programExpression(guid));
                    } else {
                        this.pushStackLiteral(null);
                    }
                },

                // [registerDecorator]
                //
                // On stack, before: hash, program, params..., ...
                // On stack, after: ...
                //
                // Pops off the decorator's parameters, invokes the decorator,
                // and inserts the decorator into the decorators list.
                registerDecorator: function registerDecorator(paramSize, name) {
                    var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
                        options = this.setupHelperArgs(name, paramSize);

                    this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
                },

                // [invokeHelper]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of helper invocation
                //
                // Pops off the helper's parameters, invokes the helper,
                // and pushes the helper's return value onto the stack.
                //
                // If the helper is not found, `helperMissing` is called.
                invokeHelper: function invokeHelper(paramSize, name, isSimple) {
                    var nonHelper = this.popStack(),
                        helper = this.setupHelper(paramSize, name),
                        simple = isSimple ? [helper.name, ' || '] : '';

                    var lookup = ['('].concat(simple, nonHelper);
                    if (!this.options.strict) {
                        lookup.push(' || ', this.aliasable('helpers.helperMissing'));
                    }
                    lookup.push(')');

                    this.push(this.source.functionCall(lookup, 'call', helper.callParams));
                },

                // [invokeKnownHelper]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of helper invocation
                //
                // This operation is used when the helper is known to exist,
                // so a `helperMissing` fallback is not required.
                invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
                    var helper = this.setupHelper(paramSize, name);
                    this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
                },

                // [invokeAmbiguous]
                //
                // On stack, before: hash, inverse, program, params..., ...
                // On stack, after: result of disambiguation
                //
                // This operation is used when an expression like `{{foo}}`
                // is provided, but we don't know at compile-time whether it
                // is a helper or a path.
                //
                // This operation emits more code than the other options,
                // and can be avoided by passing the `knownHelpers` and
                // `knownHelpersOnly` flags at compile-time.
                invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
                    this.useRegister('helper');

                    var nonHelper = this.popStack();

                    this.emptyHash();
                    var helper = this.setupHelper(0, name, helperCall);

                    var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

                    var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
                    if (!this.options.strict) {
                        lookup[0] = '(helper = ';
                        lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
                    }

                    this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
                },

                // [invokePartial]
                //
                // On stack, before: context, ...
                // On stack after: result of partial invocation
                //
                // This operation pops off a context, invokes a partial with that context,
                // and pushes the result of the invocation back.
                invokePartial: function invokePartial(isDynamic, name, indent) {
                    var params = [],
                        options = this.setupParams(name, 1, params);

                    if (isDynamic) {
                        name = this.popStack();
                        delete options.name;
                    }

                    if (indent) {
                        options.indent = JSON.stringify(indent);
                    }
                    options.helpers = 'helpers';
                    options.partials = 'partials';
                    options.decorators = 'container.decorators';

                    if (!isDynamic) {
                        params.unshift(this.nameLookup('partials', name, 'partial'));
                    } else {
                        params.unshift(name);
                    }

                    if (this.options.compat) {
                        options.depths = 'depths';
                    }
                    options = this.objectLiteral(options);
                    params.push(options);

                    this.push(this.source.functionCall('container.invokePartial', '', params));
                },

                // [assignToHash]
                //
                // On stack, before: value, ..., hash, ...
                // On stack, after: ..., hash, ...
                //
                // Pops a value off the stack and assigns it to the current hash
                assignToHash: function assignToHash(key) {
                    var value = this.popStack(),
                        context = undefined,
                        type = undefined,
                        id = undefined;

                    if (this.trackIds) {
                        id = this.popStack();
                    }
                    if (this.stringParams) {
                        type = this.popStack();
                        context = this.popStack();
                    }

                    var hash = this.hash;
                    if (context) {
                        hash.contexts[key] = context;
                    }
                    if (type) {
                        hash.types[key] = type;
                    }
                    if (id) {
                        hash.ids[key] = id;
                    }
                    hash.values[key] = value;
                },

                pushId: function pushId(type, name, child) {
                    if (type === 'BlockParam') {
                        this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
                    } else if (type === 'PathExpression') {
                        this.pushString(name);
                    } else if (type === 'SubExpression') {
                        this.pushStackLiteral('true');
                    } else {
                        this.pushStackLiteral('null');
                    }
                },

                // HELPERS

                compiler: JavaScriptCompiler,

                compileChildren: function compileChildren(environment, options) {
                    var children = environment.children,
                        child = undefined,
                        compiler = undefined;

                    for (var i = 0, l = children.length; i < l; i++) {
                        child = children[i];
                        compiler = new this.compiler(); // eslint-disable-line new-cap

                        var existing = this.matchExistingProgram(child);

                        if (existing == null) {
                            this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
                            var index = this.context.programs.length;
                            child.index = index;
                            child.name = 'program' + index;
                            this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
                            this.context.decorators[index] = compiler.decorators;
                            this.context.environments[index] = child;

                            this.useDepths = this.useDepths || compiler.useDepths;
                            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
                            child.useDepths = this.useDepths;
                            child.useBlockParams = this.useBlockParams;
                        } else {
                            child.index = existing.index;
                            child.name = 'program' + existing.index;

                            this.useDepths = this.useDepths || existing.useDepths;
                            this.useBlockParams = this.useBlockParams || existing.useBlockParams;
                        }
                    }
                },
                matchExistingProgram: function matchExistingProgram(child) {
                    for (var i = 0, len = this.context.environments.length; i < len; i++) {
                        var environment = this.context.environments[i];
                        if (environment && environment.equals(child)) {
                            return environment;
                        }
                    }
                },

                programExpression: function programExpression(guid) {
                    var child = this.environment.children[guid],
                        programParams = [child.index, 'data', child.blockParams];

                    if (this.useBlockParams || this.useDepths) {
                        programParams.push('blockParams');
                    }
                    if (this.useDepths) {
                        programParams.push('depths');
                    }

                    return 'container.program(' + programParams.join(', ') + ')';
                },

                useRegister: function useRegister(name) {
                    if (!this.registers[name]) {
                        this.registers[name] = true;
                        this.registers.list.push(name);
                    }
                },

                push: function push(expr) {
                    if (!(expr instanceof Literal)) {
                        expr = this.source.wrap(expr);
                    }

                    this.inlineStack.push(expr);
                    return expr;
                },

                pushStackLiteral: function pushStackLiteral(item) {
                    this.push(new Literal(item));
                },

                pushSource: function pushSource(source) {
                    if (this.pendingContent) {
                        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
                        this.pendingContent = undefined;
                    }

                    if (source) {
                        this.source.push(source);
                    }
                },

                replaceStack: function replaceStack(callback) {
                    var prefix = ['('],
                        stack = undefined,
                        createdStack = undefined,
                        usedLiteral = undefined;

                    /* istanbul ignore next */
                    if (!this.isInline()) {
                        throw new _exception2['default']('replaceStack on non-inline');
                    }

                    // We want to merge the inline statement into the replacement statement via ','
                    var top = this.popStack(true);

                    if (top instanceof Literal) {
                        // Literals do not need to be inlined
                        stack = [top.value];
                        prefix = ['(', stack];
                        usedLiteral = true;
                    } else {
                        // Get or create the current stack name for use by the inline
                        createdStack = true;
                        var _name = this.incrStack();

                        prefix = ['((', this.push(_name), ' = ', top, ')'];
                        stack = this.topStack();
                    }

                    var item = callback.call(this, stack);

                    if (!usedLiteral) {
                        this.popStack();
                    }
                    if (createdStack) {
                        this.stackSlot--;
                    }
                    this.push(prefix.concat(item, ')'));
                },

                incrStack: function incrStack() {
                    this.stackSlot++;
                    if (this.stackSlot > this.stackVars.length) {
                        this.stackVars.push('stack' + this.stackSlot);
                    }
                    return this.topStackName();
                },
                topStackName: function topStackName() {
                    return 'stack' + this.stackSlot;
                },
                flushInline: function flushInline() {
                    var inlineStack = this.inlineStack;
                    this.inlineStack = [];
                    for (var i = 0, len = inlineStack.length; i < len; i++) {
                        var entry = inlineStack[i];
                        /* istanbul ignore if */
                        if (entry instanceof Literal) {
                            this.compileStack.push(entry);
                        } else {
                            var stack = this.incrStack();
                            this.pushSource([stack, ' = ', entry, ';']);
                            this.compileStack.push(stack);
                        }
                    }
                },
                isInline: function isInline() {
                    return this.inlineStack.length;
                },

                popStack: function popStack(wrapped) {
                    var inline = this.isInline(),
                        item = (inline ? this.inlineStack : this.compileStack).pop();

                    if (!wrapped && item instanceof Literal) {
                        return item.value;
                    } else {
                        if (!inline) {
                            /* istanbul ignore next */
                            if (!this.stackSlot) {
                                throw new _exception2['default']('Invalid stack pop');
                            }
                            this.stackSlot--;
                        }
                        return item;
                    }
                },

                topStack: function topStack() {
                    var stack = this.isInline() ? this.inlineStack : this.compileStack,
                        item = stack[stack.length - 1];

                    /* istanbul ignore if */
                    if (item instanceof Literal) {
                        return item.value;
                    } else {
                        return item;
                    }
                },

                contextName: function contextName(context) {
                    if (this.useDepths && context) {
                        return 'depths[' + context + ']';
                    } else {
                        return 'depth' + context;
                    }
                },

                quotedString: function quotedString(str) {
                    return this.source.quotedString(str);
                },

                objectLiteral: function objectLiteral(obj) {
                    return this.source.objectLiteral(obj);
                },

                aliasable: function aliasable(name) {
                    var ret = this.aliases[name];
                    if (ret) {
                        ret.referenceCount++;
                        return ret;
                    }

                    ret = this.aliases[name] = this.source.wrap(name);
                    ret.aliasable = true;
                    ret.referenceCount = 1;

                    return ret;
                },

                setupHelper: function setupHelper(paramSize, name, blockHelper) {
                    var params = [],
                        paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
                    var foundHelper = this.nameLookup('helpers', name, 'helper'),
                        callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

                    return {
                        params: params,
                        paramsInit: paramsInit,
                        name: foundHelper,
                        callParams: [callContext].concat(params)
                    };
                },

                setupParams: function setupParams(helper, paramSize, params) {
                    var options = {},
                        contexts = [],
                        types = [],
                        ids = [],
                        objectArgs = !params,
                        param = undefined;

                    if (objectArgs) {
                        params = [];
                    }

                    options.name = this.quotedString(helper);
                    options.hash = this.popStack();

                    if (this.trackIds) {
                        options.hashIds = this.popStack();
                    }
                    if (this.stringParams) {
                        options.hashTypes = this.popStack();
                        options.hashContexts = this.popStack();
                    }

                    var inverse = this.popStack(),
                        program = this.popStack();

                    // Avoid setting fn and inverse if neither are set. This allows
                    // helpers to do a check for `if (options.fn)`
                    if (program || inverse) {
                        options.fn = program || 'container.noop';
                        options.inverse = inverse || 'container.noop';
                    }

                    // The parameters go on to the stack in order (making sure that they are evaluated in order)
                    // so we need to pop them off the stack in reverse order
                    var i = paramSize;
                    while (i--) {
                        param = this.popStack();
                        params[i] = param;

                        if (this.trackIds) {
                            ids[i] = this.popStack();
                        }
                        if (this.stringParams) {
                            types[i] = this.popStack();
                            contexts[i] = this.popStack();
                        }
                    }

                    if (objectArgs) {
                        options.args = this.source.generateArray(params);
                    }

                    if (this.trackIds) {
                        options.ids = this.source.generateArray(ids);
                    }
                    if (this.stringParams) {
                        options.types = this.source.generateArray(types);
                        options.contexts = this.source.generateArray(contexts);
                    }

                    if (this.options.data) {
                        options.data = 'data';
                    }
                    if (this.useBlockParams) {
                        options.blockParams = 'blockParams';
                    }
                    return options;
                },

                setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
                    var options = this.setupParams(helper, paramSize, params);
                    options = this.objectLiteral(options);
                    if (useRegister) {
                        this.useRegister('options');
                        params.push('options');
                        return ['options=', options];
                    } else if (params) {
                        params.push(options);
                        return '';
                    } else {
                        return options;
                    }
                }
            };

            (function () {
                var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

                var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

                for (var i = 0, l = reservedWords.length; i < l; i++) {
                    compilerWords[reservedWords[i]] = true;
                }
            })();

            JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
                return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
            };

            function strictLookup(requireTerminal, compiler, parts, type) {
                var stack = compiler.popStack(),
                    i = 0,
                    len = parts.length;
                if (requireTerminal) {
                    len--;
                }

                for (; i < len; i++) {
                    stack = compiler.nameLookup(stack, parts[i], type);
                }

                if (requireTerminal) {
                    return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
                } else {
                    return stack;
                }
            }

            exports['default'] = JavaScriptCompiler;
            module.exports = exports['default'];

            /***/ }),
        /* 43 */
        /***/ (function(module, exports, __webpack_require__) {

            /* global define */
            'use strict';

            exports.__esModule = true;

            var _utils = __webpack_require__(5);

            var SourceNode = undefined;

            try {
                /* istanbul ignore next */
                if (false) {
                    // We don't support this in AMD environments. For these environments, we asusme that
                    // they are running on the browser and thus have no need for the source-map library.
                    var SourceMap = require('source-map');
                    SourceNode = SourceMap.SourceNode;
                }
            } catch (err) {}
            /* NOP */

            /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
            if (!SourceNode) {
                SourceNode = function (line, column, srcFile, chunks) {
                    this.src = '';
                    if (chunks) {
                        this.add(chunks);
                    }
                };
                /* istanbul ignore next */
                SourceNode.prototype = {
                    add: function add(chunks) {
                        if (_utils.isArray(chunks)) {
                            chunks = chunks.join('');
                        }
                        this.src += chunks;
                    },
                    prepend: function prepend(chunks) {
                        if (_utils.isArray(chunks)) {
                            chunks = chunks.join('');
                        }
                        this.src = chunks + this.src;
                    },
                    toStringWithSourceMap: function toStringWithSourceMap() {
                        return { code: this.toString() };
                    },
                    toString: function toString() {
                        return this.src;
                    }
                };
            }

            function castChunk(chunk, codeGen, loc) {
                if (_utils.isArray(chunk)) {
                    var ret = [];

                    for (var i = 0, len = chunk.length; i < len; i++) {
                        ret.push(codeGen.wrap(chunk[i], loc));
                    }
                    return ret;
                } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
                    // Handle primitives that the SourceNode will throw up on
                    return chunk + '';
                }
                return chunk;
            }

            function CodeGen(srcFile) {
                this.srcFile = srcFile;
                this.source = [];
            }

            CodeGen.prototype = {
                isEmpty: function isEmpty() {
                    return !this.source.length;
                },
                prepend: function prepend(source, loc) {
                    this.source.unshift(this.wrap(source, loc));
                },
                push: function push(source, loc) {
                    this.source.push(this.wrap(source, loc));
                },

                merge: function merge() {
                    var source = this.empty();
                    this.each(function (line) {
                        source.add(['  ', line, '\n']);
                    });
                    return source;
                },

                each: function each(iter) {
                    for (var i = 0, len = this.source.length; i < len; i++) {
                        iter(this.source[i]);
                    }
                },

                empty: function empty() {
                    var loc = this.currentLocation || { start: {} };
                    return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
                },
                wrap: function wrap(chunk) {
                    var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

                    if (chunk instanceof SourceNode) {
                        return chunk;
                    }

                    chunk = castChunk(chunk, this, loc);

                    return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
                },

                functionCall: function functionCall(fn, type, params) {
                    params = this.generateList(params);
                    return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
                },

                quotedString: function quotedString(str) {
                    return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
                        .replace(/\u2029/g, '\\u2029') + '"';
                },

                objectLiteral: function objectLiteral(obj) {
                    var pairs = [];

                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            var value = castChunk(obj[key], this);
                            if (value !== 'undefined') {
                                pairs.push([this.quotedString(key), ':', value]);
                            }
                        }
                    }

                    var ret = this.generateList(pairs);
                    ret.prepend('{');
                    ret.add('}');
                    return ret;
                },

                generateList: function generateList(entries) {
                    var ret = this.empty();

                    for (var i = 0, len = entries.length; i < len; i++) {
                        if (i) {
                            ret.add(',');
                        }

                        ret.add(castChunk(entries[i], this));
                    }

                    return ret;
                },

                generateArray: function generateArray(entries) {
                    var ret = this.generateList(entries);
                    ret.prepend('[');
                    ret.add(']');

                    return ret;
                }
            };

            exports['default'] = CodeGen;
            module.exports = exports['default'];

            /***/ })
        /******/ ])
});
;/*!
* Pub/Sub implementation
* http://addyosmani.com/
* Licensed under the GPL
* http://jsfiddle.net/LxPrq/
*/


;(function ( window, doc, undef ) {

    var topics = {},
        subUid = -1,
        pubsubz ={};

    pubsubz.publish = function ( topic, args ) {

        if (!topics[topic]) {
            return false;
        }

        setTimeout(function () {
            var subscribers = topics[topic],
                len = subscribers ? subscribers.length : 0;

            while (len--) {
                subscribers[len].func(topic, args);
            }
        }, 0);

        return true;

    };

    pubsubz.subscribe = function ( topic, func ) {

        if (!topics[topic]) {
            topics[topic] = [];
        }

        var token = (++subUid).toString();
        topics[topic].push({
            token: token,
            func: func
        });
        return token;
    };

    pubsubz.unsubscribe = function ( token ) {
        for (var m in topics) {
            if (topics[m]) {
                for (var i = 0, j = topics[m].length; i < j; i++) {
                    if (topics[m][i].token === token) {
                        topics[m].splice(i, 1);
                        return token;
                    }
                }
            }
        }
        return false;
    };

    getPubSubz = function(){
        return pubsubz;
    };

    window.pubsubz = getPubSubz();

}( this, this.document ));if(typeof jwplayer=="undefined"){var jwplayer=function(a){if(jwplayer.api){return jwplayer.api.selectPlayer(a)}};var $jw=jwplayer;jwplayer.version="5.10.2295 (Licensed version)";jwplayer.vid=document.createElement("video");jwplayer.audio=document.createElement("audio");jwplayer.source=document.createElement("source");(function(b){b.utils=function(){};b.utils.typeOf=function(d){var c=typeof d;if(c==="object"){if(d){if(d instanceof Array){c="array"}}else{c="null"}}return c};b.utils.extend=function(){var c=b.utils.extend["arguments"];if(c.length>1){for(var e=1;e<c.length;e++){for(var d in c[e]){c[0][d]=c[e][d]}}return c[0]}return null};b.utils.clone=function(f){var c;var d=b.utils.clone["arguments"];if(d.length==1){switch(b.utils.typeOf(d[0])){case"object":c={};for(var e in d[0]){c[e]=b.utils.clone(d[0][e])}break;case"array":c=[];for(var e in d[0]){c[e]=b.utils.clone(d[0][e])}break;default:return d[0];break}}return c};b.utils.extension=function(c){if(!c){return""}c=c.substring(c.lastIndexOf("/")+1,c.length);c=c.split("?")[0];if(c.lastIndexOf(".")>-1){return c.substr(c.lastIndexOf(".")+1,c.length).toLowerCase()}return};b.utils.html=function(c,d){c.innerHTML=d};b.utils.wrap=function(c,d){if(c.parentNode){c.parentNode.replaceChild(d,c)}d.appendChild(c)};b.utils.ajax=function(g,f,c){var e;if(window.XMLHttpRequest){e=new XMLHttpRequest()}else{e=new ActiveXObject("Microsoft.XMLHTTP")}e.onreadystatechange=function(){if(e.readyState===4){if(e.status===200){if(f){if(!b.utils.exists(e.responseXML)){try{if(window.DOMParser){var h=(new DOMParser()).parseFromString(e.responseText,"text/xml");if(h){e=b.utils.extend({},e,{responseXML:h})}}else{h=new ActiveXObject("Microsoft.XMLDOM");h.async="false";h.loadXML(e.responseText);e=b.utils.extend({},e,{responseXML:h})}}catch(j){if(c){c(g)}}}f(e)}}else{if(c){c(g)}}}};try{e.open("GET",g,true);e.send(null)}catch(d){if(c){c(g)}}return e};b.utils.load=function(d,e,c){d.onreadystatechange=function(){if(d.readyState===4){if(d.status===200){if(e){e()}}else{if(c){c()}}}}};b.utils.find=function(d,c){return d.getElementsByTagName(c)};b.utils.append=function(c,d){c.appendChild(d)};b.utils.isIE=function(){return((!+"\v1")||(typeof window.ActiveXObject!="undefined"))};b.utils.userAgentMatch=function(d){var c=navigator.userAgent.toLowerCase();return(c.match(d)!==null)};b.utils.isIOS=function(){return b.utils.userAgentMatch(/iP(hone|ad|od)/i)};b.utils.isIPad=function(){return b.utils.userAgentMatch(/iPad/i)};b.utils.isIPod=function(){return b.utils.userAgentMatch(/iP(hone|od)/i)};b.utils.isAndroid=function(){return b.utils.userAgentMatch(/android/i)};b.utils.isLegacyAndroid=function(){return b.utils.userAgentMatch(/android 2.[012]/i)};b.utils.isBlackberry=function(){return b.utils.userAgentMatch(/blackberry/i)};b.utils.isMobile=function(){return b.utils.userAgentMatch(/(iP(hone|ad|od))|android/i)};b.utils.getFirstPlaylistItemFromConfig=function(c){var d={};var e;if(c.playlist&&c.playlist.length){e=c.playlist[0]}else{e=c}d.file=e.file;d.levels=e.levels;d.streamer=e.streamer;d.playlistfile=e.playlistfile;d.provider=e.provider;if(!d.provider){if(d.file&&(d.file.toLowerCase().indexOf("youtube.com")>-1||d.file.toLowerCase().indexOf("youtu.be")>-1)){d.provider="youtube"}if(d.streamer&&d.streamer.toLowerCase().indexOf("rtmp://")==0){d.provider="rtmp"}if(e.type){d.provider=e.type.toLowerCase()}}if(d.provider=="audio"){d.provider="sound"}return d};b.utils.getOuterHTML=function(c){if(c.outerHTML){return c.outerHTML}else{try{return new XMLSerializer().serializeToString(c)}catch(d){return""}}};b.utils.setOuterHTML=function(f,e){if(f.outerHTML){f.outerHTML=e}else{var g=document.createElement("div");g.innerHTML=e;var c=document.createRange();c.selectNodeContents(g);var d=c.extractContents();f.parentNode.insertBefore(d,f);f.parentNode.removeChild(f)}};b.utils.hasFlash=function(){if(typeof navigator.plugins!="undefined"&&typeof navigator.plugins["Shockwave Flash"]!="undefined"){return true}if(typeof window.ActiveXObject!="undefined"){try{new ActiveXObject("ShockwaveFlash.ShockwaveFlash");return true}catch(c){}}return false};b.utils.getPluginName=function(c){if(c.lastIndexOf("/")>=0){c=c.substring(c.lastIndexOf("/")+1,c.length)}if(c.lastIndexOf("-")>=0){c=c.substring(0,c.lastIndexOf("-"))}if(c.lastIndexOf(".swf")>=0){c=c.substring(0,c.lastIndexOf(".swf"))}if(c.lastIndexOf(".js")>=0){c=c.substring(0,c.lastIndexOf(".js"))}return c};b.utils.getPluginVersion=function(c){if(c.lastIndexOf("-")>=0){if(c.lastIndexOf(".js")>=0){return c.substring(c.lastIndexOf("-")+1,c.lastIndexOf(".js"))}else{if(c.lastIndexOf(".swf")>=0){return c.substring(c.lastIndexOf("-")+1,c.lastIndexOf(".swf"))}else{return c.substring(c.lastIndexOf("-")+1)}}}return""};b.utils.getAbsolutePath=function(j,h){if(!b.utils.exists(h)){h=document.location.href}if(!b.utils.exists(j)){return undefined}if(a(j)){return j}var k=h.substring(0,h.indexOf("://")+3);var g=h.substring(k.length,h.indexOf("/",k.length+1));var d;if(j.indexOf("/")===0){d=j.split("/")}else{var e=h.split("?")[0];e=e.substring(k.length+g.length+1,e.lastIndexOf("/"));d=e.split("/").concat(j.split("/"))}var c=[];for(var f=0;f<d.length;f++){if(!d[f]||!b.utils.exists(d[f])||d[f]=="."){continue}else{if(d[f]==".."){c.pop()}else{c.push(d[f])}}}return k+g+"/"+c.join("/")};function a(d){if(!b.utils.exists(d)){return}var e=d.indexOf("://");var c=d.indexOf("?");return(e>0&&(c<0||(c>e)))}b.utils.pluginPathType={ABSOLUTE:"ABSOLUTE",RELATIVE:"RELATIVE",CDN:"CDN"};b.utils.getPluginPathType=function(d){if(typeof d!="string"){return}d=d.split("?")[0];var e=d.indexOf("://");if(e>0){return b.utils.pluginPathType.ABSOLUTE}var c=d.indexOf("/");var f=b.utils.extension(d);if(e<0&&c<0&&(!f||!isNaN(f))){return b.utils.pluginPathType.CDN}return b.utils.pluginPathType.RELATIVE};b.utils.mapEmpty=function(c){for(var d in c){return false}return true};b.utils.mapLength=function(d){var c=0;for(var e in d){c++}return c};b.utils.log=function(d,c){if(typeof console!="undefined"&&typeof console.log!="undefined"){if(c){console.log(d,c)}else{console.log(d)}}};b.utils.css=function(d,g,c){if(b.utils.exists(d)){for(var e in g){try{if(typeof g[e]==="undefined"){continue}else{if(typeof g[e]=="number"&&!(e=="zIndex"||e=="opacity")){if(isNaN(g[e])){continue}if(e.match(/color/i)){g[e]="#"+b.utils.strings.pad(g[e].toString(16),6)}else{g[e]=Math.ceil(g[e])+"px"}}}d.style[e]=g[e]}catch(f){}}}};b.utils.isYouTube=function(c){return(c.indexOf("youtube.com")>-1||c.indexOf("youtu.be")>-1)};b.utils.transform=function(e,d,c,g,h){if(!b.utils.exists(d)){d=1}if(!b.utils.exists(c)){c=1}if(!b.utils.exists(g)){g=0}if(!b.utils.exists(h)){h=0}if(d==1&&c==1&&g==0&&h==0){e.style.webkitTransform="";e.style.MozTransform="";e.style.OTransform=""}else{var f="scale("+d+","+c+") translate("+g+"px,"+h+"px)";e.style.webkitTransform=f;e.style.MozTransform=f;e.style.OTransform=f}};b.utils.stretch=function(k,q,p,g,n,h){if(typeof p=="undefined"||typeof g=="undefined"||typeof n=="undefined"||typeof h=="undefined"){return}var d=p/n;var f=g/h;var m=0;var l=0;var e=false;var c={};if(q.parentElement){q.parentElement.style.overflow="hidden"}b.utils.transform(q);switch(k.toUpperCase()){case b.utils.stretching.NONE:c.width=n;c.height=h;c.top=(g-c.height)/2;c.left=(p-c.width)/2;break;case b.utils.stretching.UNIFORM:if(d>f){c.width=n*f;c.height=h*f;if(c.width/p>0.95){e=true;d=Math.ceil(100*p/c.width)/100;f=1;c.width=p}}else{c.width=n*d;c.height=h*d;if(c.height/g>0.95){e=true;d=1;f=Math.ceil(100*g/c.height)/100;c.height=g}}c.top=(g-c.height)/2;c.left=(p-c.width)/2;break;case b.utils.stretching.FILL:if(d>f){c.width=n*d;c.height=h*d}else{c.width=n*f;c.height=h*f}c.top=(g-c.height)/2;c.left=(p-c.width)/2;break;case b.utils.stretching.EXACTFIT:c.width=n;c.height=h;var o=Math.round((n/2)*(1-1/d));var j=Math.round((h/2)*(1-1/f));e=true;c.top=c.left=0;break;default:break}if(e){b.utils.transform(q,d,f,o,j)}b.utils.css(q,c)};b.utils.stretching={NONE:"NONE",FILL:"FILL",UNIFORM:"UNIFORM",EXACTFIT:"EXACTFIT"};b.utils.deepReplaceKeyName=function(k,e,c){switch(b.utils.typeOf(k)){case"array":for(var g=0;g<k.length;g++){k[g]=b.utils.deepReplaceKeyName(k[g],e,c)}break;case"object":for(var f in k){var j,h;if(e instanceof Array&&c instanceof Array){if(e.length!=c.length){continue}else{j=e;h=c}}else{j=[e];h=[c]}var d=f;for(var g=0;g<j.length;g++){d=d.replace(new RegExp(e[g],"g"),c[g])}k[d]=b.utils.deepReplaceKeyName(k[f],e,c);if(f!=d){delete k[f]}}break}return k};b.utils.isInArray=function(e,d){if(!(e)||!(e instanceof Array)){return false}for(var c=0;c<e.length;c++){if(d===e[c]){return true}}return false};b.utils.exists=function(c){switch(typeof(c)){case"string":return(c.length>0);break;case"object":return(c!==null);case"undefined":return false}return true};b.utils.empty=function(c){if(typeof c.hasChildNodes=="function"){while(c.hasChildNodes()){c.removeChild(c.firstChild)}}};b.utils.parseDimension=function(c){if(typeof c=="string"){if(c===""){return 0}else{if(c.lastIndexOf("%")>-1){return c}else{return parseInt(c.replace("px",""),10)}}}return c};b.utils.getDimensions=function(c){if(c&&c.style){return{x:b.utils.parseDimension(c.style.left),y:b.utils.parseDimension(c.style.top),width:b.utils.parseDimension(c.style.width),height:b.utils.parseDimension(c.style.height)}}else{return{}}};b.utils.getElementWidth=function(c){if(!c){return null}else{if(c==document.body){return b.utils.parentNode(c).clientWidth}else{if(c.clientWidth>0){return c.clientWidth}else{if(c.style){return b.utils.parseDimension(c.style.width)}else{return null}}}}};b.utils.getElementHeight=function(c){if(!c){return null}else{if(c==document.body){return b.utils.parentNode(c).clientHeight}else{if(c.clientHeight>0){return c.clientHeight}else{if(c.style){return b.utils.parseDimension(c.style.height)}else{return null}}}}};b.utils.timeFormat=function(c){str="00:00";if(c>0){str=Math.floor(c/60)<10?"0"+Math.floor(c/60)+":":Math.floor(c/60)+":";str+=Math.floor(c%60)<10?"0"+Math.floor(c%60):Math.floor(c%60)}return str};b.utils.useNativeFullscreen=function(){return(navigator&&navigator.vendor&&navigator.vendor.indexOf("Apple")==0)};b.utils.parentNode=function(c){if(!c){return document.body}else{if(c.parentNode){return c.parentNode}else{if(c.parentElement){return c.parentElement}else{return c}}}};b.utils.getBoundingClientRect=function(c){if(typeof c.getBoundingClientRect=="function"){return c.getBoundingClientRect()}else{return{left:c.offsetLeft+document.body.scrollLeft,top:c.offsetTop+document.body.scrollTop,width:c.offsetWidth,height:c.offsetHeight}}};b.utils.translateEventResponse=function(e,c){var g=b.utils.extend({},c);if(e==b.api.events.JWPLAYER_FULLSCREEN&&!g.fullscreen){g.fullscreen=g.message=="true"?true:false;delete g.message}else{if(typeof g.data=="object"){g=b.utils.extend(g,g.data);delete g.data}else{if(typeof g.metadata=="object"){b.utils.deepReplaceKeyName(g.metadata,["__dot__","__spc__","__dsh__"],["."," ","-"])}}}var d=["position","duration","offset"];for(var f in d){if(g[d[f]]){g[d[f]]=Math.round(g[d[f]]*1000)/1000}}return g};b.utils.saveCookie=function(c,d){document.cookie="jwplayer."+c+"="+d+"; path=/"};b.utils.getCookies=function(){var f={};var e=document.cookie.split("; ");for(var d=0;d<e.length;d++){var c=e[d].split("=");if(c[0].indexOf("jwplayer.")==0){f[c[0].substring(9,c[0].length)]=c[1]}}return f};b.utils.readCookie=function(c){return b.utils.getCookies()[c]}})(jwplayer);(function(a){a.events=function(){};a.events.COMPLETE="COMPLETE";a.events.ERROR="ERROR"})(jwplayer);(function(jwplayer){jwplayer.events.eventdispatcher=function(debug){var _debug=debug;var _listeners;var _globallisteners;this.resetEventListeners=function(){_listeners={};_globallisteners=[]};this.resetEventListeners();this.addEventListener=function(type,listener,count){try{if(!jwplayer.utils.exists(_listeners[type])){_listeners[type]=[]}if(typeof(listener)=="string"){eval("listener = "+listener)}_listeners[type].push({listener:listener,count:count})}catch(err){jwplayer.utils.log("error",err)}return false};this.removeEventListener=function(type,listener){if(!_listeners[type]){return}try{for(var listenerIndex=0;listenerIndex<_listeners[type].length;listenerIndex++){if(_listeners[type][listenerIndex].listener.toString()==listener.toString()){_listeners[type].splice(listenerIndex,1);break}}}catch(err){jwplayer.utils.log("error",err)}return false};this.addGlobalListener=function(listener,count){try{if(typeof(listener)=="string"){eval("listener = "+listener)}_globallisteners.push({listener:listener,count:count})}catch(err){jwplayer.utils.log("error",err)}return false};this.removeGlobalListener=function(listener){if(!listener){return}try{for(var globalListenerIndex=0;globalListenerIndex<_globallisteners.length;globalListenerIndex++){if(_globallisteners[globalListenerIndex].listener.toString()==listener.toString()){_globallisteners.splice(globalListenerIndex,1);break}}}catch(err){jwplayer.utils.log("error",err)}return false};this.sendEvent=function(type,data){if(!jwplayer.utils.exists(data)){data={}}if(_debug){jwplayer.utils.log(type,data)}if(typeof _listeners[type]!="undefined"){for(var listenerIndex=0;listenerIndex<_listeners[type].length;listenerIndex++){try{_listeners[type][listenerIndex].listener(data)}catch(err){jwplayer.utils.log("There was an error while handling a listener: "+err.toString(),_listeners[type][listenerIndex].listener)}if(_listeners[type][listenerIndex]){if(_listeners[type][listenerIndex].count===1){delete _listeners[type][listenerIndex]}else{if(_listeners[type][listenerIndex].count>0){_listeners[type][listenerIndex].count=_listeners[type][listenerIndex].count-1}}}}}for(var globalListenerIndex=0;globalListenerIndex<_globallisteners.length;globalListenerIndex++){try{_globallisteners[globalListenerIndex].listener(data)}catch(err){jwplayer.utils.log("There was an error while handling a listener: "+err.toString(),_globallisteners[globalListenerIndex].listener)}if(_globallisteners[globalListenerIndex]){if(_globallisteners[globalListenerIndex].count===1){delete _globallisteners[globalListenerIndex]}else{if(_globallisteners[globalListenerIndex].count>0){_globallisteners[globalListenerIndex].count=_globallisteners[globalListenerIndex].count-1}}}}}}})(jwplayer);(function(a){var b={};a.utils.animations=function(){};a.utils.animations.transform=function(c,d){c.style.webkitTransform=d;c.style.MozTransform=d;c.style.OTransform=d;c.style.msTransform=d};a.utils.animations.transformOrigin=function(c,d){c.style.webkitTransformOrigin=d;c.style.MozTransformOrigin=d;c.style.OTransformOrigin=d;c.style.msTransformOrigin=d};a.utils.animations.rotate=function(c,d){a.utils.animations.transform(c,["rotate(",d,"deg)"].join(""))};a.utils.cancelAnimation=function(c){delete b[c.id]};a.utils.fadeTo=function(m,f,e,j,h,d){if(b[m.id]!=d&&a.utils.exists(d)){return}if(m.style.opacity==f){return}var c=new Date().getTime();if(d>c){setTimeout(function(){a.utils.fadeTo(m,f,e,j,0,d)},d-c)}if(m.style.display=="none"){m.style.display="block"}if(!a.utils.exists(j)){j=m.style.opacity===""?1:m.style.opacity}if(m.style.opacity==f&&m.style.opacity!==""&&a.utils.exists(d)){if(f===0){m.style.display="none"}return}if(!a.utils.exists(d)){d=c;b[m.id]=d}if(!a.utils.exists(h)){h=0}var k=(e>0)?((c-d)/(e*1000)):0;k=k>1?1:k;var l=f-j;var g=j+(k*l);if(g>1){g=1}else{if(g<0){g=0}}m.style.opacity=g;if(h>0){b[m.id]=d+h*1000;a.utils.fadeTo(m,f,e,j,0,b[m.id]);return}setTimeout(function(){a.utils.fadeTo(m,f,e,j,0,d)},10)}})(jwplayer);(function(a){a.utils.arrays=function(){};a.utils.arrays.indexOf=function(c,d){for(var b=0;b<c.length;b++){if(c[b]==d){return b}}return -1};a.utils.arrays.remove=function(c,d){var b=a.utils.arrays.indexOf(c,d);if(b>-1){c.splice(b,1)}}})(jwplayer);(function(a){a.utils.extensionmap={"3gp":{html5:"video/3gpp",flash:"video"},"3gpp":{html5:"video/3gpp"},"3g2":{html5:"video/3gpp2",flash:"video"},"3gpp2":{html5:"video/3gpp2"},flv:{flash:"video"},f4a:{html5:"audio/mp4"},f4b:{html5:"audio/mp4",flash:"video"},f4v:{html5:"video/mp4",flash:"video"},mov:{html5:"video/quicktime",flash:"video"},m4a:{html5:"audio/mp4",flash:"video"},m4b:{html5:"audio/mp4"},m4p:{html5:"audio/mp4"},m4v:{html5:"video/mp4",flash:"video"},mp4:{html5:"video/mp4",flash:"video"},rbs:{flash:"sound"},aac:{html5:"audio/aac",flash:"video"},mp3:{html5:"audio/mp3",flash:"sound"},ogg:{html5:"audio/ogg"},oga:{html5:"audio/ogg"},ogv:{html5:"video/ogg"},webm:{html5:"video/webm"},m3u8:{html5:"audio/x-mpegurl"},gif:{flash:"image"},jpeg:{flash:"image"},jpg:{flash:"image"},swf:{flash:"image"},png:{flash:"image"},wav:{html5:"audio/x-wav"}}})(jwplayer);(function(e){e.utils.mediaparser=function(){};var g={element:{width:"width",height:"height",id:"id","class":"className",name:"name"},media:{src:"file",preload:"preload",autoplay:"autostart",loop:"repeat",controls:"controls"},source:{src:"file",type:"type",media:"media","data-jw-width":"width","data-jw-bitrate":"bitrate"},video:{poster:"image"}};var f={};e.utils.mediaparser.parseMedia=function(j){return d(j)};function c(k,j){if(!e.utils.exists(j)){j=g[k]}else{e.utils.extend(j,g[k])}return j}function d(n,j){if(f[n.tagName.toLowerCase()]&&!e.utils.exists(j)){return f[n.tagName.toLowerCase()](n)}else{j=c("element",j);var o={};for(var k in j){if(k!="length"){var m=n.getAttribute(k);if(e.utils.exists(m)){o[j[k]]=m}}}var l=n.style["#background-color"];if(l&&!(l=="transparent"||l=="rgba(0, 0, 0, 0)")){o.screencolor=l}return o}}function h(n,k){k=c("media",k);var l=[];var j=e.utils.selectors("source",n);for(var m in j){if(!isNaN(m)){l.push(a(j[m]))}}var o=d(n,k);if(e.utils.exists(o.file)){l[0]={file:o.file}}o.levels=l;return o}function a(l,k){k=c("source",k);var j=d(l,k);j.width=j.width?j.width:0;j.bitrate=j.bitrate?j.bitrate:0;return j}function b(l,k){k=c("video",k);var j=h(l,k);return j}f.media=h;f.audio=h;f.source=a;f.video=b})(jwplayer);(function(a){a.utils.loaderstatus={NEW:"NEW",LOADING:"LOADING",ERROR:"ERROR",COMPLETE:"COMPLETE"};a.utils.scriptloader=function(c){var d=a.utils.loaderstatus.NEW;var b=new a.events.eventdispatcher();a.utils.extend(this,b);this.load=function(){if(d==a.utils.loaderstatus.NEW){d=a.utils.loaderstatus.LOADING;var e=document.createElement("script");e.onload=function(f){d=a.utils.loaderstatus.COMPLETE;b.sendEvent(a.events.COMPLETE)};e.onerror=function(f){d=a.utils.loaderstatus.ERROR;b.sendEvent(a.events.ERROR)};e.onreadystatechange=function(){if(e.readyState=="loaded"||e.readyState=="complete"){d=a.utils.loaderstatus.COMPLETE;b.sendEvent(a.events.COMPLETE)}};document.getElementsByTagName("head")[0].appendChild(e);e.src=c}};this.getStatus=function(){return d}}})(jwplayer);(function(a){a.utils.selectors=function(b,e){if(!a.utils.exists(e)){e=document}b=a.utils.strings.trim(b);var c=b.charAt(0);if(c=="#"){return e.getElementById(b.substr(1))}else{if(c=="."){if(e.getElementsByClassName){return e.getElementsByClassName(b.substr(1))}else{return a.utils.selectors.getElementsByTagAndClass("*",b.substr(1))}}else{if(b.indexOf(".")>0){var d=b.split(".");return a.utils.selectors.getElementsByTagAndClass(d[0],d[1])}else{return e.getElementsByTagName(b)}}}return null};a.utils.selectors.getElementsByTagAndClass=function(e,h,g){var j=[];if(!a.utils.exists(g)){g=document}var f=g.getElementsByTagName(e);for(var d=0;d<f.length;d++){if(a.utils.exists(f[d].className)){var c=f[d].className.split(" ");for(var b=0;b<c.length;b++){if(c[b]==h){j.push(f[d])}}}}return j}})(jwplayer);(function(a){a.utils.strings=function(){};a.utils.strings.trim=function(b){return b.replace(/^\s*/,"").replace(/\s*$/,"")};a.utils.strings.pad=function(c,d,b){if(!b){b="0"}while(c.length<d){c=b+c}return c};a.utils.strings.serialize=function(b){if(b==null){return null}else{if(b=="true"){return true}else{if(b=="false"){return false}else{if(isNaN(Number(b))||b.length>5||b.length==0){return b}else{return Number(b)}}}}};a.utils.strings.seconds=function(d){d=d.replace(",",".");var b=d.split(":");var c=0;if(d.substr(-1)=="s"){c=Number(d.substr(0,d.length-1))}else{if(d.substr(-1)=="m"){c=Number(d.substr(0,d.length-1))*60}else{if(d.substr(-1)=="h"){c=Number(d.substr(0,d.length-1))*3600}else{if(b.length>1){c=Number(b[b.length-1]);c+=Number(b[b.length-2])*60;if(b.length==3){c+=Number(b[b.length-3])*3600}}else{c=Number(d)}}}}return c};a.utils.strings.xmlAttribute=function(b,c){for(var d=0;d<b.attributes.length;d++){if(b.attributes[d].name&&b.attributes[d].name.toLowerCase()==c.toLowerCase()){return b.attributes[d].value.toString()}}return""};a.utils.strings.jsonToString=function(f){var h=h||{};if(h&&h.stringify){return h.stringify(f)}var c=typeof(f);if(c!="object"||f===null){if(c=="string"){f='"'+f.replace(/"/g,'\\"')+'"'}else{return String(f)}}else{var g=[],b=(f&&f.constructor==Array);for(var d in f){var e=f[d];switch(typeof(e)){case"string":e='"'+e.replace(/"/g,'\\"')+'"';break;case"object":if(a.utils.exists(e)){e=a.utils.strings.jsonToString(e)}break}if(b){if(typeof(e)!="function"){g.push(String(e))}}else{if(typeof(e)!="function"){g.push('"'+d+'":'+String(e))}}}if(b){return"["+String(g)+"]"}else{return"{"+String(g)+"}"}}}})(jwplayer);(function(c){var d=new RegExp(/^(#|0x)[0-9a-fA-F]{3,6}/);c.utils.typechecker=function(g,f){f=!c.utils.exists(f)?b(g):f;return e(g,f)};function b(f){var g=["true","false","t","f"];if(g.toString().indexOf(f.toLowerCase().replace(" ",""))>=0){return"boolean"}else{if(d.test(f)){return"color"}else{if(!isNaN(parseInt(f,10))&&parseInt(f,10).toString().length==f.length){return"integer"}else{if(!isNaN(parseFloat(f))&&parseFloat(f).toString().length==f.length){return"float"}}}}return"string"}function e(g,f){if(!c.utils.exists(f)){return g}switch(f){case"color":if(g.length>0){return a(g)}return null;case"integer":return parseInt(g,10);case"float":return parseFloat(g);case"boolean":if(g.toLowerCase()=="true"){return true}else{if(g=="1"){return true}}return false}return g}function a(f){switch(f.toLowerCase()){case"blue":return parseInt("0000FF",16);case"green":return parseInt("00FF00",16);case"red":return parseInt("FF0000",16);case"cyan":return parseInt("00FFFF",16);case"magenta":return parseInt("FF00FF",16);case"yellow":return parseInt("FFFF00",16);case"black":return parseInt("000000",16);case"white":return parseInt("FFFFFF",16);default:f=f.replace(/(#|0x)?([0-9A-F]{3,6})$/gi,"$2");if(f.length==3){f=f.charAt(0)+f.charAt(0)+f.charAt(1)+f.charAt(1)+f.charAt(2)+f.charAt(2)}return parseInt(f,16)}return parseInt("000000",16)}})(jwplayer);(function(a){a.utils.parsers=function(){};a.utils.parsers.localName=function(b){if(!b){return""}else{if(b.localName){return b.localName}else{if(b.baseName){return b.baseName}else{return""}}}};a.utils.parsers.textContent=function(b){if(!b){return""}else{if(b.textContent){return b.textContent}else{if(b.text){return b.text}else{return""}}}}})(jwplayer);(function(a){a.utils.parsers.jwparser=function(){};a.utils.parsers.jwparser.PREFIX="jwplayer";a.utils.parsers.jwparser.parseEntry=function(c,d){for(var b=0;b<c.childNodes.length;b++){if(c.childNodes[b].prefix==a.utils.parsers.jwparser.PREFIX){d[a.utils.parsers.localName(c.childNodes[b])]=a.utils.strings.serialize(a.utils.parsers.textContent(c.childNodes[b]));if(a.utils.parsers.localName(c.childNodes[b])=="file"&&d.levels){delete d.levels}}if(!d.file&&String(d.link).toLowerCase().indexOf("youtube")>-1){d.file=d.link}}return d};a.utils.parsers.jwparser.getProvider=function(c){if(c.type){return c.type}else{if(c.file.indexOf("youtube.com/w")>-1||c.file.indexOf("youtube.com/v")>-1||c.file.indexOf("youtu.be/")>-1){return"youtube"}else{if(c.streamer&&c.streamer.indexOf("rtmp")==0){return"rtmp"}else{if(c.streamer&&c.streamer.indexOf("http")==0){return"http"}else{var b=a.utils.strings.extension(c.file);if(extensions.hasOwnProperty(b)){return extensions[b]}}}}}return""}})(jwplayer);(function(a){a.utils.parsers.mediaparser=function(){};a.utils.parsers.mediaparser.PREFIX="media";a.utils.parsers.mediaparser.parseGroup=function(d,f){var e=false;for(var c=0;c<d.childNodes.length;c++){if(d.childNodes[c].prefix==a.utils.parsers.mediaparser.PREFIX){if(!a.utils.parsers.localName(d.childNodes[c])){continue}switch(a.utils.parsers.localName(d.childNodes[c]).toLowerCase()){case"content":if(!e){f.file=a.utils.strings.xmlAttribute(d.childNodes[c],"url")}if(a.utils.strings.xmlAttribute(d.childNodes[c],"duration")){f.duration=a.utils.strings.seconds(a.utils.strings.xmlAttribute(d.childNodes[c],"duration"))}if(a.utils.strings.xmlAttribute(d.childNodes[c],"start")){f.start=a.utils.strings.seconds(a.utils.strings.xmlAttribute(d.childNodes[c],"start"))}if(d.childNodes[c].childNodes&&d.childNodes[c].childNodes.length>0){f=a.utils.parsers.mediaparser.parseGroup(d.childNodes[c],f)}if(a.utils.strings.xmlAttribute(d.childNodes[c],"width")||a.utils.strings.xmlAttribute(d.childNodes[c],"bitrate")||a.utils.strings.xmlAttribute(d.childNodes[c],"url")){if(!f.levels){f.levels=[]}f.levels.push({width:a.utils.strings.xmlAttribute(d.childNodes[c],"width"),bitrate:a.utils.strings.xmlAttribute(d.childNodes[c],"bitrate"),file:a.utils.strings.xmlAttribute(d.childNodes[c],"url")})}break;case"title":f.title=a.utils.parsers.textContent(d.childNodes[c]);break;case"description":f.description=a.utils.parsers.textContent(d.childNodes[c]);break;case"keywords":f.tags=a.utils.parsers.textContent(d.childNodes[c]);break;case"thumbnail":f.image=a.utils.strings.xmlAttribute(d.childNodes[c],"url");break;case"credit":f.author=a.utils.parsers.textContent(d.childNodes[c]);break;case"player":var b=d.childNodes[c].url;if(b.indexOf("youtube.com")>=0||b.indexOf("youtu.be")>=0){e=true;f.file=a.utils.strings.xmlAttribute(d.childNodes[c],"url")}break;case"group":a.utils.parsers.mediaparser.parseGroup(d.childNodes[c],f);break}}}return f}})(jwplayer);(function(b){b.utils.parsers.rssparser=function(){};b.utils.parsers.rssparser.parse=function(f){var c=[];for(var e=0;e<f.childNodes.length;e++){if(b.utils.parsers.localName(f.childNodes[e]).toLowerCase()=="channel"){for(var d=0;d<f.childNodes[e].childNodes.length;d++){if(b.utils.parsers.localName(f.childNodes[e].childNodes[d]).toLowerCase()=="item"){c.push(a(f.childNodes[e].childNodes[d]))}}}}return c};function a(d){var e={};for(var c=0;c<d.childNodes.length;c++){if(!b.utils.parsers.localName(d.childNodes[c])){continue}switch(b.utils.parsers.localName(d.childNodes[c]).toLowerCase()){case"enclosure":e.file=b.utils.strings.xmlAttribute(d.childNodes[c],"url");break;case"title":e.title=b.utils.parsers.textContent(d.childNodes[c]);break;case"pubdate":e.date=b.utils.parsers.textContent(d.childNodes[c]);break;case"description":e.description=b.utils.parsers.textContent(d.childNodes[c]);break;case"link":e.link=b.utils.parsers.textContent(d.childNodes[c]);break;case"category":if(e.tags){e.tags+=b.utils.parsers.textContent(d.childNodes[c])}else{e.tags=b.utils.parsers.textContent(d.childNodes[c])}break}}e=b.utils.parsers.mediaparser.parseGroup(d,e);e=b.utils.parsers.jwparser.parseEntry(d,e);return new b.html5.playlistitem(e)}})(jwplayer);(function(a){var c={};var b={};a.plugins=function(){};a.plugins.loadPlugins=function(e,d){b[e]=new a.plugins.pluginloader(new a.plugins.model(c),d);return b[e]};a.plugins.registerPlugin=function(h,f,e){var d=a.utils.getPluginName(h);if(c[d]){c[d].registerPlugin(h,f,e)}else{a.utils.log("A plugin ("+h+") was registered with the player that was not loaded. Please check your configuration.");for(var g in b){b[g].pluginFailed()}}}})(jwplayer);(function(a){a.plugins.model=function(b){this.addPlugin=function(c){var d=a.utils.getPluginName(c);if(!b[d]){b[d]=new a.plugins.plugin(c)}return b[d]}}})(jwplayer);(function(a){a.plugins.pluginmodes={FLASH:"FLASH",JAVASCRIPT:"JAVASCRIPT",HYBRID:"HYBRID"};a.plugins.plugin=function(b){var d="http://lp.longtailvideo.com";var j=a.utils.loaderstatus.NEW;var k;var h;var l;var c=new a.events.eventdispatcher();a.utils.extend(this,c);function e(){switch(a.utils.getPluginPathType(b)){case a.utils.pluginPathType.ABSOLUTE:return b;case a.utils.pluginPathType.RELATIVE:return a.utils.getAbsolutePath(b,window.location.href);case a.utils.pluginPathType.CDN:var o=a.utils.getPluginName(b);var n=a.utils.getPluginVersion(b);var m=(window.location.href.indexOf("https://")==0)?d.replace("http://","https://secure"):d;return m+"/"+a.version.split(".")[0]+"/"+o+"/"+o+(n!==""?("-"+n):"")+".js"}}function g(m){l=setTimeout(function(){j=a.utils.loaderstatus.COMPLETE;c.sendEvent(a.events.COMPLETE)},1000)}function f(m){j=a.utils.loaderstatus.ERROR;c.sendEvent(a.events.ERROR)}this.load=function(){if(j==a.utils.loaderstatus.NEW){if(b.lastIndexOf(".swf")>0){k=b;j=a.utils.loaderstatus.COMPLETE;c.sendEvent(a.events.COMPLETE);return}j=a.utils.loaderstatus.LOADING;var m=new a.utils.scriptloader(e());m.addEventListener(a.events.COMPLETE,g);m.addEventListener(a.events.ERROR,f);m.load()}};this.registerPlugin=function(o,n,m){if(l){clearTimeout(l);l=undefined}if(n&&m){k=m;h=n}else{if(typeof n=="string"){k=n}else{if(typeof n=="function"){h=n}else{if(!n&&!m){k=o}}}}j=a.utils.loaderstatus.COMPLETE;c.sendEvent(a.events.COMPLETE)};this.getStatus=function(){return j};this.getPluginName=function(){return a.utils.getPluginName(b)};this.getFlashPath=function(){if(k){switch(a.utils.getPluginPathType(k)){case a.utils.pluginPathType.ABSOLUTE:return k;case a.utils.pluginPathType.RELATIVE:if(b.lastIndexOf(".swf")>0){return a.utils.getAbsolutePath(k,window.location.href)}return a.utils.getAbsolutePath(k,e());case a.utils.pluginPathType.CDN:if(k.indexOf("-")>-1){return k+"h"}return k+"-h"}}return null};this.getJS=function(){return h};this.getPluginmode=function(){if(typeof k!="undefined"&&typeof h!="undefined"){return a.plugins.pluginmodes.HYBRID}else{if(typeof k!="undefined"){return a.plugins.pluginmodes.FLASH}else{if(typeof h!="undefined"){return a.plugins.pluginmodes.JAVASCRIPT}}}};this.getNewInstance=function(n,m,o){return new h(n,m,o)};this.getURL=function(){return b}}})(jwplayer);(function(a){a.plugins.pluginloader=function(h,e){var g={};var k=a.utils.loaderstatus.NEW;var d=false;var b=false;var c=new a.events.eventdispatcher();a.utils.extend(this,c);function f(){if(!b){b=true;k=a.utils.loaderstatus.COMPLETE;c.sendEvent(a.events.COMPLETE)}}function j(){if(!b){var m=0;for(plugin in g){var l=g[plugin].getStatus();if(l==a.utils.loaderstatus.LOADING||l==a.utils.loaderstatus.NEW){m++}}if(m==0){f()}}}this.setupPlugins=function(n,l,s){var m={length:0,plugins:{}};var p={length:0,plugins:{}};for(var o in g){var q=g[o].getPluginName();if(g[o].getFlashPath()){m.plugins[g[o].getFlashPath()]=l.plugins[o];m.plugins[g[o].getFlashPath()].pluginmode=g[o].getPluginmode();m.length++}if(g[o].getJS()){var r=document.createElement("div");r.id=n.id+"_"+q;r.style.position="absolute";r.style.zIndex=p.length+10;p.plugins[q]=g[o].getNewInstance(n,l.plugins[o],r);p.length++;if(typeof p.plugins[q].resize!="undefined"){n.onReady(s(p.plugins[q],r,true));n.onResize(s(p.plugins[q],r))}}}n.plugins=p.plugins;return m};this.load=function(){k=a.utils.loaderstatus.LOADING;d=true;for(var l in e){if(a.utils.exists(l)){g[l]=h.addPlugin(l);g[l].addEventListener(a.events.COMPLETE,j);g[l].addEventListener(a.events.ERROR,j)}}for(l in g){g[l].load()}d=false;j()};this.pluginFailed=function(){f()};this.getStatus=function(){return k}}})(jwplayer);(function(b){var a=[];b.api=function(d){this.container=d;this.id=d.id;var m={};var t={};var p={};var c=[];var g=undefined;var k=false;var h=[];var r=undefined;var o=b.utils.getOuterHTML(d);var s={};var j={};this.getBuffer=function(){return this.callInternal("jwGetBuffer")};this.getContainer=function(){return this.container};function e(v,u){return function(A,w,x,y){if(v.renderingMode=="flash"||v.renderingMode=="html5"){var z;if(w){j[A]=w;z="jwplayer('"+v.id+"').callback('"+A+"')"}else{if(!w&&j[A]){delete j[A]}}g.jwDockSetButton(A,z,x,y)}return u}}this.getPlugin=function(u){var w=this;var v={};if(u=="dock"){return b.utils.extend(v,{setButton:e(w,v),show:function(){w.callInternal("jwDockShow");return v},hide:function(){w.callInternal("jwDockHide");return v},onShow:function(x){w.componentListener("dock",b.api.events.JWPLAYER_COMPONENT_SHOW,x);return v},onHide:function(x){w.componentListener("dock",b.api.events.JWPLAYER_COMPONENT_HIDE,x);return v}})}else{if(u=="controlbar"){return b.utils.extend(v,{show:function(){w.callInternal("jwControlbarShow");return v},hide:function(){w.callInternal("jwControlbarHide");return v},onShow:function(x){w.componentListener("controlbar",b.api.events.JWPLAYER_COMPONENT_SHOW,x);return v},onHide:function(x){w.componentListener("controlbar",b.api.events.JWPLAYER_COMPONENT_HIDE,x);return v}})}else{if(u=="display"){return b.utils.extend(v,{show:function(){w.callInternal("jwDisplayShow");return v},hide:function(){w.callInternal("jwDisplayHide");return v},onShow:function(x){w.componentListener("display",b.api.events.JWPLAYER_COMPONENT_SHOW,x);return v},onHide:function(x){w.componentListener("display",b.api.events.JWPLAYER_COMPONENT_HIDE,x);return v}})}else{return this.plugins[u]}}}};this.callback=function(u){if(j[u]){return j[u]()}};this.getDuration=function(){return this.callInternal("jwGetDuration")};this.getFullscreen=function(){return this.callInternal("jwGetFullscreen")};this.getHeight=function(){return this.callInternal("jwGetHeight")};this.getLockState=function(){return this.callInternal("jwGetLockState")};this.getMeta=function(){return this.getItemMeta()};this.getMute=function(){return this.callInternal("jwGetMute")};this.getPlaylist=function(){var v=this.callInternal("jwGetPlaylist");if(this.renderingMode=="flash"){b.utils.deepReplaceKeyName(v,["__dot__","__spc__","__dsh__"],["."," ","-"])}for(var u=0;u<v.length;u++){if(!b.utils.exists(v[u].index)){v[u].index=u}}return v};this.getPlaylistItem=function(u){if(!b.utils.exists(u)){u=this.getCurrentItem()}return this.getPlaylist()[u]};this.getPosition=function(){return this.callInternal("jwGetPosition")};this.getRenderingMode=function(){return this.renderingMode};this.getState=function(){return this.callInternal("jwGetState")};this.getVolume=function(){return this.callInternal("jwGetVolume")};this.getWidth=function(){return this.callInternal("jwGetWidth")};this.setFullscreen=function(u){if(!b.utils.exists(u)){this.callInternal("jwSetFullscreen",!this.callInternal("jwGetFullscreen"))}else{this.callInternal("jwSetFullscreen",u)}return this};this.setMute=function(u){if(!b.utils.exists(u)){this.callInternal("jwSetMute",!this.callInternal("jwGetMute"))}else{this.callInternal("jwSetMute",u)}return this};this.lock=function(){return this};this.unlock=function(){return this};this.load=function(u){this.callInternal("jwLoad",u);return this};this.playlistItem=function(u){this.callInternal("jwPlaylistItem",u);return this};this.playlistPrev=function(){this.callInternal("jwPlaylistPrev");return this};this.playlistNext=function(){this.callInternal("jwPlaylistNext");return this};this.resize=function(v,u){if(this.renderingMode=="html5"){g.jwResize(v,u)}else{this.container.width=v;this.container.height=u;var w=document.getElementById(this.id+"_wrapper");if(w){w.style.width=v+"px";w.style.height=u+"px"}}return this};this.play=function(u){if(typeof u=="undefined"){u=this.getState();if(u==b.api.events.state.PLAYING||u==b.api.events.state.BUFFERING){this.callInternal("jwPause")}else{this.callInternal("jwPlay")}}else{this.callInternal("jwPlay",u)}return this};this.pause=function(u){if(typeof u=="undefined"){u=this.getState();if(u==b.api.events.state.PLAYING||u==b.api.events.state.BUFFERING){this.callInternal("jwPause")}else{this.callInternal("jwPlay")}}else{this.callInternal("jwPause",u)}return this};this.stop=function(){this.callInternal("jwStop");return this};this.seek=function(u){this.callInternal("jwSeek",u);return this};this.setVolume=function(u){this.callInternal("jwSetVolume",u);return this};this.loadInstream=function(v,u){r=new b.api.instream(this,g,v,u);return r};this.onBufferChange=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_BUFFER,u)};this.onBufferFull=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_BUFFER_FULL,u)};this.onError=function(u){return this.eventListener(b.api.events.JWPLAYER_ERROR,u)};this.onFullscreen=function(u){return this.eventListener(b.api.events.JWPLAYER_FULLSCREEN,u)};this.onMeta=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_META,u)};this.onMute=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_MUTE,u)};this.onPlaylist=function(u){return this.eventListener(b.api.events.JWPLAYER_PLAYLIST_LOADED,u)};this.onPlaylistItem=function(u){return this.eventListener(b.api.events.JWPLAYER_PLAYLIST_ITEM,u)};this.onReady=function(u){return this.eventListener(b.api.events.API_READY,u)};this.onResize=function(u){return this.eventListener(b.api.events.JWPLAYER_RESIZE,u)};this.onComplete=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_COMPLETE,u)};this.onSeek=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_SEEK,u)};this.onTime=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_TIME,u)};this.onVolume=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_VOLUME,u)};this.onBeforePlay=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_BEFOREPLAY,u)};this.onBeforeComplete=function(u){return this.eventListener(b.api.events.JWPLAYER_MEDIA_BEFORECOMPLETE,u)};this.onBuffer=function(u){return this.stateListener(b.api.events.state.BUFFERING,u)};this.onPause=function(u){return this.stateListener(b.api.events.state.PAUSED,u)};this.onPlay=function(u){return this.stateListener(b.api.events.state.PLAYING,u)};this.onIdle=function(u){return this.stateListener(b.api.events.state.IDLE,u)};this.remove=function(){if(!k){throw"Cannot call remove() before player is ready";return}q(this)};function q(u){h=[];if(b.utils.getOuterHTML(u.container)!=o){b.api.destroyPlayer(u.id,o)}}this.setup=function(v){if(b.embed){var u=this.id;q(this);var w=b(u);w.config=v;return new b.embed(w)}return this};this.registerPlugin=function(w,v,u){b.plugins.registerPlugin(w,v,u)};this.setPlayer=function(u,v){g=u;this.renderingMode=v};this.stateListener=function(u,v){if(!t[u]){t[u]=[];this.eventListener(b.api.events.JWPLAYER_PLAYER_STATE,f(u))}t[u].push(v);return this};this.detachMedia=function(){if(this.renderingMode=="html5"){return this.callInternal("jwDetachMedia")}};this.attachMedia=function(){if(this.renderingMode=="html5"){return this.callInternal("jwAttachMedia")}};function f(u){return function(w){var v=w.newstate,y=w.oldstate;if(v==u){var x=t[v];if(x){for(var z=0;z<x.length;z++){if(typeof x[z]=="function"){x[z].call(this,{oldstate:y,newstate:v})}}}}}}this.componentListener=function(u,v,w){if(!p[u]){p[u]={}}if(!p[u][v]){p[u][v]=[];this.eventListener(v,l(u,v))}p[u][v].push(w);return this};function l(u,v){return function(x){if(u==x.component){var w=p[u][v];if(w){for(var y=0;y<w.length;y++){if(typeof w[y]=="function"){w[y].call(this,x)}}}}}}this.addInternalListener=function(u,v){try{u.jwAddEventListener(v,'function(dat) { jwplayer("'+this.id+'").dispatchEvent("'+v+'", dat); }')}catch(w){b.utils.log("Could not add internal listener")}};this.eventListener=function(u,v){if(!m[u]){m[u]=[];if(g&&k){this.addInternalListener(g,u)}}m[u].push(v);return this};this.dispatchEvent=function(w){if(m[w]){var v=_utils.translateEventResponse(w,arguments[1]);for(var u=0;u<m[w].length;u++){if(typeof m[w][u]=="function"){m[w][u].call(this,v)}}}};this.dispatchInstreamEvent=function(u){if(r){r.dispatchEvent(u,arguments)}};this.callInternal=function(){if(k){var w=arguments[0],u=[];for(var v=1;v<arguments.length;v++){u.push(arguments[v])}if(typeof g!="undefined"&&typeof g[w]=="function"){if(u.length==2){return(g[w])(u[0],u[1])}else{if(u.length==1){return(g[w])(u[0])}else{return(g[w])()}}}return null}else{h.push(arguments)}};this.playerReady=function(v){k=true;if(!g){this.setPlayer(document.getElementById(v.id))}this.container=document.getElementById(this.id);for(var u in m){this.addInternalListener(g,u)}this.eventListener(b.api.events.JWPLAYER_PLAYLIST_ITEM,function(w){s={}});this.eventListener(b.api.events.JWPLAYER_MEDIA_META,function(w){b.utils.extend(s,w.metadata)});this.dispatchEvent(b.api.events.API_READY);while(h.length>0){this.callInternal.apply(this,h.shift())}};this.getItemMeta=function(){return s};this.getCurrentItem=function(){return this.callInternal("jwGetPlaylistIndex")};function n(w,y,x){var u=[];if(!y){y=0}if(!x){x=w.length-1}for(var v=y;v<=x;v++){u.push(w[v])}return u}return this};b.api.selectPlayer=function(d){var c;if(!b.utils.exists(d)){d=0}if(d.nodeType){c=d}else{if(typeof d=="string"){c=document.getElementById(d)}}if(c){var e=b.api.playerById(c.id);if(e){return e}else{return b.api.addPlayer(new b.api(c))}}else{if(typeof d=="number"){return b.getPlayers()[d]}}return null};b.api.events={API_READY:"jwplayerAPIReady",JWPLAYER_READY:"jwplayerReady",JWPLAYER_FULLSCREEN:"jwplayerFullscreen",JWPLAYER_RESIZE:"jwplayerResize",JWPLAYER_ERROR:"jwplayerError",JWPLAYER_MEDIA_BEFOREPLAY:"jwplayerMediaBeforePlay",JWPLAYER_MEDIA_BEFORECOMPLETE:"jwplayerMediaBeforeComplete",JWPLAYER_COMPONENT_SHOW:"jwplayerComponentShow",JWPLAYER_COMPONENT_HIDE:"jwplayerComponentHide",JWPLAYER_MEDIA_BUFFER:"jwplayerMediaBuffer",JWPLAYER_MEDIA_BUFFER_FULL:"jwplayerMediaBufferFull",JWPLAYER_MEDIA_ERROR:"jwplayerMediaError",JWPLAYER_MEDIA_LOADED:"jwplayerMediaLoaded",JWPLAYER_MEDIA_COMPLETE:"jwplayerMediaComplete",JWPLAYER_MEDIA_SEEK:"jwplayerMediaSeek",JWPLAYER_MEDIA_TIME:"jwplayerMediaTime",JWPLAYER_MEDIA_VOLUME:"jwplayerMediaVolume",JWPLAYER_MEDIA_META:"jwplayerMediaMeta",JWPLAYER_MEDIA_MUTE:"jwplayerMediaMute",JWPLAYER_PLAYER_STATE:"jwplayerPlayerState",JWPLAYER_PLAYLIST_LOADED:"jwplayerPlaylistLoaded",JWPLAYER_PLAYLIST_ITEM:"jwplayerPlaylistItem",JWPLAYER_INSTREAM_CLICK:"jwplayerInstreamClicked",JWPLAYER_INSTREAM_DESTROYED:"jwplayerInstreamDestroyed"};b.api.events.state={BUFFERING:"BUFFERING",IDLE:"IDLE",PAUSED:"PAUSED",PLAYING:"PLAYING"};b.api.playerById=function(d){for(var c=0;c<a.length;c++){if(a[c].id==d){return a[c]}}return null};b.api.addPlayer=function(c){for(var d=0;d<a.length;d++){if(a[d]==c){return c}}a.push(c);return c};b.api.destroyPlayer=function(h,d){var g=-1;for(var l=0;l<a.length;l++){if(a[l].id==h){g=l;continue}}if(g>=0){try{a[g].callInternal("jwDestroy")}catch(k){}var c=document.getElementById(a[g].id);if(document.getElementById(a[g].id+"_wrapper")){c=document.getElementById(a[g].id+"_wrapper")}if(c){if(d){b.utils.setOuterHTML(c,d)}else{var j=document.createElement("div");var f=c.id;if(c.id.indexOf("_wrapper")==c.id.length-8){newID=c.id.substring(0,c.id.length-8)}j.setAttribute("id",f);c.parentNode.replaceChild(j,c)}}a.splice(g,1)}return null};b.getPlayers=function(){return a.slice(0)}})(jwplayer);var _userPlayerReady=(typeof playerReady=="function")?playerReady:undefined;playerReady=function(b){var a=jwplayer.api.playerById(b.id);if(a){a.playerReady(b)}else{jwplayer.api.selectPlayer(b.id).playerReady(b)}if(_userPlayerReady){_userPlayerReady.call(this,b)}};(function(a){a.api.instream=function(c,j,n,q){var h=c;var b=j;var g=n;var k=q;var e={};var p={};function f(){h.callInternal("jwLoadInstream",n,q)}function m(r,s){b.jwInstreamAddEventListener(s,'function(dat) { jwplayer("'+h.id+'").dispatchInstreamEvent("'+s+'", dat); }')}function d(r,s){if(!e[r]){e[r]=[];m(b,r)}e[r].push(s);return this}function o(r,s){if(!p[r]){p[r]=[];d(a.api.events.JWPLAYER_PLAYER_STATE,l(r))}p[r].push(s);return this}function l(r){return function(t){var s=t.newstate,v=t.oldstate;if(s==r){var u=p[s];if(u){for(var w=0;w<u.length;w++){if(typeof u[w]=="function"){u[w].call(this,{oldstate:v,newstate:s,type:t.type})}}}}}}this.dispatchEvent=function(u,t){if(e[u]){var s=_utils.translateEventResponse(u,t[1]);for(var r=0;r<e[u].length;r++){if(typeof e[u][r]=="function"){e[u][r].call(this,s)}}}};this.onError=function(r){return d(a.api.events.JWPLAYER_ERROR,r)};this.onFullscreen=function(r){return d(a.api.events.JWPLAYER_FULLSCREEN,r)};this.onMeta=function(r){return d(a.api.events.JWPLAYER_MEDIA_META,r)};this.onMute=function(r){return d(a.api.events.JWPLAYER_MEDIA_MUTE,r)};this.onComplete=function(r){return d(a.api.events.JWPLAYER_MEDIA_COMPLETE,r)};this.onSeek=function(r){return d(a.api.events.JWPLAYER_MEDIA_SEEK,r)};this.onTime=function(r){return d(a.api.events.JWPLAYER_MEDIA_TIME,r)};this.onVolume=function(r){return d(a.api.events.JWPLAYER_MEDIA_VOLUME,r)};this.onBuffer=function(r){return o(a.api.events.state.BUFFERING,r)};this.onPause=function(r){return o(a.api.events.state.PAUSED,r)};this.onPlay=function(r){return o(a.api.events.state.PLAYING,r)};this.onIdle=function(r){return o(a.api.events.state.IDLE,r)};this.onInstreamClick=function(r){return d(a.api.events.JWPLAYER_INSTREAM_CLICK,r)};this.onInstreamDestroyed=function(r){return d(a.api.events.JWPLAYER_INSTREAM_DESTROYED,r)};this.play=function(r){b.jwInstreamPlay(r)};this.pause=function(r){b.jwInstreamPause(r)};this.seek=function(r){b.jwInstreamSeek(r)};this.destroy=function(){b.jwInstreamDestroy()};this.getState=function(){return b.jwInstreamGetState()};this.getDuration=function(){return b.jwInstreamGetDuration()};this.getPosition=function(){return b.jwInstreamGetPosition()};f()}})(jwplayer);(function(a){var c=a.utils;a.embed=function(h){var k={width:400,height:300,components:{controlbar:{position:"over"}}};var g=c.mediaparser.parseMedia(h.container);var f=new a.embed.config(c.extend(k,g,h.config),this);var j=a.plugins.loadPlugins(h.id,f.plugins);function d(n,m){for(var l in m){if(typeof n[l]=="function"){(n[l]).call(n,m[l])}}}function e(){if(j.getStatus()==c.loaderstatus.COMPLETE){for(var n=0;n<f.modes.length;n++){if(f.modes[n].type&&a.embed[f.modes[n].type]){var p=f.modes[n].config;var t=f;if(p){t=c.extend(c.clone(f),p);var s=["file","levels","playlist"];for(var m=0;m<s.length;m++){var q=s[m];if(c.exists(p[q])){for(var l=0;l<s.length;l++){if(l!=m){var o=s[l];if(c.exists(t[o])&&!c.exists(p[o])){delete t[o]}}}}}}var r=new a.embed[f.modes[n].type](document.getElementById(h.id),f.modes[n],t,j,h);if(r.supportsConfig()){r.embed();d(h,f.events);return h}}}c.log("No suitable players found");new a.embed.logo(c.extend({hide:true},f.components.logo),"none",h.id)}}j.addEventListener(a.events.COMPLETE,e);j.addEventListener(a.events.ERROR,e);j.load();return h};function b(){if(!document.body){return setTimeout(b,15)}var d=c.selectors.getElementsByTagAndClass("video","jwplayer");for(var e=0;e<d.length;e++){var f=d[e];if(f.id==""){f.id="jwplayer_"+Math.round(Math.random()*100000)}a(f.id).setup({})}}b()})(jwplayer);(function(e){var k=e.utils;function h(m){var l=[{type:"flash",src:m?m:"/jwplayer/player.swf"},{type:"html5"},{type:"download"}];if(k.isAndroid()){l[0]=l.splice(1,1,l[0])[0]}return l}var a={players:"modes",autoplay:"autostart"};function b(o){var n=o.toLowerCase();var m=["left","right","top","bottom"];for(var l=0;l<m.length;l++){if(n==m[l]){return true}}return false}function c(m){var l=false;l=(m instanceof Array)||(typeof m=="object"&&!m.position&&!m.size);return l}function j(l){if(typeof l=="string"){if(parseInt(l).toString()==l||l.toLowerCase().indexOf("px")>-1){return parseInt(l)}}return l}var g=["playlist","dock","controlbar","logo","display"];function f(l){var o={};switch(k.typeOf(l.plugins)){case"object":for(var n in l.plugins){o[k.getPluginName(n)]=n}break;case"string":var p=l.plugins.split(",");for(var m=0;m<p.length;m++){o[k.getPluginName(p[m])]=p[m]}break}return o}function d(p,o,n,l){if(k.typeOf(p[o])!="object"){p[o]={}}var m=p[o][n];if(k.typeOf(m)!="object"){p[o][n]=m={}}if(l){if(o=="plugins"){var q=k.getPluginName(n);m[l]=p[q+"."+l];delete p[q+"."+l]}else{m[l]=p[n+"."+l];delete p[n+"."+l]}}}e.embed.deserialize=function(m){var n=f(m);for(var l in n){d(m,"plugins",n[l])}for(var q in m){if(q.indexOf(".")>-1){var p=q.split(".");var o=p[0];var q=p[1];if(k.isInArray(g,o)){d(m,"components",o,q)}else{if(n[o]){d(m,"plugins",n[o],q)}}}}return m};e.embed.config=function(l,v){var u=k.extend({},l);var s;if(c(u.playlist)){s=u.playlist;delete u.playlist}u=e.embed.deserialize(u);u.height=j(u.height);u.width=j(u.width);if(typeof u.plugins=="string"){var m=u.plugins.split(",");if(typeof u.plugins!="object"){u.plugins={}}for(var q=0;q<m.length;q++){var r=k.getPluginName(m[q]);if(typeof u[r]=="object"){u.plugins[m[q]]=u[r];delete u[r]}else{u.plugins[m[q]]={}}}}for(var t=0;t<g.length;t++){var p=g[t];if(k.exists(u[p])){if(typeof u[p]!="object"){if(!u.components[p]){u.components[p]={}}if(p=="logo"){u.components[p].file=u[p]}else{u.components[p].position=u[p]}delete u[p]}else{if(!u.components[p]){u.components[p]={}}k.extend(u.components[p],u[p]);delete u[p]}}if(typeof u[p+"size"]!="undefined"){if(!u.components[p]){u.components[p]={}}u.components[p].size=u[p+"size"];delete u[p+"size"]}}if(typeof u.icons!="undefined"){if(!u.components.display){u.components.display={}}u.components.display.icons=u.icons;delete u.icons}for(var o in a){if(u[o]){if(!u[a[o]]){u[a[o]]=u[o]}delete u[o]}}var n;if(u.flashplayer&&!u.modes){n=h(u.flashplayer);delete u.flashplayer}else{if(u.modes){if(typeof u.modes=="string"){n=h(u.modes)}else{if(u.modes instanceof Array){n=u.modes}else{if(typeof u.modes=="object"&&u.modes.type){n=[u.modes]}}}delete u.modes}else{n=h()}}u.modes=n;if(s){u.playlist=s}return u}})(jwplayer);(function(a){a.embed.download=function(c,g,b,d,f){this.embed=function(){var k=a.utils.extend({},b);var q={};var j=b.width?b.width:480;if(typeof j!="number"){j=parseInt(j,10)}var m=b.height?b.height:320;if(typeof m!="number"){m=parseInt(m,10)}var u,o,n;var s={};if(b.playlist&&b.playlist.length){s.file=b.playlist[0].file;o=b.playlist[0].image;s.levels=b.playlist[0].levels}else{s.file=b.file;o=b.image;s.levels=b.levels}if(s.file){u=s.file}else{if(s.levels&&s.levels.length){u=s.levels[0].file}}n=u?"pointer":"auto";var l={display:{style:{cursor:n,width:j,height:m,backgroundColor:"#000",position:"relative",textDecoration:"none",border:"none",display:"block"}},display_icon:{style:{cursor:n,position:"absolute",display:u?"block":"none",top:0,left:0,border:0,margin:0,padding:0,zIndex:3,width:50,height:50,backgroundImage:"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAALdJREFUeNrs18ENgjAYhmFouDOCcQJGcARHgE10BDcgTOIosAGwQOuPwaQeuFRi2p/3Sb6EC5L3QCxZBgAAAOCorLW1zMn65TrlkH4NcV7QNcUQt7Gn7KIhxA+qNIR81spOGkL8oFJDyLJRdosqKDDkK+iX5+d7huzwM40xptMQMkjIOeRGo+VkEVvIPfTGIpKASfYIfT9iCHkHrBEzf4gcUQ56aEzuGK/mw0rHpy4AAACAf3kJMACBxjAQNRckhwAAAABJRU5ErkJggg==)"}},display_iconBackground:{style:{cursor:n,position:"absolute",display:u?"block":"none",top:((m-50)/2),left:((j-50)/2),border:0,width:50,height:50,margin:0,padding:0,zIndex:2,backgroundImage:"url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEpJREFUeNrszwENADAIA7DhX8ENoBMZ5KR10EryckCJiIiIiIiIiIiIiIiIiIiIiIh8GmkRERERERERERERERERERERERGRHSPAAPlXH1phYpYaAAAAAElFTkSuQmCC)"}},display_image:{style:{width:j,height:m,display:o?"block":"none",position:"absolute",cursor:n,left:0,top:0,margin:0,padding:0,textDecoration:"none",zIndex:1,border:"none"}}};var h=function(v,x,y){var w=document.createElement(v);if(y){w.id=y}else{w.id=c.id+"_jwplayer_"+x}a.utils.css(w,l[x].style);return w};q.display=h("a","display",c.id);if(u){q.display.setAttribute("href",a.utils.getAbsolutePath(u))}q.display_image=h("img","display_image");q.display_image.setAttribute("alt","Click to download...");if(o){q.display_image.setAttribute("src",a.utils.getAbsolutePath(o))}if(true){q.display_icon=h("div","display_icon");q.display_iconBackground=h("div","display_iconBackground");q.display.appendChild(q.display_image);q.display_iconBackground.appendChild(q.display_icon);q.display.appendChild(q.display_iconBackground)}_css=a.utils.css;_hide=function(v){_css(v,{display:"none"})};function r(v){_imageWidth=q.display_image.naturalWidth;_imageHeight=q.display_image.naturalHeight;t()}function t(){a.utils.stretch(a.utils.stretching.UNIFORM,q.display_image,j,m,_imageWidth,_imageHeight)}q.display_image.onerror=function(v){_hide(q.display_image)};q.display_image.onload=r;c.parentNode.replaceChild(q.display,c);var p=(b.plugins&&b.plugins.logo)?b.plugins.logo:{};q.display.appendChild(new a.embed.logo(b.components.logo,"download",c.id));f.container=document.getElementById(f.id);f.setPlayer(q.display,"download")};this.supportsConfig=function(){if(b){var j=a.utils.getFirstPlaylistItemFromConfig(b);if(typeof j.file=="undefined"&&typeof j.levels=="undefined"){return true}else{if(j.file){return e(j.file,j.provider,j.playlistfile)}else{if(j.levels&&j.levels.length){for(var h=0;h<j.levels.length;h++){if(j.levels[h].file&&e(j.levels[h].file,j.provider,j.playlistfile)){return true}}}}}}else{return true}};function e(j,l,h){if(h){return false}var k=["image","sound","youtube","http"];if(l&&(k.toString().indexOf(l)>-1)){return true}if(!l||(l&&l=="video")){var m=a.utils.extension(j);if(m&&a.utils.extensionmap[m]){return true}}return false}}})(jwplayer);(function(a){a.embed.flash=function(f,g,l,e,j){function m(o,n,p){var q=document.createElement("param");q.setAttribute("name",n);q.setAttribute("value",p);o.appendChild(q)}function k(o,p,n){return function(q){if(n){document.getElementById(j.id+"_wrapper").appendChild(p)}var s=document.getElementById(j.id).getPluginConfig("display");o.resize(s.width,s.height);var r={left:s.x,top:s.y};a.utils.css(p,r)}}function d(p){if(!p){return{}}var r={};for(var o in p){var n=p[o];for(var q in n){r[o+"."+q]=n[q]}}return r}function h(q,p){if(q[p]){var s=q[p];for(var o in s){var n=s[o];if(typeof n=="string"){if(!q[o]){q[o]=n}}else{for(var r in n){if(!q[o+"."+r]){q[o+"."+r]=n[r]}}}}delete q[p]}}function b(q){if(!q){return{}}var t={},s=[];for(var n in q){var p=a.utils.getPluginName(n);var o=q[n];s.push(n);for(var r in o){t[p+"."+r]=o[r]}}t.plugins=s.join(",");return t}function c(p){var n=p.netstreambasepath?"":"netstreambasepath="+encodeURIComponent(window.location.href.split("#")[0])+"&";for(var o in p){if(typeof(p[o])=="object"){n+=o+"="+encodeURIComponent("[[JSON]]"+a.utils.strings.jsonToString(p[o]))+"&"}else{n+=o+"="+encodeURIComponent(p[o])+"&"}}return n.substring(0,n.length-1)}this.embed=function(){l.id=j.id;var A;var r=a.utils.extend({},l);var o=r.width;var y=r.height;if(f.id+"_wrapper"==f.parentNode.id){A=document.getElementById(f.id+"_wrapper")}else{A=document.createElement("div");A.id=f.id+"_wrapper";a.utils.wrap(f,A);a.utils.css(A,{position:"relative",width:o,height:y})}var p=e.setupPlugins(j,r,k);if(p.length>0){a.utils.extend(r,b(p.plugins))}else{delete r.plugins}var s=["height","width","modes","events"];for(var v=0;v<s.length;v++){delete r[s[v]]}var q="opaque";if(r.wmode){q=r.wmode}h(r,"components");h(r,"providers");if(typeof r["dock.position"]!="undefined"){if(r["dock.position"].toString().toLowerCase()=="false"){r.dock=r["dock.position"];delete r["dock.position"]}}var x=a.utils.getCookies();for(var n in x){if(typeof(r[n])=="undefined"){r[n]=x[n]}}var z="#000000";var u;if(a.utils.isIE()){var w='<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" bgcolor="'+z+'" width="100%" height="100%" id="'+f.id+'" name="'+f.id+'" tabindex=0"">';w+='<param name="movie" value="'+g.src+'">';w+='<param name="allowfullscreen" value="true">';w+='<param name="allowscriptaccess" value="always">';w+='<param name="seamlesstabbing" value="true">';w+='<param name="wmode" value="'+q+'">';w+='<param name="flashvars" value="'+c(r)+'">';w+="</object>";a.utils.setOuterHTML(f,w);u=document.getElementById(f.id)}else{var t=document.createElement("object");t.setAttribute("type","application/x-shockwave-flash");t.setAttribute("data",g.src);t.setAttribute("width","100%");t.setAttribute("height","100%");t.setAttribute("bgcolor","#000000");t.setAttribute("id",f.id);t.setAttribute("name",f.id);t.setAttribute("tabindex",0);m(t,"allowfullscreen","true");m(t,"allowscriptaccess","always");m(t,"seamlesstabbing","true");m(t,"wmode",q);m(t,"flashvars",c(r));f.parentNode.replaceChild(t,f);u=t}j.container=u;j.setPlayer(u,"flash")};this.supportsConfig=function(){if(a.utils.hasFlash()){if(l){var o=a.utils.getFirstPlaylistItemFromConfig(l);if(typeof o.file=="undefined"&&typeof o.levels=="undefined"){return true}else{if(o.file){return flashCanPlay(o.file,o.provider)}else{if(o.levels&&o.levels.length){for(var n=0;n<o.levels.length;n++){if(o.levels[n].file&&flashCanPlay(o.levels[n].file,o.provider)){return true}}}}}}else{return true}}return false};flashCanPlay=function(n,p){var o=["video","http","sound","image"];if(p&&(o.toString().indexOf(p)<0)){return true}var q=a.utils.extension(n);if(!q){return true}if(a.utils.exists(a.utils.extensionmap[q])&&!a.utils.exists(a.utils.extensionmap[q].flash)){return false}return true}}})(jwplayer);(function(a){a.embed.html5=function(c,g,b,d,f){function e(j,k,h){return function(l){var m=document.getElementById(c.id+"_displayarea");if(h){m.appendChild(k)}j.resize(m.clientWidth,m.clientHeight);k.left=m.style.left;k.top=m.style.top}}this.embed=function(){if(a.html5){d.setupPlugins(f,b,e);c.innerHTML="";var j=a.utils.extend({screencolor:"0x000000"},b);var h=["plugins","modes","events"];for(var k=0;k<h.length;k++){delete j[h[k]]}if(j.levels&&!j.sources){j.sources=b.levels}if(j.skin&&j.skin.toLowerCase().indexOf(".zip")>0){j.skin=j.skin.replace(/\.zip/i,".xml")}var l=new (a.html5(c)).setup(j);f.container=document.getElementById(f.id);f.setPlayer(l,"html5")}else{return null}};this.supportsConfig=function(){if(!!a.vid.canPlayType){if(b){var j=a.utils.getFirstPlaylistItemFromConfig(b);if(typeof j.file=="undefined"&&typeof j.levels=="undefined"){return true}else{if(j.file){return html5CanPlay(a.vid,j.file,j.provider,j.playlistfile)}else{if(j.levels&&j.levels.length){for(var h=0;h<j.levels.length;h++){if(j.levels[h].file&&html5CanPlay(a.vid,j.levels[h].file,j.provider,j.playlistfile)){return true}}}}}}else{return true}}return false};html5CanPlay=function(k,j,l,h){if(h){return false}if(l&&l=="youtube"){return true}if(l&&l!="video"&&l!="http"&&l!="sound"){return false}if(navigator.userAgent.match(/BlackBerry/i)!==null){return false}var m=a.utils.extension(j);if(!a.utils.exists(m)||!a.utils.exists(a.utils.extensionmap[m])){return true}if(!a.utils.exists(a.utils.extensionmap[m].html5)){return false}if(a.utils.isLegacyAndroid()&&m.match(/m4v|mp4/)){return true}return browserCanPlay(k,a.utils.extensionmap[m].html5)};browserCanPlay=function(j,h){if(!h){return true}if(j.canPlayType(h)){return true}else{if(h=="audio/mp3"&&navigator.userAgent.match(/safari/i)){return j.canPlayType("audio/mpeg")}else{return false}}}}})(jwplayer);(function(a){a.embed.logo=function(m,l,d){var j={prefix:"http://l.longtailvideo.com/"+l+"/",file:"",link:"",linktarget:"_top",margin:8,out:0.5,over:1,timeout:5,hide:false,position:"bottom-left"};_css=a.utils.css;var b;var h;k();function k(){o();c();f()}function o(){if(j.prefix){var q=a.version.split(/\W/).splice(0,2).join("/");if(j.prefix.indexOf(q)<0){j.prefix+=q+"/"}}h=a.utils.extend({},j,m)}function p(){var s={border:"none",textDecoration:"none",position:"absolute",cursor:"pointer",zIndex:10};s.display=h.hide?"none":"block";var r=h.position.toLowerCase().split("-");for(var q in r){s[r[q]]=h.margin}return s}function c(){b=document.createElement("img");b.id=d+"_jwplayer_logo";b.style.display="none";b.onload=function(q){_css(b,p());e()};if(!h.file){return}if(h.file.indexOf("http://")===0){b.src=h.file}else{b.src=h.prefix+h.file}}if(!h.file){return}function f(){if(h.link){b.onmouseover=g;b.onmouseout=e;b.onclick=n}else{this.mouseEnabled=false}}function n(q){if(typeof q!="undefined"){q.preventDefault();q.stopPropagation()}if(h.link){window.open(h.link,h.linktarget)}return}function e(q){if(h.link){b.style.opacity=h.out}return}function g(q){if(h.hide){b.style.opacity=h.over}return}return b}})(jwplayer);(function(a){a.html5=function(b){var c=b;this.setup=function(d){a.utils.extend(this,new a.html5.api(c,d));return this};return this}})(jwplayer);(function(a){var d=a.utils;var b=d.css;var c=d.isIOS();a.html5.view=function(n,H,h){var m=n;var y=H;var j=h;var R;var g;var t;var o;var F;var P;var O;var E=false;var x=false;var A,N;var f,S,u;function L(){R=document.createElement("div");R.id=y.id;R.className=y.className;_videowrapper=document.createElement("div");_videowrapper.id=R.id+"_video_wrapper";y.id=R.id+"_video";b(R,{position:"relative",height:j.height,width:j.width,padding:0,backgroundColor:U(),zIndex:0});function U(){if(m.skin.getComponentSettings("display")&&m.skin.getComponentSettings("display").backgroundcolor){return m.skin.getComponentSettings("display").backgroundcolor}return parseInt("000000",16)}b(y,{width:"100%",height:"100%",top:0,left:0,zIndex:1,margin:"auto",display:"block"});b(_videowrapper,{overflow:"hidden",position:"absolute",top:0,left:0,bottom:0,right:0});d.wrap(y,R);d.wrap(y,_videowrapper);o=document.createElement("div");o.id=R.id+"_displayarea";R.appendChild(o);_instreamArea=document.createElement("div");_instreamArea.id=R.id+"_instreamarea";b(_instreamArea,{overflow:"hidden",position:"absolute",top:0,left:0,bottom:0,right:0,zIndex:100,background:"000000",display:"none"});R.appendChild(_instreamArea)}function K(){for(var U=0;U<j.plugins.order.length;U++){var V=j.plugins.order[U];if(d.exists(j.plugins.object[V].getDisplayElement)){j.plugins.object[V].height=d.parseDimension(j.plugins.object[V].getDisplayElement().style.height);j.plugins.object[V].width=d.parseDimension(j.plugins.object[V].getDisplayElement().style.width);j.plugins.config[V].currentPosition=j.plugins.config[V].position}}v()}function s(U){x=j.fullscreen}function p(U){if(S){return}switch(U.newstate){case a.api.events.state.PLAYING:if(j.getMedia()&&j.getMedia().hasChrome()){o.style.display="none"}break;default:o.style.display="block";break}l()}function v(V){var X=j.getMedia()?j.getMedia().getDisplayElement():null;if(d.exists(X)){if(O!=X){if(O&&O.parentNode){O.parentNode.replaceChild(X,O)}O=X}for(var U=0;U<j.plugins.order.length;U++){var W=j.plugins.order[U];if(d.exists(j.plugins.object[W].getDisplayElement)){j.plugins.config[W].currentPosition=j.plugins.config[W].position}}}G(j.width,j.height)}this.setup=function(){if(j&&j.getMedia()){y=j.getMedia().getDisplayElement()}L();K();m.jwAddEventListener(a.api.events.JWPLAYER_PLAYER_STATE,p);m.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_LOADED,v);m.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_BEFOREPLAY,s);m.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_META,function(V){l()});var U;if(d.exists(window.onresize)){U=window.onresize}window.onresize=function(V){if(d.exists(U)){try{U(V)}catch(X){}}if(m.jwGetFullscreen()){if(!B()){var W=d.getBoundingClientRect(document.body);j.width=Math.abs(W.left)+Math.abs(W.right);j.height=window.innerHeight;G(j.width,j.height)}}else{G(j.width,j.height)}}};function M(U){switch(U.keyCode){case 27:if(m.jwGetFullscreen()){m.jwSetFullscreen(false)}break;case 32:if(m.jwGetState()!=a.api.events.state.IDLE&&m.jwGetState()!=a.api.events.state.PAUSED){m.jwPause()}else{m.jwPlay()}break}}function G(U,ad){if(R.style.display=="none"){return}var X=[].concat(j.plugins.order);X.reverse();F=X.length+2;if(x&&B()){try{if(j.fullscreen&&!j.getMedia().getDisplayElement().webkitDisplayingFullscreen){j.fullscreen=false}}catch(aa){}}if(!j.fullscreen){g=U;t=ad;if(typeof U=="string"&&U.indexOf("%")>0){g=d.getElementWidth(d.parentNode(R))*parseInt(U.replace("%"),"")/100}else{g=U}if(typeof ad=="string"&&ad.indexOf("%")>0){t=d.getElementHeight(d.parentNode(R))*parseInt(ad.replace("%"),"")/100}else{t=ad}var Y={top:0,bottom:0,left:0,right:0,width:g,height:t,position:"absolute"};b(o,Y);var ae={};var ab;try{ab=j.plugins.object.display.getDisplayElement()}catch(aa){}if(ab){ae.width=d.parseDimension(ab.style.width);ae.height=d.parseDimension(ab.style.height)}var ac=d.extend({},Y,ae,{zIndex:_instreamArea.style.zIndex,display:_instreamArea.style.display});b(_instreamArea,ac);b(R,{height:t,width:g});var Z=w(I,X);if(Z.length>0){F+=Z.length;var W=Z.indexOf("playlist"),V=Z.indexOf("controlbar");if(W>=0&&V>=0){Z[W]=Z.splice(V,1,Z[W])[0]}w(q,Z,true)}A=d.getElementWidth(o);N=d.getElementHeight(o)}else{if(!B()&&!c){w(e,X,true)}}l()}var r;function w(ab,X,Y){r=0;var Z=[];for(var W=0;W<X.length;W++){var aa=X[W];if(d.exists(j.plugins.object[aa].getDisplayElement)){if(j.plugins.config[aa].currentPosition!=a.html5.view.positions.NONE){var U=ab(aa,F--);if(!U){Z.push(aa)}else{var V=U.width;var ac=U.height;if(Y){delete U.width;delete U.height}b(j.plugins.object[aa].getDisplayElement(),U);j.plugins.object[aa].resize(V,ac)}}else{b(j.plugins.object[aa].getDisplayElement(),{display:"none"})}}}return Z}function I(V,W){if(d.exists(j.plugins.object[V].getDisplayElement)){if(j.plugins.config[V].position&&T(j.plugins.config[V].position)){if(!d.exists(j.plugins.object[V].getDisplayElement().parentNode)){R.appendChild(j.plugins.object[V].getDisplayElement())}var U=z(V);U.zIndex=W;return U}}return false}function q(U,V){if(!d.exists(j.plugins.object[U].getDisplayElement().parentNode)){o.appendChild(j.plugins.object[U].getDisplayElement())}return{position:"absolute",width:(d.getElementWidth(o)-d.parseDimension(o.style.right)),height:(d.getElementHeight(o)-d.parseDimension(o.style.bottom)),zIndex:V}}function e(U,V){return{position:"fixed",width:j.width,height:j.height,zIndex:V}}var l=this.resizeMedia=function(){o.style.position="absolute";var W=j.getMedia()?j.getMedia().getDisplayElement():u;if(!W){return}if(W&&W.tagName.toLowerCase()=="video"){if(!W.videoWidth||!W.videoHeight){W.style.width=o.style.width;W.style.height=o.style.height;return}W.style.position="absolute";d.fadeTo(W,1,0.25);if(W.parentNode){W.parentNode.style.left=o.style.left;W.parentNode.style.top=o.style.top}if(j.fullscreen&&m.jwGetStretching()==a.utils.stretching.EXACTFIT&&!d.isMobile()){var U=document.createElement("div");d.stretch(a.utils.stretching.UNIFORM,U,d.getElementWidth(o),d.getElementHeight(o),A,N);d.stretch(a.utils.stretching.EXACTFIT,W,d.parseDimension(U.style.width),d.parseDimension(U.style.height),W.videoWidth?W.videoWidth:400,W.videoHeight?W.videoHeight:300);b(W,{left:U.style.left,top:U.style.top})}else{if(!c){d.stretch(m.jwGetStretching(),W,d.getElementWidth(o),d.getElementHeight(o),W.videoWidth?W.videoWidth:400,W.videoHeight?W.videoHeight:300)}}}else{var V=j.plugins.object.display.getDisplayElement();if(V){j.getMedia().resize(d.parseDimension(V.style.width),d.parseDimension(V.style.height))}else{j.getMedia().resize(d.parseDimension(o.style.width),d.parseDimension(o.style.height))}}};var z=this.getComponentPosition=function(V){var W={position:"absolute",margin:0,padding:0,top:null};var U=j.plugins.config[V].currentPosition.toLowerCase();switch(U.toUpperCase()){case a.html5.view.positions.TOP:W.top=d.parseDimension(o.style.top);W.left=d.parseDimension(o.style.left);W.width=d.getElementWidth(o)-d.parseDimension(o.style.left)-d.parseDimension(o.style.right);W.height=j.plugins.object[V].height;o.style[U]=d.parseDimension(o.style[U])+j.plugins.object[V].height+"px";o.style.height=d.getElementHeight(o)-W.height+"px";break;case a.html5.view.positions.RIGHT:W.top=d.parseDimension(o.style.top);W.right=d.parseDimension(o.style.right);W.width=j.plugins.object[V].width;W.height=d.getElementHeight(o)-d.parseDimension(o.style.top)-d.parseDimension(o.style.bottom);o.style.width=d.getElementWidth(o)-W.width+"px";break;case a.html5.view.positions.BOTTOM:W.left=d.parseDimension(o.style.left);W.width=d.getElementWidth(o)-d.parseDimension(o.style.left)-d.parseDimension(o.style.right);W.height=j.plugins.object[V].height;W.bottom=d.parseDimension(o.style.bottom+r);r+=W.height;o.style.height=d.getElementHeight(o)-W.height+"px";break;case a.html5.view.positions.LEFT:W.top=d.parseDimension(o.style.top);W.left=d.parseDimension(o.style.left);W.width=j.plugins.object[V].width;W.height=d.getElementHeight(o)-d.parseDimension(o.style.top)-d.parseDimension(o.style.bottom);o.style[U]=d.parseDimension(o.style[U])+j.plugins.object[V].width+"px";o.style.width=d.getElementWidth(o)-W.width+"px";break;default:break}return W};this.resize=G;var J,k,Q;var C=this.fullscreen=function(W){if(c){return}var Y;try{Y=j.getMedia().getDisplayElement()}catch(X){}if(W){k=j.width;Q=j.height}var aa={position:"fixed",width:"100%",height:"100%",top:0,left:0,zIndex:2147483000},Z={position:"relative",height:k,width:Q,zIndex:0};if(B()&&Y&&Y.webkitSupportsFullscreen){if(W&&!Y.webkitDisplayingFullscreen){try{b(Y,aa);d.transform(Y);J=o.style.display;o.style.display="none";Y.webkitEnterFullscreen()}catch(V){}}else{if(!W){b(Y,Z);l();if(Y.webkitDisplayingFullscreen){try{Y.webkitExitFullscreen()}catch(V){}}o.style.display=J}}E=false}else{if(W){document.onkeydown=M;clearInterval(P);var U=d.getBoundingClientRect(document.body);j.width=Math.abs(U.left)+Math.abs(U.right);j.height=window.innerHeight;b(R,aa);aa.zIndex=1;if(j.getMedia()&&j.getMedia().getDisplayElement()){b(j.getMedia().getDisplayElement(),aa)}aa.zIndex=2;b(o,aa);E=true}else{document.onkeydown="";j.width=g;j.height=t;b(R,Z);E=false}G(j.width,j.height)}};function T(U){return([a.html5.view.positions.TOP,a.html5.view.positions.RIGHT,a.html5.view.positions.BOTTOM,a.html5.view.positions.LEFT].toString().indexOf(U.toUpperCase())>-1)}function B(){if(m.jwGetState()!=a.api.events.state.IDLE&&!E&&(j.getMedia()&&j.getMedia().getDisplayElement()&&j.getMedia().getDisplayElement().webkitSupportsFullscreen)&&d.useNativeFullscreen()){return true}return false}this.setupInstream=function(U,V){d.css(_instreamArea,{display:"block",position:"absolute"});o.style.display="none";_instreamArea.appendChild(U);u=V;S=true};var D=this.destroyInstream=function(){_instreamArea.style.display="none";_instreamArea.innerHTML="";o.style.display="block";u=null;S=false;G(j.width,j.height)}};a.html5.view.positions={TOP:"TOP",RIGHT:"RIGHT",BOTTOM:"BOTTOM",LEFT:"LEFT",OVER:"OVER",NONE:"NONE"}})(jwplayer);(function(a){var b={backgroundcolor:"",margin:10,font:"Arial,sans-serif",fontsize:10,fontcolor:parseInt("000000",16),fontstyle:"normal",fontweight:"bold",buttoncolor:parseInt("ffffff",16),position:a.html5.view.positions.BOTTOM,idlehide:false,hideplaylistcontrols:false,forcenextprev:false,layout:{left:{position:"left",elements:[{name:"play",type:"button"},{name:"divider",type:"divider"},{name:"prev",type:"button"},{name:"divider",type:"divider"},{name:"next",type:"button"},{name:"divider",type:"divider"},{name:"elapsed",type:"text"}]},center:{position:"center",elements:[{name:"time",type:"slider"}]},right:{position:"right",elements:[{name:"duration",type:"text"},{name:"blank",type:"button"},{name:"divider",type:"divider"},{name:"mute",type:"button"},{name:"volume",type:"slider"},{name:"divider",type:"divider"},{name:"fullscreen",type:"button"}]}}};_utils=a.utils;_css=_utils.css;_hide=function(c){_css(c,{display:"none"})};_show=function(c){_css(c,{display:"block"})};a.html5.controlbar=function(m,Y){window.controlbar=this;var l=m;var D=_utils.extend({},b,l.skin.getComponentSettings("controlbar"),Y);if(D.position==a.html5.view.positions.NONE||typeof a.html5.view.positions[D.position]=="undefined"){return}if(_utils.mapLength(l.skin.getComponentLayout("controlbar"))>0){D.layout=l.skin.getComponentLayout("controlbar")}var ag;var R;var af;var E;var w="none";var h;var k;var ah;var g;var f;var z;var S={};var q=false;var c={};var Q=-1;var ac;var j=false;var p;var d;var V=false;var G=false;var H;var aa=new a.html5.eventdispatcher();_utils.extend(this,aa);function K(){if(!ac){ac=l.skin.getSkinElement("controlbar","background");if(!ac){ac={width:0,height:0,src:null}}}return ac}function O(){af=0;E=0;R=0;if(!q){var ap={height:K().height,backgroundColor:D.backgroundcolor};ag=document.createElement("div");ag.id=l.id+"_jwplayer_controlbar";_css(ag,ap)}var ao=(l.skin.getSkinElement("controlbar","capLeft"));var an=(l.skin.getSkinElement("controlbar","capRight"));if(ao){y("capLeft","left",false,ag)}ad("background",ag,{position:"absolute",height:K().height,left:(ao?ao.width:0),zIndex:0},"img");if(K().src){S.background.src=K().src}ad("elements",ag,{position:"relative",height:K().height,zIndex:1});if(an){y("capRight","right",false,ag)}}this.getDisplayElement=function(){return ag};this.resize=function(ap,an){T();_utils.cancelAnimation(ag);f=ap;z=an;if(G!=l.jwGetFullscreen()){G=l.jwGetFullscreen();if(!G){Z()}d=undefined}var ao=x();J({id:l.id,duration:ah,position:k});v({id:l.id,bufferPercent:g});return ao};this.show=function(){if(j){j=false;_show(ag);W()}};this.hide=function(){if(!j){j=true;_hide(ag);ae()}};function r(){var ao=["timeSlider","volumeSlider","timeSliderRail","volumeSliderRail"];for(var ap in ao){var an=ao[ap];if(typeof S[an]!="undefined"){c[an]=_utils.getBoundingClientRect(S[an])}}}var e;function Z(an){if(j){return}clearTimeout(p);if(D.position==a.html5.view.positions.OVER||l.jwGetFullscreen()){switch(l.jwGetState()){case a.api.events.state.PAUSED:case a.api.events.state.IDLE:if(ag&&ag.style.opacity<1&&(!D.idlehide||_utils.exists(an))){e=false;setTimeout(function(){if(!e){X()}},100)}if(D.idlehide){p=setTimeout(function(){A()},2000)}break;default:e=true;if(an){X()}p=setTimeout(function(){A()},2000);break}}else{X()}}function A(){if(!j){ae();if(ag.style.opacity==1){_utils.cancelAnimation(ag);_utils.fadeTo(ag,0,0.1,1,0)}}}function X(){if(!j){W();if(ag.style.opacity==0){_utils.cancelAnimation(ag);_utils.fadeTo(ag,1,0.1,0,0)}}}function I(an){return function(){if(V&&d!=an){d=an;aa.sendEvent(an,{component:"controlbar",boundingRect:P()})}}}var W=I(a.api.events.JWPLAYER_COMPONENT_SHOW);var ae=I(a.api.events.JWPLAYER_COMPONENT_HIDE);function P(){if(D.position==a.html5.view.positions.OVER||l.jwGetFullscreen()){return _utils.getDimensions(ag)}else{return{x:0,y:0,width:0,height:0}}}function ad(ar,aq,ap,an){var ao;if(!q){if(!an){an="div"}ao=document.createElement(an);S[ar]=ao;ao.id=ag.id+"_"+ar;aq.appendChild(ao)}else{ao=document.getElementById(ag.id+"_"+ar)}if(_utils.exists(ap)){_css(ao,ap)}return ao}function N(){if(l.jwGetHeight()<=40){D.layout=_utils.clone(D.layout);for(var an=0;an<D.layout.left.elements.length;an++){if(D.layout.left.elements[an].name=="fullscreen"){D.layout.left.elements.splice(an,1)}}for(an=0;an<D.layout.right.elements.length;an++){if(D.layout.right.elements[an].name=="fullscreen"){D.layout.right.elements.splice(an,1)}}o()}am(D.layout.left);am(D.layout.center);am(D.layout.right)}function am(aq,an){var ar=aq.position=="right"?"right":"left";var ap=_utils.extend([],aq.elements);if(_utils.exists(an)){ap.reverse()}var aq=ad(aq.position+"Group",S.elements,{"float":"left",styleFloat:"left",cssFloat:"left",height:"100%"});for(var ao=0;ao<ap.length;ao++){C(ap[ao],ar,aq)}}function L(){return R++}function C(ar,au,aw){var aq,ao,ap,an,ax;if(!aw){aw=S.elements}if(ar.type=="divider"){y("divider"+L(),au,true,aw,undefined,ar.width,ar.element);return}switch(ar.name){case"play":y("playButton",au,false,aw);y("pauseButton",au,true,aw);U("playButton","jwPlay");U("pauseButton","jwPause");break;case"prev":y("prevButton",au,true,aw);U("prevButton","jwPlaylistPrev");break;case"stop":y("stopButton",au,true,aw);U("stopButton","jwStop");break;case"next":y("nextButton",au,true,aw);U("nextButton","jwPlaylistNext");break;case"elapsed":y("elapsedText",au,true,aw,null,null,l.skin.getSkinElement("controlbar","elapsedBackground"));break;case"time":ao=!_utils.exists(l.skin.getSkinElement("controlbar","timeSliderCapLeft"))?0:l.skin.getSkinElement("controlbar","timeSliderCapLeft").width;ap=!_utils.exists(l.skin.getSkinElement("controlbar","timeSliderCapRight"))?0:l.skin.getSkinElement("controlbar","timeSliderCapRight").width;aq=au=="left"?ao:ap;ax={height:K().height,position:"relative","float":"left",styleFloat:"left",cssFloat:"left"};var at=ad("timeSlider",aw,ax);y("timeSliderCapLeft",au,true,at,"relative");y("timeSliderRail",au,false,at,"relative");y("timeSliderBuffer",au,false,at,"absolute");y("timeSliderProgress",au,false,at,"absolute");y("timeSliderThumb",au,false,at,"absolute");y("timeSliderCapRight",au,true,at,"relative");ab("time");break;case"fullscreen":y("fullscreenButton",au,false,aw);y("normalscreenButton",au,true,aw);U("fullscreenButton","jwSetFullscreen",true);U("normalscreenButton","jwSetFullscreen",false);break;case"volume":ao=!_utils.exists(l.skin.getSkinElement("controlbar","volumeSliderCapLeft"))?0:l.skin.getSkinElement("controlbar","volumeSliderCapLeft").width;ap=!_utils.exists(l.skin.getSkinElement("controlbar","volumeSliderCapRight"))?0:l.skin.getSkinElement("controlbar","volumeSliderCapRight").width;aq=au=="left"?ao:ap;an=l.skin.getSkinElement("controlbar","volumeSliderRail").width+ao+ap;ax={height:K().height,position:"relative",width:an,"float":"left",styleFloat:"left",cssFloat:"left"};var av=ad("volumeSlider",aw,ax);y("volumeSliderCapLeft",au,false,av,"relative");y("volumeSliderRail",au,false,av,"relative");y("volumeSliderProgress",au,false,av,"absolute");y("volumeSliderThumb",au,false,av,"absolute");y("volumeSliderCapRight",au,false,av,"relative");ab("volume");break;case"mute":y("muteButton",au,false,aw);y("unmuteButton",au,true,aw);U("muteButton","jwSetMute",true);U("unmuteButton","jwSetMute",false);break;case"duration":y("durationText",au,true,aw,null,null,l.skin.getSkinElement("controlbar","durationBackground"));break}}function y(aq,au,ao,ax,ar,an,ap){if(_utils.exists(l.skin.getSkinElement("controlbar",aq))||aq.indexOf("Text")>0||aq.indexOf("divider")===0){var at={height:"100%",position:ar?ar:"relative",display:"block","float":"left",styleFloat:"left",cssFloat:"left"};if((aq.indexOf("next")===0||aq.indexOf("prev")===0)&&(l.jwGetPlaylist().length<2||D.hideplaylistcontrols.toString()=="true")){if(D.forcenextprev.toString()!="true"){ao=false;at.display="none"}}var ay;if(aq.indexOf("Text")>0){aq.innerhtml="00:00";at.font=D.fontsize+"px/"+(K().height+1)+"px "+D.font;at.color=D.fontcolor;at.textAlign="center";at.fontWeight=D.fontweight;at.fontStyle=D.fontstyle;at.cursor="default";if(ap){at.background="url("+ap.src+") no-repeat center";at.backgroundSize="100% "+K().height+"px"}at.padding="0 5px"}else{if(aq.indexOf("divider")===0){if(an){if(!isNaN(parseInt(an))){ay=parseInt(an)}}else{if(ap){var av=l.skin.getSkinElement("controlbar",ap);if(av){at.background="url("+av.src+") repeat-x center left";ay=av.width}}else{at.background="url("+l.skin.getSkinElement("controlbar","divider").src+") repeat-x center left";ay=l.skin.getSkinElement("controlbar","divider").width}}}else{at.background="url("+l.skin.getSkinElement("controlbar",aq).src+") repeat-x center left";ay=l.skin.getSkinElement("controlbar",aq).width}}if(au=="left"){if(ao){af+=ay}}else{if(au=="right"){if(ao){E+=ay}}}if(_utils.typeOf(ax)=="undefined"){ax=S.elements}at.width=ay;if(q){_css(S[aq],at)}else{var aw=ad(aq,ax,at);if(_utils.exists(l.skin.getSkinElement("controlbar",aq+"Over"))){aw.onmouseover=function(az){aw.style.backgroundImage=["url(",l.skin.getSkinElement("controlbar",aq+"Over").src,")"].join("")};aw.onmouseout=function(az){aw.style.backgroundImage=["url(",l.skin.getSkinElement("controlbar",aq).src,")"].join("")}}if(aq.indexOf("divider")==0){aw.setAttribute("class","divider")}aw.innerHTML="&nbsp;"}}}function F(){l.jwAddEventListener(a.api.events.JWPLAYER_PLAYLIST_LOADED,B);l.jwAddEventListener(a.api.events.JWPLAYER_PLAYLIST_ITEM,t);l.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_BUFFER,v);l.jwAddEventListener(a.api.events.JWPLAYER_PLAYER_STATE,s);l.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_TIME,J);l.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_MUTE,al);l.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_VOLUME,n);l.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_COMPLETE,M)}function B(){if(!D.hideplaylistcontrols){if(l.jwGetPlaylist().length>1||D.forcenextprev.toString()=="true"){_show(S.nextButton);_show(S.prevButton)}else{_hide(S.nextButton);_hide(S.prevButton)}x();ai()}}function t(an){ah=l.jwGetPlaylist()[an.index].duration;Q=-1;J({id:l.id,duration:ah,position:0});v({id:l.id,bufferProgress:0})}function ai(){J({id:l.id,duration:l.jwGetDuration(),position:0});v({id:l.id,bufferProgress:0});al({id:l.id,mute:l.jwGetMute()});s({id:l.id,newstate:a.api.events.state.IDLE});n({id:l.id,volume:l.jwGetVolume()})}function U(ap,aq,ao){if(q){return}if(_utils.exists(l.skin.getSkinElement("controlbar",ap))){var an=S[ap];if(_utils.exists(an)){_css(an,{cursor:"pointer"});if(aq=="fullscreen"){an.onmouseup=function(ar){ar.stopPropagation();l.jwSetFullscreen(!l.jwGetFullscreen())}}else{an.onmouseup=function(ar){ar.stopPropagation();if(_utils.exists(ao)){l[aq](ao)}else{l[aq]()}}}}}}function ab(an){if(q){return}var ao=S[an+"Slider"];_css(S.elements,{cursor:"pointer"});_css(ao,{cursor:"pointer"});ao.onmousedown=function(ap){w=an};ao.onmouseup=function(ap){ap.stopPropagation();ak(ap.pageX)};ao.onmousemove=function(ap){if(w=="time"){h=true;var aq=ap.pageX-c[an+"Slider"].left-window.pageXOffset;_css(S[w+"SliderThumb"],{left:aq})}}}function ak(ao){h=false;var an;if(w=="time"){an=ao-c.timeSliderRail.left+window.pageXOffset;var aq=an/c.timeSliderRail.width*ah;if(aq<0){aq=0}else{if(aq>ah){aq=ah-3}}if(l.jwGetState()==a.api.events.state.PAUSED||l.jwGetState()==a.api.events.state.IDLE){l.jwPlay()}l.jwSeek(aq)}else{if(w=="volume"){an=ao-c.volumeSliderRail.left-window.pageXOffset;var ap=Math.round(an/c.volumeSliderRail.width*100);if(ap<10){ap=0}else{if(ap>100){ap=100}}if(l.jwGetMute()){l.jwSetMute(false)}l.jwSetVolume(ap)}}w="none"}function v(ao){if(_utils.exists(ao.bufferPercent)){g=ao.bufferPercent}if(c.timeSliderRail){var aq=l.skin.getSkinElement("controlbar","timeSliderCapLeft");var ap=c.timeSliderRail.width;var an=isNaN(Math.round(ap*g/100))?0:Math.round(ap*g/100);_css(S.timeSliderBuffer,{width:an,left:aq?aq.width:0})}}function al(an){if(an.mute){_hide(S.muteButton);_show(S.unmuteButton);_hide(S.volumeSliderProgress)}else{_show(S.muteButton);_hide(S.unmuteButton);_show(S.volumeSliderProgress)}}function s(an){if(an.newstate==a.api.events.state.BUFFERING||an.newstate==a.api.events.state.PLAYING){_show(S.pauseButton);_hide(S.playButton)}else{_hide(S.pauseButton);_show(S.playButton)}Z();if(an.newstate==a.api.events.state.IDLE){_hide(S.timeSliderBuffer);_hide(S.timeSliderProgress);_hide(S.timeSliderThumb);J({id:l.id,duration:l.jwGetDuration(),position:0})}else{_show(S.timeSliderBuffer);if(an.newstate!=a.api.events.state.BUFFERING){_show(S.timeSliderProgress);_show(S.timeSliderThumb)}}}function M(an){v({bufferPercent:0});J(_utils.extend(an,{position:0,duration:ah}))}function J(at){if(_utils.exists(at.position)){k=at.position}var ao=false;if(_utils.exists(at.duration)&&at.duration!=ah){ah=at.duration;ao=true}var aq=(k===ah===0)?0:k/ah;var av=c.timeSliderRail;if(av){var ap=isNaN(Math.round(av.width*aq))?0:Math.round(av.width*aq);var au=l.skin.getSkinElement("controlbar","timeSliderCapLeft");var ar=ap+(au?au.width:0);if(S.timeSliderProgress){_css(S.timeSliderProgress,{width:ap,left:au?au.width:0});if(!h){if(S.timeSliderThumb){S.timeSliderThumb.style.left=ar+"px"}}}}if(S.durationText){S.durationText.innerHTML=_utils.timeFormat(ah)}if(S.elapsedText){var an=_utils.timeFormat(k);S.elapsedText.innerHTML=an;if(Q!=an.length){ao=true;Q=an.length}}if(ao){x()}}function o(){var an=S.elements.childNodes;var at,aq;for(var ap=0;ap<an.length;ap++){var ar=an[ap].childNodes;for(var ao in ar){if(isNaN(parseInt(ao,10))){continue}if(ar[ao].id.indexOf(ag.id+"_divider")===0&&aq&&aq.id.indexOf(ag.id+"_divider")===0&&ar[ao].style.backgroundImage==aq.style.backgroundImage){ar[ao].style.display="none"}else{if(ar[ao].id.indexOf(ag.id+"_divider")===0&&at&&at.style.display!="none"){ar[ao].style.display="block"}}if(ar[ao].style.display!="none"){aq=ar[ao]}at=ar[ao]}}}function aj(){if(l.jwGetFullscreen()){_show(S.normalscreenButton);_hide(S.fullscreenButton)}else{_hide(S.normalscreenButton);_show(S.fullscreenButton)}if(l.jwGetState()==a.api.events.state.BUFFERING||l.jwGetState()==a.api.events.state.PLAYING){_show(S.pauseButton);_hide(S.playButton)}else{_hide(S.pauseButton);_show(S.playButton)}if(l.jwGetMute()==true){_hide(S.muteButton);_show(S.unmuteButton);_hide(S.volumeSliderProgress)}else{_show(S.muteButton);_hide(S.unmuteButton);_show(S.volumeSliderProgress)}}function x(){o();aj();var ap={width:f};var ax={"float":"left",styleFloat:"left",cssFloat:"left"};if(D.position==a.html5.view.positions.OVER||l.jwGetFullscreen()){ap.left=D.margin;ap.width-=2*D.margin;ap.top=z-K().height-D.margin;ap.height=K().height}var ar=l.skin.getSkinElement("controlbar","capLeft");var av=l.skin.getSkinElement("controlbar","capRight");ax.width=ap.width-(ar?ar.width:0)-(av?av.width:0);var aq=_utils.getBoundingClientRect(S.leftGroup).width;var au=_utils.getBoundingClientRect(S.rightGroup).width;var at=ax.width-aq-au-1;var ao=at;var an=l.skin.getSkinElement("controlbar","timeSliderCapLeft");var aw=l.skin.getSkinElement("controlbar","timeSliderCapRight");if(_utils.exists(an)){ao-=an.width}if(_utils.exists(aw)){ao-=aw.width}S.timeSlider.style.width=at+"px";S.timeSliderRail.style.width=ao+"px";_css(ag,ap);_css(S.elements,ax);_css(S.background,ax);r();return ap}function n(at){if(_utils.exists(S.volumeSliderRail)){var ap=isNaN(at.volume/100)?1:at.volume/100;var aq=_utils.parseDimension(S.volumeSliderRail.style.width);var an=isNaN(Math.round(aq*ap))?0:Math.round(aq*ap);var au=_utils.parseDimension(S.volumeSliderRail.style.right);var ao=(!_utils.exists(l.skin.getSkinElement("controlbar","volumeSliderCapLeft")))?0:l.skin.getSkinElement("controlbar","volumeSliderCapLeft").width;_css(S.volumeSliderProgress,{width:an,left:ao});if(S.volumeSliderThumb){var ar=(an-Math.round(_utils.parseDimension(S.volumeSliderThumb.style.width)/2));ar=Math.min(Math.max(ar,0),aq-_utils.parseDimension(S.volumeSliderThumb.style.width));_css(S.volumeSliderThumb,{left:ar})}if(_utils.exists(S.volumeSliderCapLeft)){_css(S.volumeSliderCapLeft,{left:0})}}}function T(){try{var ao=(l.id.indexOf("_instream")>0?l.id.replace("_instream",""):l.id);H=document.getElementById(ao);H.addEventListener("mousemove",Z)}catch(an){_utils.log("Could not add mouse listeners to controlbar: "+an)}}function u(){O();N();r();q=true;F();D.idlehide=(D.idlehide.toString().toLowerCase()=="true");if(D.position==a.html5.view.positions.OVER&&D.idlehide){ag.style.opacity=0;V=true}else{ag.style.opacity=1;setTimeout((function(){V=true;W()}),1)}T();ai()}u();return this}})(jwplayer);(function(b){var a=["width","height","state","playlist","item","position","buffer","duration","volume","mute","fullscreen"];var c=b.utils;b.html5.controller=function(o,K,f,h){var n=o,m=f,j=h,y=K,M=true,G=-1,A=false,d=false,P,C=[],q=false;var D=(c.exists(m.config.debug)&&(m.config.debug.toString().toLowerCase()=="console")),N=new b.html5.eventdispatcher(y.id,D);c.extend(this,N);function L(T){if(q){N.sendEvent(T.type,T)}else{C.push(T)}}function s(T){if(!q){q=true;N.sendEvent(b.api.events.JWPLAYER_READY,T);if(b.utils.exists(window.playerReady)){playerReady(T)}if(b.utils.exists(window[f.config.playerReady])){window[f.config.playerReady](T)}while(C.length>0){var V=C.shift();N.sendEvent(V.type,V)}if(f.config.autostart&&!b.utils.isIOS()){O()}while(x.length>0){var U=x.shift();B(U.method,U.arguments)}}}m.addGlobalListener(L);m.addEventListener(b.api.events.JWPLAYER_MEDIA_BUFFER_FULL,function(){m.getMedia().play()});m.addEventListener(b.api.events.JWPLAYER_MEDIA_TIME,function(T){if(T.position>=m.playlist[m.item].start&&G>=0){m.playlist[m.item].start=G;G=-1}});m.addEventListener(b.api.events.JWPLAYER_MEDIA_COMPLETE,function(T){setTimeout(E,25)});m.addEventListener(b.api.events.JWPLAYER_PLAYLIST_LOADED,O);m.addEventListener(b.api.events.JWPLAYER_FULLSCREEN,p);function F(){try{P=F;if(!A){A=true;N.sendEvent(b.api.events.JWPLAYER_MEDIA_BEFOREPLAY);A=false;if(d){d=false;P=null;return}}v(m.item);if(m.playlist[m.item].levels[0].file.length>0){if(M||m.state==b.api.events.state.IDLE){m.getMedia().load(m.playlist[m.item]);M=false}else{if(m.state==b.api.events.state.PAUSED){m.getMedia().play()}}}return true}catch(T){N.sendEvent(b.api.events.JWPLAYER_ERROR,T);P=null}return false}function e(){try{if(m.playlist[m.item].levels[0].file.length>0){switch(m.state){case b.api.events.state.PLAYING:case b.api.events.state.BUFFERING:if(m.getMedia()){m.getMedia().pause()}break;default:if(A){d=true}}}return true}catch(T){N.sendEvent(b.api.events.JWPLAYER_ERROR,T)}return false}function z(T){try{if(m.playlist[m.item].levels[0].file.length>0){if(typeof T!="number"){T=parseFloat(T)}switch(m.state){case b.api.events.state.IDLE:if(G<0){G=m.playlist[m.item].start;m.playlist[m.item].start=T}if(!A){F()}break;case b.api.events.state.PLAYING:case b.api.events.state.PAUSED:case b.api.events.state.BUFFERING:m.seek(T);break}}return true}catch(U){N.sendEvent(b.api.events.JWPLAYER_ERROR,U)}return false}function w(T){P=null;if(!c.exists(T)){T=true}try{if((m.state!=b.api.events.state.IDLE||T)&&m.getMedia()){m.getMedia().stop(T)}if(A){d=true}return true}catch(U){N.sendEvent(b.api.events.JWPLAYER_ERROR,U)}return false}function k(){try{if(m.playlist[m.item].levels[0].file.length>0){if(m.config.shuffle){v(S())}else{if(m.item+1==m.playlist.length){v(0)}else{v(m.item+1)}}}if(m.state!=b.api.events.state.IDLE){var U=m.state;m.state=b.api.events.state.IDLE;N.sendEvent(b.api.events.JWPLAYER_PLAYER_STATE,{oldstate:U,newstate:b.api.events.state.IDLE})}F();return true}catch(T){N.sendEvent(b.api.events.JWPLAYER_ERROR,T)}return false}function I(){try{if(m.playlist[m.item].levels[0].file.length>0){if(m.config.shuffle){v(S())}else{if(m.item===0){v(m.playlist.length-1)}else{v(m.item-1)}}}if(m.state!=b.api.events.state.IDLE){var U=m.state;m.state=b.api.events.state.IDLE;N.sendEvent(b.api.events.JWPLAYER_PLAYER_STATE,{oldstate:U,newstate:b.api.events.state.IDLE})}F();return true}catch(T){N.sendEvent(b.api.events.JWPLAYER_ERROR,T)}return false}function S(){var T=null;if(m.playlist.length>1){while(!c.exists(T)){T=Math.floor(Math.random()*m.playlist.length);if(T==m.item){T=null}}}else{T=0}return T}function H(U){if(!m.playlist||!m.playlist[U]){return false}try{if(m.playlist[U].levels[0].file.length>0){var V=m.state;if(V!==b.api.events.state.IDLE){if(m.playlist[m.item]&&m.playlist[m.item].provider==m.playlist[U].provider){w(false)}else{w()}}v(U);F()}return true}catch(T){N.sendEvent(b.api.events.JWPLAYER_ERROR,T)}return false}function v(T){if(!m.playlist[T]){return}m.setActiveMediaProvider(m.playlist[T]);if(m.item!=T){m.item=T;M=true;N.sendEvent(b.api.events.JWPLAYER_PLAYLIST_ITEM,{index:T})}}function g(U){try{v(m.item);var V=m.getMedia();switch(typeof(U)){case"number":V.volume(U);break;case"string":V.volume(parseInt(U,10));break}m.setVolume(U);return true}catch(T){N.sendEvent(b.api.events.JWPLAYER_ERROR,T)}return false}function r(U){try{v(m.item);var V=m.getMedia();if(typeof U=="undefined"){V.mute(!m.mute);m.setMute(!m.mute)}else{if(U.toString().toLowerCase()=="true"){V.mute(true);m.setMute(true)}else{V.mute(false);m.setMute(false)}}return true}catch(T){N.sendEvent(b.api.events.JWPLAYER_ERROR,T)}return false}function J(U,T){try{m.width=U;m.height=T;j.resize(U,T);N.sendEvent(b.api.events.JWPLAYER_RESIZE,{width:m.width,height:m.height});return true}catch(V){N.sendEvent(b.api.events.JWPLAYER_ERROR,V)}return false}function u(U,V){try{if(typeof U=="undefined"){U=!m.fullscreen}if(typeof V=="undefined"){V=true}if(U!=m.fullscreen){m.fullscreen=(U.toString().toLowerCase()=="true");j.fullscreen(m.fullscreen);if(V){N.sendEvent(b.api.events.JWPLAYER_FULLSCREEN,{fullscreen:m.fullscreen})}N.sendEvent(b.api.events.JWPLAYER_RESIZE,{width:m.width,height:m.height})}return true}catch(T){N.sendEvent(b.api.events.JWPLAYER_ERROR,T)}return false}function R(T){try{w();if(A){d=false}m.loadPlaylist(T);if(m.playlist[m.item].provider){v(m.item);if(m.config.autostart.toString().toLowerCase()=="true"&&!c.isIOS()&&!A){F()}return true}else{return false}}catch(U){N.sendEvent(b.api.events.JWPLAYER_ERROR,U)}return false}function O(T){if(!c.isIOS()){v(m.item);if(m.config.autostart.toString().toLowerCase()=="true"&&!c.isIOS()){F()}}}function p(T){u(T.fullscreen,false)}function t(){try{return m.getMedia().detachMedia()}catch(T){return null}}function l(){try{var T=m.getMedia().attachMedia();if(typeof P=="function"){P()}}catch(U){return null}}b.html5.controller.repeatoptions={LIST:"LIST",ALWAYS:"ALWAYS",SINGLE:"SINGLE",NONE:"NONE"};function E(){if(m.state!=b.api.events.state.IDLE){return}P=E;switch(m.config.repeat.toUpperCase()){case b.html5.controller.repeatoptions.SINGLE:F();break;case b.html5.controller.repeatoptions.ALWAYS:if(m.item==m.playlist.length-1&&!m.config.shuffle){H(0)}else{k()}break;case b.html5.controller.repeatoptions.LIST:if(m.item==m.playlist.length-1&&!m.config.shuffle){w();v(0)}else{k()}break;default:w();break}}var x=[];function Q(T){return function(){if(q){B(T,arguments)}else{x.push({method:T,arguments:arguments})}}}function B(V,U){var T=[];for(i=0;i<U.length;i++){T.push(U[i])}V.apply(this,T)}this.play=Q(F);this.pause=Q(e);this.seek=Q(z);this.stop=Q(w);this.next=Q(k);this.prev=Q(I);this.item=Q(H);this.setVolume=Q(g);this.setMute=Q(r);this.resize=Q(J);this.setFullscreen=Q(u);this.load=Q(R);this.playerReady=s;this.detachMedia=t;this.attachMedia=l;this.beforePlay=function(){return A};this.destroy=function(){if(m.getMedia()){m.getMedia().destroy()}}}})(jwplayer);(function(a){a.html5.defaultSkin=function(){this.text='<?xml version="1.0" ?><skin author="LongTail Video" name="Five" version="1.1"><components><component name="controlbar"><settings><setting name="margin" value="20"/><setting name="fontsize" value="11"/><setting name="fontcolor" value="0x000000"/></settings><layout><group position="left"><button name="play"/><divider name="divider"/><button name="prev"/><divider name="divider"/><button name="next"/><divider name="divider"/><text name="elapsed"/></group><group position="center"><slider name="time"/></group><group position="right"><text name="duration"/><divider name="divider"/><button name="blank"/><divider name="divider"/><button name="mute"/><slider name="volume"/><divider name="divider"/><button name="fullscreen"/></group></layout><elements><element name="background" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAIAAABvFaqvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAElJREFUOI3t1LERACAMQlFgGvcfxNIhHMK4gsUvUviOmgtNsiAZkBSEKxKEnCYkkQrJn/YwbUNiSDDYRZaQRDaShv+oX9GBZEIuK+8hXVLs+/YAAAAASUVORK5CYII="/><element name="blankButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAYCAYAAAAyJzegAAAAFElEQVQYV2P8//8/AzpgHBUc7oIAGZdH0RjKN8EAAAAASUVORK5CYII="/><element name="capLeft" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAYCAYAAAA7zJfaAAAAQElEQVQIWz3LsRGAMADDQJ0XB5bMINABZ9GENGrszxhjT2WLSqxEJG2JQrTMdV2q5LpOAvyRaVmsi7WdeZ/7+AAaOTq7BVrfOQAAAABJRU5ErkJggg=="/><element name="capRight" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAYCAYAAAA7zJfaAAAAQElEQVQIWz3LsRGAMADDQJ0XB5bMINABZ9GENGrszxhjT2WLSqxEJG2JQrTMdV2q5LpOAvyRaVmsi7WdeZ/7+AAaOTq7BVrfOQAAAABJRU5ErkJggg=="/><element name="divider" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAYCAIAAAC0rgCNAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAADhJREFUCB0FwcENgEAAw7Aq+893g8APUILNOQcbFRktVGqUVFRkWNz3xTa2sUaLNUosKlRUvvf5AdbWOTtzmzyWAAAAAElFTkSuQmCC"/><element name="playButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAYCAYAAAAVibZIAAAANUlEQVR42u2RsQkAAAjD/NTTPaW6dXLrINJA1kBpGPMAjDWmOgp1HFQXx+b1KOefO4oxY57R73YnVYCQUCQAAAAASUVORK5CYII="/><element name="pauseButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAYCAYAAAAVibZIAAAAIUlEQVQ4jWNgGAWjYOiD/0gYG3/U0FFDB4Oho2AUDAYAAEwiL9HrpdMVAAAAAElFTkSuQmCC"/><element name="prevButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAYCAYAAAAVibZIAAAAQklEQVQ4y2NgGAWjYOiD/1AMA/JAfB5NjCJD/YH4PRaLyDa0H4lNNUP/DxlD59PCUBCIp3ZEwYA+NZLUKBgFgwEAAN+HLX9sB8u8AAAAAElFTkSuQmCC"/><element name="nextButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAYCAYAAAAVibZIAAAAQElEQVQ4y2NgGAWjYOiD/0B8Hojl0cT+U2ooCL8HYn9qGwrD/bQw9P+QMXQ+tSMqnpoRBUpS+tRMUqNgFAwGAADxZy1/mHvFnAAAAABJRU5ErkJggg=="/><element name="timeSliderRail" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAOElEQVRIDe3BwQkAIRADwAhhw/nU/kWwUK+KPITMABFh19Y+F0acY8CJvX9wYpXgRElwolSIiMf9ZWEDhtwurFsAAAAASUVORK5CYII="/><element name="timeSliderBuffer" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAN0lEQVRIDe3BwQkAMQwDMBcc55mRe9zi7RR+FCwBEWG39vcfGHFm4MTuhhMlwYlVBSdKhYh43AW/LQMKm1spzwAAAABJRU5ErkJggg=="/><element name="timeSliderProgress" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAIElEQVRIiWNgGAWjYBTQBfynMR61YCRYMApGwSigMQAAiVWPcbq6UkIAAAAASUVORK5CYII="/><element name="timeSliderThumb" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAYCAYAAAA/OUfnAAAAO0lEQVQYlWP4//8/Awwz0JgDBP/BeN6Cxf/hnI2btiI4u/fsQ3AOHjqK4Jw4eQbBOX/hEoKDYjSd/AMA4cS4mfLsorgAAAAASUVORK5CYII="/><element name="muteButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAYCAYAAADKx8xXAAAAJklEQVQ4y2NgGAUjDcwH4v/kaPxPikZkxcNVI9mBQ5XoGAWDFwAAsKAXKQQmfbUAAAAASUVORK5CYII="/><element name="unmuteButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAYCAYAAADKx8xXAAAAMklEQVQ4y2NgGAWDHPyntub5xBr6Hwv/Pzk2/yfVG/8psRFE25Oq8T+tQnsIaB4FVAcAi2YVysVY52AAAAAASUVORK5CYII="/><element name="volumeSliderRail" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYAgMAAACdGdVrAAAACVBMVEUAAACmpqampqbBXAu8AAAAAnRSTlMAgJsrThgAAAArSURBVAhbY2AgErBAyA4I2QEhOyBkB4TsYOhAoaCCUCUwDTDtMMNgRuMHAFB5FoGH5T0UAAAAAElFTkSuQmCC"/><element name="volumeSliderProgress" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYAgMAAACdGdVrAAAACVBMVEUAAAAAAAAAAACDY+nAAAAAAnRSTlMAgJsrThgAAAArSURBVAhbY2AgErBAyA4I2QEhOyBkB4TsYOhAoaCCUCUwDTDtMMNgRuMHAFB5FoGH5T0UAAAAAElFTkSuQmCC"/><element name="volumeSliderCapRight" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAYCAYAAAAyJzegAAAAFElEQVQYV2P8//8/AzpgHBUc7oIAGZdH0RjKN8EAAAAASUVORK5CYII="/><element name="fullscreenButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQklEQVRIiWNgGAWjYMiD/0iYFDmSLbDHImdPLQtgBpEiR7Zl2NijAA5oEkT/0Whi5UiyAJ8BVMsHNMtoo2AUDAIAAGdcIN3IDNXoAAAAAElFTkSuQmCC"/><element name="normalscreenButton" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAP0lEQVRIx2NgGAWjYMiD/1RSQ5QB/wmIUWzJfzx8qhj+n4DYCAY0DyJ7PBbYU8sHMEvwiZFtODXUjIJRMJgBACpWIN2ZxdPTAAAAAElFTkSuQmCC"/></elements></component><component name="display"><elements><element name="background" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyAQMAAAAk8RryAAAABlBMVEUAAAAAAAClZ7nPAAAAAnRSTlOZpuml+rYAAAASSURBVBhXY2AYJuA/GBwY6jQAyDyoK8QcL4QAAAAASUVORK5CYII="/><element name="playIcon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAiUlEQVR42u3XSw2AMBREURwgAQlIQAISKgUpSEFKJeCg5b0E0kWBTVcD9ySTsL0Jn9IBAAAA+K2UUrBlW/Rr5ZDoIeeuoFkxJD9ss03aIXXQqB9SttoG7ZA6qNcOKdttiwcJh9RB+iFl4SshkRBuLR72+9cvH0SOKI2HRo7x/Fi1/uoCAAAAwLsD8ki99IlO2dQAAAAASUVORK5CYII="/><element name="muteIcon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAAVUlEQVR42u3WMQrAIAxAUW/g/SdvGmvpoOBeSHgPsjj5QTANAACARCJilIhYM0tEvJM+Ik3Id9E957kQIb+F3OdCPC0hPkQriqWx9hp/x/QGAABQyAPLB22VGrpLDgAAAABJRU5ErkJggg=="/><element name="errorIcon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAA/0lEQVR42u2U0QmEMBAF7cASLMESUoIlpARLSCkpwRJSgiWkhOvAXD4WsgRkyaG5DbyB+Yvg8KITAAAAAAAYk+u61mwk15EjPtlEfihmqIiZR1Qx80ghjgdUuiHXGHSVsoag0x6x8DUoyjD5KovmEJ9NTDMRPIT0mtdIUkjlonuNohO+Ha99DTmkuGgKCTcvebAzx82ZoCWC3/3aIMWSRucaxcjORSFY4xpFdjYJGp1rFGcyCYZ/RVh6AUnfcNZ2zih3/mGj1jVCdiNDwyrq1rA/xMdeEXvDVdnYc1vDc3uPkDObXrlaxbNHSOohQhr/WOeLEWfWTgAAAAAAADzNF9sHJ7PJ57MlAAAAAElFTkSuQmCC"/><element name="bufferIcon" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAACBklEQVR42u3Zv0sCYRzH8USTzOsHHEWGkC1HgaDgkktGDjUYtDQ01RDSljQ1BLU02+rk1NTm2NLq4Nx/0L/h9fnCd3j4cnZe1/U8xiO8h3uurufF0/3COd/3/0UWYiEWYiEWYiGJQ+J8xuPxKhXjEMZANinjIZhkGuVRNioE4wVURo4JkHm0xKWmhRAc1bh1EyCUw5BcBIjHiApKa4CErko6DEJwuRo6IRKzyJD8FJAyI3Zp2zRImiBcRhlfo5RtlxCcE3CcDNpGrhYIT2IhAJKilO0VRmzJ32fAMTpBTS0QMfGwlcuKMRftE0DJ0wCJdcOsCkBdXP3Mh9CEFUBTPS9mDZJBG6io4aqVzMdCokCw9H3kT6j/C/9iDdSeUMNC7DkyyxAs/Rk6Qss8FPWRZgdVtUH4DjxEn1zxh+/zj1wHlf4MQhNGrwqA6sY40U8JonRJwEQh+AO3AvCG6gHv4U7IY4krxkroWoAOkoQMGfCBrgIm+YBGqPENpIJ66CJg3x66Y0gnSUidAEEnNr9jjLiWMn5DiWP0OC/oAsCgkq43xBdGDMQr7YASP/vEkHvdl1+JOCcEV5sC4hGEOzTlPuKgd0b0xD4JkRcOgnRRTjdErkYhAsQVq6IdUuPJtmk7BCL3t/h88cx91pKQkI/pkDx6pmYTIjEoxiHsN1YWYiEWYiEWknhflZ5IErA5nr8AAAAASUVORK5CYII="/></elements></component><component name="dock"><settings><setting name="fontcolor" value="0xffffff"/></settings><elements><element name="button" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyAQMAAAAk8RryAAAABlBMVEUAAAAAAAClZ7nPAAAAAnRSTlOZpuml+rYAAAASSURBVBhXY2AYJuA/GBwY6jQAyDyoK8QcL4QAAAAASUVORK5CYII="/></elements></component><component name="playlist"><settings><setting name="backgroundcolor" value="0xe8e8e8"/></settings><elements><element name="item" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAIAAAC1nk4lAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHBJREFUaN7t2MENwCAMBEEe9N8wSKYC/D8YV7CyJoRkVtVImxkZPQInMxoP0XiIxkM0HsGbjjSNBx544IEHHnjggUe/6UQeey0PIh7XTftGxKPj4eXCtLsHHh+ZxkO0Iw8PR55Ni8ZD9Hu/EAoP0dc5RRg9qeRjVF8AAAAASUVORK5CYII="/><element name="sliderCapTop" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAHCAYAAADnCQYGAAAAFUlEQVQokWP8//8/A7UB46ihI9hQAKt6FPPXhVGHAAAAAElFTkSuQmCC"/><element name="sliderRail" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAUCAYAAABiS3YzAAAAKElEQVQ4y2P4//8/Az68bNmy/+iYkB6GUUNHDR01dNTQUUNHDaXcUABUDOKhcxnsSwAAAABJRU5ErkJggg=="/><element name="sliderThumb" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAUCAYAAABiS3YzAAAAJUlEQVQ4T2P4//8/Ay4MBP9xYbz6Rg0dNXTU0FFDRw0dNZRyQwHH4NBa7GJsXAAAAABJRU5ErkJggg=="/><element name="sliderCapBottom" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAHCAYAAADnCQYGAAAAFUlEQVQokWP8//8/A7UB46ihI9hQAKt6FPPXhVGHAAAAAElFTkSuQmCC"/></elements></component></components></skin>';this.xml=null;if(window.DOMParser){parser=new DOMParser();this.xml=parser.parseFromString(this.text,"text/xml")}else{this.xml=new ActiveXObject("Microsoft.XMLDOM");this.xml.async="false";this.xml.loadXML(this.text)}return this}})(jwplayer);(function(a){_utils=a.utils;_css=_utils.css;_hide=function(b){_css(b,{display:"none"})};_show=function(b){_css(b,{display:"block"})};a.html5.display=function(k,K){var j={icons:true,showmute:false};var X=_utils.extend({},j,K);var h=k;var W={};var e;var w;var z;var T;var u;var M;var E;var N=!_utils.exists(h.skin.getComponentSettings("display").bufferrotation)?15:parseInt(h.skin.getComponentSettings("display").bufferrotation,10);var s=!_utils.exists(h.skin.getComponentSettings("display").bufferinterval)?100:parseInt(h.skin.getComponentSettings("display").bufferinterval,10);var D=-1;var v=a.api.events.state.IDLE;var O=true;var d;var C=false,V=true;var p="";var g=false;var o=false;var m;var y,R;var L=new a.html5.eventdispatcher();_utils.extend(this,L);var H={display:{style:{cursor:"pointer",top:0,left:0,overflow:"hidden"},click:n},display_icon:{style:{cursor:"pointer",position:"absolute",top:((h.skin.getSkinElement("display","background").height-h.skin.getSkinElement("display","playIcon").height)/2),left:((h.skin.getSkinElement("display","background").width-h.skin.getSkinElement("display","playIcon").width)/2),border:0,margin:0,padding:0,zIndex:3,display:"none"}},display_iconBackground:{style:{cursor:"pointer",position:"absolute",top:((w-h.skin.getSkinElement("display","background").height)/2),left:((e-h.skin.getSkinElement("display","background").width)/2),border:0,backgroundImage:(["url(",h.skin.getSkinElement("display","background").src,")"]).join(""),width:h.skin.getSkinElement("display","background").width,height:h.skin.getSkinElement("display","background").height,margin:0,padding:0,zIndex:2,display:"none"}},display_image:{style:{display:"none",width:e,height:w,position:"absolute",cursor:"pointer",left:0,top:0,margin:0,padding:0,textDecoration:"none",zIndex:1}},display_text:{style:{zIndex:4,position:"relative",opacity:0.8,backgroundColor:parseInt("000000",16),color:parseInt("ffffff",16),textAlign:"center",fontFamily:"Arial,sans-serif",padding:"0 5px",fontSize:14}}};h.jwAddEventListener(a.api.events.JWPLAYER_PLAYER_STATE,q);h.jwAddEventListener(a.api.events.JWPLAYER_MEDIA_MUTE,q);h.jwAddEventListener(a.api.events.JWPLAYER_PLAYLIST_LOADED,P);h.jwAddEventListener(a.api.events.JWPLAYER_PLAYLIST_ITEM,q);h.jwAddEventListener(a.api.events.JWPLAYER_ERROR,r);Q();function Q(){W.display=G("div","display");W.display_text=G("div","display_text");W.display.appendChild(W.display_text);W.display_image=G("img","display_image");W.display_image.onerror=function(Y){_hide(W.display_image)};W.display_image.onload=B;W.display_icon=G("div","display_icon");W.display_iconBackground=G("div","display_iconBackground");W.display.appendChild(W.display_image);W.display_iconBackground.appendChild(W.display_icon);W.display.appendChild(W.display_iconBackground);f();setTimeout((function(){o=true;if(X.icons.toString()=="true"){J()}}),1)}this.getDisplayElement=function(){return W.display};this.resize=function(Z,Y){if(h.jwGetFullscreen()&&_utils.isMobile()){return}_css(W.display,{width:Z,height:Y});_css(W.display_text,{width:(Z-10),top:((Y-_utils.getBoundingClientRect(W.display_text).height)/2)});_css(W.display_iconBackground,{top:((Y-h.skin.getSkinElement("display","background").height)/2),left:((Z-h.skin.getSkinElement("display","background").width)/2)});if(e!=Z||w!=Y){e=Z;w=Y;d=undefined;J()}if(!h.jwGetFullscreen()){y=Z;R=Y}c();q({})};this.show=function(){if(g){g=false;t(h.jwGetState())}};this.hide=function(){if(!g){F();g=true}};function B(Y){z=W.display_image.naturalWidth;T=W.display_image.naturalHeight;c();if(h.jwGetState()==a.api.events.state.IDLE||h.jwGetPlaylist()[h.jwGetPlaylistIndex()].provider=="sound"){_css(W.display_image,{display:"block",opacity:0});_utils.fadeTo(W.display_image,1,0.1)}C=false}function c(){if(h.jwGetFullscreen()&&h.jwGetStretching()==a.utils.stretching.EXACTFIT){var Y=document.createElement("div");_utils.stretch(a.utils.stretching.UNIFORM,Y,e,w,y,R);_utils.stretch(a.utils.stretching.EXACTFIT,W.display_image,_utils.parseDimension(Y.style.width),_utils.parseDimension(Y.style.height),z,T);_css(W.display_image,{left:Y.style.left,top:Y.style.top})}else{_utils.stretch(h.jwGetStretching(),W.display_image,e,w,z,T)}}function G(Y,aa){var Z=document.createElement(Y);Z.id=h.id+"_jwplayer_"+aa;_css(Z,H[aa].style);return Z}function f(){for(var Y in W){if(_utils.exists(H[Y].click)){W[Y].onclick=H[Y].click}}}function n(Y){if(typeof Y.preventDefault!="undefined"){Y.preventDefault()}else{Y.returnValue=false}if(typeof m=="function"){m(Y);return}else{if(h.jwGetState()!=a.api.events.state.PLAYING){h.jwPlay()}else{h.jwPause()}}}function U(Y){if(E){F();return}W.display_icon.style.backgroundImage=(["url(",h.skin.getSkinElement("display",Y).src,")"]).join("");_css(W.display_icon,{width:h.skin.getSkinElement("display",Y).width,height:h.skin.getSkinElement("display",Y).height,top:(h.skin.getSkinElement("display","background").height-h.skin.getSkinElement("display",Y).height)/2,left:(h.skin.getSkinElement("display","background").width-h.skin.getSkinElement("display",Y).width)/2});b();if(_utils.exists(h.skin.getSkinElement("display",Y+"Over"))){W.display_icon.onmouseover=function(Z){W.display_icon.style.backgroundImage=["url(",h.skin.getSkinElement("display",Y+"Over").src,")"].join("")};W.display_icon.onmouseout=function(Z){W.display_icon.style.backgroundImage=["url(",h.skin.getSkinElement("display",Y).src,")"].join("")}}else{W.display_icon.onmouseover=null;W.display_icon.onmouseout=null}}function F(){if(X.icons.toString()=="true"){_hide(W.display_icon);_hide(W.display_iconBackground);S()}}function b(){if(!g&&X.icons.toString()=="true"){_show(W.display_icon);_show(W.display_iconBackground);J()}}function r(Y){E=true;F();W.display_text.innerHTML=Y.message;_show(W.display_text);W.display_text.style.top=((w-_utils.getBoundingClientRect(W.display_text).height)/2)+"px"}function I(){V=false;W.display_image.style.display="none"}function P(){v=""}function q(Y){if((Y.type==a.api.events.JWPLAYER_PLAYER_STATE||Y.type==a.api.events.JWPLAYER_PLAYLIST_ITEM)&&E){E=false;_hide(W.display_text)}var Z=h.jwGetState();if(Z==v){return}v=Z;if(D>=0){clearTimeout(D)}if(O||h.jwGetState()==a.api.events.state.PLAYING||h.jwGetState()==a.api.events.state.PAUSED){t(h.jwGetState())}else{D=setTimeout(l(h.jwGetState()),500)}}function l(Y){return(function(){t(Y)})}function t(Y){if(_utils.exists(M)){clearInterval(M);M=null;_utils.animations.rotate(W.display_icon,0)}switch(Y){case a.api.events.state.BUFFERING:if(_utils.isIPod()){I();F()}else{if(h.jwGetPlaylist()[h.jwGetPlaylistIndex()].provider=="sound"){x()}u=0;M=setInterval(function(){u+=N;_utils.animations.rotate(W.display_icon,u%360)},s);U("bufferIcon");O=true}break;case a.api.events.state.PAUSED:if(!_utils.isIPod()){if(h.jwGetPlaylist()[h.jwGetPlaylistIndex()].provider!="sound"){_css(W.display_image,{background:"transparent no-repeat center center"})}U("playIcon");O=true}break;case a.api.events.state.IDLE:if(h.jwGetPlaylist()[h.jwGetPlaylistIndex()]&&h.jwGetPlaylist()[h.jwGetPlaylistIndex()].image){x()}else{I()}U("playIcon");O=true;break;default:if(h.jwGetPlaylist()[h.jwGetPlaylistIndex()]&&h.jwGetPlaylist()[h.jwGetPlaylistIndex()].provider=="sound"){if(_utils.isIPod()){I();O=false}else{x()}}else{I();O=false}if(h.jwGetMute()&&X.showmute){U("muteIcon")}else{F()}break}D=-1}function x(){if(h.jwGetPlaylist()[h.jwGetPlaylistIndex()]){var Y=h.jwGetPlaylist()[h.jwGetPlaylistIndex()].image;if(Y){if(Y!=p){p=Y;C=true;W.display_image.src=_utils.getAbsolutePath(Y)}else{if(!(C||V)){V=true;W.display_image.style.opacity=0;W.display_image.style.display="block";_utils.fadeTo(W.display_image,1,0.1)}}}}}function A(Y){return function(){if(!o){return}if(!g&&d!=Y){d=Y;L.sendEvent(Y,{component:"display",boundingRect:_utils.getDimensions(W.display_iconBackground)})}}}var J=A(a.api.events.JWPLAYER_COMPONENT_SHOW);var S=A(a.api.events.JWPLAYER_COMPONENT_HIDE);this.setAlternateClickHandler=function(Y){m=Y};this.revertAlternateClickHandler=function(){m=undefined};return this}})(jwplayer);(function(a){var c=a.utils;var b=c.css;a.html5.dock=function(w,D){function x(){return{align:a.html5.view.positions.RIGHT}}var n=c.extend({},x(),D);if(n.align=="FALSE"){return}var j={};var A=[];var k;var F;var f=false;var C=false;var g={x:0,y:0,width:0,height:0};var z;var o;var y;var m=new a.html5.eventdispatcher();c.extend(this,m);var r=document.createElement("div");r.id=w.id+"_jwplayer_dock";r.style.opacity=1;p();w.jwAddEventListener(a.api.events.JWPLAYER_PLAYER_STATE,q);this.getDisplayElement=function(){return r};this.setButton=function(K,H,I,J){if(!H&&j[K]){c.arrays.remove(A,K);r.removeChild(j[K].div);delete j[K]}else{if(H){if(!j[K]){j[K]={}}j[K].handler=H;j[K].outGraphic=I;j[K].overGraphic=J;if(!j[K].div){A.push(K);j[K].div=document.createElement("div");j[K].div.style.position="absolute";r.appendChild(j[K].div);j[K].div.appendChild(document.createElement("div"));j[K].div.childNodes[0].style.position="relative";j[K].div.childNodes[0].style.width="100%";j[K].div.childNodes[0].style.height="100%";j[K].div.childNodes[0].style.zIndex=10;j[K].div.childNodes[0].style.cursor="pointer";j[K].div.appendChild(document.createElement("img"));j[K].div.childNodes[1].style.position="absolute";j[K].div.childNodes[1].style.left=0;j[K].div.childNodes[1].style.top=0;if(w.skin.getSkinElement("dock","button")){j[K].div.childNodes[1].src=w.skin.getSkinElement("dock","button").src}j[K].div.childNodes[1].style.zIndex=9;j[K].div.childNodes[1].style.cursor="pointer";j[K].div.onmouseover=function(){if(j[K].overGraphic){j[K].div.childNodes[0].style.background=h(j[K].overGraphic)}if(w.skin.getSkinElement("dock","buttonOver")){j[K].div.childNodes[1].src=w.skin.getSkinElement("dock","buttonOver").src}};j[K].div.onmouseout=function(){if(j[K].outGraphic){j[K].div.childNodes[0].style.background=h(j[K].outGraphic)}if(w.skin.getSkinElement("dock","button")){j[K].div.childNodes[1].src=w.skin.getSkinElement("dock","button").src}};if(w.skin.getSkinElement("dock","button")){j[K].div.childNodes[1].src=w.skin.getSkinElement("dock","button").src}}if(j[K].outGraphic){j[K].div.childNodes[0].style.background=h(j[K].outGraphic)}else{if(j[K].overGraphic){j[K].div.childNodes[0].style.background=h(j[K].overGraphic)}}if(H){j[K].div.onclick=function(L){L.preventDefault();a(w.id).callback(K);if(j[K].overGraphic){j[K].div.childNodes[0].style.background=h(j[K].overGraphic)}if(w.skin.getSkinElement("dock","button")){j[K].div.childNodes[1].src=w.skin.getSkinElement("dock","button").src}}}}}l(k,F)};function h(H){return"url("+H+") no-repeat center center"}function t(H){}function l(H,T){p();if(A.length>0){var I=10;var S=I;var P=-1;var Q=w.skin.getSkinElement("dock","button").height;var O=w.skin.getSkinElement("dock","button").width;var M=H-O-I;var R,L;if(n.align==a.html5.view.positions.LEFT){P=1;M=I}for(var J=0;J<A.length;J++){var U=Math.floor(S/T);if((S+Q+I)>((U+1)*T)){S=((U+1)*T)+I;U=Math.floor(S/T)}var K=j[A[J]].div;K.style.top=(S%T)+"px";K.style.left=(M+(w.skin.getSkinElement("dock","button").width+I)*U*P)+"px";var N={x:c.parseDimension(K.style.left),y:c.parseDimension(K.style.top),width:O,height:Q};if(!R||(N.x<=R.x&&N.y<=R.y)){R=N}if(!L||(N.x>=L.x&&N.y>=L.y)){L=N}K.style.width=O+"px";K.style.height=Q+"px";S+=w.skin.getSkinElement("dock","button").height+I}g={x:R.x,y:R.y,width:L.x-R.x+L.width,height:R.y-L.y+L.height}}if(C!=w.jwGetFullscreen()||k!=H||F!=T){k=H;F=T;C=w.jwGetFullscreen();z=undefined;setTimeout(s,1)}}function d(H){return function(){if(!f&&z!=H&&A.length>0){z=H;m.sendEvent(H,{component:"dock",boundingRect:g})}}}function q(H){if(c.isMobile()){if(H.newstate==a.api.events.state.IDLE){v()}else{e()}}else{B()}}function B(H){if(f){return}clearTimeout(y);if(D.position==a.html5.view.positions.OVER||w.jwGetFullscreen()){switch(w.jwGetState()){case a.api.events.state.PAUSED:case a.api.events.state.IDLE:if(r&&r.style.opacity<1&&(!D.idlehide||c.exists(H))){E()}if(D.idlehide){y=setTimeout(function(){u()},2000)}break;default:if(c.exists(H)){E()}y=setTimeout(function(){u()},2000);break}}else{E()}}var s=d(a.api.events.JWPLAYER_COMPONENT_SHOW);var G=d(a.api.events.JWPLAYER_COMPONENT_HIDE);this.resize=l;var v=function(){b(r,{display:"block"});if(f){f=false;s()}};var e=function(){b(r,{display:"none"});if(!f){G();f=true}};function u(){if(!f){G();if(r.style.opacity==1){c.cancelAnimation(r);c.fadeTo(r,0,0.1,1,0)}}}function E(){if(!f){s();if(r.style.opacity==0){c.cancelAnimation(r);c.fadeTo(r,1,0.1,0,0)}}}function p(){try{o=document.getElementById(w.id);o.addEventListener("mousemove",B)}catch(H){c.log("Could not add mouse listeners to dock: "+H)}}this.hide=e;this.show=v;return this}})(jwplayer);(function(a){a.html5.eventdispatcher=function(d,b){var c=new a.events.eventdispatcher(b);a.utils.extend(this,c);this.sendEvent=function(e,f){if(!a.utils.exists(f)){f={}}a.utils.extend(f,{id:d,version:a.version,type:e});c.sendEvent(e,f)}}})(jwplayer);(function(a){var b=a.utils;a.html5.instream=function(y,m,x,z){var t={controlbarseekable:"always",controlbarpausable:true,controlbarstoppable:true,playlistclickable:true};var v,A,C=y,E=m,j=x,w=z,r,H,o,G,e,f,g,l,q,h=false,k,d,n=this;this.load=function(M,K){c();h=true;A=b.extend(t,K);v=a.html5.playlistitem(M);F();d=document.createElement("div");d.id=n.id+"_instream_container";w.detachMedia();r=g.getDisplayElement();f=E.playlist[E.item];e=C.jwGetState();if(e==a.api.events.state.BUFFERING||e==a.api.events.state.PLAYING){r.pause()}H=r.src?r.src:r.currentSrc;o=r.innerHTML;G=r.currentTime;q=new a.html5.display(n,b.extend({},E.plugins.config.display));q.setAlternateClickHandler(function(N){if(_fakemodel.state==a.api.events.state.PAUSED){n.jwInstreamPlay()}else{D(a.api.events.JWPLAYER_INSTREAM_CLICK,N)}});d.appendChild(q.getDisplayElement());if(!b.isMobile()){l=new a.html5.controlbar(n,b.extend({},E.plugins.config.controlbar,{}));if(E.plugins.config.controlbar.position==a.html5.view.positions.OVER){d.appendChild(l.getDisplayElement())}else{var L=E.plugins.object.controlbar.getDisplayElement().parentNode;L.appendChild(l.getDisplayElement())}}j.setupInstream(d,r);p();g.load(v)};this.jwInstreamDestroy=function(K){if(!h){return}h=false;if(e!=a.api.events.state.IDLE){g.load(f,false);g.stop(false)}else{g.stop(true)}g.detachMedia();j.destroyInstream();if(l){try{l.getDisplayElement().parentNode.removeChild(l.getDisplayElement())}catch(L){}}D(a.api.events.JWPLAYER_INSTREAM_DESTROYED,{reason:(K?"complete":"destroyed")},true);w.attachMedia();if(e==a.api.events.state.BUFFERING||e==a.api.events.state.PLAYING){r.play();if(E.playlist[E.item]==f){E.getMedia().seek(G)}}return};this.jwInstreamAddEventListener=function(K,L){k.addEventListener(K,L)};this.jwInstreamRemoveEventListener=function(K,L){k.removeEventListener(K,L)};this.jwInstreamPlay=function(){if(!h){return}g.play(true)};this.jwInstreamPause=function(){if(!h){return}g.pause(true)};this.jwInstreamSeek=function(K){if(!h){return}g.seek(K)};this.jwInstreamGetState=function(){if(!h){return undefined}return _fakemodel.state};this.jwInstreamGetPosition=function(){if(!h){return undefined}return _fakemodel.position};this.jwInstreamGetDuration=function(){if(!h){return undefined}return _fakemodel.duration};this.playlistClickable=function(){return(!h||A.playlistclickable.toString().toLowerCase()=="true")};function s(){_fakemodel=new a.html5.model(this,E.getMedia()?E.getMedia().getDisplayElement():E.container,E);k=new a.html5.eventdispatcher();C.jwAddEventListener(a.api.events.JWPLAYER_RESIZE,p);C.jwAddEventListener(a.api.events.JWPLAYER_FULLSCREEN,p)}function c(){_fakemodel.setMute(E.mute);_fakemodel.setVolume(E.volume)}function F(){if(!g){g=new a.html5.mediavideo(_fakemodel,E.getMedia()?E.getMedia().getDisplayElement():E.container);g.addGlobalListener(I);g.addEventListener(a.api.events.JWPLAYER_MEDIA_META,J);g.addEventListener(a.api.events.JWPLAYER_MEDIA_COMPLETE,u);g.addEventListener(a.api.events.JWPLAYER_MEDIA_BUFFER_FULL,B)}g.attachMedia()}function I(K){if(h){D(K.type,K)}}function B(K){if(h){g.play()}}function u(K){if(h){setTimeout(function(){n.jwInstreamDestroy(true)},10)}}function J(K){if(K.metadata.width&&K.metadata.height){j.resizeMedia()}}function D(K,L,M){if(h||M){k.sendEvent(K,L)}}function p(){var K=E.plugins.object.display.getDisplayElement().style;if(l){var L=E.plugins.object.controlbar.getDisplayElement().style;l.resize(b.parseDimension(K.width),b.parseDimension(K.height));_css(l.getDisplayElement(),b.extend({},L,{zIndex:1001,opacity:1}))}if(q){q.resize(b.parseDimension(K.width),b.parseDimension(K.height));_css(q.getDisplayElement(),b.extend({},K,{zIndex:1000}))}if(j){j.resizeMedia()}}this.jwPlay=function(K){if(A.controlbarpausable.toString().toLowerCase()=="true"){this.jwInstreamPlay()}};this.jwPause=function(K){if(A.controlbarpausable.toString().toLowerCase()=="true"){this.jwInstreamPause()}};this.jwStop=function(){if(A.controlbarstoppable.toString().toLowerCase()=="true"){this.jwInstreamDestroy();C.jwStop()}};this.jwSeek=function(K){switch(A.controlbarseekable.toLowerCase()){case"always":this.jwInstreamSeek(K);break;case"backwards":if(_fakemodel.position>K){this.jwInstreamSeek(K)}break}};this.jwGetPosition=function(){};this.jwGetDuration=function(){};this.jwGetWidth=C.jwGetWidth;this.jwGetHeight=C.jwGetHeight;this.jwGetFullscreen=C.jwGetFullscreen;this.jwSetFullscreen=C.jwSetFullscreen;this.jwGetVolume=function(){return E.volume};this.jwSetVolume=function(K){g.volume(K);C.jwSetVolume(K)};this.jwGetMute=function(){return E.mute};this.jwSetMute=function(K){g.mute(K);C.jwSetMute(K)};this.jwGetState=function(){return _fakemodel.state};this.jwGetPlaylist=function(){return[v]};this.jwGetPlaylistIndex=function(){return 0};this.jwGetStretching=function(){return E.config.stretching};this.jwAddEventListener=function(L,K){k.addEventListener(L,K)};this.jwRemoveEventListener=function(L,K){k.removeEventListener(L,K)};this.skin=C.skin;this.id=C.id+"_instream";s();return this}})(jwplayer);(function(a){var b={prefix:"",file:"",link:"",linktarget:"_top",margin:8,out:0.5,over:1,timeout:5,hide:true,position:"bottom-left"};_css=a.utils.css;a.html5.logo=function(n,r){var q=n;var u;var d;var t;var h=false;g();function g(){o();q.jwAddEventListener(a.api.events.JWPLAYER_PLAYER_STATE,j);c();l()}function o(){if(b.prefix){var v=n.version.split(/\W/).splice(0,2).join("/");if(b.prefix.indexOf(v)<0){b.prefix+=v+"/"}}if(r.position==a.html5.view.positions.OVER){r.position=b.position}try{if(window.location.href.indexOf("https")==0){b.prefix=b.prefix.replace("http://l.longtailvideo.com","https://securel.longtailvideo.com")}}catch(w){}d=a.utils.extend({},b,r)}function c(){t=document.createElement("img");t.id=q.id+"_jwplayer_logo";t.style.display="none";t.onload=function(v){_css(t,k());p()};if(!d.file){return}if(d.file.indexOf("/")>=0){t.src=d.file}else{t.src=d.prefix+d.file}}if(!d.file){return}this.resize=function(w,v){};this.getDisplayElement=function(){return t};function l(){if(d.link){t.onmouseover=f;t.onmouseout=p;t.onclick=s}else{this.mouseEnabled=false}}function s(v){if(typeof v!="undefined"){v.stopPropagation()}if(!h){return}q.jwPause();q.jwSetFullscreen(false);if(d.link){window.open(d.link,d.linktarget)}return}function p(v){if(d.link&&h){t.style.opacity=d.out}return}function f(v){if(h){t.style.opacity=d.over}return}function k(){var x={textDecoration:"none",position:"absolute",cursor:"pointer"};x.display=(d.hide.toString()=="true"&&!h)?"none":"block";var w=d.position.toLowerCase().split("-");for(var v in w){x[w[v]]=parseInt(d.margin)}return x}function m(){if(d.hide.toString()=="true"){t.style.display="block";t.style.opacity=0;a.utils.fadeTo(t,d.out,0.1,parseFloat(t.style.opacity));u=setTimeout(function(){e()},d.timeout*1000)}h=true}function e(){h=false;if(d.hide.toString()=="true"){a.utils.fadeTo(t,0,0.1,parseFloat(t.style.opacity))}}function j(v){if(v.newstate==a.api.events.state.BUFFERING){clearTimeout(u);m()}}return this}})(jwplayer);(function(b){var d={ended:b.api.events.state.IDLE,playing:b.api.events.state.PLAYING,pause:b.api.events.state.PAUSED,buffering:b.api.events.state.BUFFERING};var f=b.utils;var a=f.isMobile();var g,e;var c={};b.html5.mediavideo=function(k,I){var M={abort:A,canplay:r,canplaythrough:r,durationchange:w,emptied:A,ended:r,error:q,loadeddata:w,loadedmetadata:w,loadstart:r,pause:r,play:A,playing:r,progress:G,ratechange:A,seeked:r,seeking:r,stalled:r,suspend:r,timeupdate:Q,volumechange:n,waiting:r,canshowcurrentframe:A,dataunavailable:A,empty:A,load:j,loadedfirstframe:A,webkitfullscreenchange:m};var E={};var N=new b.html5.eventdispatcher();f.extend(this,N);var l=k,D=I,o,h,F,W,H,P,O=false,v=false,z=false,L,J,T;U();this.load=function(Y,Z){if(typeof Z=="undefined"){Z=true}if(!v){return}W=Y;z=(W.duration>0);l.duration=W.duration;f.empty(o);o.style.display="block";o.style.opacity=1;if(g&&e){o.style.width=g;o.style.height=e;g=_previousHieght=0}T=0;s(Y.levels);if(Y.levels&&Y.levels.length>0){if(Y.levels.length==1||f.isIOS()){o.src=Y.levels[0].file}else{if(o.src){o.removeAttribute("src")}for(var X=0;X<Y.levels.length;X++){var aa=o.ownerDocument.createElement("source");aa.src=Y.levels[X].file;o.appendChild(aa);T++}}}else{o.src=Y.file}o.volume=l.volume/100;o.muted=l.mute;if(a){S()}L=J=F=false;l.buffer=0;if(!f.exists(Y.start)){Y.start=0}P=(Y.start>0)?Y.start:-1;u(b.api.events.JWPLAYER_MEDIA_LOADED);if((!a&&Y.levels.length==1)||!O){o.load()}O=false;if(Z){y(b.api.events.state.BUFFERING);u(b.api.events.JWPLAYER_MEDIA_BUFFER,{bufferPercent:0});C()}if(o.videoWidth>0&&o.videoHeight>0){w()}};this.play=function(){if(!v){return}C();if(J){y(b.api.events.state.PLAYING)}else{o.load();y(b.api.events.state.BUFFERING)}o.play()};this.pause=function(){if(!v){return}o.pause();y(b.api.events.state.PAUSED)};this.seek=function(X){if(!v){return}if(!F&&o.readyState>0){if(!(l.duration<=0||isNaN(l.duration))&&!(l.position<=0||isNaN(l.position))){o.currentTime=X;o.play()}}else{P=X}};var B=this.stop=function(X){if(!v){return}if(!f.exists(X)){X=true}t();if(X){J=false;var Y=navigator.userAgent;if(o.webkitSupportsFullscreen){try{o.webkitExitFullscreen()}catch(Z){}}o.style.opacity=0;x();if(f.isIE()){o.src=""}else{o.removeAttribute("src")}f.empty(o);o.load();O=true}if(f.isIPod()){g=o.style.width;e=o.style.height;o.style.width=0;o.style.height=0}else{if(f.isIPad()){o.style.display="none";try{o.webkitExitFullscreen()}catch(aa){}}}y(b.api.events.state.IDLE)};this.fullscreen=function(X){if(X===true){this.resize("100%","100%")}else{this.resize(l.config.width,l.config.height)}};this.resize=function(Y,X){};this.volume=function(X){if(!a){o.volume=X/100;u(b.api.events.JWPLAYER_MEDIA_VOLUME,{volume:(X/100)})}};this.mute=function(X){if(!a){o.muted=X;u(b.api.events.JWPLAYER_MEDIA_MUTE,{mute:X})}};this.getDisplayElement=function(){return o};this.hasChrome=function(){return a&&(h==b.api.events.state.PLAYING)};this.detachMedia=function(){v=false;return this.getDisplayElement()};this.attachMedia=function(){v=true};this.destroy=function(){if(o&&o.parentNode){t();for(var X in M){o.removeEventListener(X,K(X,M[X]),true)}f.empty(o);D=o.parentNode;o.parentNode.removeChild(o);delete c[l.id];o=null}};function K(Y,X){if(E[Y]){return E[Y]}else{E[Y]=function(Z){if(f.exists(Z.target.parentNode)){X(Z)}};return E[Y]}}function U(){h=b.api.events.state.IDLE;v=true;o=p();o.setAttribute("x-webkit-airplay","allow");if(D.parentNode){o.id=D.id;D.parentNode.replaceChild(o,D)}}function p(){var X=c[l.id];if(!X){if(D.tagName.toLowerCase()=="video"){X=D}else{X=document.createElement("video")}c[l.id]=X;if(!X.id){X.id=D.id}}for(var Y in M){X.addEventListener(Y,K(Y,M[Y]),true)}return X}function y(X){if(X==b.api.events.state.PAUSED&&h==b.api.events.state.IDLE){return}if(a){switch(X){case b.api.events.state.PLAYING:S();break;case b.api.events.state.BUFFERING:case b.api.events.state.PAUSED:x();break}}if(h!=X){var Y=h;l.state=h=X;u(b.api.events.JWPLAYER_PLAYER_STATE,{oldstate:Y,newstate:X})}}function A(X){}function n(X){var Y=Math.round(o.volume*100);u(b.api.events.JWPLAYER_MEDIA_VOLUME,{volume:Y},true);u(b.api.events.JWPLAYER_MEDIA_MUTE,{mute:o.muted},true)}function G(Z){if(!v){return}var Y;if(f.exists(Z)&&Z.lengthComputable&&Z.total){Y=Z.loaded/Z.total*100}else{if(f.exists(o.buffered)&&(o.buffered.length>0)){var X=o.buffered.length-1;if(X>=0){Y=o.buffered.end(X)/o.duration*100}}}if(f.useNativeFullscreen()&&f.exists(o.webkitDisplayingFullscreen)){if(l.fullscreen!=o.webkitDisplayingFullscreen){u(b.api.events.JWPLAYER_FULLSCREEN,{fullscreen:o.webkitDisplayingFullscreen},true)}}if(J===false&&h==b.api.events.state.BUFFERING){u(b.api.events.JWPLAYER_MEDIA_BUFFER_FULL);J=true}if(!L){if(Y==100){L=true}if(f.exists(Y)&&(Y>l.buffer)){l.buffer=Math.round(Y);u(b.api.events.JWPLAYER_MEDIA_BUFFER,{bufferPercent:Math.round(Y)})}}}function Q(Y){if(!v){return}if(f.exists(Y)&&f.exists(Y.target)){if(z>0){if(!isNaN(Y.target.duration)&&(isNaN(l.duration)||l.duration<1)){if(Y.target.duration==Infinity){l.duration=0}else{l.duration=Math.round(Y.target.duration*10)/10}}}if(!F&&o.readyState>0){y(b.api.events.state.PLAYING)}if(h==b.api.events.state.PLAYING){if(o.readyState>0&&(P>-1||!F)){F=true;try{if(o.currentTime!=P&&P>-1){o.currentTime=P;P=-1}}catch(X){}o.volume=l.volume/100;o.muted=l.mute}l.position=l.duration>0?(Math.round(Y.target.currentTime*10)/10):0;u(b.api.events.JWPLAYER_MEDIA_TIME,{position:l.position,duration:l.duration});if(l.position>=l.duration&&(l.position>0||l.duration>0)){R();return}}}G(Y)}function j(X){}function r(X){if(!v){return}if(g&&e){o.style.width=g;o.style.height=e;g=_previousHieght=0}if(d[X.type]){if(X.type=="ended"){R()}else{y(d[X.type])}}}function w(Y){if(!v){return}var X=Math.round(o.duration*10)/10;var Z={height:o.videoHeight,width:o.videoWidth,duration:X};if(!z){if((l.duration<X||isNaN(l.duration))&&o.duration!=Infinity){l.duration=X}}u(b.api.events.JWPLAYER_MEDIA_META,{metadata:Z})}function q(Z){if(!v){return}if(h==b.api.events.state.IDLE){return}var Y="There was an error: ";if((Z.target.error&&Z.target.tagName.toLowerCase()=="video")||Z.target.parentNode.error&&Z.target.parentNode.tagName.toLowerCase()=="video"){var X=!f.exists(Z.target.error)?Z.target.parentNode.error:Z.target.error;switch(X.code){case X.MEDIA_ERR_ABORTED:f.log("User aborted the video playback.");return;case X.MEDIA_ERR_NETWORK:Y="A network error caused the video download to fail part-way: ";break;case X.MEDIA_ERR_DECODE:Y="The video playback was aborted due to a corruption problem or because the video used features your browser did not support: ";break;case X.MEDIA_ERR_SRC_NOT_SUPPORTED:Y="The video could not be loaded, either because the server or network failed or because the format is not supported: ";break;default:Y="An unknown error occurred: ";break}}else{if(Z.target.tagName.toLowerCase()=="source"){T--;if(T>0){return}if(f.userAgentMatch(/firefox/i)){f.log("The video could not be loaded, either because the server or network failed or because the format is not supported.");B(false);return}else{Y="The video could not be loaded, either because the server or network failed or because the format is not supported: "}}else{f.log("An unknown error occurred.  Continuing...");return}}B(false);Y+=V();_error=true;u(b.api.events.JWPLAYER_ERROR,{message:Y});return}function V(){var Z="";for(var Y in W.levels){var X=W.levels[Y];var aa=D.ownerDocument.createElement("source");Z+=b.utils.getAbsolutePath(X.file);if(Y<(W.levels.length-1)){Z+=", "}}return Z}function C(){if(!f.exists(H)){H=setInterval(function(){G()},100)}}function t(){clearInterval(H);H=null}function R(){if(h==b.api.events.state.PLAYING){B(false);u(b.api.events.JWPLAYER_MEDIA_BEFORECOMPLETE);u(b.api.events.JWPLAYER_MEDIA_COMPLETE)}}function m(X){if(f.exists(o.webkitDisplayingFullscreen)){if(l.fullscreen&&!o.webkitDisplayingFullscreen){u(b.api.events.JWPLAYER_FULLSCREEN,{fullscreen:false},true)}}}function s(Z){if(Z.length>0&&f.userAgentMatch(/Safari/i)&&!f.userAgentMatch(/Chrome/i)){var X=-1;for(var Y=0;Y<Z.length;Y++){switch(f.extension(Z[Y].file)){case"mp4":if(X<0){X=Y}break;case"webm":Z.splice(Y,1);break}}if(X>0){var aa=Z.splice(X,1)[0];Z.unshift(aa)}}}function S(){setTimeout(function(){o.setAttribute("controls","controls")},100)}function x(){setTimeout(function(){o.removeAttribute("controls")},250)}function u(X,Z,Y){if(v||Y){if(Z){N.sendEvent(X,Z)}else{N.sendEvent(X)}}}}})(jwplayer);(function(a){var c={ended:a.api.events.state.IDLE,playing:a.api.events.state.PLAYING,pause:a.api.events.state.PAUSED,buffering:a.api.events.state.BUFFERING};var b=a.utils.css;a.html5.mediayoutube=function(j,e){var f=new a.html5.eventdispatcher();a.utils.extend(this,f);var l=j;var h=document.getElementById(e.id);var g=a.api.events.state.IDLE;var n,m;function k(p){if(g!=p){var q=g;l.state=p;g=p;f.sendEvent(a.api.events.JWPLAYER_PLAYER_STATE,{oldstate:q,newstate:p})}}this.getDisplayElement=this.detachMedia=function(){return h};this.attachMedia=function(){};this.play=function(){if(g==a.api.events.state.IDLE){f.sendEvent(a.api.events.JWPLAYER_MEDIA_BUFFER,{bufferPercent:100});f.sendEvent(a.api.events.JWPLAYER_MEDIA_BUFFER_FULL);k(a.api.events.state.PLAYING)}else{if(g==a.api.events.state.PAUSED){k(a.api.events.state.PLAYING)}}};this.pause=function(){k(a.api.events.state.PAUSED)};this.seek=function(p){};this.stop=function(p){if(!_utils.exists(p)){p=true}l.position=0;k(a.api.events.state.IDLE);if(p){b(h,{display:"none"})}};this.volume=function(p){l.setVolume(p);f.sendEvent(a.api.events.JWPLAYER_MEDIA_VOLUME,{volume:Math.round(p)})};this.mute=function(p){h.muted=p;f.sendEvent(a.api.events.JWPLAYER_MEDIA_MUTE,{mute:p})};this.resize=function(q,p){if(q*p>0&&n){n.width=m.width=q;n.height=m.height=p}};this.fullscreen=function(p){if(p===true){this.resize("100%","100%")}else{this.resize(l.config.width,l.config.height)}};this.load=function(p){o(p);b(n,{display:"block"});k(a.api.events.state.BUFFERING);f.sendEvent(a.api.events.JWPLAYER_MEDIA_BUFFER,{bufferPercent:0});f.sendEvent(a.api.events.JWPLAYER_MEDIA_LOADED);this.play()};this.hasChrome=function(){return(g!=a.api.events.state.IDLE)};function o(v){var s=v.levels[0].file;s=["http://www.youtube.com/v/",d(s),"&amp;hl=en_US&amp;fs=1&autoplay=1"].join("");n=document.createElement("object");n.id=h.id;n.style.position="absolute";var u={movie:s,allowfullscreen:"true",allowscriptaccess:"always"};for(var p in u){var t=document.createElement("param");t.name=p;t.value=u[p];n.appendChild(t)}m=document.createElement("embed");n.appendChild(m);var q={src:s,type:"application/x-shockwave-flash",allowfullscreen:"true",allowscriptaccess:"always",width:n.width,height:n.height};for(var r in q){m.setAttribute(r,q[r])}n.appendChild(m);n.style.zIndex=2147483000;if(h!=n&&h.parentNode){h.parentNode.replaceChild(n,h)}h=n}function d(q){var p=q.split(/\?|\#\!/);var s="";for(var r=0;r<p.length;r++){if(p[r].substr(0,2)=="v="){s=p[r].substr(2)}}if(s==""){if(q.indexOf("/v/")>=0){s=q.substr(q.indexOf("/v/")+3)}else{if(q.indexOf("youtu.be")>=0){s=q.substr(q.indexOf("youtu.be/")+9)}else{s=q}}}if(s.indexOf("?")>-1){s=s.substr(0,s.indexOf("?"))}if(s.indexOf("&")>-1){s=s.substr(0,s.indexOf("&"))}return s}this.embed=m;return this}})(jwplayer);(function(jwplayer){var _configurableStateVariables=["width","height","start","duration","volume","mute","fullscreen","item","plugins","stretching"];var _utils=jwplayer.utils;jwplayer.html5.model=function(api,container,options){var _api=api;var _container=container;var _cookies=_utils.getCookies();var _model={id:_container.id,playlist:[],state:jwplayer.api.events.state.IDLE,position:0,buffer:0,container:_container,config:{width:480,height:320,item:-1,skin:undefined,file:undefined,image:undefined,start:0,duration:0,bufferlength:5,volume:_cookies.volume?_cookies.volume:90,mute:_cookies.mute&&_cookies.mute.toString().toLowerCase()=="true"?true:false,fullscreen:false,repeat:"",stretching:jwplayer.utils.stretching.UNIFORM,autostart:false,debug:undefined,screencolor:undefined}};var _media;var _eventDispatcher=new jwplayer.html5.eventdispatcher();var _components=["display","logo","controlbar","playlist","dock"];jwplayer.utils.extend(_model,_eventDispatcher);for(var option in options){if(typeof options[option]=="string"){var type=/color$/.test(option)?"color":null;options[option]=jwplayer.utils.typechecker(options[option],type)}var config=_model.config;var path=option.split(".");for(var edge in path){if(edge==path.length-1){config[path[edge]]=options[option]}else{if(!jwplayer.utils.exists(config[path[edge]])){config[path[edge]]={}}config=config[path[edge]]}}}for(var index in _configurableStateVariables){var configurableStateVariable=_configurableStateVariables[index];_model[configurableStateVariable]=_model.config[configurableStateVariable]}var pluginorder=_components.concat([]);if(jwplayer.utils.exists(_model.plugins)){if(typeof _model.plugins=="string"){var userplugins=_model.plugins.split(",");for(var userplugin in userplugins){if(typeof userplugins[userplugin]=="string"){pluginorder.push(userplugins[userplugin].replace(/^\s+|\s+$/g,""))}}}}if(jwplayer.utils.isMobile()){pluginorder=["display","logo","dock","playlist"];if(!jwplayer.utils.exists(_model.config.repeat)){_model.config.repeat="list"}}else{if(_model.config.chromeless){pluginorder=["logo","dock","playlist"];if(!jwplayer.utils.exists(_model.config.repeat)){_model.config.repeat="list"}}}_model.plugins={order:pluginorder,config:{},object:{}};if(typeof _model.config.components!="undefined"){for(var component in _model.config.components){_model.plugins.config[component]=_model.config.components[component]}}var playlistVisible=false;for(var pluginIndex in _model.plugins.order){var pluginName=_model.plugins.order[pluginIndex];var pluginConfig=!jwplayer.utils.exists(_model.plugins.config[pluginName])?{}:_model.plugins.config[pluginName];_model.plugins.config[pluginName]=!jwplayer.utils.exists(_model.plugins.config[pluginName])?pluginConfig:jwplayer.utils.extend(_model.plugins.config[pluginName],pluginConfig);if(!jwplayer.utils.exists(_model.plugins.config[pluginName].position)){if(pluginName=="playlist"){_model.plugins.config[pluginName].position=jwplayer.html5.view.positions.NONE}else{_model.plugins.config[pluginName].position=jwplayer.html5.view.positions.OVER}}else{if(pluginName=="playlist"){playlistVisible=true}_model.plugins.config[pluginName].position=_model.plugins.config[pluginName].position.toString().toUpperCase()}}if(_model.plugins.config.controlbar&&playlistVisible){_model.plugins.config.controlbar.hideplaylistcontrols=true}if(typeof _model.plugins.config.dock!="undefined"){if(typeof _model.plugins.config.dock!="object"){var position=_model.plugins.config.dock.toString().toUpperCase();_model.plugins.config.dock={position:position}}if(typeof _model.plugins.config.dock.position!="undefined"){_model.plugins.config.dock.align=_model.plugins.config.dock.position;_model.plugins.config.dock.position=jwplayer.html5.view.positions.OVER}if(typeof _model.plugins.config.dock.idlehide=="undefined"){try{_model.plugins.config.dock.idlehide=_model.plugins.config.controlbar.idlehide}catch(e){}}}function _loadExternal(playlistfile){var loader=new jwplayer.html5.playlistloader();loader.addEventListener(jwplayer.api.events.JWPLAYER_PLAYLIST_LOADED,function(evt){_model.playlist=new jwplayer.html5.playlist(evt);_loadComplete(true)});loader.addEventListener(jwplayer.api.events.JWPLAYER_ERROR,function(evt){_model.playlist=new jwplayer.html5.playlist({playlist:[]});_loadComplete(false)});loader.load(playlistfile)}function _loadComplete(){if(_model.config.shuffle){_model.item=_getShuffleItem()}else{if(_model.config.item>=_model.playlist.length){_model.config.item=_model.playlist.length-1}else{if(_model.config.item<0){_model.config.item=0}}_model.item=_model.config.item}_model.position=0;_model.duration=_model.playlist.length>0?_model.playlist[_model.item].duration:0;_eventDispatcher.sendEvent(jwplayer.api.events.JWPLAYER_PLAYLIST_LOADED,{playlist:_model.playlist});_eventDispatcher.sendEvent(jwplayer.api.events.JWPLAYER_PLAYLIST_ITEM,{index:_model.item})}_model.loadPlaylist=function(arg){var input;if(typeof arg=="string"){if(arg.indexOf("[")==0||arg.indexOf("{")=="0"){try{input=eval(arg)}catch(err){input=arg}}else{input=arg}}else{input=arg}var config;switch(jwplayer.utils.typeOf(input)){case"object":config=input;break;case"array":config={playlist:input};break;default:config={file:input};break}_model.playlist=new jwplayer.html5.playlist(config);_model.item=_model.config.item>=0?_model.config.item:0;if(!_model.playlist[0].provider&&_model.playlist[0].file){_loadExternal(_model.playlist[0].file)}else{_loadComplete()}};function _getShuffleItem(){var result=null;if(_model.playlist.length>1){while(!jwplayer.utils.exists(result)){result=Math.floor(Math.random()*_model.playlist.length);if(result==_model.item){result=null}}}else{result=0}return result}function forward(evt){switch(evt.type){case jwplayer.api.events.JWPLAYER_MEDIA_LOADED:_container=_media.getDisplayElement();break;case jwplayer.api.events.JWPLAYER_MEDIA_MUTE:this.mute=evt.mute;break;case jwplayer.api.events.JWPLAYER_MEDIA_VOLUME:this.volume=evt.volume;break}_eventDispatcher.sendEvent(evt.type,evt)}var _mediaProviders={};_model.setActiveMediaProvider=function(playlistItem){if(playlistItem.provider=="audio"){playlistItem.provider="sound"}var provider=playlistItem.provider;var current=_media?_media.getDisplayElement():null;if(provider=="sound"||provider=="http"||provider==""){provider="video"}if(!jwplayer.utils.exists(_mediaProviders[provider])){switch(provider){case"video":_media=new jwplayer.html5.mediavideo(_model,current?current:_container);break;case"youtube":_media=new jwplayer.html5.mediayoutube(_model,current?current:_container);break}if(!jwplayer.utils.exists(_media)){return false}_media.addGlobalListener(forward);_mediaProviders[provider]=_media}else{if(_media!=_mediaProviders[provider]){if(_media){_media.stop()}_media=_mediaProviders[provider]}}return true};_model.getMedia=function(){return _media};_model.seek=function(pos){_eventDispatcher.sendEvent(jwplayer.api.events.JWPLAYER_MEDIA_SEEK,{position:_model.position,offset:pos});return _media.seek(pos)};_model.setVolume=function(newVol){_utils.saveCookie("volume",newVol);_model.volume=newVol};_model.setMute=function(state){_utils.saveCookie("mute",state);_model.mute=state};_model.setupPlugins=function(){if(!jwplayer.utils.exists(_model.plugins)||!jwplayer.utils.exists(_model.plugins.order)||_model.plugins.order.length==0){jwplayer.utils.log("No plugins to set up");return _model}for(var i=0;i<_model.plugins.order.length;i++){try{var pluginName=_model.plugins.order[i];if(jwplayer.utils.exists(jwplayer.html5[pluginName])){if(pluginName=="playlist"){_model.plugins.object[pluginName]=new jwplayer.html5.playlistcomponent(_api,_model.plugins.config[pluginName])}else{_model.plugins.object[pluginName]=new jwplayer.html5[pluginName](_api,_model.plugins.config[pluginName])}}else{_model.plugins.order.splice(plugin,plugin+1)}if(typeof _model.plugins.object[pluginName].addGlobalListener=="function"){_model.plugins.object[pluginName].addGlobalListener(forward)}}catch(err){jwplayer.utils.log("Could not setup "+pluginName)}}};return _model}})(jwplayer);(function(a){a.html5.playlist=function(b){var d=[];if(b.playlist&&b.playlist instanceof Array&&b.playlist.length>0){for(var c in b.playlist){if(!isNaN(parseInt(c))){d.push(new a.html5.playlistitem(b.playlist[c]))}}}else{d.push(new a.html5.playlistitem(b))}return d}})(jwplayer);(function(a){var c={size:180,position:a.html5.view.positions.NONE,itemheight:60,thumbs:true,fontcolor:"#000000",overcolor:"",activecolor:"",backgroundcolor:"#f8f8f8",font:"_sans",fontsize:"",fontstyle:"",fontweight:""};var b={_sans:"Arial, Helvetica, sans-serif",_serif:"Times, Times New Roman, serif",_typewriter:"Courier New, Courier, monospace"};_utils=a.utils;_css=_utils.css;_hide=function(d){_css(d,{display:"none"})};_show=function(d){_css(d,{display:"block"})};a.html5.playlistcomponent=function(r,C){var x=r;var e=a.utils.extend({},c,x.skin.getComponentSettings("playlist"),C);if(e.position==a.html5.view.positions.NONE||typeof a.html5.view.positions[e.position]=="undefined"){return}var y;var l;var D;var d;var g;var f;var k=-1;var h={background:undefined,item:undefined,itemOver:undefined,itemImage:undefined,itemActive:undefined};this.getDisplayElement=function(){return y};this.resize=function(G,E){l=G;D=E;if(x.jwGetFullscreen()){_hide(y)}else{var F={display:"block",width:l,height:D};_css(y,F)}};this.show=function(){_show(y)};this.hide=function(){_hide(y)};function j(){y=document.createElement("div");y.id=x.id+"_jwplayer_playlistcomponent";y.style.overflow="hidden";switch(e.position){case a.html5.view.positions.RIGHT:case a.html5.view.positions.LEFT:y.style.width=e.size+"px";break;case a.html5.view.positions.TOP:case a.html5.view.positions.BOTTOM:y.style.height=e.size+"px";break}B();if(h.item){e.itemheight=h.item.height}y.style.backgroundColor="#C6C6C6";x.jwAddEventListener(a.api.events.JWPLAYER_PLAYLIST_LOADED,s);x.jwAddEventListener(a.api.events.JWPLAYER_PLAYLIST_ITEM,v);x.jwAddEventListener(a.api.events.JWPLAYER_PLAYER_STATE,m)}function p(){var E=document.createElement("ul");_css(E,{width:y.style.width,minWidth:y.style.width,height:y.style.height,backgroundColor:e.backgroundcolor,backgroundImage:h.background?"url("+h.background.src+")":"",color:e.fontcolor,listStyle:"none",margin:0,padding:0,fontFamily:b[e.font]?b[e.font]:b._sans,fontSize:(e.fontsize?e.fontsize:11)+"px",fontStyle:e.fontstyle,fontWeight:e.fontweight,overflowY:"auto"});return E}function z(E){return function(){var F=f.getElementsByClassName("item")[E];var G=e.fontcolor;var H=h.item?"url("+h.item.src+")":"";if(E==x.jwGetPlaylistIndex()){if(e.activecolor!==""){G=e.activecolor}if(h.itemActive){H="url("+h.itemActive.src+")"}}_css(F,{color:e.overcolor!==""?e.overcolor:G,backgroundImage:h.itemOver?"url("+h.itemOver.src+")":H})}}function o(E){return function(){var F=f.getElementsByClassName("item")[E];var G=e.fontcolor;var H=h.item?"url("+h.item.src+")":"";if(E==x.jwGetPlaylistIndex()){if(e.activecolor!==""){G=e.activecolor}if(h.itemActive){H="url("+h.itemActive.src+")"}}_css(F,{color:G,backgroundImage:H})}}function q(J){var Q=d[J];var P=document.createElement("li");P.className="item";_css(P,{height:e.itemheight,display:"block",cursor:"pointer",backgroundImage:h.item?"url("+h.item.src+")":"",backgroundSize:"100% "+e.itemheight+"px"});P.onmouseover=z(J);P.onmouseout=o(J);var K=document.createElement("div");var G=new Image();var L=0;var M=0;var N=0;if(w()&&(Q.image||Q["playlist.image"]||h.itemImage)){G.className="image";if(h.itemImage){L=(e.itemheight-h.itemImage.height)/2;M=h.itemImage.width;N=h.itemImage.height}else{M=e.itemheight*4/3;N=e.itemheight}_css(K,{height:N,width:M,"float":"left",styleFloat:"left",cssFloat:"left",margin:"0 5px 0 0",background:"black",overflow:"hidden",margin:L+"px",position:"relative"});_css(G,{position:"relative"});K.appendChild(G);G.onload=function(){a.utils.stretch(a.utils.stretching.FILL,G,M,N,this.naturalWidth,this.naturalHeight)};if(Q["playlist.image"]){G.src=Q["playlist.image"]}else{if(Q.image){G.src=Q.image}else{if(h.itemImage){G.src=h.itemImage.src}}}P.appendChild(K)}var F=l-M-L*2;if(D<e.itemheight*d.length){F-=15}var E=document.createElement("div");_css(E,{position:"relative",height:"100%",overflow:"hidden"});var H=document.createElement("span");if(Q.duration>0){H.className="duration";_css(H,{fontSize:(e.fontsize?e.fontsize:11)+"px",fontWeight:(e.fontweight?e.fontweight:"bold"),width:"40px",height:e.fontsize?e.fontsize+10:20,lineHeight:24,"float":"right",styleFloat:"right",cssFloat:"right"});H.innerHTML=_utils.timeFormat(Q.duration);E.appendChild(H)}var O=document.createElement("span");O.className="title";_css(O,{padding:"5px 5px 0 "+(L?0:"5px"),height:e.fontsize?e.fontsize+10:20,lineHeight:e.fontsize?e.fontsize+10:20,overflow:"hidden","float":"left",styleFloat:"left",cssFloat:"left",width:((Q.duration>0)?F-50:F)-10+"px",fontSize:(e.fontsize?e.fontsize:13)+"px",fontWeight:(e.fontweight?e.fontweight:"bold")});O.innerHTML=Q?Q.title:"";E.appendChild(O);if(Q.description){var I=document.createElement("span");I.className="description";_css(I,{display:"block","float":"left",styleFloat:"left",cssFloat:"left",margin:0,paddingLeft:O.style.paddingLeft,paddingRight:O.style.paddingRight,lineHeight:(e.fontsize?e.fontsize+4:16)+"px",overflow:"hidden",position:"relative"});I.innerHTML=Q.description;E.appendChild(I)}P.appendChild(E);return P}function s(F){y.innerHTML="";d=t();if(!d){return}items=[];f=p();for(var G=0;G<d.length;G++){var E=q(G);E.onclick=A(G);f.appendChild(E);items.push(E)}k=x.jwGetPlaylistIndex();o(k)();y.appendChild(f);if(_utils.isIOS()&&window.iScroll){f.style.height=e.itemheight*d.length+"px";var H=new iScroll(y.id)}}function t(){var F=x.jwGetPlaylist();var G=[];for(var E=0;E<F.length;E++){if(!F[E]["ova.hidden"]){G.push(F[E])}}return G}function A(E){return function(){x.jwPlaylistItem(E);x.jwPlay(true)}}function n(){f.scrollTop=x.jwGetPlaylistIndex()*e.itemheight}function w(){return e.thumbs.toString().toLowerCase()=="true"}function v(E){if(k>=0){o(k)();k=E.index}o(E.index)();n()}function m(){if(e.position==a.html5.view.positions.OVER){switch(x.jwGetState()){case a.api.events.state.IDLE:_show(y);break;default:_hide(y);break}}}function B(){for(var E in h){h[E]=u(E)}}function u(E){return x.skin.getSkinElement("playlist",E)}j();return this}})(jwplayer);(function(b){b.html5.playlistitem=function(d){var e={author:"",date:"",description:"",image:"",link:"",mediaid:"",tags:"",title:"",provider:"",file:"",streamer:"",duration:-1,start:0,currentLevel:-1,levels:[]};var c=b.utils.extend({},e,d);if(c.type){c.provider=c.type;delete c.type}if(c.levels.length===0){c.levels[0]=new b.html5.playlistitemlevel(c)}if(!c.provider){c.provider=a(c.levels[0])}else{c.provider=c.provider.toLowerCase()}return c};function a(e){if(b.utils.isYouTube(e.file)){return"youtube"}else{var f=b.utils.extension(e.file);var c;if(f&&b.utils.extensionmap[f]){if(f=="m3u8"){return"video"}c=b.utils.extensionmap[f].html5}else{if(e.type){c=e.type}}if(c){var d=c.split("/")[0];if(d=="audio"){return"sound"}else{if(d=="video"){return d}}}}return""}})(jwplayer);(function(a){a.html5.playlistitemlevel=function(b){var d={file:"",streamer:"",bitrate:0,width:0};for(var c in d){if(a.utils.exists(b[c])){d[c]=b[c]}}return d}})(jwplayer);(function(a){a.html5.playlistloader=function(){var c=new a.html5.eventdispatcher();a.utils.extend(this,c);this.load=function(e){a.utils.ajax(e,d,b)};function d(g){var f=[];try{var f=a.utils.parsers.rssparser.parse(g.responseXML.firstChild);c.sendEvent(a.api.events.JWPLAYER_PLAYLIST_LOADED,{playlist:new a.html5.playlist({playlist:f})})}catch(h){b("Could not parse the playlist")}}function b(e){c.sendEvent(a.api.events.JWPLAYER_ERROR,{message:e?e:"Could not load playlist an unknown reason."})}}})(jwplayer);(function(a){a.html5.skin=function(){var b={};var c=false;this.load=function(d,e){new a.html5.skinloader(d,function(f){c=true;b=f;e()},function(){new a.html5.skinloader("",function(f){c=true;b=f;e()})})};this.getSkinElement=function(d,e){if(c){try{return b[d].elements[e]}catch(f){a.utils.log("No such skin component / element: ",[d,e])}}return null};this.getComponentSettings=function(d){if(c&&b&&b[d]){return b[d].settings}return null};this.getComponentLayout=function(d){if(c){return b[d].layout}return null}}})(jwplayer);(function(a){a.html5.skinloader=function(f,p,k){var o={};var c=p;var l=k;var e=true;var j;var n=f;var s=false;function m(){if(typeof n!="string"||n===""){d(a.html5.defaultSkin().xml)}else{a.utils.ajax(a.utils.getAbsolutePath(n),function(t){try{if(a.utils.exists(t.responseXML)){d(t.responseXML);return}}catch(u){h()}d(a.html5.defaultSkin().xml)},function(t){d(a.html5.defaultSkin().xml)})}}function d(y){var E=y.getElementsByTagName("component");if(E.length===0){return}for(var H=0;H<E.length;H++){var C=E[H].getAttribute("name");var B={settings:{},elements:{},layout:{}};o[C]=B;var G=E[H].getElementsByTagName("elements")[0].getElementsByTagName("element");for(var F=0;F<G.length;F++){b(G[F],C)}var z=E[H].getElementsByTagName("settings")[0];if(z&&z.childNodes.length>0){var K=z.getElementsByTagName("setting");for(var P=0;P<K.length;P++){var Q=K[P].getAttribute("name");var I=K[P].getAttribute("value");var x=/color$/.test(Q)?"color":null;o[C].settings[Q]=a.utils.typechecker(I,x)}}var L=E[H].getElementsByTagName("layout")[0];if(L&&L.childNodes.length>0){var M=L.getElementsByTagName("group");for(var w=0;w<M.length;w++){var A=M[w];o[C].layout[A.getAttribute("position")]={elements:[]};for(var O=0;O<A.attributes.length;O++){var D=A.attributes[O];o[C].layout[A.getAttribute("position")][D.name]=D.value}var N=A.getElementsByTagName("*");for(var v=0;v<N.length;v++){var t=N[v];o[C].layout[A.getAttribute("position")].elements.push({type:t.tagName});for(var u=0;u<t.attributes.length;u++){var J=t.attributes[u];o[C].layout[A.getAttribute("position")].elements[v][J.name]=J.value}if(!a.utils.exists(o[C].layout[A.getAttribute("position")].elements[v].name)){o[C].layout[A.getAttribute("position")].elements[v].name=t.tagName}}}}e=false;r()}}function r(){clearInterval(j);if(!s){j=setInterval(function(){q()},100)}}function b(y,x){var w=new Image();var t=y.getAttribute("name");var v=y.getAttribute("src");var A;if(v.indexOf("data:image/png;base64,")===0){A=v}else{var u=a.utils.getAbsolutePath(n);var z=u.substr(0,u.lastIndexOf("/"));A=[z,x,v].join("/")}o[x].elements[t]={height:0,width:0,src:"",ready:false,image:w};w.onload=function(B){g(w,t,x)};w.onerror=function(B){s=true;r();l()};w.src=A}function h(){for(var u in o){var w=o[u];for(var t in w.elements){var x=w.elements[t];var v=x.image;v.onload=null;v.onerror=null;delete x.image;delete w.elements[t]}delete o[u]}}function q(){for(var t in o){if(t!="properties"){for(var u in o[t].elements){if(!o[t].elements[u].ready){return}}}}if(e===false){clearInterval(j);c(o)}}function g(t,v,u){if(o[u]&&o[u].elements[v]){o[u].elements[v].height=t.height;o[u].elements[v].width=t.width;o[u].elements[v].src=t.src;o[u].elements[v].ready=true;r()}else{a.utils.log("Loaded an image for a missing element: "+u+"."+v)}}m()}})(jwplayer);(function(a){a.html5.api=function(c,p){var n={};var g=document.createElement("div");c.parentNode.replaceChild(g,c);g.id=c.id;n.version=a.version;n.id=g.id;var m=new a.html5.model(n,g,p);var k=new a.html5.view(n,g,m);var l=new a.html5.controller(n,g,m,k);n.skin=new a.html5.skin();n.jwPlay=function(q){if(typeof q=="undefined"){f()}else{if(q.toString().toLowerCase()=="true"){l.play()}else{l.pause()}}};n.jwPause=function(q){if(typeof q=="undefined"){f()}else{if(q.toString().toLowerCase()=="true"){l.pause()}else{l.play()}}};function f(){if(m.state==a.api.events.state.PLAYING||m.state==a.api.events.state.BUFFERING){l.pause()}else{l.play()}}n.jwStop=l.stop;n.jwSeek=l.seek;n.jwPlaylistItem=function(q){if(d){if(d.playlistClickable()){d.jwInstreamDestroy();return l.item(q)}}else{return l.item(q)}};n.jwPlaylistNext=l.next;n.jwPlaylistPrev=l.prev;n.jwResize=l.resize;n.jwLoad=l.load;n.jwDetachMedia=l.detachMedia;n.jwAttachMedia=l.attachMedia;function j(q){return function(){return m[q]}}function e(q,s,r){return function(){var t=m.plugins.object[q];if(t&&t[s]&&typeof t[s]=="function"){t[s].apply(t,r)}}}n.jwGetPlaylistIndex=j("item");n.jwGetPosition=j("position");n.jwGetDuration=j("duration");n.jwGetBuffer=j("buffer");n.jwGetWidth=j("width");n.jwGetHeight=j("height");n.jwGetFullscreen=j("fullscreen");n.jwSetFullscreen=l.setFullscreen;n.jwGetVolume=j("volume");n.jwSetVolume=l.setVolume;n.jwGetMute=j("mute");n.jwSetMute=l.setMute;n.jwGetStretching=function(){return m.stretching.toUpperCase()};n.jwGetState=j("state");n.jwGetVersion=function(){return n.version};n.jwGetPlaylist=function(){return m.playlist};n.jwAddEventListener=l.addEventListener;n.jwRemoveEventListener=l.removeEventListener;n.jwSendEvent=l.sendEvent;n.jwDockSetButton=function(t,q,r,s){if(m.plugins.object.dock&&m.plugins.object.dock.setButton){m.plugins.object.dock.setButton(t,q,r,s)}};n.jwControlbarShow=e("controlbar","show");n.jwControlbarHide=e("controlbar","hide");n.jwDockShow=e("dock","show");n.jwDockHide=e("dock","hide");n.jwDisplayShow=e("display","show");n.jwDisplayHide=e("display","hide");var d;n.jwLoadInstream=function(r,q){if(!d){d=new a.html5.instream(n,m,k,l)}setTimeout(function(){d.load(r,q)},10)};n.jwInstreamDestroy=function(){if(d){d.jwInstreamDestroy()}};n.jwInstreamAddEventListener=o("jwInstreamAddEventListener");n.jwInstreamRemoveEventListener=o("jwInstreamRemoveEventListener");n.jwInstreamGetState=o("jwInstreamGetState");n.jwInstreamGetDuration=o("jwInstreamGetDuration");n.jwInstreamGetPosition=o("jwInstreamGetPosition");n.jwInstreamPlay=o("jwInstreamPlay");n.jwInstreamPause=o("jwInstreamPause");n.jwInstreamSeek=o("jwInstreamSeek");function o(q){return function(){if(d&&typeof d[q]=="function"){return d[q].apply(this,arguments)}else{_utils.log("Could not call instream method - instream API not initialized")}}}n.jwDestroy=function(){l.destroy()};n.jwGetLevel=function(){};n.jwGetBandwidth=function(){};n.jwGetLockState=function(){};n.jwLock=function(){};n.jwUnlock=function(){};function b(){if(m.config.playlistfile){m.addEventListener(a.api.events.JWPLAYER_PLAYLIST_LOADED,h);m.loadPlaylist(m.config.playlistfile)}else{if(typeof m.config.playlist=="string"){m.addEventListener(a.api.events.JWPLAYER_PLAYLIST_LOADED,h);m.loadPlaylist(m.config.playlist)}else{m.loadPlaylist(m.config);setTimeout(h,25)}}}function h(q){m.removeEventListener(a.api.events.JWPLAYER_PLAYLIST_LOADED,h);m.setupPlugins();k.setup();var q={id:n.id,version:n.version};l.playerReady(q)}if(m.config.chromeless&&!a.utils.isIOS()){b()}else{n.skin.load(m.config.skin,b)}return n}})(jwplayer)};/*!
 * jQuery hashchange event - v1.3 - 7/21/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.3, Last updated: 7/21/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and
// robust, there are a few unfortunate browser bugs surrounding expected
// hashchange event-based behaviors, independent of any JavaScript
// window.onhashchange abstraction. See the following examples for more
// information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// Also note that should a browser natively support the window.onhashchange 
// event, but not report that it does, the fallback polling loop will be used.
// 
// About: Release History
// 
// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more
//         "removable" for mobile-only development. Added IE6/7 document.title
//         support. Attempted to make Iframe as hidden as possible by using
//         techniques from http://www.paciellogroup.com/blog/?p=604. Added 
//         support for the "shortcut" format $(window).hashchange( fn ) and
//         $(window).hashchange() like jQuery provides for built-in events.
//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and
//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>
//         and <jQuery.fn.hashchange.src> properties plus document-domain.html
//         file to address access denied issues when setting document.domain in
//         IE6/7.
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Reused string.
  var str_hashchange = 'hashchange',
    
    // Method / object references.
    doc = document,
    fake_onhashchange,
    special = $.event.special,
    
    // Does the browser support window.onhashchange? Note that IE8 running in
    // IE7 compatibility mode reports true for 'onhashchange' in window, even
    // though the event isn't supported, so also test document.documentMode.
    doc_mode = doc.documentMode,
    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || location.href;
    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Method: jQuery.fn.hashchange
  // 
  // Bind a handler to the window.onhashchange event or trigger all bound
  // window.onhashchange event handlers. This behavior is consistent with
  // jQuery's built-in event handlers.
  // 
  // Usage:
  // 
  // > jQuery(window).hashchange( [ handler ] );
  // 
  // Arguments:
  // 
  //  handler - (Function) Optional handler to be bound to the hashchange
  //    event. This is a "shortcut" for the more verbose form:
  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,
  //    all bound window.onhashchange event handlers will be triggered. This
  //    is a shortcut for the more verbose
  //    jQuery(window).trigger( 'hashchange' ). These forms are described in
  //    the <hashchange event> section.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements.
  
  // Allow the "shortcut" format $(elem).hashchange( fn ) for binding and
  // $(elem).hashchange() for triggering, like jQuery does for built-in events.
  $.fn[ str_hashchange ] = function( fn ) {
    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );
  };
  
  // Property: jQuery.fn.hashchange.delay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 50.
  
  // Property: jQuery.fn.hashchange.domain
  // 
  // If you're setting document.domain in your JavaScript, and you want hash
  // history to work in IE6/7, not only must this property be set, but you must
  // also set document.domain BEFORE jQuery is loaded into the page. This
  // property is only applicable if you are supporting IE6/7 (or IE8 operating
  // in "IE7 compatibility" mode).
  // 
  // In addition, the <jQuery.fn.hashchange.src> property must be set to the
  // path of the included "document-domain.html" file, which can be renamed or
  // modified if necessary (note that the document.domain specified must be the
  // same in both your main JavaScript as well as in this file).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.domain = document.domain;
  
  // Property: jQuery.fn.hashchange.src
  // 
  // If, for some reason, you need to specify an Iframe src file (for example,
  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can
  // do so using this property. Note that when using this property, history
  // won't be recorded in IE6/7 until the Iframe src file loads. This property
  // is only applicable if you are supporting IE6/7 (or IE8 operating in "IE7
  // compatibility" mode).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.src = 'path/to/file.html';
  
  $.fn[ str_hashchange ].delay = 50;
  /*
  $.fn[ str_hashchange ].domain = null;
  $.fn[ str_hashchange ].src = null;
  */
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // HTML5 window.onhashchange event is used, otherwise a polling loop is
  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to
  // see if the hash has changed. In IE6/7 (and IE8 operating in "IE7
  // compatibility" mode), a hidden Iframe is created to allow the back button
  // and hash-based history to work.
  // 
  // Usage as described in <jQuery.fn.hashchange>:
  // 
  // > // Bind an event handler.
  // > jQuery(window).hashchange( function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).hashchange();
  // 
  // A more verbose usage that allows for event namespacing:
  // 
  // > // Bind an event handler.
  // > jQuery(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).trigger( 'hashchange' );
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one handler
  //   is actually bound to the 'hashchange' event.
  // * If you need the bound handler(s) to execute immediately, in cases where
  //   a location.hash exists on page load, via bookmark or page refresh for
  //   example, use jQuery(window).hashchange() or the more verbose 
  //   jQuery(window).trigger( 'hashchange' ).
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a DOM ready handler.
  
  // Override existing $.event.special.hashchange methods (allowing this plugin
  // to be defined after jQuery BBQ in BBQ's source code).
  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      
      // Remember the initial hash so it doesn't get triggered immediately.
      last_hash = get_fragment(),
      
      fn_retval = function(val){ return val; },
      history_set = fn_retval,
      history_get = fn_retval;
    
    // Start the polling loop.
    self.start = function() {
      timeout_id || poll();
    };
    
    // Stop the polling loop.
    self.stop = function() {
      timeout_id && clearTimeout( timeout_id );
      timeout_id = undefined;
    };
    
    // This polling loop checks every $.fn.hashchange.delay milliseconds to see
    // if location.hash has changed, and triggers the 'hashchange' event on
    // window when necessary.
    function poll() {
      var hash = get_fragment(),
        history_hash = history_get( last_hash );
      
      if ( hash !== last_hash ) {
        history_set( last_hash = hash, history_hash );
        
        $(window).trigger( str_hashchange );
        
      } else if ( history_hash !== last_hash ) {
        location.href = location.href.replace( /#.*/, '' ) + history_hash;
      }
      
      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );
    };
    
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    $.browser.msie && !supports_onhashchange && (function(){
      // Not only do IE6/7 need the "magical" Iframe treatment, but so does IE8
      // when running in "IE7 compatibility" mode.
      
      var iframe,
        iframe_src;
      
      // When the event is bound and polling starts in IE 6/7, create a hidden
      // Iframe for history handling.
      self.start = function(){
        if ( !iframe ) {
          iframe_src = $.fn[ str_hashchange ].src;
          iframe_src = iframe_src && iframe_src + get_fragment();
          
          // Create hidden Iframe. Attempt to make Iframe as hidden as possible
          // by using techniques from http://www.paciellogroup.com/blog/?p=604.
          iframe = $('<iframe tabindex="-1" title="empty"/>').hide()
            
            // When Iframe has completely loaded, initialize the history and
            // start polling.
            .one( 'load', function(){
              iframe_src || history_set( get_fragment() );
              poll();
            })
            
            // Load Iframe src if specified, otherwise nothing.
            .attr( 'src', iframe_src || 'javascript:0' )
            
            // Append Iframe after the end of the body to prevent unnecessary
            // initial page scrolling (yes, this works).
            .insertAfter( 'body' )[0].contentWindow;
          
          // Whenever `document.title` changes, update the Iframe's title to
          // prettify the back/next history menu entries. Since IE sometimes
          // errors with "Unspecified error" the very first time this is set
          // (yes, very useful) wrap this with a try/catch block.
          doc.onpropertychange = function(){
            try {
              if ( event.propertyName === 'title' ) {
                iframe.document.title = doc.title;
              }
            } catch(e) {}
          };
          
        }
      };
      
      // Override the "stop" method since an IE6/7 Iframe was created. Even
      // if there are no longer any bound event handlers, the polling loop
      // is still necessary for back/next to work at all!
      self.stop = fn_retval;
      
      // Get history by looking at the hidden Iframe's location.hash.
      history_get = function() {
        return get_fragment( iframe.location.href );
      };
      
      // Set a new history item by opening and then closing the Iframe
      // document, *then* setting its location.hash. If document.domain has
      // been set, update that as well.
      history_set = function( hash, history_hash ) {
        var iframe_doc = iframe.document,
          domain = $.fn[ str_hashchange ].domain;
        
        if ( hash !== history_hash ) {
          // Update Iframe with any initial `document.title` that might be set.
          iframe_doc.title = doc.title;
          
          // Opening the Iframe's document after it has been closed is what
          // actually adds a history entry.
          iframe_doc.open();
          
          // Set document.domain for the Iframe document as well, if necessary.
          domain && iframe_doc.write( '<script>document.domain="' + domain + '"</script>' );
          
          iframe_doc.close();
          
          // Update the Iframe's hash, for great justice.
          iframe.location.hash = hash;
        }
      };
      
    })();
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    return self;
  })();
  
})(mrm.$,this);
/*!
 * jQuery outside events - v1.1 - 3/16/2010
 * http://benalman.com/projects/jquery-outside-events-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery outside events
//
// *Version: 1.1, Last updated: 3/16/2010*
// 
// Project Home - http://benalman.com/projects/jquery-outside-events-plugin/
// GitHub       - http://github.com/cowboy/jquery-outside-events/
// Source       - http://github.com/cowboy/jquery-outside-events/raw/master/jquery.ba-outside-events.js
// (Minified)   - http://github.com/cowboy/jquery-outside-events/raw/master/jquery.ba-outside-events.min.js (0.9kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// clickoutside - http://benalman.com/code/projects/jquery-outside-events/examples/clickoutside/
// dblclickoutside - http://benalman.com/code/projects/jquery-outside-events/examples/dblclickoutside/
// mouseoveroutside - http://benalman.com/code/projects/jquery-outside-events/examples/mouseoveroutside/
// focusoutside - http://benalman.com/code/projects/jquery-outside-events/examples/focusoutside/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-outside-events/unit/
// 
// About: Release History
// 
// 1.1 - (3/16/2010) Made "clickoutside" plugin more general, resulting in a
//       whole new plugin with more than a dozen default "outside" events and
//       a method that can be used to add new ones.
// 1.0 - (2/27/2010) Initial release
//
// Topic: Default "outside" events
// 
// Note that each "outside" event is powered by an "originating" event. Only
// when the originating event is triggered on an element outside the element
// to which that outside event is bound will the bound event be triggered.
// 
// Because each outside event is powered by a separate originating event,
// stopping propagation of that originating event will prevent its related
// outside event from triggering.
// 
//  OUTSIDE EVENT     - ORIGINATING EVENT
//  clickoutside      - click
//  dblclickoutside   - dblclick
//  focusoutside      - focusin
//  bluroutside       - focusout
//  mousemoveoutside  - mousemove
//  mousedownoutside  - mousedown
//  mouseupoutside    - mouseup
//  mouseoveroutside  - mouseover
//  mouseoutoutside   - mouseout
//  keydownoutside    - keydown
//  keypressoutside   - keypress
//  keyupoutside      - keyup
//  changeoutside     - change
//  selectoutside     - select
//  submitoutside     - submit

(function($,doc,outside){
  '$:nomunge'; // Used by YUI compressor.
  
  $.map(
    // All these events will get an "outside" event counterpart by default.
    'click dblclick mousemove mousedown mouseup mouseover mouseout change select submit keydown keypress keyup touchend'.split(' '),
    function( event_name ) { jq_addOutsideEvent( event_name ); }
  );
  
  // The focus and blur events are really focusin and focusout when it comes
  // to delegation, so they are a special case.
  jq_addOutsideEvent( 'focusin',  'focus' + outside );
  jq_addOutsideEvent( 'focusout', 'blur' + outside );
  
  // Method: jQuery.addOutsideEvent
  // 
  // Register a new "outside" event to be with this method. Adding an outside
  // event that already exists will probably blow things up, so check the
  // <Default "outside" events> list before trying to add a new one.
  // 
  // Usage:
  // 
  // > jQuery.addOutsideEvent( event_name [, outside_event_name ] );
  // 
  // Arguments:
  // 
  //  event_name - (String) The name of the originating event that the new
  //    "outside" event will be powered by. This event can be a native or
  //    custom event, as long as it bubbles up the DOM tree.
  //  outside_event_name - (String) An optional name for the new "outside"
  //    event. If omitted, the outside event will be named whatever the
  //    value of `event_name` is plus the "outside" suffix.
  // 
  // Returns:
  // 
  //  Nothing.
  
  $.addOutsideEvent = jq_addOutsideEvent;
  
  function jq_addOutsideEvent( event_name, outside_event_name ) {
    
    // The "outside" event name.
    outside_event_name = outside_event_name || event_name + outside;
    
    // A jQuery object containing all elements to which the "outside" event is
    // bound.
    var elems = $(),
      
      // The "originating" event, namespaced for easy unbinding.
      event_namespaced = event_name + '.' + outside_event_name + '-special-event';
    
    // Event: outside events
    // 
    // An "outside" event is triggered on an element when its corresponding
    // "originating" event is triggered on an element outside the element in
    // question. See the <Default "outside" events> list for more information.
    // 
    // Usage:
    // 
    // > jQuery('selector').bind( 'clickoutside', function(event) {
    // >   var clicked_elem = $(event.target);
    // >   ...
    // > });
    // 
    // > jQuery('selector').bind( 'dblclickoutside', function(event) {
    // >   var double_clicked_elem = $(event.target);
    // >   ...
    // > });
    // 
    // > jQuery('selector').bind( 'mouseoveroutside', function(event) {
    // >   var moused_over_elem = $(event.target);
    // >   ...
    // > });
    // 
    // > jQuery('selector').bind( 'focusoutside', function(event) {
    // >   var focused_elem = $(event.target);
    // >   ...
    // > });
    // 
    // You get the idea, right?
    
    $.event.special[ outside_event_name ] = {
      
      // Called only when the first "outside" event callback is bound per
      // element.
      setup: function(){
        
        // Add this element to the list of elements to which this "outside"
        // event is bound.
        elems = elems.add( this );
        
        // If this is the first element getting the event bound, bind a handler
        // to document to catch all corresponding "originating" events.
        if ( elems.length === 1 ) {
          $(doc).bind( event_namespaced, handle_event );
        }
      },
      
      // Called only when the last "outside" event callback is unbound per
      // element.
      teardown: function(){
        
        // Remove this element from the list of elements to which this
        // "outside" event is bound.
        elems = elems.not( this );
        
        // If this is the last element removed, remove the "originating" event
        // handler on document that powers this "outside" event.
        if ( elems.length === 0 ) {
          $(doc).unbind( event_namespaced );
        }
      },
      
      // Called every time a "outside" event callback is bound to an element.
      add: function( handleObj ) {
        var old_handler = handleObj.handler;
        
        // This function is executed every time the event is triggered. This is
        // used to override the default event.target reference with one that is
        // more useful.
        handleObj.handler = function( event, elem ) {
          
          // Set the event object's .target property to the element that the
          // user interacted with, not the element that the "outside" event was
          // was triggered on.
          event.target = elem;
          
          // Execute the actual bound handler.
          old_handler.apply( this, arguments );
        };
      }
    };
    
    // When the "originating" event is triggered..
    function handle_event( event ) {
      
      // Iterate over all elements to which this "outside" event is bound.
      $(elems).each(function(){
        var elem = $(this);
        
        // If this element isn't the element on which the event was triggered,
        // and this element doesn't contain said element, then said element is
        // considered to be outside, and the "outside" event will be triggered!
        if ( this !== event.target && !elem.has(event.target).length ) {
          
          // Use triggerHandler instead of trigger so that the "outside" event
          // doesn't bubble. Pass in the "originating" event's .target so that
          // the "outside" event.target can be overridden with something more
          // meaningful.
          elem.triggerHandler( outside_event_name, [ event.target ] );
        }
      });
    };
    
  };
  
})(jQuery,document,"outside");
/* Copyright (c) 2006 Brandon Aaron (http://brandonaaron.net)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) 
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * $LastChangedDate: 2007-07-21 18:45:56 -0500 (Sat, 21 Jul 2007) $
 * $Rev: 2447 $
 *
 * Version 2.1.1
 */
(function($){$.fn.bgIframe=$.fn.bgiframe=function(s){if($.browser.msie&&/msie 6\.0/i.test(navigator.userAgent)){s=$.extend({top:'auto',left:'auto',width:'auto',height:'auto',opacity:true,src:'javascript:false;'},s||{});var prop=function(n){return n&&n.constructor==Number?n+'px':n;},html='<iframe class="bgiframe"frameborder="0"tabindex="-1"src="'+s.src+'"'+'style="display:block;position:absolute;z-index:-1;'+(s.opacity!==false?'filter:Alpha(Opacity=\'0\');':'')+'top:'+(s.top=='auto'?'expression(((parseInt(this.parentNode.currentStyle.borderTopWidth)||0)*-1)+\'px\')':prop(s.top))+';'+'left:'+(s.left=='auto'?'expression(((parseInt(this.parentNode.currentStyle.borderLeftWidth)||0)*-1)+\'px\')':prop(s.left))+';'+'width:'+(s.width=='auto'?'expression(this.parentNode.offsetWidth+\'px\')':prop(s.width))+';'+'height:'+(s.height=='auto'?'expression(this.parentNode.offsetHeight+\'px\')':prop(s.height))+';'+'"/>';return this.each(function(){if($('> iframe.bgiframe',this).length==0)this.insertBefore(document.createElement(html),this.firstChild);});}return this;};})(mrm.$);/*

jQuery Browser Plugin
	* Version 2.4
	* Branch Revision 0.1
	* 2010-08-13 15:02:11
	* 2010-02-03
	* URL: http://jquery.thewikies.com/browser
	* Branch URL: http://bitbucket.org/digitaljhelms/jquery-browser-plugin/
	* additional hacks by http://pastebin.com/ZNr2sNL7
	* Description: jQuery Browser Plugin extends browser detection capabilities and can assign browser selectors to CSS classes.
	* Author: Nate Cavanaugh, Minhchau Dang, Jonathan Neal & Gregory Waxman
	* Branch Author: Jeremy Helms
	* Copyright: Copyright (c) 2008 Jonathan Neal under dual MIT/GPL license.
	* JSLint: This javascript file passes JSLint verification.
*/
/*jslint
		bitwise: true,
		browser: true,
		eqeqeq: true,
		forin: true,
		nomen: true,
		plusplus: true,
		undef: true,
		white: true
*/
/*global
		jQuery
*/

(function ($) {
	$.browserTest = function (a, z) {
		var u = 'unknown', x = 'X', m = function (r, h) {
			for (var i = 0; i < h.length; i = i + 1) {
				r = r.replace(h[i][0], h[i][1]);
			}

			return r;
		}, c = function (i, a, b, c) {
			var r = {
				name: m((a.exec(i) || [u, u])[1], b)
			};

			r[r.name] = true;

			if (!r.opera) {
				r.version = (c.exec(i) || [x, x, x, x])[3];
			}
			else {
				r.version = window.opera.version();
			}
			
			if (/safari/.test(r.name) && r.version > 400) {
				r.version = '2.0';
			}
			else if (r.name === 'presto') {
				r.version = ($.browser.version > 9.27) ? 'futhark' : 'linear_b';
			}
			
			r.versionNumber = parseFloat(r.version, 10) || 0;
			var minorStart = 1;
			if (r.versionNumber < 100 && r.versionNumber > 9) {
				minorStart = 2;
			}
			r.versionX = (r.version !== x) ? r.version.substr(0, minorStart) : x;
			r.className = r.name + r.versionX;

			return r;
		};

		a = (/Opera|Navigator|Minefield|KHTML|Chrome/.test(a) ? m(a, [
			[/(Firefox|MSIE|KHTML,\slike\sGecko|Konqueror)/, ''],
			['Chrome Safari', 'Chrome'],
			['KHTML', 'Konqueror'],
			['Minefield', 'Firefox'],
			['Navigator', 'Netscape']
		]) : a).toLowerCase();

		$.browser = $.extend((!z) ? $.browser : {}, c(a, /(camino|chrome|firefox|netscape|konqueror|lynx|msie|opera|safari)/, [], /(camino|chrome|firefox|netscape|netscape6|opera|version|konqueror|lynx|msie|safari)(\/|\s)([a-z0-9\.\+]*?)(\;|dev|rel|\s|$)/));

		$.layout = c(a, /(gecko|konqueror|msie|opera|webkit)/, [
			['konqueror', 'khtml'],
			['msie', 'trident'],
			['opera', 'presto']
		], /(applewebkit|rv|konqueror|msie)(\:|\/|\s)([a-z0-9\.]*?)(\;|\)|\s)/);

		$.os = {
			name: (/(win|mac|linux|sunos|solaris|iphone|ipad)/.exec(navigator.platform.toLowerCase()) || [u])[0].replace('sunos', 'solaris'),
			android: (/android/.test(a))
		};

		if (!z) {
			$('html').addClass([$.os.name, $.browser.name, $.browser.className, $.layout.name, $.layout.className].join(' '));
		}
	};

	$.browserTest(navigator.userAgent);
})(mrm.$);/*	
 *	jQuery carouFredSel 5.6.2
 *	Demo's and documentation:
 *	caroufredsel.frebsite.nl
 *	
 *	Copyright (c) 2012 Fred Heusschen
 *	www.frebsite.nl
 *
 *	Dual licensed under the MIT and GPL licenses.
 *	http://en.wikipedia.org/wiki/MIT_License
 *	http://en.wikipedia.org/wiki/GNU_General_Public_License
 */


(function($) {



	//	LOCAL

	if ($.fn.carouFredSel) return;

	$.fn.carouFredSel = function(options, configs) {
		if (this.length == 0) {
			debug(true, 'No element found for "'+this.selector+'".');
			return this;
		}
		if (this.length > 1) {
			return this.each(function() {
				$(this).carouFredSel(options, configs);
			});
		}

		var $cfs = this,
			$tt0 = this[0];

		if ($cfs.data('cfs_isCarousel')) {
			var starting_position = $cfs.triggerHandler('_cfs_triggerEvent', 'currentPosition');
			$cfs.trigger('_cfs_triggerEvent', ['destroy', [true]]);
		} else {
			var starting_position = false;
		}

		$cfs._cfs_init = function(o, setOrig, start) {
			o = go_getObject($tt0, o);

			var obs = ['items', 'scroll', 'auto', 'prev', 'next', 'pagination'];
			for (var a = 0, l = obs.length; a < l; a++) {
				o[obs[a]] = go_getObject($tt0, o[obs[a]]);
			}

			if (typeof o.scroll == 'number') {
				if (o.scroll <= 50)					o.scroll	= { 'items'		: o.scroll 	};
				else								o.scroll	= { 'duration'	: o.scroll 	};
			} else {
				if (typeof o.scroll == 'string')	o.scroll	= { 'easing'	: o.scroll 	};
			}

				 if (typeof o.items == 'number')	o.items		= { 'visible'	: o.items 	};
			else if (		o.items == 'variable')	o.items		= { 'visible'	: o.items,
																	'width'		: o.items, 
																	'height'	: o.items	};

			if (typeof o.items != 'object') o.items = {};
			if (setOrig) opts_orig = $.extend(true, {}, $.fn.carouFredSel.defaults, o);

			opts = $.extend(true, {}, $.fn.carouFredSel.defaults, o);

			if (typeof opts.items.visibleConf != 'object') opts.items.visibleConf = {};

			if (opts.items.start == 0 && typeof start == 'number') {
				opts.items.start = start;
			}

			crsl.upDateOnWindowResize = (opts.responsive);
			crsl.direction = (opts.direction == 'up' || opts.direction == 'left') ? 'next' : 'prev';

			var dims = [
				['width'	, 'innerWidth'	, 'outerWidth'	, 'height'	, 'innerHeight'	, 'outerHeight'	, 'left', 'top'	, 'marginRight'	, 0, 1, 2, 3],
				['height'	, 'innerHeight'	, 'outerHeight'	, 'width'	, 'innerWidth'	, 'outerWidth'	, 'top'	, 'left', 'marginBottom', 3, 2, 1, 0]
			];

			var dn = dims[0].length,
				dx = (opts.direction == 'right' || opts.direction == 'left') ? 0 : 1;

			opts.d = {};
			for (var d = 0; d < dn; d++) {
				opts.d[dims[0][d]] = dims[dx][d];
			}

			var	all_itm = $cfs.children();


			//	check visible items
			switch (typeof opts.items.visible) {

				//	min and max visible items
				case 'object':
					opts.items.visibleConf.min = opts.items.visible.min;
					opts.items.visibleConf.max = opts.items.visible.max;
					opts.items.visible = false;
					break;
				
				case 'string':
					//	variable visible items
					if (opts.items.visible == 'variable') {
						opts.items.visibleConf.variable = true;

					//	adjust string visible items
					} else {
						opts.items.visibleConf.adjust = opts.items.visible;
					}
					opts.items.visible = false;
					break;

				// function visible items
				case 'function':
					opts.items.visibleConf.adjust = opts.items.visible;
					opts.items.visible = false;
					break;
			}

			//	set items filter
			if (typeof opts.items.filter == 'undefined') {
				opts.items.filter = (all_itm.filter(':hidden').length > 0) ? ':visible' : '*';
			}

			//	primary size set to auto -> measure largest size and set it
			if (opts[opts.d['width']] == 'auto') {
				opts[opts.d['width']] = ms_getTrueLargestSize(all_itm, opts, 'outerWidth');
			}
			//	primary size percentage
			if (ms_isPercentage(opts[opts.d['width']]) && !opts.responsive) {
				opts[opts.d['width']] = ms_getPercentage(ms_getTrueInnerSize($wrp.parent(), opts, 'innerWidth'), opts[opts.d['width']]);
				crsl.upDateOnWindowResize = true;
			}

			//	secondary size set to auto -> measure largest size and set it
			if (opts[opts.d['height']] == 'auto') {
				opts[opts.d['height']] = ms_getTrueLargestSize(all_itm, opts, 'outerHeight');
			}

			//	primary item-size not set
			if (!opts.items[opts.d['width']]) {
//	responsive carousel -> set to largest
if (opts.responsive) {
	//debug(true, 'Set a '+opts.d['width']+' for the items!');
	opts.items[opts.d['width']] = ms_getTrueLargestSize(all_itm, opts, 'outerWidth');
				//	 non-responsive -> measure it or set to "variable"
} else {
				opts.items[opts.d['width']] = (ms_hasVariableSizes(all_itm, opts, 'outerWidth')) 
					? 'variable' 
					: all_itm[opts.d['outerWidth']](true);
}
			}

			//	secondary item-size not set -> measure it or set to "variable"
			if (!opts.items[opts.d['height']]) {
				opts.items[opts.d['height']] = (ms_hasVariableSizes(all_itm, opts, 'outerHeight')) 
					? 'variable' 
					: all_itm[opts.d['outerHeight']](true);
			}

			//	secondary size not set -> set to secondary item-size
			if (!opts[opts.d['height']]) {
				opts[opts.d['height']] = opts.items[opts.d['height']];
			}

			//	visible-items not set
			if (!opts.items.visible && !opts.responsive) {
				//	primary item-size variable -> set visible items variable
				if (opts.items[opts.d['width']] == 'variable') {
					opts.items.visibleConf.variable = true;
				}
				if (!opts.items.visibleConf.variable) {
					//	primary size is number -> calculate visible-items
					if (typeof opts[opts.d['width']] == 'number') {
						opts.items.visible = Math.floor(opts[opts.d['width']] / opts.items[opts.d['width']]);
					} else {
						//	measure and calculate primary size and visible-items
						var maxS = ms_getTrueInnerSize($wrp.parent(), opts, 'innerWidth');
						opts.items.visible = Math.floor(maxS / opts.items[opts.d['width']]);
						opts[opts.d['width']] = opts.items.visible * opts.items[opts.d['width']];
						if (!opts.items.visibleConf.adjust) opts.align = false;
					}
					if (opts.items.visible == 'Infinity' || opts.items.visible < 1) {
						debug(true, 'Not a valid number of visible items: Set to "variable".');
						opts.items.visibleConf.variable = true;
					}
				}
			}

			//	primary size not set -> calculate it or set to "variable"
			if (!opts[opts.d['width']]) {
				opts[opts.d['width']] = 'variable';
				if (!opts.responsive && opts.items.filter == '*' && !opts.items.visibleConf.variable && opts.items[opts.d['width']] != 'variable') {
					opts[opts.d['width']] = opts.items.visible * opts.items[opts.d['width']];
					opts.align = false;
				}
			}

			//	variable primary item-sizes with variabe visible-items
			if (opts.items.visibleConf.variable) {
				opts.maxDimention = (opts[opts.d['width']] == 'variable')
					? ms_getTrueInnerSize($wrp.parent(), opts, 'innerWidth')
					: opts[opts.d['width']];
				if (opts.align === false) {
					opts[opts.d['width']] = 'variable';
				}
				opts.items.visible = gn_getVisibleItemsNext(all_itm, opts, 0);

			//	set visible items by filter
			} else if (opts.items.filter != '*') {
				opts.items.visibleConf.org = opts.items.visible;
				opts.items.visible = gn_getVisibleItemsNextFilter(all_itm, opts, 0);
			}

			//	align not set -> set to center if primary size is number
			if (typeof opts.align == 'undefined') {
				opts.align = (opts[opts.d['width']] == 'variable')
					? false
					: 'center';
			}

			opts.items.visible = cf_getItemsAdjust(opts.items.visible, opts, opts.items.visibleConf.adjust, $tt0);
			opts.items.visibleConf.old = opts.items.visible;
			opts.usePadding = false;


if (opts.responsive) {

	if (!opts.items.visibleConf.min) opts.items.visibleConf.min = opts.items.visible;
	if (!opts.items.visibleConf.max) opts.items.visibleConf.max = opts.items.visible;

	opts.align = false;
	opts.padding = [0, 0, 0, 0];

	var isVisible = $wrp.is(':visible');
	if (isVisible) $wrp.hide();
	var fullS = ms_getPercentage(ms_getTrueInnerSize($wrp.parent(), opts, 'innerWidth'), opts[opts.d['width']]);

	if (typeof opts[opts.d['width']] == 'number' && fullS < opts[opts.d['width']]) {
		fullS = opts[opts.d['width']];
	}
	if (isVisible) $wrp.show();

	var visb = cf_getItemAdjustMinMax(Math.ceil(fullS / opts.items[opts.d['width']]), opts.items.visibleConf);
	if (visb > all_itm.length) {
		visb = all_itm.length;
	}

	var newS = Math.floor(fullS/visb),
		seco = opts[opts.d['height']],
		secp = ms_isPercentage(seco);

	all_itm.each(function() {
		var $t = $(this),
			nw = newS - ms_getPaddingBorderMargin($t, opts, 'Width');

		$t[opts.d['width']](nw);
		if (secp) {
			$t[opts.d['height']](ms_getPercentage(nw, seco));
		}
	});

	opts.items.visible = visb;
	opts.items[opts.d['width']] = newS;
	opts[opts.d['width']] = visb * newS;
	
} else {

			opts.padding = cf_getPadding(opts.padding);

			if (opts.align == 'top') 		opts.align = 'left';
			if (opts.align == 'bottom') 	opts.align = 'right';


			switch (opts.align) {
				//	align: center, left or right
				case 'center':
				case 'left':
				case 'right':
					if (opts[opts.d['width']] != 'variable') {
						var p = cf_getAlignPadding(gi_getCurrentItems(all_itm, opts), opts);
						opts.usePadding = true;
						opts.padding[opts.d[1]] = p[1];
						opts.padding[opts.d[3]] = p[0];
					}
					break;

				//	padding
				default:
					opts.align = false;
					opts.usePadding = (
						opts.padding[0] == 0 && 
						opts.padding[1] == 0 && 
						opts.padding[2] == 0 && 
						opts.padding[3] == 0
					) ? false : true;
					break;
			}
}

			if (typeof opts.cookie == 'boolean' && opts.cookie)			opts.cookie 					= 'caroufredsel_cookie_'+$cfs.attr('id');
			if (typeof opts.items.minimum				!= 'number')	opts.items.minimum				= opts.items.visible;
			if (typeof opts.scroll.duration				!= 'number')	opts.scroll.duration			= 500;
			if (typeof opts.scroll.items				== 'undefined') opts.scroll.items 				= (opts.items.visibleConf.variable || opts.items.filter != '*') ? 'visible' : opts.items.visible;

			opts.auto		= go_getNaviObject($tt0, opts.auto, 'auto');
			opts.prev		= go_getNaviObject($tt0, opts.prev);
			opts.next		= go_getNaviObject($tt0, opts.next);
			opts.pagination	= go_getNaviObject($tt0, opts.pagination, 'pagination');

			opts.auto		= $.extend(true, {}, opts.scroll, opts.auto);
			opts.prev		= $.extend(true, {}, opts.scroll, opts.prev);
			opts.next		= $.extend(true, {}, opts.scroll, opts.next);
			opts.pagination	= $.extend(true, {}, opts.scroll, opts.pagination);

			if (typeof opts.pagination.keys				!= 'boolean')	opts.pagination.keys 			= false;
			if (typeof opts.pagination.anchorBuilder	!= 'function'
					&& opts.pagination.anchorBuilder	!== false)		opts.pagination.anchorBuilder	= $.fn.carouFredSel.pageAnchorBuilder;
			if (typeof opts.auto.play					!= 'boolean')	opts.auto.play					= true;
			if (typeof opts.auto.delay					!= 'number')	opts.auto.delay					= 0;
			if (typeof opts.auto.pauseOnEvent 			== 'undefined')	opts.auto.pauseOnEvent			= true;
			if (typeof opts.auto.pauseOnResize 			!= 'boolean')	opts.auto.pauseOnResize			= true;
			if (typeof opts.auto.pauseDuration			!= 'number')	opts.auto.pauseDuration			= (opts.auto.duration < 10) ? 2500 : opts.auto.duration * 5;

			if (opts.synchronise) {
				opts.synchronise = cf_getSynchArr(opts.synchronise);
			}
			if (conf.debug) {
				debug(conf, 'Carousel width: '+opts.width);
				debug(conf, 'Carousel height: '+opts.height);
				if (opts.maxDimention)	debug(conf, 'Available '+opts.d['width']+': '+opts.maxDimention);
				debug(conf, 'Item widths: '+opts.items.width);
				debug(conf, 'Item heights: '+opts.items.height);
				debug(conf, 'Number of items visible: '+opts.items.visible);
				if (opts.auto.play)		debug(conf, 'Number of items scrolled automatically: '+opts.auto.items);
				if (opts.prev.button)	debug(conf, 'Number of items scrolled backward: '+opts.prev.items);
				if (opts.next.button)	debug(conf, 'Number of items scrolled forward: '+opts.next.items);
			}
		};	//	/init

		$cfs._cfs_build = function() {
			$cfs.data('cfs_isCarousel', true);

			var orgCSS = {
				'textAlign'		: $cfs.css('textAlign'),
				'float'			: $cfs.css('float'),
				'position'		: $cfs.css('position'),
				'top'			: $cfs.css('top'),
				'right'			: $cfs.css('right'),
				'bottom'		: $cfs.css('bottom'),
				'left'			: $cfs.css('left'),
				'width'			: $cfs.css('width'),
				'height'		: $cfs.css('height'),
				'marginTop'		: $cfs.css('marginTop'),
				'marginRight'	: $cfs.css('marginRight'),
				'marginBottom'	: $cfs.css('marginBottom'),
				'marginLeft'	: $cfs.css('marginLeft')
			};

			switch (orgCSS.position) {
				case 'absolute':
					var newPosition = 'absolute';
					break;
				case 'fixed':
					var newPosition = 'fixed';
					break;
				default:
					var newPosition = 'relative';
			} 

			$wrp.css(orgCSS).css({
				'overflow'		: 'hidden',
				'position'		: newPosition
			});

			$cfs.data('cfs_origCss', orgCSS).css({
				'textAlign'		: 'left',
				'float'			: 'none',
				'position'		: 'absolute',
				'top'			: 0,
				'left'			: 0,
				'marginTop'		: 0,
				'marginRight'	: 0,
				'marginBottom'	: 0,
				'marginLeft'	: 0
			});

			if (opts.usePadding) {
				$cfs.children().each(function() {
					var m = parseInt($(this).css(opts.d['marginRight']));
					if (isNaN(m)) m = 0;
					$(this).data('cfs_origCssMargin', m);
				});
			}

		};	//	/build

		$cfs._cfs_bind_events = function() {
			$cfs._cfs_unbind_events();

			//	stop event
			$cfs.bind(cf_e('stop', conf), function(e, imm) {
				e.stopPropagation();

				//	button
				if (!crsl.isStopped) {
					if (opts.auto.button) {
						opts.auto.button.addClass(cf_c('stopped', conf));
					}
				}

				//	set stopped
				crsl.isStopped = true;

				if (opts.auto.play) {
					opts.auto.play = false;
					$cfs.trigger(cf_e('pause', conf), imm);
				}
				return true;
			});

			//	finish event
			$cfs.bind(cf_e('finish', conf), function(e) {
				e.stopPropagation();
				if (crsl.isScrolling) {
					sc_stopScroll(scrl);
				}
				return true;
			});

			//	pause event
			$cfs.bind(cf_e('pause', conf), function(e, imm, res) {
				e.stopPropagation();
				tmrs = sc_clearTimers(tmrs);

				//	immediately pause
				if (imm && crsl.isScrolling) {
					scrl.isStopped = true;
					var nst = getTime() - scrl.startTime;
					scrl.duration -= nst;
					if (scrl.pre) scrl.pre.duration -= nst;
					if (scrl.post) scrl.post.duration -= nst;
					sc_stopScroll(scrl, false);
				}

				//	update remaining pause-time
				if (!crsl.isPaused && !crsl.isScrolling) {
					if (res) tmrs.timePassed += getTime() - tmrs.startTime;
				}
				
				//	button
				if (!crsl.isPaused) {
					if (opts.auto.button) {
						opts.auto.button.addClass(cf_c('paused', conf));
					}
				}

				//	set paused
				crsl.isPaused = true;

				//	pause pause callback
				if (opts.auto.onPausePause) {
					var dur1 = opts.auto.pauseDuration - tmrs.timePassed,
						perc = 100 - Math.ceil( dur1 * 100 / opts.auto.pauseDuration );
					opts.auto.onPausePause.call($tt0, perc, dur1);
				}
				return true;
			});

			//	play event
			$cfs.bind(cf_e('play', conf), function(e, dir, del, res) {
				e.stopPropagation();
				tmrs = sc_clearTimers(tmrs);

				//	sort params
				var v = [dir, del, res],
					t = ['string', 'number', 'boolean'],
					a = cf_sortParams(v, t);

				var dir = a[0],
					del = a[1],
					res = a[2];

				if (dir != 'prev' && dir != 'next') dir = crsl.direction;
				if (typeof del != 'number') 		del = 0;
				if (typeof res != 'boolean') 		res = false;

				//	stopped?
				if (res) {
					crsl.isStopped = false;
					opts.auto.play = true;
				}
				if (!opts.auto.play) {
					e.stopImmediatePropagation();
					return debug(conf, 'Carousel stopped: Not scrolling.');
				}

				//	button
				if (crsl.isPaused) {
					if (opts.auto.button) {
						opts.auto.button.removeClass(cf_c('stopped', conf));
						opts.auto.button.removeClass(cf_c('paused', conf));
					}
				}

				//	set playing
				crsl.isPaused = false;
				tmrs.startTime = getTime();

				//	timeout the scrolling
				var dur1 = opts.auto.pauseDuration + del;
					dur2 = dur1 - tmrs.timePassed;
					perc = 100 - Math.ceil(dur2 * 100 / dur1);

				tmrs.auto = setTimeout(function() {
					if (opts.auto.onPauseEnd) {
						opts.auto.onPauseEnd.call($tt0, perc, dur2);
					}
					if (crsl.isScrolling) {
						$cfs.trigger(cf_e('play', conf), dir);
					} else {
						$cfs.trigger(cf_e(dir, conf), opts.auto);
					}
				}, dur2);

				//	pause start callback
				if (opts.auto.onPauseStart) {
					opts.auto.onPauseStart.call($tt0, perc, dur2);
				}

				return true;
			});

			//	resume event
			$cfs.bind(cf_e('resume', conf), function(e) {
				e.stopPropagation();
				if (scrl.isStopped) {
					scrl.isStopped = false;
					crsl.isPaused = false;
					crsl.isScrolling = true;
					scrl.startTime = getTime();
					sc_startScroll(scrl);
				} else {
					$cfs.trigger(cf_e('play', conf));
				}
				return true;
			});

			//	prev + next events
			$cfs.bind(cf_e('prev', conf)+' '+cf_e('next', conf), function(e, obj, num, clb) {
				e.stopPropagation();

				//	stopped or hidden carousel, don't scroll, don't queue
				if (crsl.isStopped || $cfs.is(':hidden')) {
					e.stopImmediatePropagation();
					return debug(conf, 'Carousel stopped or hidden: Not scrolling.');
				}

				//	not enough items
				if (opts.items.minimum >= itms.total) {
					e.stopImmediatePropagation();
					return debug(conf, 'Not enough items ('+itms.total+', '+opts.items.minimum+' needed): Not scrolling.');
				}

				//	get config
				var v = [obj, num, clb],
					t = ['object', 'number/string', 'function'],
					a = cf_sortParams(v, t);

				var obj = a[0],
					num = a[1],
					clb = a[2];

				var eType = e.type.slice(conf.events.prefix.length);

				if (typeof obj != 'object' || obj == null)	obj = opts[eType];
				if (typeof clb == 'function')				obj.onAfter = clb;

				if (typeof num != 'number') {
					if (opts.items.filter != '*') {
						num = 'visible';
					} else {
						var arr = [num, obj.items, opts[eType].items];
						for (var a = 0, l = arr.length; a < l; a++) {
							if (typeof arr[a] == 'number' || arr[a] == 'page' || arr[a] == 'visible') {
								num = arr[a];
								break;
							}
						}
					}
					switch(num) {
						case 'page':
							e.stopImmediatePropagation();
							return $cfs.triggerHandler(eType+'Page', [obj, clb]);
							break;

						case 'visible':
							if (!opts.items.visibleConf.variable && opts.items.filter == '*') {
								num = opts.items.visible;
							}
							break;
					}
				}

				//	resume animation, add current to queue
				if (scrl.isStopped) {
					$cfs.trigger(cf_e('resume', conf));
					$cfs.trigger(cf_e('queue', conf), [eType, [obj, num, clb]]);
					e.stopImmediatePropagation();
					return debug(conf, 'Carousel resumed scrolling.');
				}

				//	queue if scrolling
				if (obj.duration > 0) {
					if (crsl.isScrolling) {
						if (obj.queue) $cfs.trigger(cf_e('queue', conf), [eType, [obj, num, clb]]);
						e.stopImmediatePropagation();
						return debug(conf, 'Carousel currently scrolling.');
					}
				}

				//	test conditions callback
				if (obj.conditions && !obj.conditions.call($tt0)) {
					e.stopImmediatePropagation();
					return debug(conf, 'Callback "conditions" returned false.');
				}

				tmrs.timePassed = 0;


                // Define a loading element that will display while the slide image is loading
				//var $spinner = $('<div class="sk-fading-circle"><div class="sk-circle1 sk-circle"></div><div class="sk-circle2 sk-circle"></div><div class="sk-circle3 sk-circle"></div><div class="sk-circle4 sk-circle"></div><div class="sk-circle5 sk-circle"></div><div class="sk-circle6 sk-circle"></div><div class="sk-circle7 sk-circle"></div><div class="sk-circle8 sk-circle"></div><div class="sk-circle9 sk-circle"></div><div class="sk-circle10 sk-circle"></div><div class="sk-circle11 sk-circle"></div><div class="sk-circle12 sk-circle"></div></div>');
				if ("next" == eType) {
					var slide_offset = parseInt(num)
				} else {
					var slide_offset = parseInt(num) * -1
				}
				if ($cfs.find("li") && slide_offset) {
					// Find the slide that the user navigated to
					var $slide = $cfs.children("li").eq(slide_offset);
					if ("object" == typeof $slide) {
                        var $slide_img = $slide.find("img." + mrm.ui.image_loader.onscroll_class);
						if (("object" == typeof $slide_img) && $slide_img.attr("data-" + mrm.ui.image_loader.src_attribute) && 0 != $slide_img.attr("data-" + mrm.ui.image_loader.src_attribute).length) {
							/* 
                               Fix for TFS 404889: Adding code to guess the height of the lazy-loaded image before it loads - Jarred Jacobs                               
                            */
                            var src = $slide_img.attr("data-" + mrm.ui.image_loader.src_attribute);                            
                            var guess_height = null;
                            var sizeRegEx = /(\d+x\d+)/.exec(src); // Find <width>x<height> string in image file name
                            /* 
                                Fix for TFS 409051: Adding checks to prevent errors when the regex fails - Jarred Jacobs
                            */
							if (sizeRegEx && sizeRegEx[0]) {
								var sizes = sizeRegEx[0].split('x'); // Splint the string into an array containing [0]->width, [1]->height
								if (sizes && sizes[1]) {
									guess_height = parseInt(sizes[1]);
								}
							}
							if (guess_height && 'number' == typeof guess_height && NaN != typeof guess_height) {
								$slide_img.parent('div').css('height', guess_height);
								$cfs.parents(".caroufredsel_wrapper").css("maxHeight", "auto"); // Allow wrapper height to be flexible
							} else if (parseInt($cfs.parents(".caroufredsel_wrapper").css("height")) > 1) {
								// Keep wrapper for the new slide the same height as the previous slide to prevent the auto resize code from adding too much white space
								$cfs.parents(".caroufredsel_wrapper").css("maxHeight", $cfs.parents(".caroufredsel_wrapper").css("height"));
							}
							$slide_img.attr("src", src);
							$slide_img.one("load", function () {
								$slide_img.addClass(mrm.ui.image_loader.loaded_class).removeClass(mrm.ui.image_loader.onscroll_class);
								//$slide_img.parent().find(".sk-fading-circle").detach()
								var true_height = $slide_img[0].height;
								$slide_img.css("height", true_height);
								$slide_img.parent("div").css("height", true_height)
							});
						}
					}
				}

				$cfs.trigger('_cfs_triggerEvent', ['slide_'+eType, [obj, num]]);

				//	synchronise
				if (opts.synchronise) {
					var s = opts.synchronise,
						c = [obj, num];
					for (var j = 0, l = s.length; j < l; j++) {
						var d = eType;

						if (!s[j][1]) c[0] = s[j][0].triggerHandler('_cfs_triggerEvent', ['configuration', [d]]);
						if (!s[j][2]) d = (d == 'prev') ? 'next' : 'prev';
						c[1] = num + s[j][3];
						s[j][0].trigger('_cfs_triggerEvent', ['slide_'+d, [c]]);
					}
				}
				return true;
			});

			//	prev event
			$cfs.bind(cf_e('slide_prev', conf), function(e, sO, nI) {
				e.stopPropagation();
				var a_itm = $cfs.children();

				//	non-circular at start, scroll to end
				if (!opts.circular) {
					if (itms.first == 0) {
						if (opts.infinite) {
							$cfs.trigger(cf_e('next', conf), itms.total-1);
						}
						return e.stopImmediatePropagation();
					}
				}

				if (opts.usePadding) sz_resetMargin(a_itm, opts);

				//	find number of items to scroll
				if (typeof nI != 'number') {
					if (opts.items.visibleConf.variable) {
						nI = gn_getVisibleItemsPrev(a_itm, opts, itms.total-1);
					} else if (opts.items.filter != '*') {
						var xI = (typeof sO.items == 'number') ? sO.items : gn_getVisibleOrg($cfs, opts);
						nI = gn_getScrollItemsPrevFilter(a_itm, opts, itms.total-1, xI);
					} else {
						nI = opts.items.visible;
					}
					nI = cf_getAdjust(nI, opts, sO.items, $tt0);
				}

				//	prevent non-circular from scrolling to far
				if (!opts.circular) {
					if (itms.total - nI < itms.first) {
						nI = itms.total - itms.first;
					}
				}

				//	set new number of visible items
				opts.items.visibleConf.old = opts.items.visible;
				if (opts.items.visibleConf.variable) {
					var vI = gn_getVisibleItemsNext(a_itm, opts, itms.total-nI);
					if (opts.items.visible+nI <= vI && nI < itms.total) {
						nI++;
						vI = gn_getVisibleItemsNext(a_itm, opts, itms.total-nI);
					}
					opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
				} else if (opts.items.filter != '*') {
					var vI = gn_getVisibleItemsNextFilter(a_itm, opts, itms.total-nI);
					opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
				}

				if (opts.usePadding) sz_resetMargin(a_itm, opts, true);

				//	scroll 0, don't scroll
				if (nI == 0) {
					e.stopImmediatePropagation();
					return debug(conf, '0 items to scroll: Not scrolling.');
				}
				debug(conf, 'Scrolling '+nI+' items backward.');

				//	save new config
				itms.first += nI;
				while (itms.first >= itms.total) {
					itms.first -= itms.total;
				}

				//	non-circular callback
				if (!opts.circular) {
					if (itms.first == 0 && sO.onEnd) sO.onEnd.call($tt0);
					if (!opts.infinite) nv_enableNavi(opts, itms.first, conf);
				}

				//	rearrange items
				$cfs.children().slice(itms.total-nI, itms.total).prependTo($cfs);
				if (itms.total < opts.items.visible + nI) {
					$cfs.children().slice(0, (opts.items.visible+nI)-itms.total).clone(true).appendTo($cfs);
				}

				//	the needed items
				var a_itm = $cfs.children(),
					c_old = gi_getOldItemsPrev(a_itm, opts, nI),
					c_new = gi_getNewItemsPrev(a_itm, opts),
					l_cur = a_itm.eq(nI-1),
					l_old = c_old.last(),
					l_new = c_new.last();

				if (opts.usePadding) sz_resetMargin(a_itm, opts);
				if (opts.align) {
					var p = cf_getAlignPadding(c_new, opts),
						pL = p[0],
						pR = p[1];
				} else {
					var pL = 0,
						pR = 0;
				}
				var oL = (pL < 0) ? opts.padding[opts.d[3]] : 0;

				//	hide items for fx directscroll
				if (sO.fx == 'directscroll' && opts.items.visible < nI) {
					var hiddenitems = a_itm.slice(opts.items.visibleConf.old, nI),
						orgW = opts.items[opts.d['width']];
					hiddenitems.each(function() {
						var hi = $(this);
						hi.data('isHidden', hi.is(':hidden')).hide();
					});
					opts.items[opts.d['width']] = 'variable';
				} else {
					var hiddenitems = false;
				}

				//	save new sizes
				var i_siz = ms_getTotalSize(a_itm.slice(0, nI), opts, 'width'),
					w_siz = cf_mapWrapperSizes(ms_getSizes(c_new, opts, true), opts, !opts.usePadding);

				if (hiddenitems) opts.items[opts.d['width']] = orgW;

				if (opts.usePadding) {
					sz_resetMargin(a_itm, opts, true);
					if (pR >= 0) {
						sz_resetMargin(l_old, opts, opts.padding[opts.d[1]]);
					}
					sz_resetMargin(l_cur, opts, opts.padding[opts.d[3]]);
				}
				if (opts.align) {
					opts.padding[opts.d[1]] = pR;
					opts.padding[opts.d[3]] = pL;
				}

				//	animation configuration
				var a_cfs = {},
					a_dur = sO.duration;

					 if (sO.fx == 'none')	a_dur = 0;
				else if (a_dur == 'auto')	a_dur = opts.scroll.duration / opts.scroll.items * nI;
				else if (a_dur <= 0)		a_dur = 0;
				else if (a_dur < 10)		a_dur = i_siz / a_dur;

				scrl = sc_setScroll(a_dur, sO.easing);

				//	animate wrapper
				if (opts[opts.d['width']] == 'variable' || opts[opts.d['height']] == 'variable') {
					scrl.anims.push([$wrp, w_siz]);
				}

				//	animate items
				if (opts.usePadding) {
					var new_m = opts.padding[opts.d[3]];

					if (l_new.not(l_cur).length) {
			 			var a_cur = {};
			 				a_cur[opts.d['marginRight']] = l_cur.data('cfs_origCssMargin');

						if (pL < 0) l_cur.css(a_cur);
						else 		scrl.anims.push([l_cur, a_cur]);
					}

					if (l_new.not(l_old).length) {
						var a_old = {};
							a_old[opts.d['marginRight']] = l_old.data('cfs_origCssMargin');
						scrl.anims.push([l_old, a_old]);
					}

					if (pR >= 0) {
						var a_new = {};
							a_new[opts.d['marginRight']] = l_new.data('cfs_origCssMargin') + opts.padding[opts.d[1]];
						scrl.anims.push([l_new, a_new]);
					}
				} else {
					var new_m = 0;
				}

				//	animate carousel
				a_cfs[opts.d['left']] = new_m;

				//	onBefore callback
				var args = [c_old, c_new, w_siz, a_dur];
				if (sO.onBefore) sO.onBefore.apply($tt0, args);
				clbk.onBefore = sc_callCallbacks(clbk.onBefore, $tt0, args);



				//	ALTERNATIVE EFFECTS

				//	extra animation arrays
				switch(sO.fx) {
					case 'fade':
					case 'crossfade':
					case 'cover':
					case 'uncover':
						scrl.pre = sc_setScroll(scrl.duration, scrl.easing);
						scrl.post = sc_setScroll(scrl.duration, scrl.easing);
						scrl.duration = 0;
						break;
				}

				//	create copy
				switch(sO.fx) {
					case 'crossfade':
					case 'cover':
					case 'uncover':
						var $cf2 = $cfs.clone().appendTo($wrp);
						break;
				}
				switch(sO.fx) {
					case 'uncover':
						$cf2.children().slice(0, nI).remove();
					case 'crossfade':
					case 'cover':
						$cf2.children().slice(opts.items.visible).remove();
						break;
				}

				//	animations
				switch(sO.fx) {
					case 'fade':
						scrl.pre.anims.push([$cfs, { 'opacity': 0 }]);
						break;
					case 'crossfade':
						$cf2.css({ 'opacity': 0 });
						scrl.pre.anims.push([$cfs, { 'width': '+=0' }, function() { $cf2.remove(); }]);
						scrl.post.anims.push([$cf2, { 'opacity': 1 }]);
						break;
					case 'cover':
						scrl = fx_cover(scrl, $cfs, $cf2, opts, true);
						break;
					case 'uncover':
						scrl = fx_uncover(scrl, $cfs, $cf2, opts, true, nI);
						break;
				}

				//	/ALTERNATIVE EFFECTS


				//	complete callback
				var a_complete = function() {

					var overFill = opts.items.visible+nI-itms.total;
					if (overFill > 0) {
						$cfs.children().slice(itms.total).remove();
						c_old = $( $cfs.children().slice(itms.total-(opts.items.visible-overFill)).get().concat( $cfs.children().slice(0, overFill).get() ) );
					}
					if (hiddenitems) {
						hiddenitems.each(function() {
							var hi = $(this);
							if (!hi.data('isHidden')) hi.show();
						});	
					}
					if (opts.usePadding) {
						var l_itm = $cfs.children().eq(opts.items.visible+nI-1);
						l_itm.css(opts.d['marginRight'], l_itm.data('cfs_origCssMargin'));
					}

					scrl.anims = [];
					if (scrl.pre) scrl.pre = sc_setScroll(scrl.orgDuration, scrl.easing);

					var fn = function() {
						switch(sO.fx) {
							case 'fade':
							case 'crossfade':
								$cfs.css('filter', '');
								break;
						}

						scrl.post = sc_setScroll(0, null);
						crsl.isScrolling = false;

						var args = [c_old, c_new, w_siz];
						if (sO.onAfter) sO.onAfter.apply($tt0, args);
						clbk.onAfter = sc_callCallbacks(clbk.onAfter, $tt0, args);

						if (queu.length) {
							$cfs.trigger(cf_e(queu[0][0], conf), queu[0][1]);
							queu.shift();
						}
						if (!crsl.isPaused) $cfs.trigger(cf_e('play', conf));
					};
					switch(sO.fx) {
						case 'fade':
							scrl.pre.anims.push([$cfs, { 'opacity': 1 }, fn]);
							sc_startScroll(scrl.pre);
							break;
						case 'uncover':
							scrl.pre.anims.push([$cfs, { 'width': '+=0' }, fn]);
							sc_startScroll(scrl.pre);
							break;
						default:
							fn();
							break;
					}
				};

				scrl.anims.push([$cfs, a_cfs, a_complete]);
				crsl.isScrolling = true;
				$cfs.css(opts.d['left'], -(i_siz-oL));
				tmrs = sc_clearTimers(tmrs);
				sc_startScroll(scrl);
				cf_setCookie(opts.cookie, $cfs.triggerHandler(cf_e('currentPosition', conf)));

				$cfs.trigger(cf_e('updatePageStatus', conf), [false, w_siz]);

				return true;
			});

			//	next event
			$cfs.bind(cf_e('slide_next', conf), function(e, sO, nI) {
				e.stopPropagation();
				var a_itm = $cfs.children();

				//	non-circular at end, scroll to start
				if (!opts.circular) {
					if (itms.first == opts.items.visible) {
						if (opts.infinite) {
							$cfs.trigger(cf_e('prev', conf), itms.total-1);
						}
						return e.stopImmediatePropagation();
					}
				}

				if (opts.usePadding) sz_resetMargin(a_itm, opts);

				//	find number of items to scroll
				if (typeof nI != 'number') {
					if (opts.items.filter != '*') {
						var xI = (typeof sO.items == 'number') ? sO.items : gn_getVisibleOrg($cfs, opts);
						nI = gn_getScrollItemsNextFilter(a_itm, opts, 0, xI);
					} else {
						nI = opts.items.visible;
					}
					nI = cf_getAdjust(nI, opts, sO.items, $tt0);
				}

				var lastItemNr = (itms.first == 0) ? itms.total : itms.first;

				//	prevent non-circular from scrolling to far
				if (!opts.circular) {
					if (opts.items.visibleConf.variable) {
						var vI = gn_getVisibleItemsNext(a_itm, opts, nI),
							xI = gn_getVisibleItemsPrev(a_itm, opts, lastItemNr-1);
					} else {
						var vI = opts.items.visible,
							xI = opts.items.visible;
					}

					if (nI + vI > lastItemNr) {
						nI = lastItemNr - xI;
					}
				}

				//	set new number of visible items
				opts.items.visibleConf.old = opts.items.visible;
				if (opts.items.visibleConf.variable) {
					var vI = gn_getVisibleItemsNextTestCircular(a_itm, opts, nI, lastItemNr);
					while (opts.items.visible-nI >= vI && nI < itms.total) {
						nI++;
						vI = gn_getVisibleItemsNextTestCircular(a_itm, opts, nI, lastItemNr);
					}
					opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
				} else if (opts.items.filter != '*') {
					var vI = gn_getVisibleItemsNextFilter(a_itm, opts, nI);
					opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
				}

				if (opts.usePadding) sz_resetMargin(a_itm, opts, true);

				//	scroll 0, don't scroll
				if (nI == 0) {
					e.stopImmediatePropagation();
					return debug(conf, '0 items to scroll: Not scrolling.');
				}
				debug(conf, 'Scrolling '+nI+' items forward.');

				//	save new config
				itms.first -= nI;
				while (itms.first < 0) {
					itms.first += itms.total;
				}

				//	non-circular callback
				if (!opts.circular) {
					if (itms.first == opts.items.visible && sO.onEnd) sO.onEnd.call($tt0);
					if (!opts.infinite) nv_enableNavi(opts, itms.first, conf);
				}

				//	rearrange items
				if (itms.total < opts.items.visible+nI) {
					$cfs.children().slice(0, (opts.items.visible+nI)-itms.total).clone(true).appendTo($cfs);
				}

				//	the needed items
				var a_itm = $cfs.children(),
					c_old = gi_getOldItemsNext(a_itm, opts),
					c_new = gi_getNewItemsNext(a_itm, opts, nI),
					l_cur = a_itm.eq(nI-1),
					l_old = c_old.last(),
					l_new = c_new.last();

				if (opts.usePadding) sz_resetMargin(a_itm, opts);
				if (opts.align)	{
					var p = cf_getAlignPadding(c_new, opts),
						pL = p[0],
						pR = p[1];
				} else {
					var pL = 0,
						pR = 0;
				}

				//	hide items for fx directscroll
				if (sO.fx == 'directscroll' && opts.items.visibleConf.old < nI) {
					var hiddenitems = a_itm.slice(opts.items.visibleConf.old, nI),
						orgW = opts.items[opts.d['width']];
					hiddenitems.each(function() {
						var hi = $(this);
						hi.data('isHidden', hi.is(':hidden')).hide();
					});
					opts.items[opts.d['width']] = 'variable';
				} else {
					var hiddenitems = false;
				}

				//	save new sizes
				var i_siz = ms_getTotalSize(a_itm.slice(0, nI), opts, 'width'),
					w_siz = cf_mapWrapperSizes(ms_getSizes(c_new, opts, true), opts, !opts.usePadding);

				if (hiddenitems) opts.items[opts.d['width']] = orgW;

				if (opts.align) {
					if (opts.padding[opts.d[1]] < 0) {
						opts.padding[opts.d[1]] = 0;
					}
				}
				if (opts.usePadding) {
					sz_resetMargin(a_itm, opts, true);
					sz_resetMargin(l_old, opts, opts.padding[opts.d[1]]);
				}
				if (opts.align) {
					opts.padding[opts.d[1]] = pR;
					opts.padding[opts.d[3]] = pL;
				}

				//	animation configuration
				var a_cfs = {},
					a_dur = sO.duration;

					 if (sO.fx == 'none')	a_dur = 0;
				else if (a_dur == 'auto')	a_dur = opts.scroll.duration / opts.scroll.items * nI;
				else if (a_dur <= 0)		a_dur = 0;
				else if (a_dur < 10)		a_dur = i_siz / a_dur;

				scrl = sc_setScroll(a_dur, sO.easing);

				//	animate wrapper
				if (opts[opts.d['width']] == 'variable' || opts[opts.d['height']] == 'variable') {
					scrl.anims.push([$wrp, w_siz]);
				}

				//	animate items
				if (opts.usePadding) {
					var l_new_m = l_new.data('cfs_origCssMargin');
					if (pR >= 0) {
						l_new_m += opts.padding[opts.d[1]];
					}
					l_new.css(opts.d['marginRight'], l_new_m);

					if (l_cur.not(l_old).length) {
						var a_old = {};
							a_old[opts.d['marginRight']] = l_old.data('cfs_origCssMargin');
						scrl.anims.push([l_old, a_old]);
					}

					var c_new_m = l_cur.data('cfs_origCssMargin');
					if (pL >= 0) {
						c_new_m += opts.padding[opts.d[3]];
					}
					var a_cur = {};
						a_cur[opts.d['marginRight']] = c_new_m;
					scrl.anims.push([l_cur, a_cur]);

				}

				//	animate carousel
				a_cfs[opts.d['left']] = -i_siz;
				if (pL < 0) {
					a_cfs[opts.d['left']] += pL;
				}

				//	onBefore callback
				var args = [c_old, c_new, w_siz, a_dur];
				if (sO.onBefore) sO.onBefore.apply($tt0, args);
				clbk.onBefore = sc_callCallbacks(clbk.onBefore, $tt0, args);



				//	ALTERNATIVE EFFECTS

				//	extra animation arrays
				switch(sO.fx) {
					case 'fade':
					case 'crossfade':
					case 'cover':
					case 'uncover':
						scrl.pre = sc_setScroll(scrl.duration, scrl.easing);
						scrl.post = sc_setScroll(scrl.duration, scrl.easing);
						scrl.duration = 0;
						break;
				}

				//	create copy
				switch(sO.fx) {
					case 'crossfade':
					case 'cover':
					case 'uncover':
						var $cf2 = $cfs.clone().appendTo($wrp);
						break;
				}
				switch(sO.fx) {
					case 'uncover':
						$cf2.children().slice(opts.items.visibleConf.old).remove();
						break;
					case 'crossfade':
					case 'cover':
						$cf2.children().slice(0, nI).remove();
						$cf2.children().slice(opts.items.visible).remove();
						break;
				}

				//	animations
				switch(sO.fx) {
					case 'fade':
						scrl.pre.anims.push([$cfs, { 'opacity': 0 }]);
						break;
					case 'crossfade':
						$cf2.css({ 'opacity': 0 });
						scrl.pre.anims.push([$cfs, { 'width': '+=0' }, function() { $cf2.remove(); }]);
						scrl.post.anims.push([$cf2, { 'opacity': 1 }]);
						break;
					case 'cover':
						scrl = fx_cover(scrl, $cfs, $cf2, opts, false);
						break;
					case 'uncover':
						scrl = fx_uncover(scrl, $cfs, $cf2, opts, false, nI);
						break;
				}

				//	/ALTERNATIVE EFFECTS


				//	complete callback
				var a_complete = function() {

					var overFill = opts.items.visible+nI-itms.total,
						new_m = (opts.usePadding) ? opts.padding[opts.d[3]] : 0;
					$cfs.css(opts.d['left'], new_m);
					if (overFill > 0) {
						$cfs.children().slice(itms.total).remove();
					}
					var l_itm = $cfs.children().slice(0, nI).appendTo($cfs).last();
					if (overFill > 0) {
						c_new = gi_getCurrentItems(a_itm, opts);
					}
					if (hiddenitems) {
						hiddenitems.each(function() {
							var hi = $(this);
							if (!hi.data('isHidden')) hi.show();
						});
					}
					if (opts.usePadding) {
						if (itms.total < opts.items.visible+nI) {
							var l_cur = $cfs.children().eq(opts.items.visible-1);
							l_cur.css(opts.d['marginRight'], l_cur.data('cfs_origCssMargin') + opts.padding[opts.d[3]]);
						}
						l_itm.css(opts.d['marginRight'], l_itm.data('cfs_origCssMargin'));
					}

					scrl.anims = [];
					if (scrl.pre) scrl.pre = sc_setScroll(scrl.orgDuration, scrl.easing);

					var fn = function() {
						switch(sO.fx) {
							case 'fade':
							case 'crossfade':
								$cfs.css('filter', '');
								break;
						}

						scrl.post = sc_setScroll(0, null);
						crsl.isScrolling = false;

						var args = [c_old, c_new, w_siz];
						if (sO.onAfter) sO.onAfter.apply($tt0, args);
						clbk.onAfter = sc_callCallbacks(clbk.onAfter, $tt0, args);

						if (queu.length) {
							$cfs.trigger(cf_e(queu[0][0], conf), queu[0][1]);
							queu.shift();
						}
						if (!crsl.isPaused) $cfs.trigger(cf_e('play', conf));
					};
					switch(sO.fx) {
						case 'fade':
							scrl.pre.anims.push([$cfs, { 'opacity': 1 }, fn]);
							sc_startScroll(scrl.pre);
							break;
						case 'uncover':
							scrl.pre.anims.push([$cfs, { 'width': '+=0' }, fn]);
							sc_startScroll(scrl.pre);
							break;
						default:
							fn();
							break;
					}
				};

				scrl.anims.push([$cfs, a_cfs, a_complete]);
				crsl.isScrolling = true;
				tmrs = sc_clearTimers(tmrs);
				sc_startScroll(scrl);
				cf_setCookie(opts.cookie, $cfs.triggerHandler(cf_e('currentPosition', conf)));

				$cfs.trigger(cf_e('updatePageStatus', conf), [false, w_siz]);

				return true;
			});

			//	slideTo event
			$cfs.bind(cf_e('slideTo', conf), function(e, num, dev, org, obj, dir, clb) {
				e.stopPropagation();

				var v = [num, dev, org, obj, dir, clb],
					t = ['string/number/object', 'number', 'boolean', 'object', 'string', 'function'],
					a = cf_sortParams(v, t);
				
				var obj = a[3],
					dir = a[4],
					clb = a[5];

				num = gn_getItemIndex(a[0], a[1], a[2], itms, $cfs);

				if (num == 0) return;
				if (typeof obj != 'object') obj = false;

				if (crsl.isScrolling) {
					if (typeof obj != 'object' || obj.duration > 0) return false;
				}

				if (dir != 'prev' && dir != 'next') {
					if (opts.circular) {
						if (num <= itms.total / 2) 	dir = 'next';
						else 						dir = 'prev';
					} else {
						if (itms.first == 0 ||
							itms.first > num)		dir = 'next';
						else						dir = 'prev';
					}
				}

				if (dir == 'prev') num = itms.total-num;
				$cfs.trigger(cf_e(dir, conf), [obj, num, clb]);

				return true;
			});

			//	prevPage event
			$cfs.bind(cf_e('prevPage', conf), function(e, obj, clb) {
				e.stopPropagation();
				var cur = $cfs.triggerHandler(cf_e('currentPage', conf));
				return $cfs.triggerHandler(cf_e('slideToPage', conf), [cur-1, obj, 'prev', clb]);
			});

			//	nextPage event
			$cfs.bind(cf_e('nextPage', conf), function(e, obj, clb) {
				e.stopPropagation();
				var cur = $cfs.triggerHandler(cf_e('currentPage', conf));
				return $cfs.triggerHandler(cf_e('slideToPage', conf), [cur+1, obj, 'next', clb]);
			});

			//	slideToPage event
			$cfs.bind(cf_e('slideToPage', conf), function(e, pag, obj, dir, clb) {
				e.stopPropagation();
				if (typeof pag != 'number') pag = $cfs.triggerHandler(cf_e('currentPage', conf));
				var ipp = opts.pagination.items || opts.items.visible,
					max = Math.ceil(itms.total / ipp)-1;
				if (pag < 0)	pag = max;
				if (pag > max)	pag = 0;
				return $cfs.triggerHandler(cf_e('slideTo', conf), [pag*ipp, 0, true, obj, dir, clb]);
			});

			//	jumpToStart event
			$cfs.bind(cf_e('jumpToStart', conf), function(e, s) {
				e.stopPropagation();
				if (s)	s = gn_getItemIndex(s, 0, true, itms, $cfs);
				else 	s = 0;

				s += itms.first;
				if (s != 0) {
					while (s > itms.total) s -= itms.total;
					$cfs.prepend($cfs.children().slice(s, itms.total));
				}
				return true;
			});

			//	synchronise event
			$cfs.bind(cf_e('synchronise', conf), function(e, s) {
				e.stopPropagation();
					 if (s) 				s = cf_getSynchArr(s);
				else if (opts.synchronise)	s = opts.synchronise;
				else return debug(conf, 'No carousel to synchronise.');

				var n = $cfs.triggerHandler(cf_e('currentPosition', conf)),
					x = true;
				for (var j = 0, l = s.length; j < l; j++) {
					if (!s[j][0].triggerHandler(cf_e('slideTo', conf), [n, s[j][3], true])) {
						x = false;
					}
				}
				return x;
			});

			//	queue event
			$cfs.bind(cf_e('queue', conf), function(e, dir, opt) {
				e.stopPropagation();
				if (typeof dir == 'function') {
					dir.call($tt0, queu);
				} else if (is_array(dir)) {
					queu = dir;
				} else if (typeof dir != 'undefined') {
					queu.push([dir, opt]);
				}
				return queu;
			});

			//	insertItem event
			$cfs.bind(cf_e('insertItem', conf), function(e, itm, num, org, dev) {
				e.stopPropagation();

				var v = [itm, num, org, dev],
					t = ['string/object', 'string/number/object', 'boolean', 'number'],
					a = cf_sortParams(v, t);
				
				var itm = a[0],
					num = a[1],
					org = a[2],
					dev = a[3];

				if (typeof itm == 'object' && 
					typeof itm.jquery == 'undefined')	itm = $(itm);
				if (typeof itm == 'string') 			itm = $(itm);
				if (typeof itm != 'object' ||
					typeof itm.jquery == 'undefined' || 
					itm.length == 0) return debug(conf, 'Not a valid object.');

				if (typeof num == 'undefined') num = 'end';

				if (opts.usePadding) {
					itm.each(function() {
						var m = parseInt($(this).css(opts.d['marginRight']));
						if (isNaN(m)) m = 0;
						$(this).data('cfs_origCssMargin', m);
					});
				}

				var orgNum = num,
					before = 'before';

				if (num == 'end') {
					if (org) {
						if (itms.first == 0) {
							num = itms.total-1;
							before = 'after';
						} else {
							num = itms.first;
							itms.first += itm.length
						}
						if (num < 0) num = 0;
					} else {
						num = itms.total-1;
						before = 'after';
					}
				} else {
					num = gn_getItemIndex(num, dev, org, itms, $cfs);
				}
				if (orgNum != 'end' && !org) {
					if (num < itms.first) itms.first += itm.length;
				}
				if (itms.first >= itms.total) itms.first -= itms.total;

				var $cit = $cfs.children().eq(num);
				if ($cit.length) {
					$cit[before](itm);
				} else {
					$cfs.append(itm);
				}

				itms.total = $cfs.children().length;

				var sz = $cfs.triggerHandler('updateSizes');
				nv_showNavi(opts, itms.total, conf);
				nv_enableNavi(opts, itms.first, conf);
				$cfs.trigger(cf_e('linkAnchors', conf));
				$cfs.trigger(cf_e('updatePageStatus', conf), [true, sz]);

				return true;
			});

			//	removeItem event
			$cfs.bind(cf_e('removeItem', conf), function(e, num, org, dev) {
				e.stopPropagation();
				
				var v = [num, org, dev],
					t = ['string/number/object', 'boolean', 'number'],
					a = cf_sortParams(v, t);
				
				num = a[0];
				org = a[1];
				dev = a[2];

				var removed = false;
				if (num instanceof $ && num.length > 1)
				{
					$removed = $();
					num.each(function(i, el) {
						var $rem = $cfs.trigger(cf_e('removeItem', conf), [$(this), org, dev]);
						if ($rem) $removed = $removed.add($rem);
					});
					return $removed;
				}

				if (typeof num == 'undefined' || num == 'end') {
					$removed = $cfs.children().last();
				} else {
					num = gn_getItemIndex(num, dev, org, itms, $cfs);
					var $removed = $cfs.children().eq(num);
					if ($removed.length){
						if (num < itms.first) itms.first -= $removed.length;
					}
				}
				if ($removed && $removed.length) {
					$removed.detach();
					itms.total = $cfs.children().length;
					var sz = $cfs.triggerHandler('updateSizes');
					nv_showNavi(opts, itms.total, conf);
					nv_enableNavi(opts, itms.first, conf);
					$cfs.trigger(cf_e('updatePageStatus', conf), [true, sz]);
				}			

				return $removed;
			});

			//	onBefore and onAfter event
			$cfs.bind(cf_e('onBefore', conf)+' '+cf_e('onAfter', conf), function(e, fn) {
				e.stopPropagation();
				var eType = e.type.slice(conf.events.prefix.length);
				if (is_array(fn))				clbk[eType] = fn;
				if (typeof fn == 'function')	clbk[eType].push(fn);
				return clbk[eType];
			});

			//	currentPosition event
			$cfs.bind(cf_e('currentPosition', conf), function(e, fn) {
				e.stopPropagation();
				if (itms.first == 0) var val = 0;
				else var val = itms.total - itms.first;
				if (typeof fn == 'function') fn.call($tt0, val);
				return val;
			});

			//	currentPage event
			$cfs.bind(cf_e('currentPage', conf), function(e, fn) {
				e.stopPropagation();
				var ipp = opts.pagination.items || opts.items.visible;
				var max = Math.ceil(itms.total/ipp-1);
				if (itms.first == 0) 							var nr = 0;
				else if (itms.first < itms.total % ipp) 		var nr = 0;
				else if (itms.first == ipp && !opts.circular) 	var nr = max;
				else 											var nr = Math.round((itms.total-itms.first)/ipp);
				if (nr < 0) nr = 0;
				if (nr > max) nr = max;
				if (typeof fn == 'function') fn.call($tt0, nr);
				return nr;
			});

			//	currentVisible event
			$cfs.bind(cf_e('currentVisible', conf), function(e, fn) {
				e.stopPropagation();
				$i = gi_getCurrentItems($cfs.children(), opts);
				if (typeof fn == 'function') fn.call($tt0, $i);
				return $i;
			});
			
			//	slice event
			$cfs.bind(cf_e('slice', conf), function(e, f, l, fn) {
				e.stopPropagation();

				if (itms.total == 0) return false;

				var v = [f, l, fn],
					t = ['number', 'number', 'function'],
					a = cf_sortParams(v, t);

				f = (typeof a[0] == 'number') ? a[0] : 0;
				l = (typeof a[1] == 'number') ? a[1] : itms.total;
				fn = a[2];
				
				f += itms.first;
				l += itms.first;

				while (f > itms.total) { f -= itms.total }
				while (l > itms.total) { l -= itms.total }
				while (f < 0) { f += itms.total }
				while (l < 0) { l += itms.total }

				var $iA = $cfs.children();

				if (l > f) {
					var $i = $iA.slice(f, l);	
				} else {
					var $i = $( $iA.slice(f, itms.total).get().concat( $iA.slice(0, l).get() ) );
				}

				if (typeof fn == 'function') fn.call($tt0, $i);
				return $i;
			});

			//	isPaused, isStopped and isScrolling events
			$cfs.bind(cf_e('isPaused', conf)+' '+cf_e('isStopped', conf)+' '+cf_e('isScrolling', conf), function(e, fn) {
				e.stopPropagation();
				var eType = e.type.slice(conf.events.prefix.length);
				if (typeof fn == 'function') fn.call($tt0, crsl[eType]);
				return crsl[eType];
			});

			//	configuration event
			$cfs.bind(cf_e('configuration', conf), function(e, a, b, c) {
				e.stopPropagation();
				var reInit = false;

				//	return entire configuration-object
				if (typeof a == 'function') {
					a.call($tt0, opts);

				//	set multiple options via object
				} else if (typeof a == 'object') {
					opts_orig = $.extend(true, {}, opts_orig, a);
					if (b !== false) reInit = true;
					else opts = $.extend(true, {}, opts, a);

				} else if (typeof a != 'undefined') {

					//	callback function for specific option
					if (typeof b == 'function') {
						var val = eval('opts.'+a);
						if (typeof val == 'undefined') val = '';
						b.call($tt0, val);

					//	set individual option
					} else if (typeof b != 'undefined') {
						if (typeof c !== 'boolean') c = true;
						eval('opts_orig.'+a+' = b');
						if (c !== false) reInit = true;
						else eval('opts.'+a+' = b');

					//	return value for specific option
					} else {
						return eval('opts.'+a);
					}
				}
				if (reInit) {
					sz_resetMargin($cfs.children(), opts);
					$cfs._cfs_init(opts_orig);
					$cfs._cfs_bind_buttons();
					var siz = sz_setSizes($cfs, opts, false);
					$cfs.trigger(cf_e('updatePageStatus', conf), [true, siz]);
				}
				return opts;
			});

			//	linkAnchors event
			$cfs.bind(cf_e('linkAnchors', conf), function(e, $con, sel) {
				e.stopPropagation();
				if (typeof $con == 'undefined' || $con.length == 0) $con = $('body');
				else if (typeof $con == 'string') $con = $($con);
				if (typeof $con != 'object') return debug(conf, 'Not a valid object.');
				if (typeof sel != 'string' || sel.length == 0) sel = 'a.caroufredsel';
				$con.find(sel).each(function() {
					var h = this.hash || '';
					if (h.length > 0 && $cfs.children().index($(h)) != -1) {
						$(this).unbind('click').click(function(e) {
							e.preventDefault();
							$cfs.trigger(cf_e('slideTo', conf), h);
						});
					}
				});
				return true;
			});

			//	updatePageStatus event
			$cfs.bind(cf_e('updatePageStatus', conf), function(e, build, sizes) {
				e.stopPropagation();
				if (!opts.pagination.container) return;
				
				if (build) {
					var ipp = opts.pagination.items || opts.items.visible,
						l = Math.ceil(itms.total/ipp);

					if (opts.pagination.anchorBuilder) {
						opts.pagination.container.children().remove();
						opts.pagination.container.each(function() {
							for (var a = 0; a < l; a++) {
								var i = $cfs.children().eq( gn_getItemIndex(a*ipp, 0, true, itms, $cfs) );
								$(this).append(opts.pagination.anchorBuilder(a+1, i));
							}
						});
					}
					opts.pagination.container.each(function() {
						$(this).children().unbind(opts.pagination.event).each(function(a) {
							$(this).bind(opts.pagination.event, function(e) {
								e.preventDefault();
								$cfs.trigger(cf_e('slideTo', conf), [a*ipp, 0, true, opts.pagination]);
							});
						});
					});
				}
				opts.pagination.container.each(function() {
					$(this).children().removeClass(cf_c('selected', conf)).eq($cfs.triggerHandler(cf_e('currentPage', conf))).addClass(cf_c('selected', conf));
				});
				return true;
			});

			//	updateSizes event
			$cfs.bind(cf_e('updateSizes', conf), function(e) {
				var a_itm = $cfs.children(),
					vI = opts.items.visible;

					 if (opts.items.visibleConf.variable)	vI = gn_getVisibleItemsNext(a_itm, opts, 0);
				else if (opts.items.filter != '*') 			vI = gn_getVisibleItemsNextFilter(a_itm, opts, 0);

				if (!opts.circular && itms.first != 0 && vI > itms.first) {
					if (opts.items.visibleConf.variable) {
						var nI = gn_getVisibleItemsPrev(a_itm, opts, itms.first) - itms.first;
					} else if (opts.items.filter != '*') {
						var nI = gn_getVisibleItemsPrevFilter(a_itm, opts, itms.first) - itms.first;
					} else {
						nI = opts.items.visible - itms.first;
					}
					debug(conf, 'Preventing non-circular: sliding '+nI+' items backward.');
					$cfs.trigger('prev', nI);
				}
				opts.items.visible = cf_getItemsAdjust(vI, opts, opts.items.visibleConf.adjust, $tt0);
				return sz_setSizes($cfs, opts);
			});

			//	destroy event
			$cfs.bind(cf_e('destroy', conf), function(e, orgOrder) {
				e.stopPropagation();
				tmrs = sc_clearTimers(tmrs);

				$cfs.data('cfs_isCarousel', false);
				$cfs.trigger(cf_e('finish', conf));
				if (orgOrder) {
					$cfs.trigger(cf_e('jumpToStart', conf));
				}
				if (opts.usePadding) {
					sz_resetMargin($cfs.children(), opts);
				}

				$cfs.css($cfs.data('cfs_origCss'));
				$cfs._cfs_unbind_events();
				$cfs._cfs_unbind_buttons();
				$wrp.replaceWith($cfs);

				return true;
			});
			
			//	triggerEvent, making prefixed and namespaced events accessible from the outside
			$cfs.bind('_cfs_triggerEvent', function(e, n, o) {
				e.stopPropagation();
				return $cfs.triggerHandler(cf_e(n, conf), o);
			});
		};	//	/bind_events

		$cfs._cfs_unbind_events = function() {
			$cfs.unbind(cf_e('', conf));
			$cfs.unbind(cf_e('', conf, false));
			$cfs.unbind('_cfs_triggerEvent');
		};	//	/unbind_events

		$cfs._cfs_bind_buttons = function() {
			$cfs._cfs_unbind_buttons();
			nv_showNavi(opts, itms.total, conf);
			nv_enableNavi(opts, itms.first, conf);

			if (opts.auto.pauseOnHover) {
				var pC = bt_pauseOnHoverConfig(opts.auto.pauseOnHover);
				$wrp.bind(cf_e('mouseenter', conf, false), function() { $cfs.trigger(cf_e('pause', conf), pC);	})
					.bind(cf_e('mouseleave', conf, false), function() { $cfs.trigger(cf_e('resume', conf));		});
			}

			if (opts.auto.button) {
				opts.auto.button.bind(cf_e(opts.auto.event, conf, false), function(e) {
					e.preventDefault();
					var ev = false,
						pC = null;

					if (crsl.isPaused) {
						ev = 'play';
					} else if (opts.auto.pauseOnEvent) {
						ev = 'pause';
						pC = bt_pauseOnHoverConfig(opts.auto.pauseOnEvent);
					}
					if (ev) {
						$cfs.trigger(cf_e(ev, conf), pC);
					}
				});
			}
			if (opts.prev.button) {
				opts.prev.button.bind(cf_e(opts.prev.event, conf, false), function(e) {
					e.preventDefault();
					$cfs.trigger(cf_e('prev', conf));
				});
				if (opts.prev.pauseOnHover) {
					var pC = bt_pauseOnHoverConfig(opts.prev.pauseOnHover);
					opts.prev.button.bind(cf_e('mouseenter', conf, false), function() { $cfs.trigger(cf_e('pause', conf), pC);	})
									.bind(cf_e('mouseleave', conf, false), function() { $cfs.trigger(cf_e('resume', conf));		});
				}
			}

			if (opts.next.button) {
				opts.next.button.bind(cf_e(opts.next.event, conf, false), function(e) {
					e.preventDefault();
					$cfs.trigger(cf_e('next', conf));
				});
				if (opts.next.pauseOnHover) {
					var pC = bt_pauseOnHoverConfig(opts.next.pauseOnHover);
					opts.next.button.bind(cf_e('mouseenter', conf, false), function() { $cfs.trigger(cf_e('pause', conf), pC); 	})
									.bind(cf_e('mouseleave', conf, false), function() { $cfs.trigger(cf_e('resume', conf));		});
				}
			}
			if ($.fn.mousewheel) {
				if (opts.prev.mousewheel) {
					if (!crsl.mousewheelPrev) {
						crsl.mousewheelPrev = true;
						$wrp.mousewheel(function(e, delta) { 
							if (delta > 0) {
								e.preventDefault();
								var num = bt_mousesheelNumber(opts.prev.mousewheel);
								$cfs.trigger(cf_e('prev', conf), num);
							}
						});
					}
				}
				if (opts.next.mousewheel) {
					if (!crsl.mousewheelNext) {
						crsl.mousewheelNext = true;
						$wrp.mousewheel(function(e, delta) { 
							if (delta < 0) {
								e.preventDefault();
								var num = bt_mousesheelNumber(opts.next.mousewheel);
								$cfs.trigger(cf_e('next', conf), num);
							}
						});
					}
				}
			}
			if ($.fn.touchwipe) {
				var wP = (opts.prev.wipe) ? function() { $cfs.trigger(cf_e('prev', conf)) } : null,
					wN = (opts.next.wipe) ? function() { $cfs.trigger(cf_e('next', conf)) } : null;

				if (wN || wN) {
					if (!crsl.touchwipe) {
						crsl.touchwipe = true;
						var twOps = {
							'min_move_x': 30,
							'min_move_y': 30,
							'preventDefaultEvents': true
						};
						switch (opts.direction) {
							case 'up':
							case 'down':
								twOps.wipeUp = wP;
								twOps.wipeDown = wN;
								break;
							default:
								twOps.wipeLeft = wN;
								twOps.wipeRight = wP;
						}
						$wrp.touchwipe(twOps);
					}
				}
			}
			if (opts.pagination.container) {
				if (opts.pagination.pauseOnHover) {
					var pC = bt_pauseOnHoverConfig(opts.pagination.pauseOnHover);
					opts.pagination.container.bind(cf_e('mouseenter', conf, false), function() { $cfs.trigger(cf_e('pause', conf), pC);	})
											 .bind(cf_e('mouseleave', conf, false), function() { $cfs.trigger(cf_e('resume', conf));	});
				}
			}
			if (opts.prev.key || opts.next.key) {
				$(document).bind(cf_e('keyup', conf, false, true, true), function(e) {
					var k = e.keyCode;
					if (k == opts.next.key)	{
						e.preventDefault();
						$cfs.trigger(cf_e('next', conf));
					}
					if (k == opts.prev.key) {
						e.preventDefault();
						$cfs.trigger(cf_e('prev', conf));
					}
				});
			}
			if (opts.pagination.keys) {
				$(document).bind(cf_e('keyup', conf, false, true, true), function(e) {
					var k = e.keyCode;
					if (k >= 49 && k < 58) {
						k = (k-49) * opts.items.visible;
						if (k <= itms.total) {
							e.preventDefault();
							$cfs.trigger(cf_e('slideTo', conf), [k, 0, true, opts.pagination]);
						}
					}
				});
			}
			if (opts.auto.play) {
				$cfs.trigger(cf_e('play', conf), opts.auto.delay);
			}

			if (crsl.upDateOnWindowResize) {
				var $w = $(window),
					_windowWidth = $w.width(),
					_windowHeight = $w.height();
			
				$w.bind(cf_e('resize', conf, false, true, true), function(e) {
					if ($w.width() != _windowWidth || $w.height() != _windowHeight) {
						$cfs.trigger(cf_e('finish', conf));
						if (opts.auto.pauseOnResize && !crsl.isPaused) {
							$cfs.trigger(cf_e('play', conf));
						}
						sz_resetMargin($cfs.children(), opts);
						$cfs._cfs_init(opts_orig);
						var siz = sz_setSizes($cfs, opts, false);
						$cfs.trigger(cf_e('updatePageStatus', conf), [true, siz]);
				
						_windowWidth = $w.width();
						_windowHeight = $w.height();
					}
				});
			}

		};	//	/bind_buttons

		$cfs._cfs_unbind_buttons = function() {
			var ns1 = cf_e('', conf),
				ns2 = cf_e('', conf, false);
				ns3 = cf_e('', conf, false, true, true);

			$(document).unbind(ns3);
			$(window).unbind(ns3);
			$wrp.unbind(ns2);

			if (opts.auto.button) opts.auto.button.unbind(ns2);
			if (opts.prev.button) opts.prev.button.unbind(ns2);
			if (opts.next.button) opts.next.button.unbind(ns2);
			if (opts.pagination.container) {
				opts.pagination.container.unbind(ns2);
				if (opts.pagination.anchorBuilder) {
					opts.pagination.container.children().remove();
				}
			}

			nv_showNavi(opts, 'hide', conf);
			nv_enableNavi(opts, 'removeClass', conf);

		};	//	/unbind_buttons



		//	START

		var crsl = {
				'direction'		: 'next',
				'isPaused'		: true,
				'isScrolling'	: false,
				'isStopped'		: false,

				'mousewheelNext': false,
				'mousewheelPrev': false,
				'touchwipe'		: false
			},
			itms = {
				'total'			: $cfs.children().length,
				'first'			: 0
			},
			tmrs = {
				'timer'			: null,
				'auto'			: null,
				'queue'			: null,
				'startTime'		: getTime(),
				'timePassed'	: 0
			},
			scrl = {
				'isStopped'		: false,
				'duration'		: 0,
				'startTime'		: 0,
				'easing'		: '',
				'anims'			: []
			},
			clbk = {
				'onBefore'		: [],
				'onAfter'		: []
			},
			queu = [],
			conf = $.extend(true, {}, $.fn.carouFredSel.configs, configs),
			opts = {},
			opts_orig = options,
			$wrp = $cfs.wrap('<'+conf.wrapper.element+' class="'+conf.wrapper.classname+'" />').parent();

		conf.selector		= $cfs.selector;
		conf.serialNumber	= $.fn.carouFredSel.serialNumber++;

		//	create carousel
		$cfs._cfs_init(opts_orig, true, starting_position);
		$cfs._cfs_build();
		$cfs._cfs_bind_events();
		$cfs._cfs_bind_buttons();

		//	find item to start
		if (is_array(opts.items.start)) {
			var start_arr = opts.items.start;
		} else {
			var start_arr = [];
			if (opts.items.start != 0) {
				start_arr.push(opts.items.start);
			}
		}
		if (opts.cookie) {
			start_arr.unshift(cf_readCookie(opts.cookie));
		}
		if (start_arr.length > 0) {
			for (var a = 0, l = start_arr.length; a < l; a++) {
				var s = start_arr[a];
				if (s == 0) {
					continue;
				}
				if (s === true) {
					s = window.location.hash;
					if (s.length < 1) {
						continue;
					}
				} else if (s === 'random') {
					s = Math.floor(Math.random()*itms.total);
				}
				if ($cfs.triggerHandler(cf_e('slideTo', conf), [s, 0, true, { fx: 'none' }])) {
					break;
				}
			}
		}
		var siz = sz_setSizes($cfs, opts, false),
			itm = gi_getCurrentItems($cfs.children(), opts);

		if (opts.onCreate) {
			opts.onCreate.call($tt0, itm, siz);
		}

		$cfs.trigger(cf_e('updatePageStatus', conf), [true, siz]);
		$cfs.trigger(cf_e('linkAnchors', conf));

		return $cfs;
	};


	//	GLOBAL PUBLIC

	$.fn.carouFredSel.serialNumber = 1;
	$.fn.carouFredSel.defaults = {
		'synchronise'	: false,
		'infinite'		: true,
		'circular'		: true,
		'responsive'	: false,
		'direction'		: 'left',
		'items'			: {
			'start'			: 0
		},
		'scroll'		: {
			'easing'		: 'swing',
			'duration'		: 500,
			'pauseOnHover'	: false,
			'mousewheel'	: false,
			'wipe'			: false,
			'event'			: 'click',
			'queue'			: false
		}
	};
	$.fn.carouFredSel.configs = {
		'debug'			: false,
		'events'		: {
			'prefix'		: '',
			'namespace'		: 'cfs'
		},
		'wrapper'		: {
			'element'		: 'div',
			'classname'		: 'caroufredsel_wrapper'
		},
		'classnames'	: {}
	};
	$.fn.carouFredSel.pageAnchorBuilder = function(nr, itm) {
		return '<a href="#"><span>'+nr+'</span></a>';
	};


	//	GLOBAL PRIVATE

	//	scrolling functions
	function sc_setScroll(d, e) {
		return {
			anims		: [],
			duration	: d,
			orgDuration	: d,
			easing		: e,
			startTime	: getTime()
		};
	}
	function sc_startScroll(s) {
		if (typeof s.pre == 'object') {
			sc_startScroll(s.pre);
		}
		for (var a = 0, l = s.anims.length; a < l; a++) {
			var b = s.anims[a];
			if (!b) continue;
			if (b[3]) b[0].stop();
			b[0].animate(b[1], {
				complete: b[2],
				duration: s.duration,
				easing: s.easing
			});
		}
		if (typeof s.post == 'object') {
			sc_startScroll(s.post);
		}
	}
	function sc_stopScroll(s, finish) {
		if (typeof finish != 'boolean') finish = true;
		if (typeof s.pre == 'object') {
			sc_stopScroll(s.pre, finish);
		}
		for (var a = 0, l = s.anims.length; a < l; a++) {
			var b = s.anims[a];
			b[0].stop(true);
			if (finish) {
				b[0].css(b[1]);
				if (typeof b[2] == 'function') b[2]();
			}
		}
		if (typeof s.post == 'object') {
			sc_stopScroll(s.post, finish);
		}
	}
	function sc_clearTimers(t) {
		if (t.auto) clearTimeout(t.auto);
		return t;
	}
	function sc_callCallbacks(cbs, t, args) {
		if (cbs.length) {
			for (var a = 0, l = cbs.length; a < l; a++) {
				cbs[a].apply(t, args);
			}
		}
		return [];
	}

	//	fx functions
	function fx_fade(sO, c, x, d, f) {
		var o = {
			'duration'	: d,
			'easing'	: sO.easing
		};
		if (typeof f == 'function') o.complete = f;
		c.animate({
			opacity: x
		}, o);
	}
	function fx_cover(sc, c1, c2, o, prev) {
		var old_w = ms_getSizes(gi_getOldItemsNext(c1.children(), o), o, true)[0],
			new_w = ms_getSizes(c2.children(), o, true)[0],
			cur_l = (prev) ? -new_w : old_w,
			css_o = {},
			ani_o = {};

		css_o[o.d['width']] = new_w;
		css_o[o.d['left']] = cur_l;
		ani_o[o.d['left']] = 0;
		
		sc.pre.anims.push([c1, { 'opacity': 1 }]);
		sc.post.anims.push([c2, ani_o, function() { $(this).remove(); }]);
		c2.css(css_o);
		return sc;
	}
	function fx_uncover(sc, c1, c2, o, prev, n) {
		var new_w = ms_getSizes(gi_getNewItemsNext(c1.children(), o, n), o, true)[0],
			old_w = ms_getSizes(c2.children(), o, true)[0],
			cur_l = (prev) ? -old_w : new_w,
			css_o = {},
			ani_o = {};

		css_o[o.d['width']] = old_w;
		css_o[o.d['left']] = 0;
		ani_o[o.d['left']] = cur_l;
		sc.post.anims.push([c2, ani_o, function() { $(this).remove(); }]);
		c2.css(css_o);
		return sc;
	}

	//	navigation functions
	function nv_showNavi(o, t, c) {
		if (t == 'show' || t == 'hide') {
			var f = t;
		} else if (o.items.minimum >= t) {
			debug(c, 'Not enough items: hiding navigation ('+t+' items, '+o.items.minimum+' needed).');
			var f = 'hide';
		} else {
			var f = 'show';
		}
		var s = (f == 'show') ? 'removeClass' : 'addClass',
			h = cf_c('hidden', c);
		if (o.auto.button) o.auto.button[f]()[s](h);
		if (o.prev.button) o.prev.button[f]()[s](h);
		if (o.next.button) o.next.button[f]()[s](h);
		if (o.pagination.container) o.pagination.container[f]()[s](h);
	}
	function nv_enableNavi(o, f, c) {
		if (o.circular || o.infinite) return;
		var fx = (f == 'removeClass' || f == 'addClass') ? f : false,
			di = cf_c('disabled', c);
		if (o.auto.button && fx) {
			o.auto.button[fx](di);
		}
		if (o.prev.button) {
			var fn = fx || (f == 0) ? 'addClass' : 'removeClass';
			o.prev.button[fn](di);
		}
		if (o.next.button) {
			var fn = fx || (f == o.items.visible) ? 'addClass' : 'removeClass';
			o.next.button[fn](di);
		}
	}

	//	get object functions
	function go_getObject($tt, obj) {
		if (typeof obj == 'function')	obj = obj.call($tt);
		if (typeof obj == 'undefined')	obj = {};
		return obj;
	}
	function go_getNaviObject($tt, obj, type) {
		if (typeof type != 'string') type = '';

		obj = go_getObject($tt, obj);
		if (typeof obj == 'string') {
			var temp = cf_getKeyCode(obj);
			if (temp == -1) obj = $(obj);
			else 			obj = temp;
		}

		//	pagination
		if (type == 'pagination') {
			if (typeof obj 				== 'boolean')	obj = { 'keys': obj };
			if (typeof obj.jquery 		!= 'undefined')	obj = { 'container': obj };
			if (typeof obj.container	== 'function')	obj.container = obj.container.call($tt);
			if (typeof obj.container	== 'string')	obj.container = $(obj.container);
			if (typeof obj.items		!= 'number')	obj.items = false;

		//	auto
		} else if (type == 'auto') {
			if (typeof obj.jquery	!= 'undefined')		obj = { 'button': obj };
			if (typeof obj == 'boolean')				obj = { 'play': obj };
			if (typeof obj == 'number')					obj = { 'pauseDuration': obj };
			if (typeof obj.button		== 'function')	obj.button = obj.button.call($tt);
			if (typeof obj.button		== 'string')	obj.button = $(obj.button);

		//	prev + next
		} else {
			if (typeof obj.jquery		!= 'undefined')	obj = { 'button': obj };
			if (typeof obj 				== 'number')	obj = { 'key': obj };
			if (typeof obj.button		== 'function')	obj.button = obj.button.call($tt);
			if (typeof obj.button		== 'string')	obj.button = $(obj.button);
			if (typeof obj.key			== 'string')	obj.key = cf_getKeyCode(obj.key);
		}			

		return obj;
	}

	//	get number functions
	function gn_getItemIndex(num, dev, org, items, $cfs) {
		if (typeof num == 'string') {
			if (isNaN(num)) num = $(num);
			else 			num = parseInt(num);
		}
		if (typeof num == 'object') {
			if (typeof num.jquery == 'undefined') num = $(num);
			num = $cfs.children().index(num);
			if (num == -1) num = 0;
			if (typeof org != 'boolean') org = false;
		} else {
			if (typeof org != 'boolean') org = true;
		}
		if (isNaN(num))	num = 0;
		else 			num = parseInt(num);
		if (isNaN(dev))	dev = 0;
		else 			dev = parseInt(dev);

		if (org) {
			num += items.first;
		}
		num += dev;
		if (items.total > 0) {
			while (num >= items.total)	{	num -= items.total; }
			while (num < 0)				{	num += items.total; }
		}
		return num;
	}

	//	items prev
	function gn_getVisibleItemsPrev(i, o, s) {
		var t = 0,
			x = 0;

		for (var a = s; a >= 0; a--) {
			var j = i.eq(a);
			t += (j.is(':visible')) ? j[o.d['outerWidth']](true) : 0;
			if (t > o.maxDimention) return x;
			if (a == 0) a = i.length;
			x++;
		}
	}
	function gn_getVisibleItemsPrevFilter(i, o, s) {
		return gn_getItemsPrevFilter(i, o.items.filter, o.items.visibleConf.org, s);
	}
	function gn_getScrollItemsPrevFilter(i, o, s, m) {
		return gn_getItemsPrevFilter(i, o.items.filter, m, s);
	}
	function gn_getItemsPrevFilter(i, f, m, s) {
		var t = 0,
			x = 0;
	
		for (var a = s, l = i.length; a >= 0; a--) {
			x++;
			if (x == l) return x;

			var j = i.eq(a);
			if (j.is(f)) {
				t++;
				if (t == m) return x;
			}
			if (a == 0) a = l;
		}
	}

	function gn_getVisibleOrg($c, o) {
		return o.items.visibleConf.org || $c.children().slice(0, o.items.visible).filter(o.items.filter).length;
	}

	//	items next
	function gn_getVisibleItemsNext(i, o, s) {
		var t = 0,
			x = 0;

		for (var a = s, l = i.length-1; a <= l; a++) {
			var j = i.eq(a);

			t += (j.is(':visible')) ? j[o.d['outerWidth']](true) : 0;
			if (t > o.maxDimention) return x;

			x++;
			if (x == l+1) return x;
			if (a == l) a = -1;
		}
	}
	function gn_getVisibleItemsNextTestCircular(i, o, s, l) {
		var v = gn_getVisibleItemsNext(i, o, s);
		if (!o.circular) {
			if (s + v > l) v = l - s;
		}
		return v;
	}
	function gn_getVisibleItemsNextFilter(i, o, s) {
		return gn_getItemsNextFilter(i, o.items.filter, o.items.visibleConf.org, s, o.circular);
	}
	function gn_getScrollItemsNextFilter(i, o, s, m) {
		return gn_getItemsNextFilter(i, o.items.filter, m+1, s, o.circular) - 1;
	}
	function gn_getItemsNextFilter(i, f, m, s, c) {
		var t = 0,
			x = 0;

		for (var a = s, l = i.length-1; a <= l; a++) {
			x++;
			if (x == l) return x;

			var j = i.eq(a);
			if (j.is(f)) {
				t++;
				if (t == m) return x;
			}
			if (a == l) a = -1;
		}
	}

	//	get items functions
	function gi_getCurrentItems(i, o) {
		return i.slice(0, o.items.visible);
	}
	function gi_getOldItemsPrev(i, o, n) {
		return i.slice(n, o.items.visibleConf.old+n);
	}
	function gi_getNewItemsPrev(i, o) {
		return i.slice(0, o.items.visible);
	}
	function gi_getOldItemsNext(i, o) {
		return i.slice(0, o.items.visibleConf.old);
	}
	function gi_getNewItemsNext(i, o, n) {
		return i.slice(n, o.items.visible+n);
	}

	//	sizes functions
	function sz_resetMargin(i, o, m) {
		var x = (typeof m == 'boolean') ? m : false;
		if (typeof m != 'number') m = 0;
		i.each(function() {
			var j = $(this);
			var t = parseInt(j.css(o.d['marginRight']));
			if (isNaN(t)) t = 0;
			j.data('cfs_tempCssMargin', t);
			j.css(o.d['marginRight'], ((x) ? j.data('cfs_tempCssMargin') : m + j.data('cfs_origCssMargin')));
		});
	}
	function sz_setSizes($c, o, p) {
		var $w = $c.parent(),
			$i = $c.children(),
			$v = gi_getCurrentItems($i, o),
			sz = cf_mapWrapperSizes(ms_getSizes($v, o, true), o, p);

		$w.css(sz);

		if (o.usePadding) {
			var p = o.padding,
				r = p[o.d[1]];
			if (o.align) {
				if (r < 0) r = 0;
			}
			var $l = $v.last();
			$l.css(o.d['marginRight'], $l.data('cfs_origCssMargin') + r);
			$c.css(o.d['top'], p[o.d[0]]);
			$c.css(o.d['left'], p[o.d[3]]);
		}

		$c.css(o.d['width'], sz[o.d['width']]+(ms_getTotalSize($i, o, 'width')*2));
		$c.css(o.d['height'], ms_getLargestSize($i, o, 'height'));
		return sz;
	}

	//	measuring functions
	function ms_getSizes(i, o, wrapper) {
		var s1 = ms_getTotalSize(i, o, 'width', wrapper),
			s2 = ms_getLargestSize(i, o, 'height', wrapper);
		return [s1, s2];
	}
	function ms_getLargestSize(i, o, dim, wrapper) {
		if (typeof wrapper != 'boolean') wrapper = false;
		if (typeof o[o.d[dim]] == 'number' && wrapper) return o[o.d[dim]];
		if (typeof o.items[o.d[dim]] == 'number') return o.items[o.d[dim]];
		var di2 = (dim.toLowerCase().indexOf('width') > -1) ? 'outerWidth' : 'outerHeight';
		return ms_getTrueLargestSize(i, o, di2);
	}
	function ms_getTrueLargestSize(i, o, dim) {
		var s = 0;

		for (var a = 0, l = i.length; a < l; a++) {
			var j = i.eq(a);

			var m = (j.is(':visible')) ? j[o.d[dim]](true) : 0;
			if (s < m) s = m;
		}
		return s;
	}
	function ms_getTrueInnerSize($el, o, dim) {
		if (!$el.is(':visible')) return 0;

		var siz = $el[o.d[dim]](),
			arr = (o.d[dim].toLowerCase().indexOf('width') > -1) ? ['paddingLeft', 'paddingRight'] : ['paddingTop', 'paddingBottom'];
		
		for (var a = 0, l = arr.length; a < l; a++) {
			var m = parseInt($el.css(arr[a]));
			siz -= (isNaN(m)) ? 0 : m;
		}
		return siz;
	}
	function ms_getTotalSize(i, o, dim, wrapper) {
		if (typeof wrapper != 'boolean') wrapper = false;
		if (typeof o[o.d[dim]] == 'number' && wrapper) return o[o.d[dim]];
		if (typeof o.items[o.d[dim]] == 'number') return o.items[o.d[dim]] * i.length;
		
		var d = (dim.toLowerCase().indexOf('width') > -1) ? 'outerWidth' : 'outerHeight',
			s = 0;
		
		for (var a = 0, l = i.length; a < l; a++) {
			var j = i.eq(a);
			s += (j.is(':visible')) ? j[o.d[d]](true) : 0;
		}
		return s;
	}
	function ms_hasVariableSizes(i, o, dim) {
		var s = false,
			v = false;
		
		for (var a = 0, l = i.length; a < l; a++) {
			var j = i.eq(a);

			var c = (j.is(':visible')) ? j[o.d[dim]](true) : 0;
			if (s === false) s = c;
			else if (s != c) v = true;
			if (s == 0)		 v = true;
		}
		return v;
	}
	function ms_getPaddingBorderMargin(i, o, d) {
		return i[o.d['outer'+d]](true) - ms_getTrueInnerSize(i, o, 'inner'+d);
	}
	function ms_isPercentage(x) {
		return (typeof x == 'string' && x.slice(-1) == '%');
	}
	function ms_getPercentage(s, o) {
		if (ms_isPercentage(o)) {
			o = o.slice(0, -1);
			if (isNaN(o)) return s;
			s *= o/100;
		}
		return s;
	}

	//	config functions
	function cf_e(n, c, pf, ns, rd) {
		if (typeof pf != 'boolean') pf = true;
		if (typeof ns != 'boolean') ns = true;
		if (typeof rd != 'boolean') rd = false;
		
		if (pf) n = c.events.prefix + n;
		if (ns) n = n +'.'+ c.events.namespace;
		if (ns && rd) n += c.serialNumber;

		return n;
	}
	function cf_c(n, c) {
		return (typeof c.classnames[n] == 'string') ? c.classnames[n] : n;
	}
	function cf_mapWrapperSizes(ws, o, p) {
		if (typeof p != 'boolean') p = true;
		var pad = (o.usePadding && p) ? o.padding : [0, 0, 0, 0];
		var wra = {};
			wra[o.d['width']] = ws[0] + pad[1] + pad[3];
			wra[o.d['height']] = ws[1] + pad[0] + pad[2];

		return wra;
	}
	function cf_sortParams(vals, typs) {
		var arr = [];
		for (var a = 0, l1 = vals.length; a < l1; a++) {
			for (var b = 0, l2 = typs.length; b < l2; b++) {
				if (typs[b].indexOf(typeof vals[a]) > -1 && typeof arr[b] == 'undefined') {
					arr[b] = vals[a];
					break;
				}
			}
		}
		return arr;
	}
	function cf_getPadding(p) {
		if (typeof p == 'undefined') return [0, 0, 0, 0];
		
		if (typeof p == 'number') return [p, p, p, p];
		else if (typeof p == 'string') p = p.split('px').join('').split('em').join('').split(' ');

		if (!is_array(p)) {
			return [0, 0, 0, 0];
		}
		for (var i = 0; i < 4; i++) {
			p[i] = parseInt(p[i]);
		}
		switch (p.length) {
			case 0:	return [0, 0, 0, 0];
			case 1: return [p[0], p[0], p[0], p[0]];
			case 2: return [p[0], p[1], p[0], p[1]];
			case 3: return [p[0], p[1], p[2], p[1]];
			default: return [p[0], p[1], p[2], p[3]];
		}
	}
	function cf_getAlignPadding(itm, o) {
		var x = (typeof o[o.d['width']] == 'number') ? Math.ceil(o[o.d['width']] - ms_getTotalSize(itm, o, 'width')) : 0;
		switch (o.align) {
			case 'left': return [0, x];
			case 'right': return [x, 0];
			case 'center':
			default:
				return [Math.ceil(x/2), Math.floor(x/2)];
		}
	}
	function cf_getAdjust(x, o, a, $t) {
		var v = x;
		if (typeof a == 'function') {
			v = a.call($t, v);

		} else if (typeof a == 'string') {
			var p = a.split('+'),
				m = a.split('-');
			
			if (m.length > p.length) {
				var neg = true,
					sta = m[0],
					adj = m[1];
			} else {
				var neg = false,
					sta = p[0],
					adj = p[1];
			}

			switch(sta) {
				case 'even':
					v = (x % 2 == 1) ? x-1 : x;
					break;
				case 'odd':
					v = (x % 2 == 0) ? x-1 : x;
					break;
				default:
					v = x;
					break;
			}
			adj = parseInt(adj);
			if (!isNaN(adj)) {
				if (neg) adj = -adj;
				v += adj;
			}
		}
		if (typeof v != 'number') v = 1;
		if (v < 1) v = 1;
		return v;
	}
	function cf_getItemsAdjust(x, o, a, $t) {
		return cf_getItemAdjustMinMax(cf_getAdjust(x, o, a, $t), o.items.visibleConf);
	}
	function cf_getItemAdjustMinMax(v, i) {
		if (typeof i.min == 'number' && v < i.min) v = i.min;
		if (typeof i.max == 'number' && v > i.max) v = i.max;
		if (v < 1) v = 1;
		return v;
	}
	function cf_getSynchArr(s) {
		if (!is_array(s)) 		s = [[s]];
		if (!is_array(s[0]))	s = [s];
		for (var j = 0, l = s.length; j < l; j++) {
			if (typeof s[j][0] == 'string')		s[j][0] = $(s[j][0]);
			if (typeof s[j][1] != 'boolean')	s[j][1] = true;
			if (typeof s[j][2] != 'boolean')	s[j][2] = true;
			if (typeof s[j][3] != 'number')		s[j][3] = 0;
		}
		return s;
	}
	function cf_getKeyCode(k) {
		if (k == 'right')	return 39;
		if (k == 'left')	return 37;
		if (k == 'up')		return 38;
		if (k == 'down')	return 40;
		return -1;
	}
	function cf_setCookie(n, v) {
		if (n) document.cookie = n+'='+v+'; path=/';
	}
	function cf_readCookie(n) {
		n += '=';
		var ca = document.cookie.split(';');
		for (var a = 0, l = ca.length; a < l; a++) {
			var c = ca[a];
			while (c.charAt(0) == ' ') {
				c = c.slice(1);
			}
			if (c.indexOf(n) == 0) {
				return c.slice(n.length);
			}
		}
		return 0;
	}

	//	buttons functions
	function bt_pauseOnHoverConfig(p) {
		if (p && typeof p == 'string') {
			var i = (p.indexOf('immediate') > -1) ? true : false,
				r = (p.indexOf('resume') 	> -1) ? true : false;
		} else {
			var i = r = false;
		}
		return [i, r];
	}
	function bt_mousesheelNumber(mw) {
		return (typeof mw == 'number') ? mw : null
	}

	//	helper functions
	function is_array(a) {
		return typeof(a) == 'object' && (a instanceof Array);
	}

	function getTime() {
		return new Date().getTime();
	}

	function debug(d, m) {
		if (typeof d == 'object') {
			var s = ' ('+d.selector+')';
			d = d.debug;
		} else {
			var s = '';
		}
		if (!d) return false;
		
		if (typeof m == 'string') m = 'carouFredSel'+s+': ' + m;
		else m = ['carouFredSel'+s+':', m];

		if (window.console && window.console.log) window.console.log(m);
		return false;
	}


	//	CAROUFREDSEL ALL LOWERCASE

	$.fn.caroufredsel = function(o, c) {
		return this.carouFredSel(o, c);
	};


	//	EASING FUNCTIONS

	$.extend($.easing, {
		'quadratic'	: function(t) {
			var t2 = t * t;
			return t * (-t2 * t + 4 * t2 - 6 * t + 4);
		},
		'cubic'		: function(t) {
			return t * (4 * t * t - 9 * t + 6);
		},
		'elastic'	: function(t) {
			var t2 = t * t;
			return t * (33 * t2 * t2 - 106 * t2 * t + 126 * t2 - 67 * t + 15);
		}
	});


})(mrm.$);/*
 * jQuery clueTip plugin
 * Version 1.0.7  (January 28, 2010)
 * @requires jQuery v1.3+
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 */
 
/*
 *
 * Full list of options/settings can be found at the bottom of this file and at http://plugins.learningjquery.com/cluetip/
 *
 * Examples can be found at http://plugins.learningjquery.com/cluetip/demo/
 *
*/

;(function($) { 
  $.cluetip = {version: '1.0.6'};
  var $cluetip, $cluetipInner, $cluetipOuter, $cluetipTitle, $cluetipArrows, $cluetipWait, $dropShadow, imgCount;
  
  $.fn.cluetip = function(js, options) {
    if (typeof js == 'object') {
      options = js;
      js = null;
    }
    if (js == 'destroy') {
      return this.removeData('thisInfo').unbind('.cluetip');
    }
    return this.each(function(index) {
      var link = this, $this = $(this);
      
      // support metadata plugin (v1.0 and 2.0)
      var opts = $.extend(true, {}, $.fn.cluetip.defaults, options || {}, $.metadata ? $this.metadata() : $.meta ? $this.data() : {});

      // start out with no contents (for ajax activation)
      var cluetipContents = false;
      var cluezIndex = +opts.cluezIndex;
      $this.data('thisInfo', {title: link.title, zIndex: cluezIndex});
      var isActive = false, closeOnDelay = 0;

      // create the cluetip divs
      if (!$('#cluetip').length) {
        $(['<div id="cluetip">',
          '<div id="cluetip-outer">',
            '<h3 id="cluetip-title"></h3>',
            '<div id="cluetip-inner"></div>',
          '</div>',
          '<div id="cluetip-extra"></div>',
          '<div id="cluetip-arrows" class="cluetip-arrows"></div>',
        '</div>'].join(''))
        [insertionType](insertionElement).hide();
        
        $cluetip = $('#cluetip').css({position: 'absolute'});
        $cluetipOuter = $('#cluetip-outer').css({position: 'relative', zIndex: cluezIndex});
        $cluetipInner = $('#cluetip-inner');
        $cluetipTitle = $('#cluetip-title');        
        $cluetipArrows = $('#cluetip-arrows');
        $cluetipWait = $('<div id="cluetip-waitimage"></div>')
          .css({position: 'absolute'}).insertBefore($cluetip).hide();
      }
      var dropShadowSteps = (opts.dropShadow) ? +opts.dropShadowSteps : 0;
      if (!$dropShadow) {
        $dropShadow = $([]);
        for (var i=0; i < dropShadowSteps; i++) {
          $dropShadow = $dropShadow.add($('<div></div>').css({zIndex: cluezIndex-1, opacity:.1, top: 1+i, left: 1+i}));
        }
        $dropShadow.css({position: 'absolute', backgroundColor: '#000'})
        .prependTo($cluetip);
      }
      var tipAttribute = $this.attr(opts.attribute), ctClass = opts.cluetipClass;
      if (!tipAttribute && !opts.splitTitle && !js) {
        return true;
      }
      // if hideLocal is set to true, on DOM ready hide the local content that will be displayed in the clueTip
      if (opts.local && opts.localPrefix) {tipAttribute = opts.localPrefix + tipAttribute;}
      if (opts.local && opts.hideLocal) { $(tipAttribute + ':first').hide(); }
      var tOffset = parseInt(opts.topOffset, 10), lOffset = parseInt(opts.leftOffset, 10);
      // vertical measurement variables
      var tipHeight, wHeight,
          defHeight = isNaN(parseInt(opts.height, 10)) ? 'auto' : (/\D/g).test(opts.height) ? opts.height : opts.height + 'px';
      var sTop, linkTop, posY, tipY, mouseY, baseline;
      // horizontal measurement variables
      var tipInnerWidth = parseInt(opts.width, 10) || 275,
          tipWidth = tipInnerWidth + (parseInt($cluetip.css('paddingLeft'),10)||0) + (parseInt($cluetip.css('paddingRight'),10)||0) + dropShadowSteps,
          tipMaxWidth = parseInt(opts.maxWidth),
          linkWidth = this.offsetWidth,
          linkLeft, posX, tipX, mouseX, winWidth;

      if (opts.width == 'auto') {
    	  tipInnerWidth = 'auto';
      }
      // parse the title
      var tipParts;
      var tipTitle = (opts.attribute != 'title') ? $this.attr(opts.titleAttribute) : '';
      if (opts.splitTitle) {
        if (tipTitle == undefined) {tipTitle = '';}
        tipParts = tipTitle.split(opts.splitTitle);
        tipTitle = tipParts.shift();
      }
      if (opts.escapeTitle) {
        tipTitle = tipTitle.replace(/&/g,'&amp;').replace(/>/g,'&gt;').replace(/</g,'&lt;');
      }
      
      var localContent;
      function returnFalse() { return false; }

/***************************************      
* ACTIVATION
****************************************/
    
//activate clueTip
    var activate = function(event) {
      if (!opts.onActivate($this)) {
        return false;
      }
      isActive = true;
      $cluetip.removeClass().css({width: tipInnerWidth});
      if (tipAttribute == $this.attr('href')) {
        $this.css('cursor', opts.cursor);
      }
      if (opts.hoverClass) {
        $this.addClass(opts.hoverClass);
      }
      linkTop = posY = $this.offset().top;
      linkLeft = $this.offset().left;
      mouseX = event.pageX;
      mouseY = event.pageY;
      if (link.tagName.toLowerCase() != 'area') {
        sTop = $(document).scrollTop();
        winWidth = $(window).width();
      }
// position clueTip horizontally
      if (opts.positionBy == 'fixed') {
        posX = linkWidth + linkLeft + lOffset;
        $cluetip.css({left: posX});
      } else {
        posX = (linkWidth > linkLeft && linkLeft > tipWidth)
          || linkLeft + linkWidth + tipWidth + lOffset > winWidth 
          ? linkLeft - tipWidth - lOffset 
          : linkWidth + linkLeft + lOffset;
        if (link.tagName.toLowerCase() == 'area' || opts.positionBy == 'mouse' || linkWidth + tipWidth > winWidth) { // position by mouse
          if (mouseX + 20 + tipWidth > winWidth) {  
            $cluetip.addClass(' cluetip-' + ctClass);
            posX = (mouseX - tipWidth - lOffset) >= 0 ? mouseX - tipWidth - lOffset - parseInt($cluetip.css('marginLeft'),10) + parseInt($cluetipInner.css('marginRight'),10) :  mouseX - (tipWidth/2);
          } else {
            posX = mouseX + lOffset;
          }
        }
        var pY = posX < 0 ? event.pageY + tOffset : event.pageY;
        $cluetip.css({
          left: (posX > 0 && opts.positionBy != 'bottomTop') ? posX : (mouseX + (tipWidth/2) > winWidth) ? winWidth/2 - tipWidth/2 : Math.max(mouseX - (tipWidth/2),0),
          zIndex: $this.data('thisInfo').zIndex
        });
        $cluetipArrows.css({zIndex: $this.data('thisInfo').zIndex+1});
      }
        wHeight = $(window).height();

/***************************************
* load a string from cluetip method's first argument
***************************************/
      if (js) {
        if (typeof js == 'function') {
          js = js.call(link);
        }
        $cluetipInner.html(js);
        cluetipShow(pY);
      }
/***************************************
* load the title attribute only (or user-selected attribute). 
* clueTip title is the string before the first delimiter
* subsequent delimiters place clueTip body text on separate lines
***************************************/

      else if (tipParts) {
        var tpl = tipParts.length;
        $cluetipInner.html(tpl ? tipParts[0] : '');
        if (tpl > 1) {
          for (var i=1; i < tpl; i++){
            $cluetipInner.append('<div class="split-body">' + tipParts[i] + '</div>');
          }          
        }
        cluetipShow(pY);
      }
/***************************************
* load external file via ajax          
***************************************/

      else if (!opts.local && tipAttribute.indexOf('#') !== 0) {
        if (/\.(jpe?g|tiff?|gif|png)$/i.test(tipAttribute)) {
          $cluetipInner.html('<img src="' + tipAttribute + '" alt="' + tipTitle + '" />');
          cluetipShow(pY);
        } else if (cluetipContents && opts.ajaxCache) {
          $cluetipInner.html(cluetipContents);
          cluetipShow(pY);
        } else {
          var optionBeforeSend = opts.ajaxSettings.beforeSend,
              optionError = opts.ajaxSettings.error,
              optionSuccess = opts.ajaxSettings.success,
              optionComplete = opts.ajaxSettings.complete;
          var ajaxSettings = {
            cache: false, // force requested page not to be cached by browser
            url: tipAttribute,
            beforeSend: function(xhr) {
              if (optionBeforeSend) {optionBeforeSend.call(link, xhr, $cluetip, $cluetipInner);}
              $cluetipOuter.children().empty();
              if (opts.waitImage) {
                $cluetipWait
                .css({top: mouseY+20, left: mouseX+20, zIndex: $this.data('thisInfo').zIndex-1})
                .show();
              }
            },
            error: function(xhr, textStatus) {
              if (isActive) {
                if (optionError) {
                  optionError.call(link, xhr, textStatus, $cluetip, $cluetipInner);
                } else {
                  $cluetipInner.html('<i>sorry, the contents could not be loaded</i>');  
                }
              }
            },
            success: function(data, textStatus) {       
              cluetipContents = opts.ajaxProcess.call(link, data);
              if (isActive) {
                if (optionSuccess) {optionSuccess.call(link, data, textStatus, $cluetip, $cluetipInner);}
                $cluetipInner.html(cluetipContents);
              }
            },
            complete: function(xhr, textStatus) {
              if (optionComplete) {optionComplete.call(link, xhr, textStatus, $cluetip, $cluetipInner);}
              var imgs = $cluetipInner[0].getElementsByTagName('img');
              imgCount = imgs.length;
              for (var i=0, l = imgs.length; i < l; i++) {
                if (imgs[i].complete) {
                  imgCount--;
                }
              }
              if (imgCount && !$.browser.opera) {
                $(imgs).bind('load error', function() {
                  imgCount--;
                  if (imgCount<1) {
                    $cluetipWait.hide();
                    if (isActive) { cluetipShow(pY); }
                  }
                }); 
              } else {
                $cluetipWait.hide();
                if (isActive) { cluetipShow(pY); }
              } 
            }
          };
          var ajaxMergedSettings = $.extend(true, {}, opts.ajaxSettings, ajaxSettings);
          
          $.ajax(ajaxMergedSettings);
        }

/***************************************
* load an element from the same page
***************************************/
      } else if (opts.local) {
        
        var $localContent = $(tipAttribute + (/#\S+$/.test(tipAttribute) ? '' : ':eq(' + index + ')')).clone(true).show();
        $cluetipInner.html($localContent);
        cluetipShow(pY);
      }
    };

// get dimensions and options for cluetip and prepare it to be shown
    var cluetipShow = function(bpY) {
      $cluetip.addClass('cluetip-' + ctClass);
      if (opts.truncate) { 
        var $truncloaded = $cluetipInner.text().slice(0,opts.truncate) + '...';
        $cluetipInner.html($truncloaded);
      }
      function doNothing() {}; //empty function
      tipTitle ? $cluetipTitle.show().html(tipTitle) : (opts.showTitle) ? $cluetipTitle.show().html('&nbsp;') : $cluetipTitle.hide();
      if (opts.sticky) {
        var $closeLink = $('<div id="cluetip-close"><a href="#">' + opts.closeText + '</a></div>');
        (opts.closePosition == 'bottom') ? $closeLink.appendTo($cluetipInner) : (opts.closePosition == 'title') ? $closeLink.prependTo($cluetipTitle) : $closeLink.prependTo($cluetipInner);
        $closeLink.bind('click.cluetip', function() {
          cluetipClose();
          return false;
        });
        if (opts.mouseOutClose) {
          $cluetip.bind('mouseleave.cluetip', function() {
            cluetipClose();
          });
        } else {
          $cluetip.unbind('mouseleave.cluetip');
        }
      }
// now that content is loaded, finish the positioning 
      var direction = '';
      $cluetipOuter.css({zIndex: $this.data('thisInfo').zIndex, overflow: defHeight == 'auto' ? 'visible' : 'auto', height: defHeight});
      tipHeight = defHeight == 'auto' ? Math.max($cluetip.outerHeight(),$cluetip.height()) : parseInt(defHeight,10);   
      tipY = posY;
      baseline = sTop + wHeight;
      if (opts.positionBy == 'fixed') {
        tipY = posY - opts.dropShadowSteps + tOffset;
      } else if ( (posX < mouseX && Math.max(posX, 0) + tipWidth > mouseX) || opts.positionBy == 'bottomTop') {
        if (posY + tipHeight + tOffset > baseline && mouseY - sTop > tipHeight + tOffset) { 
          tipY = mouseY - tipHeight - tOffset;
          direction = 'top';
        } else { 
          tipY = mouseY + tOffset;
          direction = 'bottom';
        }
      } else if ( posY + tipHeight + tOffset > baseline ) {
        tipY = (tipHeight >= wHeight) ? sTop : baseline - tipHeight - tOffset;
      } else if ($this.css('display') == 'block' || link.tagName.toLowerCase() == 'area' || opts.positionBy == "mouse") {
        tipY = bpY - tOffset;
      } else {
        tipY = posY - opts.dropShadowSteps;
      }
      if (direction == '') {
        posX < linkLeft ? direction = 'left' : direction = 'right';
      }
      if (tipMaxWidth !== '') {
    	  if ( $this.attr('class') !== 'cnt_opt' ) { // not called from features-specs page
    		  $cluetip.css({ 'max-width': tipMaxWidth }); // max-width is needed for widths set to auto
    	  }
      }
      $cluetip.css({top: tipY + 'px'}).removeClass().addClass('clue-' + direction + '-' + ctClass).addClass(' cluetip-' + ctClass);
      if (opts.arrows) { // set up arrow positioning to align with element
        var bgY = (posY - tipY - opts.dropShadowSteps);
        $cluetipArrows.css({top: (/(left|right)/.test(direction) && posX >=0 && bgY > 0) ? bgY + 'px' : /(left|right)/.test(direction) ? 0 : ''}).show();
      } else {
        $cluetipArrows.hide();
      }

// (first hide, then) ***SHOW THE CLUETIP***
      $dropShadow.hide();
      $cluetip.hide()[opts.fx.open](opts.fx.openSpeed || 0);
      if (opts.dropShadow) { $dropShadow.css({height: tipHeight, width: tipInnerWidth, zIndex: $this.data('thisInfo').zIndex-1}).show(); }
      if ($.fn.bgiframe) { $cluetip.bgiframe(); }
      // delayed close (not fully tested)
      if (opts.delayedClose > 0) {
        closeOnDelay = setTimeout(cluetipClose, opts.delayedClose);
      }
      // trigger the optional onShow function
      opts.onShow.call(link, $cluetip, $cluetipInner);
    };

/***************************************
   =INACTIVATION
-------------------------------------- */
    var inactivate = function(event) {
      isActive = false;
      $cluetipWait.hide();
      if (!opts.sticky || (/click|toggle/).test(opts.activation) ) {
        cluetipClose();
        clearTimeout(closeOnDelay);        
      }
      if (opts.hoverClass) {
        $this.removeClass(opts.hoverClass);
      }
    };
// close cluetip and reset some things
    var cluetipClose = function() {
      $cluetipOuter 
      .parent().hide().removeClass();
      opts.onHide.call(link, $cluetip, $cluetipInner);
      $this.removeClass('cluetip-clicked');
      if (tipTitle) {
        $this.attr(opts.titleAttribute, tipTitle);
      }
      $this.css('cursor','');
      if (opts.arrows) {
        $cluetipArrows.css({top: ''});
      }
    };

    $(document).bind('hideCluetip', function(e) {
      cluetipClose();
    });
/***************************************
   =BIND EVENTS
-------------------------------------- */
  // activate by click
      if ( (/click|toggle/).test(opts.activation) ) {
        $this.bind('click.cluetip', function(event) {
          if ($cluetip.is(':hidden') || !$this.is('.cluetip-clicked')) {
            activate(event);
            $('.cluetip-clicked').removeClass('cluetip-clicked');
            $this.addClass('cluetip-clicked');
          } else {
            inactivate(event);
          }
          this.blur();
          return false;
        });
  // activate by focus; inactivate by blur    
      } else if (opts.activation == 'focus') {
        $this.bind('focus.cluetip', function(event) {
          activate(event);
        });
        $this.bind('blur.cluetip', function(event) {
          inactivate(event);
        });
  // activate by hover
      } else {
        // clicking is returned false if clickThrough option is set to false
        $this[opts.clickThrough ? 'unbind' : 'bind']('click', returnFalse);
        //set up mouse tracking
        var mouseTracks = function(evt) {
          if (opts.tracking == true) {
            var trackX = posX - evt.pageX;
            var trackY = tipY ? tipY - evt.pageY : posY - evt.pageY;
            $this.bind('mousemove.cluetip', function(evt) {
              $cluetip.css({left: evt.pageX + trackX, top: evt.pageY + trackY });
            });
          }
        };
        if ($.fn.hoverIntent && opts.hoverIntent) {
          $this.hoverIntent({
            sensitivity: opts.hoverIntent.sensitivity,
            interval: opts.hoverIntent.interval,  
            over: function(event) {
              activate(event);
              mouseTracks(event);
            }, 
            timeout: opts.hoverIntent.timeout,  
            out: function(event) {inactivate(event); $this.unbind('mousemove.cluetip');}
          });           
        } else {
          $this.bind('mouseenter.cluetip', function(event) {
            activate(event);
            mouseTracks(event);
          })
          .bind('mouseleave.cluetip', function(event) {
            inactivate(event);
            $this.unbind('mousemove.cluetip');
          });
        }
        $this.bind('mouseover.cluetip', function(event) {
          $this.attr('title','');
        }).bind('mouseleave.cluetip', function(event) {
          $this.attr('title', $this.data('thisInfo').title);
        });
      }
    });
  };
  
/*
 * options for clueTip
 *
 * each one can be explicitly overridden by changing its value. 
 * for example: $.fn.cluetip.defaults.width = 200; 
 * would change the default width for all clueTips to 200. 
 *
 * each one can also be overridden by passing an options map to the cluetip method.
 * for example: $('a.example').cluetip({width: 200}); 
 * would change the default width to 200 for clueTips invoked by a link with class of "example"
 *
 */
  
  $.fn.cluetip.defaults = {  // set up default options
    width:            275,      // The width of the clueTip
    height:           'auto',   // The height of the clueTip
    cluezIndex:       97,       // Sets the z-index style property of the clueTip
    positionBy:       'auto',   // Sets the type of positioning: 'auto', 'mouse','bottomTop', 'fixed'
    topOffset:        15,       // Number of px to offset clueTip from top of invoking element
    leftOffset:       15,       // Number of px to offset clueTip from left of invoking element
    local:            false,    // Whether to use content from the same page for the clueTip's body
    localPrefix:      null,       // string to be prepended to the tip attribute if local is true
    hideLocal:        true,     // If local option is set to true, this determines whether local content
                                // to be shown in clueTip should be hidden at its original location
    attribute:        'rel',    // the attribute to be used for fetching the clueTip's body content
    titleAttribute:   'title',  // the attribute to be used for fetching the clueTip's title
    splitTitle:       '',       // A character used to split the title attribute into the clueTip title and divs
                                // within the clueTip body. more info below [6]
    escapeTitle:      false,    // whether to html escape the title attribute
    showTitle:        true,     // show title bar of the clueTip, even if title attribute not set
    cluetipClass:     'default',// class added to outermost clueTip div in the form of 'cluetip-' + clueTipClass.
    hoverClass:       '',       // class applied to the invoking element onmouseover and removed onmouseout
    waitImage:        true,     // whether to show a "loading" img, which is set in jquery.cluetip.css
    cursor:           'help',
    arrows:           false,    // if true, displays arrow on appropriate side of clueTip
    dropShadow:       true,     // set to false if you don't want the drop-shadow effect on the clueTip
    dropShadowSteps:  6,        // adjusts the size of the drop shadow
    sticky:           false,    // keep visible until manually closed
    mouseOutClose:    false,    // close when clueTip is moused out
    activation:       'hover',  // set to 'click' to force user to click to show clueTip
                                // set to 'focus' to show on focus of a form element and hide on blur
    clickThrough:     false,    // if true, and activation is not 'click', then clicking on link will take user to the link's href,
                                // even if href and tipAttribute are equal
    tracking:         false,    // if true, clueTip will track mouse movement (experimental)
    delayedClose:     0,        // close clueTip on a timed delay (experimental)
    closePosition:    'top',    // location of close text for sticky cluetips; can be 'top' or 'bottom' or 'title'
    closeText:        'Close',  // text (or HTML) to to be clicked to close sticky clueTips
    truncate:         0,        // number of characters to truncate clueTip's contents. if 0, no truncation occurs
    
    // effect and speed for opening clueTips
    fx: {             
                      open:       'show', // can be 'show' or 'slideDown' or 'fadeIn'
                      openSpeed:  ''
    },     

    // settings for when hoverIntent plugin is used             
    hoverIntent: {    
                      sensitivity:  3,
              			  interval:     50,
              			  timeout:      0
    },

    onActivate:       function(e) {return true;},
    // function to run just after clueTip is shown. 
    onShow:           function(ct, ci){},
    // function to run just after clueTip is hidden.
    onHide:           function(ct, ci){},
    // whether to cache results of ajax request to avoid unnecessary hits to server    
    ajaxCache:        true,  

    // process data retrieved via xhr before it's displayed
    ajaxProcess:      function(data) {
                        data = data.replace(/<(script|style|title)[^<]+<\/(script|style|title)>/gm, '').replace(/<(link|meta)[^>]+>/g,'');
                        return data;
    },                

    // can pass in standard $.ajax() parameters. Callback functions, such as beforeSend, 
    // will be queued first within the default callbacks. 
    // The only exception is error, which overrides the default
    ajaxSettings: {
                      // error: function(ct, ci) { /* override default error callback */ }
                      // beforeSend: function(ct, ci) { /* called first within default beforeSend callback */}
                      dataType: 'html'
    },
    debug: false
  };


/*
 * Global defaults for clueTips. Apply to all calls to the clueTip plugin.
 *
 * @example $.cluetip.setup({
 *   insertionType: 'prependTo',
 *   insertionElement: '#container'
 * });
 * 
 * @property
 * @name $.cluetip.setup
 * @type Map
 * @cat Plugins/tooltip
 * @option String insertionType: Default is 'appendTo'. Determines the method to be used for inserting the clueTip into the DOM. Permitted values are 'appendTo', 'prependTo', 'insertBefore', and 'insertAfter'
 * @option String insertionElement: Default is 'body'. Determines which element in the DOM the plugin will reference when inserting the clueTip.
 *
 */
   
  var insertionType = 'appendTo', insertionElement = 'body';

  $.cluetip.setup = function(options) {
    if (options && options.insertionType && (options.insertionType).match(/appendTo|prependTo|insertBefore|insertAfter/)) {
      insertionType = options.insertionType;
    }
    if (options && options.insertionElement) {
      insertionElement = options.insertionElement;
    }
  };
  
})(mrm.$);
/**
 * Equal Heights Plugin
 * Equalize the heights of elements. Great for columns or any elements
 * that need to be the same size (floats, etc).
 * 
 * Version 1.0
 * Updated 12/10/2008
 *
 * Copyright (c) 2008 Rob Glazebrook (cssnewbie.com) 
 *
 * Usage: $(object).equalHeights([minHeight], [maxHeight]);
 * 
 * Example 1: $(".cols").equalHeights(); Sets all columns to the same height.
 * Example 2: $(".cols").equalHeights(400); Sets all cols to at least 400px tall.
 * Example 3: $(".cols").equalHeights(100,300); Cols are at least 100 but no more
 * than 300 pixels tall. Elements with too much content will gain a scrollbar.
 * 
 */

(function($) {
	$.fn.equalHeights = function(minHeight, maxHeight) {
		var tallest = (minHeight) ? minHeight : 0;
		
		this.each(function() {
			var $this = $(this);
			if( $this.outerHeight() > tallest ) {
				tallest = $this.outerHeight();
			}
		});
		
		if((maxHeight) && tallest > maxHeight) tallest = maxHeight;
		
		return this.each(function() {
			var $this = $(this);
			var padding = parseInt($this.css('padding-top')) + parseInt($this.css('padding-bottom'));

			$this.height( tallest - padding );
		});
	}
})(mrm.$);// ==================================================
// fancyBox v3.5.3
//
// Licensed GPLv3 for open source use
// or fancyBox Commercial License for commercial use
//
// http://fancyapps.com/fancybox/
// Copyright 2018 fancyApps
//
// ==================================================
(function(window, document, $, undefined) {
    "use strict";

    window.console = window.console || {
        info: function(stuff) {}
    };

    // If there's no jQuery, fancyBox can't work
    // =========================================

    if (!$) {
        return;
    }

    // Check if fancyBox is already initialized
    // ========================================

    if ($.fn.fancybox) {
        console.info("fancyBox already initialized");

        return;
    }

    // Private default settings
    // ========================

    var defaults = {
        // Close existing modals
        // Set this to false if you do not need to stack multiple instances
        closeExisting: false,

        // Enable infinite gallery navigation
        loop: false,

        // Horizontal space between slides
        gutter: 50,

        // Enable keyboard navigation
        keyboard: true,

        // Should allow caption to overlap the content
        preventCaptionOverlap: true,

        // Should display navigation arrows at the screen edges
        arrows: true,

        // Should display counter at the top left corner
        infobar: true,

        // Should display close button (using `btnTpl.smallBtn` template) over the content
        // Can be true, false, "auto"
        // If "auto" - will be automatically enabled for "html", "inline" or "ajax" items
        smallBtn: "auto",

        // Should display toolbar (buttons at the top)
        // Can be true, false, "auto"
        // If "auto" - will be automatically hidden if "smallBtn" is enabled
        toolbar: "auto",

        // What buttons should appear in the top right corner.
        // Buttons will be created using templates from `btnTpl` option
        // and they will be placed into toolbar (class="fancybox-toolbar"` element)
        buttons: [
            "zoom",
            //"share",
            "slideShow",
            //"fullScreen",
            //"download",
            "thumbs",
            "close"
        ],

        // Detect "idle" time in seconds
        idleTime: 3,

        // Disable right-click and use simple image protection for images
        protect: false,

        // Shortcut to make content "modal" - disable keyboard navigtion, hide buttons, etc
        modal: false,

        image: {
            // Wait for images to load before displaying
            //   true  - wait for image to load and then display;
            //   false - display thumbnail and load the full-sized image over top,
            //           requires predefined image dimensions (`data-width` and `data-height` attributes)
            preload: false
        },

        ajax: {
            // Object containing settings for ajax request
            settings: {
                // This helps to indicate that request comes from the modal
                // Feel free to change naming
                data: {
                    fancybox: true
                }
            }
        },

        iframe: {
            // Iframe template
            tpl:
                '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" allowfullscreen="allowfullscreen" allow="autoplay; fullscreen" src=""></iframe>',

            // Preload iframe before displaying it
            // This allows to calculate iframe content width and height
            // (note: Due to "Same Origin Policy", you can't get cross domain data).
            preload: true,

            // Custom CSS styling for iframe wrapping element
            // You can use this to set custom iframe dimensions
            css: {},

            // Iframe tag attributes
            attr: {
                scrolling: "auto"
            }
        },

        // For HTML5 video only
        video: {
            tpl:
            '<video class="fancybox-video" controls controlsList="nodownload" poster="{{poster}}">' +
            '<source src="{{src}}" type="{{format}}" />' +
            'Sorry, your browser doesn\'t support embedded videos, <a href="{{src}}">download</a> and watch with your favorite video player!' +
            "</video>",
            format: "", // custom video format
            autoStart: true
        },

        // Default content type if cannot be detected automatically
        defaultType: "image",

        // Open/close animation type
        // Possible values:
        //   false            - disable
        //   "zoom"           - zoom images from/to thumbnail
        //   "fade"
        //   "zoom-in-out"
        //
        animationEffect: "zoom",

        // Duration in ms for open/close animation
        animationDuration: 366,

        // Should image change opacity while zooming
        // If opacity is "auto", then opacity will be changed if image and thumbnail have different aspect ratios
        zoomOpacity: "auto",

        // Transition effect between slides
        //
        // Possible values:
        //   false            - disable
        //   "fade'
        //   "slide'
        //   "circular'
        //   "tube'
        //   "zoom-in-out'
        //   "rotate'
        //
        transitionEffect: "fade",

        // Duration in ms for transition animation
        transitionDuration: 366,

        // Custom CSS class for slide element
        slideClass: "",

        // Custom CSS class for layout
        baseClass: "",

        // Base template for layout
        baseTpl:
        '<div class="fancybox-container" role="dialog" tabindex="-1">' +
        '<div class="fancybox-bg"></div>' +
        '<div class="fancybox-inner">' +
        '<div class="fancybox-infobar"><span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span></div>' +
        '<div class="fancybox-toolbar">{{buttons}}</div>' +
        '<div class="fancybox-navigation">{{arrows}}</div>' +
        '<div class="fancybox-stage"></div>' +
        '<div class="fancybox-caption"></div>' +
        "</div>" +
        "</div>",

        // Loading indicator template
        spinnerTpl: '<div class="fancybox-loading"></div>',

        // Error message template
        errorTpl: '<div class="fancybox-error"><p>{{ERROR}}</p></div>',

        btnTpl: {
            download:
            '<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}" href="javascript:;">' +
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.62 17.09V19H5.38v-1.91zm-2.97-6.96L17 11.45l-5 4.87-5-4.87 1.36-1.32 2.68 2.64V5h1.92v7.77z"/></svg>' +
            "</a>",

            zoom:
            '<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}">' +
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18.7 17.3l-3-3a5.9 5.9 0 0 0-.6-7.6 5.9 5.9 0 0 0-8.4 0 5.9 5.9 0 0 0 0 8.4 5.9 5.9 0 0 0 7.7.7l3 3a1 1 0 0 0 1.3 0c.4-.5.4-1 0-1.5zM8.1 13.8a4 4 0 0 1 0-5.7 4 4 0 0 1 5.7 0 4 4 0 0 1 0 5.7 4 4 0 0 1-5.7 0z"/></svg>' +
            "</button>",

            close:
            '<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}">' +
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 10.6L6.6 5.2 5.2 6.6l5.4 5.4-5.4 5.4 1.4 1.4 5.4-5.4 5.4 5.4 1.4-1.4-5.4-5.4 5.4-5.4-1.4-1.4-5.4 5.4z"/></svg>' +
            "</button>",

            // Arrows
            arrowLeft:
            '<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}">' +
            '<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11.28 15.7l-1.34 1.37L5 12l4.94-5.07 1.34 1.38-2.68 2.72H19v1.94H8.6z"/></svg></div>' +
            "</button>",

            arrowRight:
            '<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}">' +
            '<div><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M15.4 12.97l-2.68 2.72 1.34 1.38L19 12l-4.94-5.07-1.34 1.38 2.68 2.72H5v1.94z"/></svg></div>' +
            "</button>",

            // This small close button will be appended to your html/inline/ajax content by default,
            // if "smallBtn" option is not set to false
            smallBtn:
            '<button type="button" data-fancybox-close class="fancybox-button fancybox-close-small" title="{{CLOSE}}">' +
            '<svg xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 24 24"><path d="M13 12l5-5-1-1-5 5-5-5-1 1 5 5-5 5 1 1 5-5 5 5 1-1z"/></svg>' +
            "</button>"
        },

        // Container is injected into this element
        parentEl: "body",

        // Hide browser vertical scrollbars; use at your own risk
        hideScrollbar: true,

        // Focus handling
        // ==============

        // Try to focus on the first focusable element after opening
        autoFocus: true,

        // Put focus back to active element after closing
        backFocus: true,

        // Do not let user to focus on element outside modal content
        trapFocus: true,

        // Module specific options
        // =======================

        fullScreen: {
            autoStart: false
        },

        // Set `touch: false` to disable panning/swiping
        touch: {
            vertical: true, // Allow to drag content vertically
            momentum: true // Continue movement after releasing mouse/touch when panning
        },

        // Hash value when initializing manually,
        // set `false` to disable hash change
        hash: null,

        // Customize or add new media types
        // Example:
        /*
      media : {
        youtube : {
          params : {
            autoplay : 0
          }
        }
      }
    */
        media: {},

        slideShow: {
            autoStart: false,
            speed: 3000
        },

        thumbs: {
            autoStart: false, // Display thumbnails on opening
            hideOnClose: true, // Hide thumbnail grid when closing animation starts
            parentEl: ".fancybox-container", // Container is injected into this element
            axis: "y" // Vertical (y) or horizontal (x) scrolling
        },

        // Use mousewheel to navigate gallery
        // If 'auto' - enabled for images only
        wheel: "auto",

        // Callbacks
        //==========

        // See Documentation/API/Events for more information
        // Example:
        /*
      afterShow: function( instance, current ) {
        console.info( 'Clicked element:' );
        console.info( current.opts.$orig );
      }
    */

        onInit: $.noop, // When instance has been initialized

        beforeLoad: $.noop, // Before the content of a slide is being loaded
        afterLoad: $.noop, // When the content of a slide is done loading

        beforeShow: $.noop, // Before open animation starts
        afterShow: $.noop, // When content is done loading and animating

        beforeClose: $.noop, // Before the instance attempts to close. Return false to cancel the close.
        afterClose: $.noop, // After instance has been closed

        onActivate: $.noop, // When instance is brought to front
        onDeactivate: $.noop, // When other instance has been activated

        // Interaction
        // ===========

        // Use options below to customize taken action when user clicks or double clicks on the fancyBox area,
        // each option can be string or method that returns value.
        //
        // Possible values:
        //   "close"           - close instance
        //   "next"            - move to next gallery item
        //   "nextOrClose"     - move to next gallery item or close if gallery has only one item
        //   "toggleControls"  - show/hide controls
        //   "zoom"            - zoom image (if loaded)
        //   false             - do nothing

        // Clicked on the content
        clickContent: function(current, event) {
            return current.type === "image" ? "zoom" : false;
        },

        // Clicked on the slide
        clickSlide: "close",

        // Clicked on the background (backdrop) element;
        // if you have not changed the layout, then most likely you need to use `clickSlide` option
        clickOutside: "close",

        // Same as previous two, but for double click
        dblclickContent: false,
        dblclickSlide: false,
        dblclickOutside: false,

        // Custom options when mobile device is detected
        // =============================================

        mobile: {
            preventCaptionOverlap: false,
            idleTime: false,
            clickContent: function(current, event) {
                return current.type === "image" ? "toggleControls" : false;
            },
            clickSlide: function(current, event) {
                return current.type === "image" ? "toggleControls" : "close";
            },
            dblclickContent: function(current, event) {
                return current.type === "image" ? "zoom" : false;
            },
            dblclickSlide: function(current, event) {
                return current.type === "image" ? "zoom" : false;
            }
        },

        // Internationalization
        // ====================

        lang: "en",
        i18n: {
            en: {
                CLOSE: "Close",
                NEXT: "Next",
                PREV: "Previous",
                ERROR: "The requested content cannot be loaded. <br/> Please try again later.",
                PLAY_START: "Start slideshow",
                PLAY_STOP: "Pause slideshow",
                FULL_SCREEN: "Full screen",
                THUMBS: "Thumbnails",
                DOWNLOAD: "Download",
                SHARE: "Share",
                ZOOM: "Zoom"
            },
            de: {
                CLOSE: "Schlie&szlig;en",
                NEXT: "Weiter",
                PREV: "Zur&uuml;ck",
                ERROR: "Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es sp&auml;ter nochmal.",
                PLAY_START: "Diaschau starten",
                PLAY_STOP: "Diaschau beenden",
                FULL_SCREEN: "Vollbild",
                THUMBS: "Vorschaubilder",
                DOWNLOAD: "Herunterladen",
                SHARE: "Teilen",
                ZOOM: "Vergr&ouml;&szlig;ern"
            }
        }
    };

    // Few useful variables and methods
    // ================================

    var $W = $(window);
    var $D = $(document);

    var called = 0;

    // Check if an object is a jQuery object and not a native JavaScript object
    // ========================================================================
    var isQuery = function(obj) {
        return obj && obj.hasOwnProperty && obj instanceof $;
    };

    // Handle multiple browsers for "requestAnimationFrame" and "cancelAnimationFrame"
    // ===============================================================================
    var requestAFrame = (function() {
        return (
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            // if all else fails, use setTimeout
            function(callback) {
                return window.setTimeout(callback, 1000 / 60);
            }
        );
    })();

    var cancelAFrame = (function() {
        return (
            window.cancelAnimationFrame ||
            window.webkitCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            window.oCancelAnimationFrame ||
            function(id) {
                window.clearTimeout(id);
            }
        );
    })();

    // Detect the supported transition-end event property name
    // =======================================================
    var transitionEnd = (function() {
        var el = document.createElement("fakeelement"),
            t;

        var transitions = {
            transition: "transitionend",
            OTransition: "oTransitionEnd",
            MozTransition: "transitionend",
            WebkitTransition: "webkitTransitionEnd"
        };

        for (t in transitions) {
            if (el.style[t] !== undefined) {
                return transitions[t];
            }
        }

        return "transitionend";
    })();

    // Force redraw on an element.
    // This helps in cases where the browser doesn't redraw an updated element properly
    // ================================================================================
    var forceRedraw = function($el) {
        return $el && $el.length && $el[0].offsetHeight;
    };

    // Exclude array (`buttons`) options from deep merging
    // ===================================================
    var mergeOpts = function(opts1, opts2) {
        var rez = $.extend(true, {}, opts1, opts2);

        $.each(opts2, function(key, value) {
            if ($.isArray(value)) {
                rez[key] = value;
            }
        });

        return rez;
    };

    // How much of an element is visible in viewport
    // =============================================

    var inViewport = function(elem) {
        var elemCenter, rez;

        if (!elem || elem.ownerDocument !== document) {
            return false;
        }

        $(".fancybox-container").css("pointer-events", "none");

        elemCenter = {
            x: elem.getBoundingClientRect().left + elem.offsetWidth / 2,
            y: elem.getBoundingClientRect().top + elem.offsetHeight / 2
        };

        rez = document.elementFromPoint(elemCenter.x, elemCenter.y) === elem;

        $(".fancybox-container").css("pointer-events", "");

        return rez;
    };

    // Class definition
    // ================

    var FancyBox = function(content, opts, index) {
        var self = this;

        self.opts = mergeOpts({index: index}, $.fancybox.defaults);

        if ($.isPlainObject(opts)) {
            self.opts = mergeOpts(self.opts, opts);
        }

        if ($.fancybox.isMobile) {
            self.opts = mergeOpts(self.opts, self.opts.mobile);
        }

        self.id = self.opts.id || ++called;

        self.currIndex = parseInt(self.opts.index, 10) || 0;
        self.prevIndex = null;

        self.prevPos = null;
        self.currPos = 0;

        self.firstRun = true;

        // All group items
        self.group = [];

        // Existing slides (for current, next and previous gallery items)
        self.slides = {};

        // Create group elements
        self.addContent(content);

        if (!self.group.length) {
            return;
        }

        self.init();
    };

    $.extend(FancyBox.prototype, {
        // Create DOM structure
        // ====================

        init: function() {
            var self = this,
                firstItem = self.group[self.currIndex],
                firstItemOpts = firstItem.opts,
                $container,
                buttonStr;

            if (firstItemOpts.closeExisting) {
                $.fancybox.close(true);
            }

            // Hide scrollbars
            // ===============

            $("body").addClass("fancybox-active");

            if (
                !$.fancybox.getInstance() &&
                firstItemOpts.hideScrollbar !== false &&
                !$.fancybox.isMobile &&
                document.body.scrollHeight > window.innerHeight
            ) {
                $("head").append(
                    '<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar{margin-right:' +
                    (window.innerWidth - document.documentElement.clientWidth) +
                    "px;}</style>"
                );

                $("body").addClass("compensate-for-scrollbar");
            }

            // Build html markup and set references
            // ====================================

            // Build html code for buttons and insert into main template
            buttonStr = "";

            $.each(firstItemOpts.buttons, function(index, value) {
                buttonStr += firstItemOpts.btnTpl[value] || "";
            });

            // Create markup from base template, it will be initially hidden to
            // avoid unnecessary work like painting while initializing is not complete
            $container = $(
                self.translate(
                    self,
                    firstItemOpts.baseTpl
                        .replace("{{buttons}}", buttonStr)
                        .replace("{{arrows}}", firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight)
                )
            )
                .attr("id", "fancybox-container-" + self.id)
                .addClass(firstItemOpts.baseClass)
                .data("FancyBox", self)
                .appendTo(firstItemOpts.parentEl);

            // Create object holding references to jQuery wrapped nodes
            self.$refs = {
                container: $container
            };

            ["bg", "inner", "infobar", "toolbar", "stage", "caption", "navigation"].forEach(function(item) {
                self.$refs[item] = $container.find(".fancybox-" + item);
            });

            self.trigger("onInit");

            // Enable events, deactive previous instances
            self.activate();

            // Build slides, load and reveal content
            self.jumpTo(self.currIndex);
        },

        // Simple i18n support - replaces object keys found in template
        // with corresponding values
        // ============================================================

        translate: function(obj, str) {
            var arr = obj.opts.i18n[obj.opts.lang] || obj.opts.i18n.en;

            return str.replace(/\{\{(\w+)\}\}/g, function(match, n) {
                return arr[n] === undefined ? match : arr[n];
            });
        },

        // Populate current group with fresh content
        // Check if each object has valid type and content
        // ===============================================

        addContent: function(content) {
            var self = this,
                items = $.makeArray(content),
                thumbs;

            $.each(items, function(i, item) {
                var obj = {},
                    opts = {},
                    $item,
                    type,
                    found,
                    src,
                    srcParts;

                // Step 1 - Make sure we have an object
                // ====================================

                if ($.isPlainObject(item)) {
                    // We probably have manual usage here, something like
                    // $.fancybox.open( [ { src : "image.jpg", type : "image" } ] )

                    obj = item;
                    opts = item.opts || item;
                } else if ($.type(item) === "object" && $(item).length) {
                    // Here we probably have jQuery collection returned by some selector
                    $item = $(item);

                    // Support attributes like `data-options='{"touch" : false}'` and `data-touch='false'`
                    opts = $item.data() || {};
                    opts = $.extend(true, {}, opts, opts.options);

                    // Here we store clicked element
                    opts.$orig = $item;

                    obj.src = self.opts.src || opts.src || $item.attr("href");

                    // Assume that simple syntax is used, for example:
                    //   `$.fancybox.open( $("#test"), {} );`
                    if (!obj.type && !obj.src) {
                        obj.type = "inline";
                        obj.src = item;
                    }
                } else {
                    // Assume we have a simple html code, for example:
                    //   $.fancybox.open( '<div><h1>Hi!</h1></div>' );
                    obj = {
                        type: "html",
                        src: item + ""
                    };
                }

                // Each gallery object has full collection of options
                obj.opts = $.extend(true, {}, self.opts, opts);

                // Do not merge buttons array
                if ($.isArray(opts.buttons)) {
                    obj.opts.buttons = opts.buttons;
                }

                if ($.fancybox.isMobile && obj.opts.mobile) {
                    obj.opts = mergeOpts(obj.opts, obj.opts.mobile);
                }

                // Step 2 - Make sure we have content type, if not - try to guess
                // ==============================================================

                type = obj.type || obj.opts.type;
                src = obj.src || "";

                if (!type && src) {
                    if ((found = src.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i))) {
                        type = "video";

                        if (!obj.opts.video.format) {
                            obj.opts.video.format = "video/" + (found[1] === "ogv" ? "ogg" : found[1]);
                        }
                    } else if (src.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)) {
                        type = "image";
                    } else if (src.match(/\.(pdf)((\?|#).*)?$/i)) {
                        type = "iframe";
                        obj = $.extend(true, obj, {contentType: "pdf", opts: {iframe: {preload: false}}});
                    } else if (src.charAt(0) === "#") {
                        type = "inline";
                    }
                }

                if (type) {
                    obj.type = type;
                } else {
                    self.trigger("objectNeedsType", obj);
                }

                if (!obj.contentType) {
                    obj.contentType = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1 ? "html" : obj.type;
                }

                // Step 3 - Some adjustments
                // =========================

                obj.index = self.group.length;

                if (obj.opts.smallBtn == "auto") {
                    obj.opts.smallBtn = $.inArray(obj.type, ["html", "inline", "ajax"]) > -1;
                }

                if (obj.opts.toolbar === "auto") {
                    obj.opts.toolbar = !obj.opts.smallBtn;
                }

                // Find thumbnail image, check if exists and if is in the viewport
                obj.$thumb = obj.opts.$thumb || null;

                if (obj.opts.$trigger && obj.index === self.opts.index) {
                    obj.$thumb = obj.opts.$trigger.find("img:first");

                    if (obj.$thumb.length) {
                        obj.opts.$orig = obj.opts.$trigger;
                    }
                }

                if (!(obj.$thumb && obj.$thumb.length) && obj.opts.$orig) {
                    obj.$thumb = obj.opts.$orig.find("img:first");
                }

                if (obj.$thumb && !obj.$thumb.length) {
                    obj.$thumb = null;
                }

                obj.thumb = obj.opts.thumb || (obj.$thumb ? obj.$thumb[0].src : null);

                // "caption" is a "special" option, it can be used to customize caption per gallery item
                if ($.type(obj.opts.caption) === "function") {
                    obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);
                }

                if ($.type(self.opts.caption) === "function") {
                    obj.opts.caption = self.opts.caption.apply(item, [self, obj]);
                }

                // Make sure we have caption as a string or jQuery object
                if (!(obj.opts.caption instanceof $)) {
                    obj.opts.caption = obj.opts.caption === undefined ? "" : obj.opts.caption + "";
                }

                // Check if url contains "filter" used to filter the content
                // Example: "ajax.html #something"
                if (obj.type === "ajax") {
                    srcParts = src.split(/\s+/, 2);

                    if (srcParts.length > 1) {
                        obj.src = srcParts.shift();

                        obj.opts.filter = srcParts.shift();
                    }
                }

                // Hide all buttons and disable interactivity for modal items
                if (obj.opts.modal) {
                    obj.opts = $.extend(true, obj.opts, {
                        trapFocus: true,
                        // Remove buttons
                        infobar: 0,
                        toolbar: 0,

                        smallBtn: 0,

                        // Disable keyboard navigation
                        keyboard: 0,

                        // Disable some modules
                        slideShow: 0,
                        fullScreen: 0,
                        thumbs: 0,
                        touch: 0,

                        // Disable click event handlers
                        clickContent: false,
                        clickSlide: false,
                        clickOutside: false,
                        dblclickContent: false,
                        dblclickSlide: false,
                        dblclickOutside: false
                    });
                }

                // Step 4 - Add processed object to group
                // ======================================

                self.group.push(obj);
            });

            // Update controls if gallery is already opened
            if (Object.keys(self.slides).length) {
                self.updateControls();

                // Update thumbnails, if needed
                thumbs = self.Thumbs;

                if (thumbs && thumbs.isActive) {
                    thumbs.create();

                    thumbs.focus();
                }
            }
        },

        // Attach an event handler functions for:
        //   - navigation buttons
        //   - browser scrolling, resizing;
        //   - focusing
        //   - keyboard
        //   - detecting inactivity
        // ======================================

        addEvents: function() {
            var self = this;

            self.removeEvents();

            // Make navigation elements clickable
            // ==================================

            self.$refs.container
                .on("click.fb-close", "[data-fancybox-close]", function(e) {
                    e.stopPropagation();
                    e.preventDefault();

                    self.close(e);
                })
                .on("touchstart.fb-prev click.fb-prev", "[data-fancybox-prev]", function(e) {
                    e.stopPropagation();
                    e.preventDefault();

                    self.previous();
                })
                .on("touchstart.fb-next click.fb-next", "[data-fancybox-next]", function(e) {
                    e.stopPropagation();
                    e.preventDefault();

                    self.next();
                })
                .on("click.fb", "[data-fancybox-zoom]", function(e) {
                    // Click handler for zoom button
                    self[self.isScaledDown() ? "scaleToActual" : "scaleToFit"]();
                });

            // Handle page scrolling and browser resizing
            // ==========================================

            $W.on("orientationchange.fb resize.fb", function(e) {
                if (e && e.originalEvent && e.originalEvent.type === "resize") {
                    if (self.requestId) {
                        cancelAFrame(self.requestId);
                    }

                    self.requestId = requestAFrame(function() {
                        self.update(e);
                    });
                } else {
                    if (self.current && self.current.type === "iframe") {
                        self.$refs.stage.hide();
                    }

                    setTimeout(
                        function() {
                            self.$refs.stage.show();

                            self.update(e);
                        },
                        $.fancybox.isMobile ? 600 : 250
                    );
                }
            });

            $D.on("keydown.fb", function(e) {
                var instance = $.fancybox ? $.fancybox.getInstance() : null,
                    current = instance.current,
                    keycode = e.keyCode || e.which;

                // Trap keyboard focus inside of the modal
                // =======================================

                if (keycode == 9) {
                    if (current.opts.trapFocus) {
                        self.focus(e);
                    }

                    return;
                }

                // Enable keyboard navigation
                // ==========================

                if (!current.opts.keyboard || e.ctrlKey || e.altKey || e.shiftKey || $(e.target).is("input,textarea,video,audio")) {
                    return;
                }

                // Backspace and Esc keys
                if (keycode === 8 || keycode === 27) {
                    e.preventDefault();

                    self.close(e);

                    return;
                }

                // Left arrow and Up arrow
                if (keycode === 37 || keycode === 38) {
                    e.preventDefault();

                    self.previous();

                    return;
                }

                // Righ arrow and Down arrow
                if (keycode === 39 || keycode === 40) {
                    e.preventDefault();

                    self.next();

                    return;
                }

                self.trigger("afterKeydown", e, keycode);
            });

            // Hide controls after some inactivity period
            if (self.group[self.currIndex].opts.idleTime) {
                self.idleSecondsCounter = 0;

                $D.on(
                    "mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle",
                    function(e) {
                        self.idleSecondsCounter = 0;

                        if (self.isIdle) {
                            self.showControls();
                        }

                        self.isIdle = false;
                    }
                );

                self.idleInterval = window.setInterval(function() {
                    self.idleSecondsCounter++;

                    if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime && !self.isDragging) {
                        self.isIdle = true;
                        self.idleSecondsCounter = 0;

                        self.hideControls();
                    }
                }, 1000);
            }
        },

        // Remove events added by the core
        // ===============================

        removeEvents: function() {
            var self = this;

            $W.off("orientationchange.fb resize.fb");
            $D.off("keydown.fb .fb-idle");

            this.$refs.container.off(".fb-close .fb-prev .fb-next");

            if (self.idleInterval) {
                window.clearInterval(self.idleInterval);

                self.idleInterval = null;
            }
        },

        // Change to previous gallery item
        // ===============================

        previous: function(duration) {
            return this.jumpTo(this.currPos - 1, duration);
        },

        // Change to next gallery item
        // ===========================

        next: function(duration) {
            return this.jumpTo(this.currPos + 1, duration);
        },

        // Switch to selected gallery item
        // ===============================

        jumpTo: function(pos, duration) {
            var self = this,
                groupLen = self.group.length,
                firstRun,
                isMoved,
                loop,
                current,
                previous,
                slidePos,
                stagePos,
                prop,
                diff;

            if (self.isDragging || self.isClosing || (self.isAnimating && self.firstRun)) {
                return;
            }

            // Should loop?
            pos = parseInt(pos, 10);
            loop = self.current ? self.current.opts.loop : self.opts.loop;

            if (!loop && (pos < 0 || pos >= groupLen)) {
                return false;
            }

            // Check if opening for the first time; this helps to speed things up
            firstRun = self.firstRun = !Object.keys(self.slides).length;

            // Create slides
            previous = self.current;

            self.prevIndex = self.currIndex;
            self.prevPos = self.currPos;

            current = self.createSlide(pos);

            if (groupLen > 1) {
                if (loop || current.index < groupLen - 1) {
                    self.createSlide(pos + 1);
                }

                if (loop || current.index > 0) {
                    self.createSlide(pos - 1);
                }
            }

            self.current = current;
            self.currIndex = current.index;
            self.currPos = current.pos;

            self.trigger("beforeShow", firstRun);

            self.updateControls();

            // Validate duration length
            current.forcedDuration = undefined;

            if ($.isNumeric(duration)) {
                current.forcedDuration = duration;
            } else {
                duration = current.opts[firstRun ? "animationDuration" : "transitionDuration"];
            }

            duration = parseInt(duration, 10);

            // Check if user has swiped the slides or if still animating
            isMoved = self.isMoved(current);

            // Make sure current slide is visible
            current.$slide.addClass("fancybox-slide--current");

            // Fresh start - reveal container, current slide and start loading content
            if (firstRun) {
                if (current.opts.animationEffect && duration) {
                    self.$refs.container.css("transition-duration", duration + "ms");
                }

                self.$refs.container.addClass("fancybox-is-open").trigger("focus");

                // Attempt to load content into slide
                // This will later call `afterLoad` -> `revealContent`
                self.loadSlide(current);

                self.preload("image");

                return;
            }

            // Get actual slide/stage positions (before cleaning up)
            slidePos = $.fancybox.getTranslate(previous.$slide);
            stagePos = $.fancybox.getTranslate(self.$refs.stage);

            // Clean up all slides
            $.each(self.slides, function(index, slide) {
                $.fancybox.stop(slide.$slide, true);
            });

            if (previous.pos !== current.pos) {
                previous.isComplete = false;
            }

            previous.$slide.removeClass("fancybox-slide--complete fancybox-slide--current");

            // If slides are out of place, then animate them to correct position
            if (isMoved) {
                // Calculate horizontal swipe distance
                diff = slidePos.left - (previous.pos * slidePos.width + previous.pos * previous.opts.gutter);

                $.each(self.slides, function(index, slide) {
                    slide.$slide.removeClass("fancybox-animated").removeClass(function(index, className) {
                        return (className.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ");
                    });

                    // Make sure that each slide is in equal distance
                    // This is mostly needed for freshly added slides, because they are not yet positioned
                    var leftPos = slide.pos * slidePos.width + slide.pos * slide.opts.gutter;

                    $.fancybox.setTranslate(slide.$slide, {top: 0, left: leftPos - stagePos.left + diff});

                    if (slide.pos !== current.pos) {
                        slide.$slide.addClass("fancybox-slide--" + (slide.pos > current.pos ? "next" : "previous"));
                    }

                    // Redraw to make sure that transition will start
                    forceRedraw(slide.$slide);

                    // Animate the slide
                    $.fancybox.animate(
                        slide.$slide,
                        {
                            top: 0,
                            left: (slide.pos - current.pos) * slidePos.width + (slide.pos - current.pos) * slide.opts.gutter
                        },
                        duration,
                        function() {
                            slide.$slide
                                .css({
                                    transform: "",
                                    opacity: ""
                                })
                                .removeClass("fancybox-slide--next fancybox-slide--previous");

                            if (slide.pos === self.currPos) {
                                self.complete();
                            }
                        }
                    );
                });
            } else if (duration && current.opts.transitionEffect) {
                // Set transition effect for previously active slide
                prop = "fancybox-animated fancybox-fx-" + current.opts.transitionEffect;

                previous.$slide.addClass("fancybox-slide--" + (previous.pos > current.pos ? "next" : "previous"));

                $.fancybox.animate(
                    previous.$slide,
                    prop,
                    duration,
                    function() {
                        previous.$slide.removeClass(prop).removeClass("fancybox-slide--next fancybox-slide--previous");
                    },
                    false
                );
            }

            if (current.isLoaded) {
                self.revealContent(current);
            } else {
                self.loadSlide(current);
            }

            self.preload("image");
        },

        // Create new "slide" element
        // These are gallery items  that are actually added to DOM
        // =======================================================

        createSlide: function(pos) {
            var self = this,
                $slide,
                index;

            index = pos % self.group.length;
            index = index < 0 ? self.group.length + index : index;

            if (!self.slides[pos] && self.group[index]) {
                $slide = $('<div class="fancybox-slide"></div>').appendTo(self.$refs.stage);

                self.slides[pos] = $.extend(true, {}, self.group[index], {
                    pos: pos,
                    $slide: $slide,
                    isLoaded: false
                });

                self.updateSlide(self.slides[pos]);
            }

            return self.slides[pos];
        },

        // Scale image to the actual size of the image;
        // x and y values should be relative to the slide
        // ==============================================

        scaleToActual: function(x, y, duration) {
            var self = this,
                current = self.current,
                $content = current.$content,
                canvasWidth = $.fancybox.getTranslate(current.$slide).width,
                canvasHeight = $.fancybox.getTranslate(current.$slide).height,
                newImgWidth = current.width,
                newImgHeight = current.height,
                imgPos,
                posX,
                posY,
                scaleX,
                scaleY;

            if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
                return;
            }

            self.isAnimating = true;

            $.fancybox.stop($content);

            x = x === undefined ? canvasWidth * 0.5 : x;
            y = y === undefined ? canvasHeight * 0.5 : y;

            imgPos = $.fancybox.getTranslate($content);

            imgPos.top -= $.fancybox.getTranslate(current.$slide).top;
            imgPos.left -= $.fancybox.getTranslate(current.$slide).left;

            scaleX = newImgWidth / imgPos.width;
            scaleY = newImgHeight / imgPos.height;

            // Get center position for original image
            posX = canvasWidth * 0.5 - newImgWidth * 0.5;
            posY = canvasHeight * 0.5 - newImgHeight * 0.5;

            // Make sure image does not move away from edges
            if (newImgWidth > canvasWidth) {
                posX = imgPos.left * scaleX - (x * scaleX - x);

                if (posX > 0) {
                    posX = 0;
                }

                if (posX < canvasWidth - newImgWidth) {
                    posX = canvasWidth - newImgWidth;
                }
            }

            if (newImgHeight > canvasHeight) {
                posY = imgPos.top * scaleY - (y * scaleY - y);

                if (posY > 0) {
                    posY = 0;
                }

                if (posY < canvasHeight - newImgHeight) {
                    posY = canvasHeight - newImgHeight;
                }
            }

            self.updateCursor(newImgWidth, newImgHeight);

            $.fancybox.animate(
                $content,
                {
                    top: posY,
                    left: posX,
                    scaleX: scaleX,
                    scaleY: scaleY
                },
                duration || 366,
                function() {
                    self.isAnimating = false;
                }
            );

            // Stop slideshow
            if (self.SlideShow && self.SlideShow.isActive) {
                self.SlideShow.stop();
            }
        },

        // Scale image to fit inside parent element
        // ========================================

        scaleToFit: function(duration) {
            var self = this,
                current = self.current,
                $content = current.$content,
                end;

            if (self.isAnimating || self.isMoved() || !$content || !(current.type == "image" && current.isLoaded && !current.hasError)) {
                return;
            }

            self.isAnimating = true;

            $.fancybox.stop($content);

            end = self.getFitPos(current);

            self.updateCursor(end.width, end.height);

            $.fancybox.animate(
                $content,
                {
                    top: end.top,
                    left: end.left,
                    scaleX: end.width / $content.width(),
                    scaleY: end.height / $content.height()
                },
                duration || 366,
                function() {
                    self.isAnimating = false;
                }
            );
        },

        // Calculate image size to fit inside viewport
        // ===========================================

        getFitPos: function(slide) {
            var self = this,
                $content = slide.$content,
                $slide = slide.$slide,
                width = slide.width || slide.opts.width,
                height = slide.height || slide.opts.height,
                maxWidth,
                maxHeight,
                minRatio,
                aspectRatio,
                rez = {};

            if (!slide.isLoaded || !$content || !$content.length) {
                return false;
            }

            maxWidth = $.fancybox.getTranslate(self.$refs.stage).width;
            maxHeight = $.fancybox.getTranslate(self.$refs.stage).height;

            maxWidth -=
                parseFloat($slide.css("paddingLeft")) +
                parseFloat($slide.css("paddingRight")) +
                parseFloat($content.css("marginLeft")) +
                parseFloat($content.css("marginRight"));

            maxHeight -=
                parseFloat($slide.css("paddingTop")) +
                parseFloat($slide.css("paddingBottom")) +
                parseFloat($content.css("marginTop")) +
                parseFloat($content.css("marginBottom"));

            if (!width || !height) {
                width = maxWidth;
                height = maxHeight;
            }

            minRatio = Math.min(1, maxWidth / width, maxHeight / height);

            width = minRatio * width;
            height = minRatio * height;

            // Adjust width/height to precisely fit into container
            if (width > maxWidth - 0.5) {
                width = maxWidth;
            }

            if (height > maxHeight - 0.5) {
                height = maxHeight;
            }

            if (slide.type === "image") {
                rez.top = Math.floor((maxHeight - height) * 0.5) + parseFloat($slide.css("paddingTop"));
                rez.left = Math.floor((maxWidth - width) * 0.5) + parseFloat($slide.css("paddingLeft"));
            } else if (slide.contentType === "video") {
                // Force aspect ratio for the video
                // "I say the whole world must learn of our peaceful ways by force!"
                aspectRatio = slide.opts.width && slide.opts.height ? width / height : slide.opts.ratio || 16 / 9;

                if (height > width / aspectRatio) {
                    height = width / aspectRatio;
                } else if (width > height * aspectRatio) {
                    width = height * aspectRatio;
                }
            }

            rez.width = width;
            rez.height = height;

            return rez;
        },

        // Update content size and position for all slides
        // ==============================================

        update: function(e) {
            var self = this;

            $.each(self.slides, function(key, slide) {
                self.updateSlide(slide, e);
            });
        },

        // Update slide content position and size
        // ======================================

        updateSlide: function(slide, e) {
            var self = this,
                $content = slide && slide.$content,
                width = slide.width || slide.opts.width,
                height = slide.height || slide.opts.height,
                $slide = slide.$slide;

            // First, prevent caption overlap, if needed
            self.adjustCaption(slide);

            // Then resize content to fit inside the slide
            if ($content && (width || height || slide.contentType === "video") && !slide.hasError) {
                $.fancybox.stop($content);

                $.fancybox.setTranslate($content, self.getFitPos(slide));

                if (slide.pos === self.currPos) {
                    self.isAnimating = false;

                    self.updateCursor();
                }
            }

            // Then some adjustments
            self.adjustLayout(slide);

            if ($slide.length) {
                $slide.trigger("refresh");

                if (slide.pos === self.currPos) {
                    self.$refs.toolbar
                        .add(self.$refs.navigation.find(".fancybox-button--arrow_right"))
                        .toggleClass("compensate-for-scrollbar", $slide.get(0).scrollHeight > $slide.get(0).clientHeight);
                }
            }

            self.trigger("onUpdate", slide, e);
        },

        // Horizontally center slide
        // =========================

        centerSlide: function(duration) {
            var self = this,
                current = self.current,
                $slide = current.$slide;

            if (self.isClosing || !current) {
                return;
            }

            $slide.siblings().css({
                transform: "",
                opacity: ""
            });

            $slide
                .parent()
                .children()
                .removeClass("fancybox-slide--previous fancybox-slide--next");

            $.fancybox.animate(
                $slide,
                {
                    top: 0,
                    left: 0,
                    opacity: 1
                },
                duration === undefined ? 0 : duration,
                function() {
                    // Clean up
                    $slide.css({
                        transform: "",
                        opacity: ""
                    });

                    if (!current.isComplete) {
                        self.complete();
                    }
                },
                false
            );
        },

        // Check if current slide is moved (swiped)
        // ========================================

        isMoved: function(slide) {
            var current = slide || this.current,
                slidePos,
                stagePos;

            if (!current) {
                return false;
            }

            stagePos = $.fancybox.getTranslate(this.$refs.stage);
            slidePos = $.fancybox.getTranslate(current.$slide);

            return (
                !current.$slide.hasClass("fancybox-animated") &&
                (Math.abs(slidePos.top - stagePos.top) > 0.5 || Math.abs(slidePos.left - stagePos.left) > 0.5)
            );
        },

        // Update cursor style depending if content can be zoomed
        // ======================================================

        updateCursor: function(nextWidth, nextHeight) {
            var self = this,
                current = self.current,
                $container = self.$refs.container,
                canPan,
                isZoomable;

            if (!current || self.isClosing || !self.Guestures) {
                return;
            }

            $container.removeClass("fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-zoomOut fancybox-can-swipe fancybox-can-pan");

            canPan = self.canPan(nextWidth, nextHeight);

            isZoomable = canPan ? true : self.isZoomable();

            $container.toggleClass("fancybox-is-zoomable", isZoomable);

            $("[data-fancybox-zoom]").prop("disabled", !isZoomable);

            if (canPan) {
                $container.addClass("fancybox-can-pan");
            } else if (
                isZoomable &&
                (current.opts.clickContent === "zoom" || ($.isFunction(current.opts.clickContent) && current.opts.clickContent(current) == "zoom"))
            ) {
                $container.addClass("fancybox-can-zoomIn");
            } else if (current.opts.touch && (current.opts.touch.vertical || self.group.length > 1) && current.contentType !== "video") {
                $container.addClass("fancybox-can-swipe");
            }
        },

        // Check if current slide is zoomable
        // ==================================

        isZoomable: function() {
            var self = this,
                current = self.current,
                fitPos;

            // Assume that slide is zoomable if:
            //   - image is still loading
            //   - actual size of the image is smaller than available area
            if (current && !self.isClosing && current.type === "image" && !current.hasError) {
                if (!current.isLoaded) {
                    return true;
                }

                fitPos = self.getFitPos(current);

                if (fitPos && (current.width > fitPos.width || current.height > fitPos.height)) {
                    return true;
                }
            }

            return false;
        },

        // Check if current image dimensions are smaller than actual
        // =========================================================

        isScaledDown: function(nextWidth, nextHeight) {
            var self = this,
                rez = false,
                current = self.current,
                $content = current.$content;

            if (nextWidth !== undefined && nextHeight !== undefined) {
                rez = nextWidth < current.width && nextHeight < current.height;
            } else if ($content) {
                rez = $.fancybox.getTranslate($content);
                rez = rez.width < current.width && rez.height < current.height;
            }

            return rez;
        },

        // Check if image dimensions exceed parent element
        // ===============================================

        canPan: function(nextWidth, nextHeight) {
            var self = this,
                current = self.current,
                pos = null,
                rez = false;

            if (current.type === "image" && (current.isComplete || (nextWidth && nextHeight)) && !current.hasError) {
                rez = self.getFitPos(current);

                if (nextWidth !== undefined && nextHeight !== undefined) {
                    pos = {width: nextWidth, height: nextHeight};
                } else if (current.isComplete) {
                    pos = $.fancybox.getTranslate(current.$content);
                }

                if (pos && rez) {
                    rez = Math.abs(pos.width - rez.width) > 1.5 || Math.abs(pos.height - rez.height) > 1.5;
                }
            }

            return rez;
        },

        // Load content into the slide
        // ===========================

        loadSlide: function(slide) {
            var self = this,
                type,
                $slide,
                ajaxLoad;

            if (slide.isLoading || slide.isLoaded) {
                return;
            }

            slide.isLoading = true;

            if (self.trigger("beforeLoad", slide) === false) {
                slide.isLoading = false;

                return false;
            }

            type = slide.type;
            $slide = slide.$slide;

            $slide
                .off("refresh")
                .trigger("onReset")
                .addClass(slide.opts.slideClass);

            // Create content depending on the type
            switch (type) {
                case "image":
                    self.setImage(slide);

                    break;

                case "iframe":
                    self.setIframe(slide);

                    break;

                case "html":
                    self.setContent(slide, slide.src || slide.content);

                    break;

                case "video":
                    self.setContent(
                        slide,
                        slide.opts.video.tpl
                            .replace(/\{\{src\}\}/gi, slide.src)
                            .replace("{{format}}", slide.opts.videoFormat || slide.opts.video.format || "")
                            .replace("{{poster}}", slide.thumb || "")
                    );

                    break;

                case "inline":
                    if ($(slide.src).length) {
                        self.setContent(slide, $(slide.src));
                    } else {
                        self.setError(slide);
                    }

                    break;

                case "ajax":
                    self.showLoading(slide);

                    ajaxLoad = $.ajax(
                        $.extend({}, slide.opts.ajax.settings, {
                            url: slide.src,
                            success: function(data, textStatus) {
                                if (textStatus === "success") {
                                    self.setContent(slide, data);
                                }
                            },
                            error: function(jqXHR, textStatus) {
                                if (jqXHR && textStatus !== "abort") {
                                    self.setError(slide);
                                }
                            }
                        })
                    );

                    $slide.one("onReset", function() {
                        ajaxLoad.abort();
                    });

                    break;

                default:
                    self.setError(slide);

                    break;
            }

            return true;
        },

        // Use thumbnail image, if possible
        // ================================

        setImage: function(slide) {
            var self = this,
                ghost;

            // Check if need to show loading icon
            setTimeout(function() {
                var $img = slide.$image;

                if (!self.isClosing && slide.isLoading && (!$img || !$img.length || !$img[0].complete) && !slide.hasError) {
                    self.showLoading(slide);
                }
            }, 50);

            //Check if image has srcset
            self.checkSrcset(slide);

            // This will be wrapper containing both ghost and actual image
            slide.$content = $('<div class="fancybox-content"></div>')
                .addClass("fancybox-is-hidden")
                .appendTo(slide.$slide.addClass("fancybox-slide--image"));

            // If we have a thumbnail, we can display it while actual image is loading
            // Users will not stare at black screen and actual image will appear gradually
            if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && slide.thumb) {
                slide.width = slide.opts.width;
                slide.height = slide.opts.height;

                ghost = document.createElement("img");

                ghost.onerror = function() {
                    $(this).remove();

                    slide.$ghost = null;
                };

                ghost.onload = function() {
                    self.afterLoad(slide);
                };

                slide.$ghost = $(ghost)
                    .addClass("fancybox-image")
                    .appendTo(slide.$content)
                    .attr("src", slide.thumb);
            }

            // Start loading actual image
            self.setBigImage(slide);
        },

        // Check if image has srcset and get the source
        // ============================================
        checkSrcset: function(slide) {
            var srcset = slide.opts.srcset || slide.opts.image.srcset,
                found,
                temp,
                pxRatio,
                windowWidth;

            // If we have "srcset", then we need to find first matching "src" value.
            // This is necessary, because when you set an src attribute, the browser will preload the image
            // before any javascript or even CSS is applied.
            if (srcset) {
                pxRatio = window.devicePixelRatio || 1;
                windowWidth = window.innerWidth * pxRatio;

                temp = srcset.split(",").map(function(el) {
                    var ret = {};

                    el.trim()
                        .split(/\s+/)
                        .forEach(function(el, i) {
                            var value = parseInt(el.substring(0, el.length - 1), 10);

                            if (i === 0) {
                                return (ret.url = el);
                            }

                            if (value) {
                                ret.value = value;
                                ret.postfix = el[el.length - 1];
                            }
                        });

                    return ret;
                });

                // Sort by value
                temp.sort(function(a, b) {
                    return a.value - b.value;
                });

                // Ok, now we have an array of all srcset values
                for (var j = 0; j < temp.length; j++) {
                    var el = temp[j];

                    if ((el.postfix === "w" && el.value >= windowWidth) || (el.postfix === "x" && el.value >= pxRatio)) {
                        found = el;
                        break;
                    }
                }

                // If not found, take the last one
                if (!found && temp.length) {
                    found = temp[temp.length - 1];
                }

                if (found) {
                    slide.src = found.url;

                    // If we have default width/height values, we can calculate height for matching source
                    if (slide.width && slide.height && found.postfix == "w") {
                        slide.height = (slide.width / slide.height) * found.value;
                        slide.width = found.value;
                    }

                    slide.opts.srcset = srcset;
                }
            }
        },

        // Create full-size image
        // ======================

        setBigImage: function(slide) {
            var self = this,
                img = document.createElement("img"),
                $img = $(img);

            slide.$image = $img
                .one("error", function() {
                    self.setError(slide);
                })
                .one("load", function() {
                    var sizes;

                    if (!slide.$ghost) {
                        self.resolveImageSlideSize(slide, this.naturalWidth, this.naturalHeight);

                        self.afterLoad(slide);
                    }

                    if (self.isClosing) {
                        return;
                    }

                    if (slide.opts.srcset) {
                        sizes = slide.opts.sizes;

                        if (!sizes || sizes === "auto") {
                            sizes =
                                (slide.width / slide.height > 1 && $W.width() / $W.height() > 1 ? "100" : Math.round((slide.width / slide.height) * 100)) +
                                "vw";
                        }

                        $img.attr("sizes", sizes).attr("srcset", slide.opts.srcset);
                    }

                    // Hide temporary image after some delay
                    if (slide.$ghost) {
                        setTimeout(function() {
                            if (slide.$ghost && !self.isClosing) {
                                slide.$ghost.hide();
                            }
                        }, Math.min(300, Math.max(1000, slide.height / 1600)));
                    }

                    self.hideLoading(slide);
                })
                .addClass("fancybox-image")
                .attr("src", slide.src)
                .appendTo(slide.$content);

            if ((img.complete || img.readyState == "complete") && $img.naturalWidth && $img.naturalHeight) {
                $img.trigger("load");
            } else if (img.error) {
                $img.trigger("error");
            }
        },

        // Computes the slide size from image size and maxWidth/maxHeight
        // ==============================================================

        resolveImageSlideSize: function(slide, imgWidth, imgHeight) {
            var maxWidth = parseInt(slide.opts.width, 10),
                maxHeight = parseInt(slide.opts.height, 10);

            // Sets the default values from the image
            slide.width = imgWidth;
            slide.height = imgHeight;

            if (maxWidth > 0) {
                slide.width = maxWidth;
                slide.height = Math.floor((maxWidth * imgHeight) / imgWidth);
            }

            if (maxHeight > 0) {
                slide.width = Math.floor((maxHeight * imgWidth) / imgHeight);
                slide.height = maxHeight;
            }
        },

        // Create iframe wrapper, iframe and bindings
        // ==========================================

        setIframe: function(slide) {
            var self = this,
                opts = slide.opts.iframe,
                $slide = slide.$slide,
                $iframe;

            slide.$content = $('<div class="fancybox-content' + (opts.preload ? " fancybox-is-hidden" : "") + '"></div>')
                .css(opts.css)
                .appendTo($slide);

            $slide.addClass("fancybox-slide--" + slide.contentType);

            slide.$iframe = $iframe = $(opts.tpl.replace(/\{rnd\}/g, new Date().getTime()))
                .attr(opts.attr)
                .appendTo(slide.$content);

            if (opts.preload) {
                self.showLoading(slide);

                // Unfortunately, it is not always possible to determine if iframe is successfully loaded
                // (due to browser security policy)

                $iframe.on("load.fb error.fb", function(e) {
                    this.isReady = 1;

                    slide.$slide.trigger("refresh");

                    self.afterLoad(slide);
                });

                // Recalculate iframe content size
                // ===============================

                $slide.on("refresh.fb", function() {
                    var $content = slide.$content,
                        frameWidth = opts.css.width,
                        frameHeight = opts.css.height,
                        $contents,
                        $body;

                    if ($iframe[0].isReady !== 1) {
                        return;
                    }

                    try {
                        $contents = $iframe.contents();
                        $body = $contents.find("body");
                    } catch (ignore) {}

                    // Calculate content dimensions, if it is accessible
                    if ($body && $body.length && $body.children().length) {
                        // Avoid scrolling to top (if multiple instances)
                        $slide.css("overflow", "visible");

                        $content.css({
                            width: "100%",
                            "max-width": "100%",
                            height: "9999px"
                        });

                        if (frameWidth === undefined) {
                            frameWidth = Math.ceil(Math.max($body[0].clientWidth, $body.outerWidth(true)));
                        }

                        $content.css("width", frameWidth ? frameWidth : "").css("max-width", "");

                        if (frameHeight === undefined) {
                            frameHeight = Math.ceil(Math.max($body[0].clientHeight, $body.outerHeight(true)));
                        }

                        $content.css("height", frameHeight ? frameHeight : "");

                        $slide.css("overflow", "auto");
                    }

                    $content.removeClass("fancybox-is-hidden");
                });
            } else {
                self.afterLoad(slide);
            }

            $iframe.attr("src", slide.src);

            // Remove iframe if closing or changing gallery item
            $slide.one("onReset", function() {
                // This helps IE not to throw errors when closing
                try {
                    $(this)
                        .find("iframe")
                        .hide()
                        .unbind()
                        .attr("src", "//about:blank");
                } catch (ignore) {}

                $(this)
                    .off("refresh.fb")
                    .empty();

                slide.isLoaded = false;
                slide.isRevealed = false;
            });
        },

        // Wrap and append content to the slide
        // ======================================

        setContent: function(slide, content) {
            var self = this;

            if (self.isClosing) {
                return;
            }

            self.hideLoading(slide);

            if (slide.$content) {
                $.fancybox.stop(slide.$content);
            }

            slide.$slide.empty();

            // If content is a jQuery object, then it will be moved to the slide.
            // The placeholder is created so we will know where to put it back.
            if (isQuery(content) && content.parent().length) {
                // Make sure content is not already moved to fancyBox
                if (content.hasClass("fancybox-content") || content.parent().hasClass("fancybox-content")) {
                    content.parents(".fancybox-slide").trigger("onReset");
                }

                // Create temporary element marking original place of the content
                slide.$placeholder = $("<div>")
                    .hide()
                    .insertAfter(content);

                // Make sure content is visible
                content.css("display", "inline-block");
            } else if (!slide.hasError) {
                // If content is just a plain text, try to convert it to html
                if ($.type(content) === "string") {
                    content = $("<div>")
                        .append($.trim(content))
                        .contents();
                }

                // If "filter" option is provided, then filter content
                if (slide.opts.filter) {
                    content = $("<div>")
                        .html(content)
                        .find(slide.opts.filter);
                }
            }

            slide.$slide.one("onReset", function() {
                // Pause all html5 video/audio
                $(this)
                    .find("video,audio")
                    .trigger("pause");

                // Put content back
                if (slide.$placeholder) {
                    slide.$placeholder.after(content.removeClass("fancybox-content").hide()).remove();

                    slide.$placeholder = null;
                }

                // Remove custom close button
                if (slide.$smallBtn) {
                    slide.$smallBtn.remove();

                    slide.$smallBtn = null;
                }

                // Remove content and mark slide as not loaded
                if (!slide.hasError) {
                    $(this).empty();

                    slide.isLoaded = false;
                    slide.isRevealed = false;
                }
            });

            $(content).appendTo(slide.$slide);

            if ($(content).is("video,audio")) {
                $(content).addClass("fancybox-video");

                $(content).wrap("<div></div>");

                slide.contentType = "video";

                slide.opts.width = slide.opts.width || $(content).attr("width");
                slide.opts.height = slide.opts.height || $(content).attr("height");
            }

            slide.$content = slide.$slide
                .children()
                .filter("div,form,main,video,audio,article,.fancybox-content")
                .first();

            slide.$content.siblings().hide();

            // Re-check if there is a valid content
            // (in some cases, ajax response can contain various elements or plain text)
            if (!slide.$content.length) {
                slide.$content = slide.$slide
                    .wrapInner("<div></div>")
                    .children()
                    .first();
            }

            slide.$content.addClass("fancybox-content");

            slide.$slide.addClass("fancybox-slide--" + slide.contentType);

            self.afterLoad(slide);
        },

        // Display error message
        // =====================

        setError: function(slide) {
            slide.hasError = true;

            slide.$slide
                .trigger("onReset")
                .removeClass("fancybox-slide--" + slide.contentType)
                .addClass("fancybox-slide--error");

            slide.contentType = "html";

            this.setContent(slide, this.translate(slide, slide.opts.errorTpl));

            if (slide.pos === this.currPos) {
                this.isAnimating = false;
            }
        },

        // Show loading icon inside the slide
        // ==================================

        showLoading: function(slide) {
            var self = this;

            slide = slide || self.current;

            if (slide && !slide.$spinner) {
                slide.$spinner = $(self.translate(self, self.opts.spinnerTpl))
                    .appendTo(slide.$slide)
                    .hide()
                    .fadeIn("fast");
            }
        },

        // Remove loading icon from the slide
        // ==================================

        hideLoading: function(slide) {
            var self = this;

            slide = slide || self.current;

            if (slide && slide.$spinner) {
                slide.$spinner.stop().remove();

                delete slide.$spinner;
            }
        },

        // Adjustments after slide content has been loaded
        // ===============================================

        afterLoad: function(slide) {
            var self = this;

            if (self.isClosing) {
                return;
            }

            slide.isLoading = false;
            slide.isLoaded = true;

            self.trigger("afterLoad", slide);

            self.hideLoading(slide);

            // Add small close button
            if (slide.opts.smallBtn && (!slide.$smallBtn || !slide.$smallBtn.length)) {
                slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content);
            }

            // Disable right click
            if (slide.opts.protect && slide.$content && !slide.hasError) {
                slide.$content.on("contextmenu.fb", function(e) {
                    if (e.button == 2) {
                        e.preventDefault();
                    }

                    return true;
                });

                // Add fake element on top of the image
                // This makes a bit harder for user to select image
                if (slide.type === "image") {
                    $('<div class="fancybox-spaceball"></div>').appendTo(slide.$content);
                }
            }

            self.adjustCaption(slide);

            self.adjustLayout(slide);

            if (slide.pos === self.currPos) {
                self.updateCursor();
            }

            self.revealContent(slide);
        },

        // Prevent caption overlap,
        // fix css inconsistency across browsers
        // =====================================

        adjustCaption: function(slide) {
            var self = this,
                current = slide || self.current,
                caption = current.opts.caption,
                $caption = self.$refs.caption,
                captionH = false,
                preventOverlap = current.opts.preventCaptionOverlap;

            $caption.toggleClass("fancybox-caption--separate", preventOverlap);

            if (preventOverlap && caption && caption.length) {
                if (current.pos !== self.currPos) {
                    $caption = $caption
                        .clone()
                        .empty()
                        .appendTo($caption.parent());

                    $caption.html(caption);

                    captionH = $caption.outerHeight(true);

                    $caption.empty().remove();
                } else if (self.$caption) {
                    captionH = self.$caption.outerHeight(true);
                }

                current.$slide.css("padding-bottom", captionH || "");
            }
        },

        // Simple hack to fix inconsistency across browsers, described here (affects Edge, too):
        // https://bugzilla.mozilla.org/show_bug.cgi?id=748518
        // ====================================================================================

        adjustLayout: function(slide) {
            var self = this,
                current = slide || self.current,
                scrollHeight,
                marginBottom,
                inlinePadding,
                actualPadding;

            if (current.isLoaded && current.opts.disableLayoutFix !== true) {
                current.$content.css("margin-bottom", "");

                // If we would always set margin-bottom for the content,
                // then it would potentially break vertical align
                if (current.$content.outerHeight() > current.$slide.height() + 0.5) {
                    inlinePadding = current.$slide[0].style["padding-bottom"];
                    actualPadding = current.$slide.css("padding-bottom");

                    if (parseFloat(actualPadding) > 0) {
                        scrollHeight = current.$slide[0].scrollHeight;

                        current.$slide.css("padding-bottom", 0);

                        if (Math.abs(scrollHeight - current.$slide[0].scrollHeight) < 1) {
                            marginBottom = actualPadding;
                        }

                        current.$slide.css("padding-bottom", inlinePadding);
                    }
                }

                current.$content.css("margin-bottom", marginBottom);
            }
        },

        // Make content visible
        // This method is called right after content has been loaded or
        // user navigates gallery and transition should start
        // ============================================================

        revealContent: function(slide) {
            var self = this,
                $slide = slide.$slide,
                end = false,
                start = false,
                isMoved = self.isMoved(slide),
                isRevealed = slide.isRevealed,
                effect,
                effectClassName,
                duration,
                opacity;

            slide.isRevealed = true;

            effect = slide.opts[self.firstRun ? "animationEffect" : "transitionEffect"];
            duration = slide.opts[self.firstRun ? "animationDuration" : "transitionDuration"];

            duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);

            if (isMoved || slide.pos !== self.currPos || !duration) {
                effect = false;
            }

            // Check if can zoom
            if (effect === "zoom") {
                if (slide.pos === self.currPos && duration && slide.type === "image" && !slide.hasError && (start = self.getThumbPos(slide))) {
                    end = self.getFitPos(slide);
                } else {
                    effect = "fade";
                }
            }

            // Zoom animation
            // ==============
            if (effect === "zoom") {
                self.isAnimating = true;

                end.scaleX = end.width / start.width;
                end.scaleY = end.height / start.height;

                // Check if we need to animate opacity
                opacity = slide.opts.zoomOpacity;

                if (opacity == "auto") {
                    opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1;
                }

                if (opacity) {
                    start.opacity = 0.1;
                    end.opacity = 1;
                }

                // Draw image at start position
                $.fancybox.setTranslate(slide.$content.removeClass("fancybox-is-hidden"), start);

                forceRedraw(slide.$content);

                // Start animation
                $.fancybox.animate(slide.$content, end, duration, function() {
                    self.isAnimating = false;

                    self.complete();
                });

                return;
            }

            self.updateSlide(slide);

            // Simply show content if no effect
            // ================================
            if (!effect) {
                slide.$content.removeClass("fancybox-is-hidden");

                if (!isRevealed && isMoved && slide.type === "image" && !slide.hasError) {
                    slide.$content.hide().fadeIn("fast");
                }

                if (slide.pos === self.currPos) {
                    self.complete();
                }

                return;
            }

            // Prepare for CSS transiton
            // =========================
            $.fancybox.stop($slide);

            //effectClassName = "fancybox-animated fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-fx-" + effect;
            effectClassName = "fancybox-slide--" + (slide.pos >= self.prevPos ? "next" : "previous") + " fancybox-animated fancybox-fx-" + effect;

            $slide.addClass(effectClassName).removeClass("fancybox-slide--current"); //.addClass(effectClassName);

            slide.$content.removeClass("fancybox-is-hidden");

            // Force reflow
            forceRedraw($slide);

            if (slide.type !== "image") {
                slide.$content.hide().show(0);
            }

            $.fancybox.animate(
                $slide,
                "fancybox-slide--current",
                duration,
                function() {
                    $slide.removeClass(effectClassName).css({
                        transform: "",
                        opacity: ""
                    });

                    if (slide.pos === self.currPos) {
                        self.complete();
                    }
                },
                true
            );
        },

        // Check if we can and have to zoom from thumbnail
        //================================================

        getThumbPos: function(slide) {
            var rez = false,
                $thumb = slide.$thumb,
                thumbPos,
                btw,
                brw,
                bbw,
                blw;

            if (!$thumb || !inViewport($thumb[0])) {
                return false;
            }

            thumbPos = $.fancybox.getTranslate($thumb);

            btw = parseFloat($thumb.css("border-top-width") || 0);
            brw = parseFloat($thumb.css("border-right-width") || 0);
            bbw = parseFloat($thumb.css("border-bottom-width") || 0);
            blw = parseFloat($thumb.css("border-left-width") || 0);

            rez = {
                top: thumbPos.top + btw,
                left: thumbPos.left + blw,
                width: thumbPos.width - brw - blw,
                height: thumbPos.height - btw - bbw,
                scaleX: 1,
                scaleY: 1
            };

            return thumbPos.width > 0 && thumbPos.height > 0 ? rez : false;
        },

        // Final adjustments after current gallery item is moved to position
        // and it`s content is loaded
        // ==================================================================

        complete: function() {
            var self = this,
                current = self.current,
                slides = {},
                $el;

            if (self.isMoved() || !current.isLoaded) {
                return;
            }

            if (!current.isComplete) {
                current.isComplete = true;

                current.$slide.siblings().trigger("onReset");

                self.preload("inline");

                // Trigger any CSS transiton inside the slide
                forceRedraw(current.$slide);

                current.$slide.addClass("fancybox-slide--complete");

                // Remove unnecessary slides
                $.each(self.slides, function(key, slide) {
                    if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {
                        slides[slide.pos] = slide;
                    } else if (slide) {
                        $.fancybox.stop(slide.$slide);

                        slide.$slide.off().remove();
                    }
                });

                self.slides = slides;
            }

            self.isAnimating = false;

            self.updateCursor();

            self.trigger("afterShow");

            // Autoplay first html5 video/audio
            if (!!current.opts.video.autoStart) {
                current.$slide
                    .find("video,audio")
                    .filter(":visible:first")
                    .trigger("play")
                    .one("ended", function() {
                        if (this.webkitExitFullscreen) {
                            this.webkitExitFullscreen();
                        }

                        self.next();
                    });
            }

            // Try to focus on the first focusable element
            if (current.opts.autoFocus && current.contentType === "html") {
                // Look for the first input with autofocus attribute
                $el = current.$content.find("input[autofocus]:enabled:visible:first");

                if ($el.length) {
                    $el.trigger("focus");
                } else {
                    self.focus(null, true);
                }
            }

            // Avoid jumping
            current.$slide.scrollTop(0).scrollLeft(0);
        },

        // Preload next and previous slides
        // ================================

        preload: function(type) {
            var self = this,
                prev,
                next;

            if (self.group.length < 2) {
                return;
            }

            next = self.slides[self.currPos + 1];
            prev = self.slides[self.currPos - 1];

            if (prev && prev.type === type) {
                self.loadSlide(prev);
            }

            if (next && next.type === type) {
                self.loadSlide(next);
            }
        },

        // Try to find and focus on the first focusable element
        // ====================================================

        focus: function(e, firstRun) {
            var self = this,
                focusableStr = [
                    "a[href]",
                    "area[href]",
                    'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
                    "select:not([disabled]):not([aria-hidden])",
                    "textarea:not([disabled]):not([aria-hidden])",
                    "button:not([disabled]):not([aria-hidden])",
                    "iframe",
                    "object",
                    "embed",
                    "video",
                    "audio",
                    "[contenteditable]",
                    '[tabindex]:not([tabindex^="-"])'
                ].join(","),
                focusableItems,
                focusedItemIndex;

            if (self.isClosing) {
                return;
            }

            if (e || !self.current || !self.current.isComplete) {
                // Focus on any element inside fancybox
                focusableItems = self.$refs.container.find("*:visible");
            } else {
                // Focus inside current slide
                focusableItems = self.current.$slide.find("*:visible" + (firstRun ? ":not(.fancybox-close-small)" : ""));
            }

            focusableItems = focusableItems.filter(focusableStr).filter(function() {
                return $(this).css("visibility") !== "hidden" && !$(this).hasClass("disabled");
            });

            if (focusableItems.length) {
                focusedItemIndex = focusableItems.index(document.activeElement);

                if (e && e.shiftKey) {
                    // Back tab
                    if (focusedItemIndex < 0 || focusedItemIndex == 0) {
                        e.preventDefault();

                        focusableItems.eq(focusableItems.length - 1).trigger("focus");
                    }
                } else {
                    // Outside or Forward tab
                    if (focusedItemIndex < 0 || focusedItemIndex == focusableItems.length - 1) {
                        if (e) {
                            e.preventDefault();
                        }

                        focusableItems.eq(0).trigger("focus");
                    }
                }
            } else {
                self.$refs.container.trigger("focus");
            }
        },

        // Activates current instance - brings container to the front and enables keyboard,
        // notifies other instances about deactivating
        // =================================================================================

        activate: function() {
            var self = this;

            // Deactivate all instances
            $(".fancybox-container").each(function() {
                var instance = $(this).data("FancyBox");

                // Skip self and closing instances
                if (instance && instance.id !== self.id && !instance.isClosing) {
                    instance.trigger("onDeactivate");

                    instance.removeEvents();

                    instance.isVisible = false;
                }
            });

            self.isVisible = true;

            if (self.current || self.isIdle) {
                self.update();

                self.updateControls();
            }

            self.trigger("onActivate");

            self.addEvents();
        },

        // Start closing procedure
        // This will start "zoom-out" animation if needed and clean everything up afterwards
        // =================================================================================

        close: function(e, d) {
            var self = this,
                current = self.current,
                effect,
                duration,
                $content,
                domRect,
                opacity,
                start,
                end;

            var done = function() {
                self.cleanUp(e);
            };

            if (self.isClosing) {
                return false;
            }

            self.isClosing = true;

            // If beforeClose callback prevents closing, make sure content is centered
            if (self.trigger("beforeClose", e) === false) {
                self.isClosing = false;

                requestAFrame(function() {
                    self.update();
                });

                return false;
            }

            // Remove all events
            // If there are multiple instances, they will be set again by "activate" method
            self.removeEvents();

            $content = current.$content;
            effect = current.opts.animationEffect;
            duration = $.isNumeric(d) ? d : effect ? current.opts.animationDuration : 0;

            current.$slide.removeClass("fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated");

            if (e !== true) {
                $.fancybox.stop(current.$slide);
            } else {
                effect = false;
            }

            // Remove other slides
            current.$slide
                .siblings()
                .trigger("onReset")
                .remove();

            // Trigger animations
            if (duration) {
                self.$refs.container
                    .removeClass("fancybox-is-open")
                    .addClass("fancybox-is-closing")
                    .css("transition-duration", duration + "ms");
            }

            // Clean up
            self.hideLoading(current);

            self.hideControls(true);

            self.updateCursor();

            // Check if possible to zoom-out
            if (
                effect === "zoom" &&
                !($content && duration && current.type === "image" && !self.isMoved() && !current.hasError && (end = self.getThumbPos(current)))
            ) {
                effect = "fade";
            }

            if (effect === "zoom") {
                $.fancybox.stop($content);

                domRect = $.fancybox.getTranslate($content);

                start = {
                    top: domRect.top,
                    left: domRect.left,
                    scaleX: domRect.width / end.width,
                    scaleY: domRect.height / end.height,
                    width: end.width,
                    height: end.height
                };

                // Check if we need to animate opacity
                opacity = current.opts.zoomOpacity;

                if (opacity == "auto") {
                    opacity = Math.abs(current.width / current.height - end.width / end.height) > 0.1;
                }

                if (opacity) {
                    end.opacity = 0;
                }

                $.fancybox.setTranslate($content, start);

                forceRedraw($content);

                $.fancybox.animate($content, end, duration, done);

                return true;
            }

            if (effect && duration) {
                $.fancybox.animate(
                    current.$slide.addClass("fancybox-slide--previous").removeClass("fancybox-slide--current"),
                    "fancybox-animated fancybox-fx-" + effect,
                    duration,
                    done
                );
            } else {
                // If skip animation
                if (e === true) {
                    setTimeout(done, duration);
                } else {
                    done();
                }
            }

            return true;
        },

        // Final adjustments after removing the instance
        // =============================================

        cleanUp: function(e) {
            var self = this,
                instance,
                $focus = self.current.opts.$orig,
                x,
                y;

            self.current.$slide.trigger("onReset");

            self.$refs.container.empty().remove();

            self.trigger("afterClose", e);

            // Place back focus
            if (!!self.current.opts.backFocus) {
                if (!$focus || !$focus.length || !$focus.is(":visible")) {
                    $focus = self.$trigger;
                }

                if ($focus && $focus.length) {
                    x = window.scrollX;
                    y = window.scrollY;

                    $focus.trigger("focus");

                    $("html, body")
                        .scrollTop(y)
                        .scrollLeft(x);
                }
            }

            self.current = null;

            // Check if there are other instances
            instance = $.fancybox.getInstance();

            if (instance) {
                instance.activate();
            } else {
                $("body").removeClass("fancybox-active compensate-for-scrollbar");

                $("#fancybox-style-noscroll").remove();
            }
        },

        // Call callback and trigger an event
        // ==================================

        trigger: function(name, slide) {
            var args = Array.prototype.slice.call(arguments, 1),
                self = this,
                obj = slide && slide.opts ? slide : self.current,
                rez;

            if (obj) {
                args.unshift(obj);
            } else {
                obj = self;
            }

            args.unshift(self);

            if ($.isFunction(obj.opts[name])) {
                rez = obj.opts[name].apply(obj, args);
            }

            if (rez === false) {
                return rez;
            }

            if (name === "afterClose" || !self.$refs) {
                $D.trigger(name + ".fb", args);
            } else {
                self.$refs.container.trigger(name + ".fb", args);
            }
        },

        // Update infobar values, navigation button states and reveal caption
        // ==================================================================

        updateControls: function() {
            var self = this,
                current = self.current,
                index = current.index,
                $container = self.$refs.container,
                $caption = self.$refs.caption,
                caption = current.opts.caption;

            // Recalculate content dimensions
            current.$slide.trigger("refresh");

            self.$caption = caption && caption.length ? $caption.html(caption) : null;

            if (!self.hasHiddenControls && !self.isIdle) {
                self.showControls();
            }

            // Update info and navigation elements
            $container.find("[data-fancybox-count]").html(self.group.length);
            $container.find("[data-fancybox-index]").html(index + 1);

            $container.find("[data-fancybox-prev]").prop("disabled", !current.opts.loop && index <= 0);
            $container.find("[data-fancybox-next]").prop("disabled", !current.opts.loop && index >= self.group.length - 1);

            if (current.type === "image") {
                // Re-enable buttons; update download button source
                $container
                    .find("[data-fancybox-zoom]")
                    .show()
                    .end()
                    .find("[data-fancybox-download]")
                    .attr("href", current.opts.image.src || current.src)
                    .show();
            } else if (current.opts.toolbar) {
                $container.find("[data-fancybox-download],[data-fancybox-zoom]").hide();
            }

            // Make sure focus is not on disabled button/element
            if ($(document.activeElement).is(":hidden,[disabled]")) {
                self.$refs.container.trigger("focus");
            }
        },

        // Hide toolbar and caption
        // ========================

        hideControls: function(andCaption) {
            var self = this,
                arr = ["infobar", "toolbar", "nav"];

            if (andCaption || !self.current.opts.preventCaptionOverlap) {
                arr.push("caption");
            }

            this.$refs.container.removeClass(
                arr
                    .map(function(i) {
                        return "fancybox-show-" + i;
                    })
                    .join(" ")
            );

            this.hasHiddenControls = true;
        },

        showControls: function() {
            var self = this,
                opts = self.current ? self.current.opts : self.opts,
                $container = self.$refs.container;

            self.hasHiddenControls = false;
            self.idleSecondsCounter = 0;

            $container
                .toggleClass("fancybox-show-toolbar", !!(opts.toolbar && opts.buttons))
                .toggleClass("fancybox-show-infobar", !!(opts.infobar && self.group.length > 1))
                .toggleClass("fancybox-show-caption", !!self.$caption)
                .toggleClass("fancybox-show-nav", !!(opts.arrows && self.group.length > 1))
                .toggleClass("fancybox-is-modal", !!opts.modal);
        },

        // Toggle toolbar and caption
        // ==========================

        toggleControls: function() {
            if (this.hasHiddenControls) {
                this.showControls();
            } else {
                this.hideControls();
            }
        }
    });

    $.fancybox = {
        version: "3.5.3",
        defaults: defaults,

        // Get current instance and execute a command.
        //
        // Examples of usage:
        //
        //   $instance = $.fancybox.getInstance();
        //   $.fancybox.getInstance().jumpTo( 1 );
        //   $.fancybox.getInstance( 'jumpTo', 1 );
        //   $.fancybox.getInstance( function() {
        //       console.info( this.currIndex );
        //   });
        // ======================================================

        getInstance: function(command) {
            var instance = $('.fancybox-container:not(".fancybox-is-closing"):last').data("FancyBox"),
                args = Array.prototype.slice.call(arguments, 1);

            if (instance instanceof FancyBox) {
                if ($.type(command) === "string") {
                    instance[command].apply(instance, args);
                } else if ($.type(command) === "function") {
                    command.apply(instance, args);
                }

                return instance;
            }

            return false;
        },

        // Create new instance
        // ===================

        open: function(items, opts, index) {
            return new FancyBox(items, opts, index);
        },

        // Close current or all instances
        // ==============================

        close: function(all) {
            var instance = this.getInstance();

            if (instance) {
                instance.close();

                // Try to find and close next instance
                if (all === true) {
                    this.close(all);
                }
            }
        },

        // Close all instances and unbind all events
        // =========================================

        destroy: function() {
            this.close(true);

            $D.add("body").off("click.fb-start", "**");
        },

        // Try to detect mobile devices
        // ============================

        isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),

        // Detect if 'translate3d' support is available
        // ============================================

        use3d: (function() {
            var div = document.createElement("div");

            return (
                window.getComputedStyle &&
                window.getComputedStyle(div) &&
                window.getComputedStyle(div).getPropertyValue("transform") &&
                !(document.documentMode && document.documentMode < 11)
            );
        })(),

        // Helper function to get current visual state of an element
        // returns array[ top, left, horizontal-scale, vertical-scale, opacity ]
        // =====================================================================

        getTranslate: function($el) {
            var domRect;

            if (!$el || !$el.length) {
                return false;
            }

            domRect = $el[0].getBoundingClientRect();

            return {
                top: domRect.top || 0,
                left: domRect.left || 0,
                width: domRect.width,
                height: domRect.height,
                opacity: parseFloat($el.css("opacity"))
            };
        },

        // Shortcut for setting "translate3d" properties for element
        // Can set be used to set opacity, too
        // ========================================================

        setTranslate: function($el, props) {
            var str = "",
                css = {};

            if (!$el || !props) {
                return;
            }

            if (props.left !== undefined || props.top !== undefined) {
                str =
                    (props.left === undefined ? $el.position().left : props.left) +
                    "px, " +
                    (props.top === undefined ? $el.position().top : props.top) +
                    "px";

                if (this.use3d) {
                    str = "translate3d(" + str + ", 0px)";
                } else {
                    str = "translate(" + str + ")";
                }
            }

            if (props.scaleX !== undefined && props.scaleY !== undefined) {
                str += " scale(" + props.scaleX + ", " + props.scaleY + ")";
            } else if (props.scaleX !== undefined) {
                str += " scaleX(" + props.scaleX + ")";
            }

            if (str.length) {
                css.transform = str;
            }

            if (props.opacity !== undefined) {
                css.opacity = props.opacity;
            }

            if (props.width !== undefined) {
                css.width = props.width;
            }

            if (props.height !== undefined) {
                css.height = props.height;
            }

            return $el.css(css);
        },

        // Simple CSS transition handler
        // =============================

        animate: function($el, to, duration, callback, leaveAnimationName) {
            var self = this,
                from;

            if ($.isFunction(duration)) {
                callback = duration;
                duration = null;
            }

            self.stop($el);

            from = self.getTranslate($el);

            $el.on(transitionEnd, function(e) {
                // Skip events from child elements and z-index change
                if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == "z-index")) {
                    return;
                }

                self.stop($el);

                if ($.isNumeric(duration)) {
                    $el.css("transition-duration", "");
                }

                if ($.isPlainObject(to)) {
                    if (to.scaleX !== undefined && to.scaleY !== undefined) {
                        self.setTranslate($el, {
                            top: to.top,
                            left: to.left,
                            width: from.width * to.scaleX,
                            height: from.height * to.scaleY,
                            scaleX: 1,
                            scaleY: 1
                        });
                    }
                } else if (leaveAnimationName !== true) {
                    $el.removeClass(to);
                }

                if ($.isFunction(callback)) {
                    callback(e);
                }
            });

            if ($.isNumeric(duration)) {
                $el.css("transition-duration", duration + "ms");
            }

            // Start animation by changing CSS properties or class name
            if ($.isPlainObject(to)) {
                if (to.scaleX !== undefined && to.scaleY !== undefined) {
                    delete to.width;
                    delete to.height;

                    if ($el.parent().hasClass("fancybox-slide--image")) {
                        $el.parent().addClass("fancybox-is-scaling");
                    }
                }

                $.fancybox.setTranslate($el, to);
            } else {
                $el.addClass(to);
            }

            // Make sure that `transitionend` callback gets fired
            $el.data(
                "timer",
                setTimeout(function() {
                    $el.trigger(transitionEnd);
                }, duration + 33)
            );
        },

        stop: function($el, callCallback) {
            if ($el && $el.length) {
                clearTimeout($el.data("timer"));

                if (callCallback) {
                    $el.trigger(transitionEnd);
                }

                $el.off(transitionEnd).css("transition-duration", "");

                $el.parent().removeClass("fancybox-is-scaling");
            }
        }
    };

    // Default click handler for "fancyboxed" links
    // ============================================

    function _run(e, opts) {
        var items = [],
            index = 0,
            $target,
            value,
            instance;

        // Avoid opening multiple times
        if (e && e.isDefaultPrevented()) {
            return;
        }

        e.preventDefault();

        opts = opts || {};

        if (e && e.data) {
            opts = mergeOpts(e.data.options, opts);
        }

        $target = opts.$target || $(e.currentTarget).trigger("blur");
        instance = $.fancybox.getInstance();

        if (instance && instance.$trigger && instance.$trigger.is($target)) {
            return;
        }

        if (opts.selector) {
            items = $(opts.selector);
        } else {
            // Get all related items and find index for clicked one
            value = $target.attr("data-fancybox") || "";

            if (value) {
                items = e.data ? e.data.items : [];
                items = items.length ? items.filter('[data-fancybox="' + value + '"]') : $('[data-fancybox="' + value + '"]');
            } else {
                items = [$target];
            }
        }

        index = $(items).index($target);

        // Sometimes current item can not be found
        if (index < 0) {
            index = 0;
        }

        instance = $.fancybox.open(items, opts, index);

        // Save last active element
        instance.$trigger = $target;
    }

    // Create a jQuery plugin
    // ======================

    $.fn.fancybox = function(options) {
        var selector;

        options = options || {};
        selector = options.selector || false;

        if (selector) {
            // Use body element instead of document so it executes first
            $("body")
                .off("click.fb-start", selector)
                .on("click.fb-start", selector, {options: options}, _run);
        } else {
            this.off("click.fb-start").on(
                "click.fb-start",
                {
                    items: this,
                    options: options
                },
                _run
            );
        }

        return this;
    };

    // Self initializing plugin for all elements having `data-fancybox` attribute
    // ==========================================================================

    $D.on("click.fb-start", "[data-fancybox]", _run);

    // Enable "trigger elements"
    // =========================

    $D.on("click.fb-start", "[data-fancybox-trigger]", function(e) {
        $('[data-fancybox="' + $(this).attr("data-fancybox-trigger") + '"]')
            .eq($(this).attr("data-fancybox-index") || 0)
            .trigger("click.fb-start", {
                $trigger: $(this)
            });
    });

    // Track focus event for better accessibility styling
    // ==================================================
    (function() {
        var buttonStr = ".fancybox-button",
            focusStr = "fancybox-focus",
            $pressed = null;

        $D.on("mousedown mouseup focus blur", buttonStr, function(e) {
            switch (e.type) {
                case "mousedown":
                    $pressed = $(this);
                    break;
                case "mouseup":
                    $pressed = null;
                    break;
                case "focusin":
                    $(buttonStr).removeClass(focusStr);

                    if (!$(this).is($pressed) && !$(this).is("[disabled]")) {
                        $(this).addClass(focusStr);
                    }
                    break;
                case "focusout":
                    $(buttonStr).removeClass(focusStr);
                    break;
            }
        });
    })();
})(window, document, jQuery);

// ==========================================================================
//
// Media
// Adds additional media type support
//
// ==========================================================================
(function($) {
    "use strict";

    // Object containing properties for each media type
    var defaults = {
        youtube: {
            matcher: /(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,
            params: {
                autoplay: 1,
                autohide: 1,
                fs: 1,
                rel: 0,
                hd: 1,
                wmode: "transparent",
                enablejsapi: 1,
                html5: 1
            },
            paramPlace: 8,
            type: "iframe",
            url: "https://www.youtube-nocookie.com/embed/$4",
            thumb: "https://img.youtube.com/vi/$4/hqdefault.jpg"
        },

        vimeo: {
            matcher: /^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,
            params: {
                autoplay: 1,
                hd: 1,
                show_title: 1,
                show_byline: 1,
                show_portrait: 0,
                fullscreen: 1
            },
            paramPlace: 3,
            type: "iframe",
            url: "//player.vimeo.com/video/$2"
        },

        instagram: {
            matcher: /(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,
            type: "image",
            url: "//$1/p/$2/media/?size=l"
        },

        // Examples:
        // http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16
        // https://www.google.com/maps/@37.7852006,-122.4146355,14.65z
        // https://www.google.com/maps/@52.2111123,2.9237542,6.61z?hl=en
        // https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572
        gmap_place: {
            matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,
            type: "iframe",
            url: function(rez) {
                return (
                    "//maps.google." +
                    rez[2] +
                    "/?ll=" +
                    (rez[9] ? rez[9] + "&z=" + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\//, "&") : "") : rez[12] + "").replace(/\?/, "&") +
                    "&output=" +
                    (rez[12] && rez[12].indexOf("layer=c") > 0 ? "svembed" : "embed")
                );
            }
        },

        // Examples:
        // https://www.google.com/maps/search/Empire+State+Building/
        // https://www.google.com/maps/search/?api=1&query=centurylink+field
        // https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393
        gmap_search: {
            matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,
            type: "iframe",
            url: function(rez) {
                return "//maps.google." + rez[2] + "/maps?q=" + rez[5].replace("query=", "q=").replace("api=1", "") + "&output=embed";
            }
        }
    };

    // Formats matching url to final form
    var format = function(url, rez, params) {
        if (!url) {
            return;
        }

        params = params || "";

        if ($.type(params) === "object") {
            params = $.param(params, true);
        }

        $.each(rez, function(key, value) {
            url = url.replace("$" + key, value || "");
        });

        if (params.length) {
            url += (url.indexOf("?") > 0 ? "&" : "?") + params;
        }

        return url;
    };

    $(document).on("objectNeedsType.fb", function(e, instance, item) {
        var url = item.src || "",
            type = false,
            media,
            thumb,
            rez,
            params,
            urlParams,
            paramObj,
            provider;

        media = $.extend(true, {}, defaults, item.opts.media);

        // Look for any matching media type
        $.each(media, function(providerName, providerOpts) {
            rez = url.match(providerOpts.matcher);

            if (!rez) {
                return;
            }

            type = providerOpts.type;
            provider = providerName;
            paramObj = {};

            if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {
                urlParams = rez[providerOpts.paramPlace];

                if (urlParams[0] == "?") {
                    urlParams = urlParams.substring(1);
                }

                urlParams = urlParams.split("&");

                for (var m = 0; m < urlParams.length; ++m) {
                    var p = urlParams[m].split("=", 2);

                    if (p.length == 2) {
                        paramObj[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
                    }
                }
            }

            params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);

            url =
                $.type(providerOpts.url) === "function" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);

            thumb =
                $.type(providerOpts.thumb) === "function" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);

            if (providerName === "youtube") {
                url = url.replace(/&t=((\d+)m)?(\d+)s/, function(match, p1, m, s) {
                    return "&start=" + ((m ? parseInt(m, 10) * 60 : 0) + parseInt(s, 10));
                });
            } else if (providerName === "vimeo") {
                url = url.replace("&%23", "#");
            }

            return false;
        });

        // If it is found, then change content type and update the url

        if (type) {
            if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {
                item.opts.thumb = thumb;
            }

            if (type === "iframe") {
                item.opts = $.extend(true, item.opts, {
                    iframe: {
                        preload: false,
                        attr: {
                            scrolling: "no"
                        }
                    }
                });
            }

            $.extend(item, {
                type: type,
                src: url,
                origSrc: item.src,
                contentSource: provider,
                contentType: type === "image" ? "image" : provider == "gmap_place" || provider == "gmap_search" ? "map" : "video"
            });
        } else if (url) {
            item.type = item.opts.defaultType;
        }
    });

    // Load YouTube/Video API on request to detect when video finished playing
    var VideoAPILoader = {
        youtube: {
            src: "https://www.youtube.com/iframe_api",
            class: "YT",
            loading: false,
            loaded: false
        },

        vimeo: {
            src: "https://player.vimeo.com/api/player.js",
            class: "Vimeo",
            loading: false,
            loaded: false
        },

        load: function(vendor) {
            var _this = this,
                script;

            if (this[vendor].loaded) {
                setTimeout(function() {
                    _this.done(vendor);
                });
                return;
            }

            if (this[vendor].loading) {
                return;
            }

            this[vendor].loading = true;

            script = document.createElement("script");
            script.type = "text/javascript";
            script.src = this[vendor].src;

            if (vendor === "youtube") {
                window.onYouTubeIframeAPIReady = function() {
                    _this[vendor].loaded = true;
                    _this.done(vendor);
                };
            } else {
                script.onload = function() {
                    _this[vendor].loaded = true;
                    _this.done(vendor);
                };
            }

            document.body.appendChild(script);
        },
        done: function(vendor) {
            var instance, $el, player;

            if (vendor === "youtube") {
                delete window.onYouTubeIframeAPIReady;
            }

            instance = $.fancybox.getInstance();

            if (instance) {
                $el = instance.current.$content.find("iframe");

                if (vendor === "youtube" && YT !== undefined && YT) {
                    player = new YT.Player($el.attr("id"), {
                        events: {
                            onStateChange: function(e) {
                                if (e.data == 0) {
                                    instance.next();
                                }
                            }
                        }
                    });
                } else if (vendor === "vimeo" && Vimeo !== undefined && Vimeo) {
                    player = new Vimeo.Player($el);

                    player.on("ended", function() {
                        instance.next();
                    });
                }
            }
        }
    };

    $(document).on({
        "afterShow.fb": function(e, instance, current) {
            if (instance.group.length > 1 && (current.contentSource === "youtube" || current.contentSource === "vimeo")) {
                VideoAPILoader.load(current.contentSource);
            }
        }
    });
})(jQuery);

// ==========================================================================
//
// Guestures
// Adds touch guestures, handles click and tap events
//
// ==========================================================================
(function(window, document, $) {
    "use strict";

    var requestAFrame = (function() {
        return (
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            // if all else fails, use setTimeout
            function(callback) {
                return window.setTimeout(callback, 1000 / 60);
            }
        );
    })();

    var cancelAFrame = (function() {
        return (
            window.cancelAnimationFrame ||
            window.webkitCancelAnimationFrame ||
            window.mozCancelAnimationFrame ||
            window.oCancelAnimationFrame ||
            function(id) {
                window.clearTimeout(id);
            }
        );
    })();

    var getPointerXY = function(e) {
        var result = [];

        e = e.originalEvent || e || window.e;
        e = e.touches && e.touches.length ? e.touches : e.changedTouches && e.changedTouches.length ? e.changedTouches : [e];

        for (var key in e) {
            if (e[key].pageX) {
                result.push({
                    x: e[key].pageX,
                    y: e[key].pageY
                });
            } else if (e[key].clientX) {
                result.push({
                    x: e[key].clientX,
                    y: e[key].clientY
                });
            }
        }

        return result;
    };

    var distance = function(point2, point1, what) {
        if (!point1 || !point2) {
            return 0;
        }

        if (what === "x") {
            return point2.x - point1.x;
        } else if (what === "y") {
            return point2.y - point1.y;
        }

        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
    };

    var isClickable = function($el) {
        if (
            $el.is('a,area,button,[role="button"],input,label,select,summary,textarea,video,audio,iframe') ||
            $.isFunction($el.get(0).onclick) ||
            $el.data("selectable")
        ) {
            return true;
        }

        // Check for attributes like data-fancybox-next or data-fancybox-close
        for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {
            if (atts[i].nodeName.substr(0, 14) === "data-fancybox-") {
                return true;
            }
        }

        return false;
    };

    var hasScrollbars = function(el) {
        var overflowY = window.getComputedStyle(el)["overflow-y"],
            overflowX = window.getComputedStyle(el)["overflow-x"],
            vertical = (overflowY === "scroll" || overflowY === "auto") && el.scrollHeight > el.clientHeight,
            horizontal = (overflowX === "scroll" || overflowX === "auto") && el.scrollWidth > el.clientWidth;

        return vertical || horizontal;
    };

    var isScrollable = function($el) {
        var rez = false;

        while (true) {
            rez = hasScrollbars($el.get(0));

            if (rez) {
                break;
            }

            $el = $el.parent();

            if (!$el.length || $el.hasClass("fancybox-stage") || $el.is("body")) {
                break;
            }
        }

        return rez;
    };

    var Guestures = function(instance) {
        var self = this;

        self.instance = instance;

        self.$bg = instance.$refs.bg;
        self.$stage = instance.$refs.stage;
        self.$container = instance.$refs.container;

        self.destroy();

        self.$container.on("touchstart.fb.touch mousedown.fb.touch", $.proxy(self, "ontouchstart"));
    };

    Guestures.prototype.destroy = function() {
        var self = this;

        self.$container.off(".fb.touch");

        $(document).off(".fb.touch");

        if (self.requestId) {
            cancelAFrame(self.requestId);
            self.requestId = null;
        }

        if (self.tapped) {
            clearTimeout(self.tapped);
            self.tapped = null;
        }
    };

    Guestures.prototype.ontouchstart = function(e) {
        var self = this,
            $target = $(e.target),
            instance = self.instance,
            current = instance.current,
            $slide = current.$slide,
            $content = current.$content,
            isTouchDevice = e.type == "touchstart";

        // Do not respond to both (touch and mouse) events
        if (isTouchDevice) {
            self.$container.off("mousedown.fb.touch");
        }

        // Ignore right click
        if (e.originalEvent && e.originalEvent.button == 2) {
            return;
        }

        // Ignore taping on links, buttons, input elements
        if (!$slide.length || !$target.length || isClickable($target) || isClickable($target.parent())) {
            return;
        }
        // Ignore clicks on the scrollbar
        if (!$target.is("img") && e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {
            return;
        }

        // Ignore clicks while zooming or closing
        if (!current || instance.isAnimating || current.$slide.hasClass("fancybox-animated")) {
            e.stopPropagation();
            e.preventDefault();

            return;
        }

        self.realPoints = self.startPoints = getPointerXY(e);

        if (!self.startPoints.length) {
            return;
        }

        // Allow other scripts to catch touch event if "touch" is set to false
        if (current.touch) {
            e.stopPropagation();
        }

        self.startEvent = e;

        self.canTap = true;
        self.$target = $target;
        self.$content = $content;
        self.opts = current.opts.touch;

        self.isPanning = false;
        self.isSwiping = false;
        self.isZooming = false;
        self.isScrolling = false;
        self.canPan = instance.canPan();

        self.startTime = new Date().getTime();
        self.distanceX = self.distanceY = self.distance = 0;

        self.canvasWidth = Math.round($slide[0].clientWidth);
        self.canvasHeight = Math.round($slide[0].clientHeight);

        self.contentLastPos = null;
        self.contentStartPos = $.fancybox.getTranslate(self.$content) || {top: 0, left: 0};
        self.sliderStartPos = $.fancybox.getTranslate($slide);

        // Since position will be absolute, but we need to make it relative to the stage
        self.stagePos = $.fancybox.getTranslate(instance.$refs.stage);

        self.sliderStartPos.top -= self.stagePos.top;
        self.sliderStartPos.left -= self.stagePos.left;

        self.contentStartPos.top -= self.stagePos.top;
        self.contentStartPos.left -= self.stagePos.left;

        $(document)
            .off(".fb.touch")
            .on(isTouchDevice ? "touchend.fb.touch touchcancel.fb.touch" : "mouseup.fb.touch mouseleave.fb.touch", $.proxy(self, "ontouchend"))
            .on(isTouchDevice ? "touchmove.fb.touch" : "mousemove.fb.touch", $.proxy(self, "ontouchmove"));

        if ($.fancybox.isMobile) {
            document.addEventListener("scroll", self.onscroll, true);
        }

        // Skip if clicked outside the sliding area
        if (!(self.opts || self.canPan) || !($target.is(self.$stage) || self.$stage.find($target).length)) {
            if ($target.is(".fancybox-image")) {
                e.preventDefault();
            }

            if (!($.fancybox.isMobile && $target.hasClass("fancybox-caption"))) {
                return;
            }
        }

        self.isScrollable = isScrollable($target) || isScrollable($target.parent());

        // Check if element is scrollable and try to prevent default behavior (scrolling)
        if (!($.fancybox.isMobile && self.isScrollable)) {
            e.preventDefault();
        }

        // One finger or mouse click - swipe or pan an image
        if (self.startPoints.length === 1 || current.hasError) {
            if (self.canPan) {
                $.fancybox.stop(self.$content);

                self.isPanning = true;
            } else {
                self.isSwiping = true;
            }

            self.$container.addClass("fancybox-is-grabbing");
        }

        // Two fingers - zoom image
        if (self.startPoints.length === 2 && current.type === "image" && (current.isLoaded || current.$ghost)) {
            self.canTap = false;
            self.isSwiping = false;
            self.isPanning = false;

            self.isZooming = true;

            $.fancybox.stop(self.$content);

            self.centerPointStartX = (self.startPoints[0].x + self.startPoints[1].x) * 0.5 - $(window).scrollLeft();
            self.centerPointStartY = (self.startPoints[0].y + self.startPoints[1].y) * 0.5 - $(window).scrollTop();

            self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width;
            self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height;

            self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);
        }
    };

    Guestures.prototype.onscroll = function(e) {
        var self = this;

        self.isScrolling = true;

        document.removeEventListener("scroll", self.onscroll, true);
    };

    Guestures.prototype.ontouchmove = function(e) {
        var self = this;

        // Make sure user has not released over iframe or disabled element
        if (e.originalEvent.buttons !== undefined && e.originalEvent.buttons === 0) {
            self.ontouchend(e);
            return;
        }

        if (self.isScrolling) {
            self.canTap = false;
            return;
        }

        self.newPoints = getPointerXY(e);

        if (!(self.opts || self.canPan) || !self.newPoints.length || !self.newPoints.length) {
            return;
        }

        if (!(self.isSwiping && self.isSwiping === true)) {
            e.preventDefault();
        }

        self.distanceX = distance(self.newPoints[0], self.startPoints[0], "x");
        self.distanceY = distance(self.newPoints[0], self.startPoints[0], "y");

        self.distance = distance(self.newPoints[0], self.startPoints[0]);

        // Skip false ontouchmove events (Chrome)
        if (self.distance > 0) {
            if (self.isSwiping) {
                self.onSwipe(e);
            } else if (self.isPanning) {
                self.onPan();
            } else if (self.isZooming) {
                self.onZoom();
            }
        }
    };

    Guestures.prototype.onSwipe = function(e) {
        var self = this,
            instance = self.instance,
            swiping = self.isSwiping,
            left = self.sliderStartPos.left || 0,
            angle;

        // If direction is not yet determined
        if (swiping === true) {
            // We need at least 10px distance to correctly calculate an angle
            if (Math.abs(self.distance) > 10) {
                self.canTap = false;

                if (instance.group.length < 2 && self.opts.vertical) {
                    self.isSwiping = "y";
                } else if (instance.isDragging || self.opts.vertical === false || (self.opts.vertical === "auto" && $(window).width() > 800)) {
                    self.isSwiping = "x";
                } else {
                    angle = Math.abs((Math.atan2(self.distanceY, self.distanceX) * 180) / Math.PI);

                    self.isSwiping = angle > 45 && angle < 135 ? "y" : "x";
                }

                if (self.isSwiping === "y" && $.fancybox.isMobile && self.isScrollable) {
                    self.isScrolling = true;

                    return;
                }

                instance.isDragging = self.isSwiping;

                // Reset points to avoid jumping, because we dropped first swipes to calculate the angle
                self.startPoints = self.newPoints;

                $.each(instance.slides, function(index, slide) {
                    var slidePos, stagePos;

                    $.fancybox.stop(slide.$slide);

                    slidePos = $.fancybox.getTranslate(slide.$slide);
                    stagePos = $.fancybox.getTranslate(instance.$refs.stage);

                    slide.$slide
                        .css({
                            transform: "",
                            opacity: "",
                            "transition-duration": ""
                        })
                        .removeClass("fancybox-animated")
                        .removeClass(function(index, className) {
                            return (className.match(/(^|\s)fancybox-fx-\S+/g) || []).join(" ");
                        });

                    if (slide.pos === instance.current.pos) {
                        self.sliderStartPos.top = slidePos.top - stagePos.top;
                        self.sliderStartPos.left = slidePos.left - stagePos.left;
                    }

                    $.fancybox.setTranslate(slide.$slide, {
                        top: slidePos.top - stagePos.top,
                        left: slidePos.left - stagePos.left
                    });
                });

                // Stop slideshow
                if (instance.SlideShow && instance.SlideShow.isActive) {
                    instance.SlideShow.stop();
                }
            }

            return;
        }

        // Sticky edges
        if (swiping == "x") {
            if (
                self.distanceX > 0 &&
                (self.instance.group.length < 2 || (self.instance.current.index === 0 && !self.instance.current.opts.loop))
            ) {
                left = left + Math.pow(self.distanceX, 0.8);
            } else if (
                self.distanceX < 0 &&
                (self.instance.group.length < 2 ||
                    (self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop))
            ) {
                left = left - Math.pow(-self.distanceX, 0.8);
            } else {
                left = left + self.distanceX;
            }
        }

        self.sliderLastPos = {
            top: swiping == "x" ? 0 : self.sliderStartPos.top + self.distanceY,
            left: left
        };

        if (self.requestId) {
            cancelAFrame(self.requestId);

            self.requestId = null;
        }

        self.requestId = requestAFrame(function() {
            if (self.sliderLastPos) {
                $.each(self.instance.slides, function(index, slide) {
                    var pos = slide.pos - self.instance.currPos;

                    $.fancybox.setTranslate(slide.$slide, {
                        top: self.sliderLastPos.top,
                        left: self.sliderLastPos.left + pos * self.canvasWidth + pos * slide.opts.gutter
                    });
                });

                self.$container.addClass("fancybox-is-sliding");
            }
        });
    };

    Guestures.prototype.onPan = function() {
        var self = this;

        // Prevent accidental movement (sometimes, when tapping casually, finger can move a bit)
        if (distance(self.newPoints[0], self.realPoints[0]) < ($.fancybox.isMobile ? 10 : 5)) {
            self.startPoints = self.newPoints;
            return;
        }

        self.canTap = false;

        self.contentLastPos = self.limitMovement();

        if (self.requestId) {
            cancelAFrame(self.requestId);
        }

        self.requestId = requestAFrame(function() {
            $.fancybox.setTranslate(self.$content, self.contentLastPos);
        });
    };

    // Make panning sticky to the edges
    Guestures.prototype.limitMovement = function() {
        var self = this;

        var canvasWidth = self.canvasWidth;
        var canvasHeight = self.canvasHeight;

        var distanceX = self.distanceX;
        var distanceY = self.distanceY;

        var contentStartPos = self.contentStartPos;

        var currentOffsetX = contentStartPos.left;
        var currentOffsetY = contentStartPos.top;

        var currentWidth = contentStartPos.width;
        var currentHeight = contentStartPos.height;

        var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY, newOffsetX, newOffsetY;

        if (currentWidth > canvasWidth) {
            newOffsetX = currentOffsetX + distanceX;
        } else {
            newOffsetX = currentOffsetX;
        }

        newOffsetY = currentOffsetY + distanceY;

        // Slow down proportionally to traveled distance
        minTranslateX = Math.max(0, canvasWidth * 0.5 - currentWidth * 0.5);
        minTranslateY = Math.max(0, canvasHeight * 0.5 - currentHeight * 0.5);

        maxTranslateX = Math.min(canvasWidth - currentWidth, canvasWidth * 0.5 - currentWidth * 0.5);
        maxTranslateY = Math.min(canvasHeight - currentHeight, canvasHeight * 0.5 - currentHeight * 0.5);

        //   ->
        if (distanceX > 0 && newOffsetX > minTranslateX) {
            newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;
        }

        //    <-
        if (distanceX < 0 && newOffsetX < maxTranslateX) {
            newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;
        }

        //   \/
        if (distanceY > 0 && newOffsetY > minTranslateY) {
            newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;
        }

        //   /\
        if (distanceY < 0 && newOffsetY < maxTranslateY) {
            newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;
        }

        return {
            top: newOffsetY,
            left: newOffsetX
        };
    };

    Guestures.prototype.limitPosition = function(newOffsetX, newOffsetY, newWidth, newHeight) {
        var self = this;

        var canvasWidth = self.canvasWidth;
        var canvasHeight = self.canvasHeight;

        if (newWidth > canvasWidth) {
            newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;
            newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;
        } else {
            // Center horizontally
            newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2);
        }

        if (newHeight > canvasHeight) {
            newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;
            newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;
        } else {
            // Center vertically
            newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2);
        }

        return {
            top: newOffsetY,
            left: newOffsetX
        };
    };

    Guestures.prototype.onZoom = function() {
        var self = this;

        // Calculate current distance between points to get pinch ratio and new width and height
        var contentStartPos = self.contentStartPos;

        var currentWidth = contentStartPos.width;
        var currentHeight = contentStartPos.height;

        var currentOffsetX = contentStartPos.left;
        var currentOffsetY = contentStartPos.top;

        var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);

        var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers;

        var newWidth = Math.floor(currentWidth * pinchRatio);
        var newHeight = Math.floor(currentHeight * pinchRatio);

        // This is the translation due to pinch-zooming
        var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;
        var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY;

        // Point between the two touches
        var centerPointEndX = (self.newPoints[0].x + self.newPoints[1].x) / 2 - $(window).scrollLeft();
        var centerPointEndY = (self.newPoints[0].y + self.newPoints[1].y) / 2 - $(window).scrollTop();

        // And this is the translation due to translation of the centerpoint
        // between the two fingers
        var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;
        var translateFromTranslatingY = centerPointEndY - self.centerPointStartY;

        // The new offset is the old/current one plus the total translation
        var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);
        var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);

        var newPos = {
            top: newOffsetY,
            left: newOffsetX,
            scaleX: pinchRatio,
            scaleY: pinchRatio
        };

        self.canTap = false;

        self.newWidth = newWidth;
        self.newHeight = newHeight;

        self.contentLastPos = newPos;

        if (self.requestId) {
            cancelAFrame(self.requestId);
        }

        self.requestId = requestAFrame(function() {
            $.fancybox.setTranslate(self.$content, self.contentLastPos);
        });
    };

    Guestures.prototype.ontouchend = function(e) {
        var self = this;

        var swiping = self.isSwiping;
        var panning = self.isPanning;
        var zooming = self.isZooming;
        var scrolling = self.isScrolling;

        self.endPoints = getPointerXY(e);
        self.dMs = Math.max(new Date().getTime() - self.startTime, 1);

        self.$container.removeClass("fancybox-is-grabbing");

        $(document).off(".fb.touch");

        document.removeEventListener("scroll", self.onscroll, true);

        if (self.requestId) {
            cancelAFrame(self.requestId);

            self.requestId = null;
        }

        self.isSwiping = false;
        self.isPanning = false;
        self.isZooming = false;
        self.isScrolling = false;

        self.instance.isDragging = false;

        if (self.canTap) {
            return self.onTap(e);
        }

        self.speed = 100;

        // Speed in px/ms
        self.velocityX = (self.distanceX / self.dMs) * 0.5;
        self.velocityY = (self.distanceY / self.dMs) * 0.5;

        if (panning) {
            self.endPanning();
        } else if (zooming) {
            self.endZooming();
        } else {
            self.endSwiping(swiping, scrolling);
        }

        return;
    };

    Guestures.prototype.endSwiping = function(swiping, scrolling) {
        var self = this,
            ret = false,
            len = self.instance.group.length,
            distanceX = Math.abs(self.distanceX),
            canAdvance = swiping == "x" && len > 1 && ((self.dMs > 130 && distanceX > 10) || distanceX > 50),
            speedX = 300;

        self.sliderLastPos = null;

        // Close if swiped vertically / navigate if horizontally
        if (swiping == "y" && !scrolling && Math.abs(self.distanceY) > 50) {
            // Continue vertical movement
            $.fancybox.animate(
                self.instance.current.$slide,
                {
                    top: self.sliderStartPos.top + self.distanceY + self.velocityY * 150,
                    opacity: 0
                },
                200
            );
            ret = self.instance.close(true, 250);
        } else if (canAdvance && self.distanceX > 0) {
            ret = self.instance.previous(speedX);
        } else if (canAdvance && self.distanceX < 0) {
            ret = self.instance.next(speedX);
        }

        if (ret === false && (swiping == "x" || swiping == "y")) {
            self.instance.centerSlide(200);
        }

        self.$container.removeClass("fancybox-is-sliding");
    };

    // Limit panning from edges
    // ========================
    Guestures.prototype.endPanning = function() {
        var self = this,
            newOffsetX,
            newOffsetY,
            newPos;

        if (!self.contentLastPos) {
            return;
        }

        if (self.opts.momentum === false || self.dMs > 350) {
            newOffsetX = self.contentLastPos.left;
            newOffsetY = self.contentLastPos.top;
        } else {
            // Continue movement
            newOffsetX = self.contentLastPos.left + self.velocityX * 500;
            newOffsetY = self.contentLastPos.top + self.velocityY * 500;
        }

        newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);

        newPos.width = self.contentStartPos.width;
        newPos.height = self.contentStartPos.height;

        $.fancybox.animate(self.$content, newPos, 366);
    };

    Guestures.prototype.endZooming = function() {
        var self = this;

        var current = self.instance.current;

        var newOffsetX, newOffsetY, newPos, reset;

        var newWidth = self.newWidth;
        var newHeight = self.newHeight;

        if (!self.contentLastPos) {
            return;
        }

        newOffsetX = self.contentLastPos.left;
        newOffsetY = self.contentLastPos.top;

        reset = {
            top: newOffsetY,
            left: newOffsetX,
            width: newWidth,
            height: newHeight,
            scaleX: 1,
            scaleY: 1
        };

        // Reset scalex/scaleY values; this helps for perfomance and does not break animation
        $.fancybox.setTranslate(self.$content, reset);

        if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {
            self.instance.scaleToFit(150);
        } else if (newWidth > current.width || newHeight > current.height) {
            self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);
        } else {
            newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);

            $.fancybox.animate(self.$content, newPos, 150);
        }
    };

    Guestures.prototype.onTap = function(e) {
        var self = this;
        var $target = $(e.target);

        var instance = self.instance;
        var current = instance.current;

        var endPoints = (e && getPointerXY(e)) || self.startPoints;

        var tapX = endPoints[0] ? endPoints[0].x - $(window).scrollLeft() - self.stagePos.left : 0;
        var tapY = endPoints[0] ? endPoints[0].y - $(window).scrollTop() - self.stagePos.top : 0;

        var where;

        var process = function(prefix) {
            var action = current.opts[prefix];

            if ($.isFunction(action)) {
                action = action.apply(instance, [current, e]);
            }

            if (!action) {
                return;
            }

            switch (action) {
                case "close":
                    instance.close(self.startEvent);

                    break;

                case "toggleControls":
                    instance.toggleControls();

                    break;

                case "next":
                    instance.next();

                    break;

                case "nextOrClose":
                    if (instance.group.length > 1) {
                        instance.next();
                    } else {
                        instance.close(self.startEvent);
                    }

                    break;

                case "zoom":
                    if (current.type == "image" && (current.isLoaded || current.$ghost)) {
                        if (instance.canPan()) {
                            instance.scaleToFit();
                        } else if (instance.isScaledDown()) {
                            instance.scaleToActual(tapX, tapY);
                        } else if (instance.group.length < 2) {
                            instance.close(self.startEvent);
                        }
                    }

                    break;
            }
        };

        // Ignore right click
        if (e.originalEvent && e.originalEvent.button == 2) {
            return;
        }

        // Skip if clicked on the scrollbar
        if (!$target.is("img") && tapX > $target[0].clientWidth + $target.offset().left) {
            return;
        }

        // Check where is clicked
        if ($target.is(".fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container")) {
            where = "Outside";
        } else if ($target.is(".fancybox-slide")) {
            where = "Slide";
        } else if (
            instance.current.$content &&
            instance.current.$content
                .find($target)
                .addBack()
                .filter($target).length
        ) {
            where = "Content";
        } else {
            return;
        }

        // Check if this is a double tap
        if (self.tapped) {
            // Stop previously created single tap
            clearTimeout(self.tapped);
            self.tapped = null;

            // Skip if distance between taps is too big
            if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50) {
                return this;
            }

            // OK, now we assume that this is a double-tap
            process("dblclick" + where);
        } else {
            // Single tap will be processed if user has not clicked second time within 300ms
            // or there is no need to wait for double-tap
            self.tapX = tapX;
            self.tapY = tapY;

            if (current.opts["dblclick" + where] && current.opts["dblclick" + where] !== current.opts["click" + where]) {
                self.tapped = setTimeout(function() {
                    self.tapped = null;

                    if (!instance.isAnimating) {
                        process("click" + where);
                    }
                }, 500);
            } else {
                process("click" + where);
            }
        }

        return this;
    };

    $(document)
        .on("onActivate.fb", function(e, instance) {
            if (instance && !instance.Guestures) {
                instance.Guestures = new Guestures(instance);
            }
        })
        .on("beforeClose.fb", function(e, instance) {
            if (instance && instance.Guestures) {
                instance.Guestures.destroy();
            }
        });
})(window, document, jQuery);

// ==========================================================================
//
// SlideShow
// Enables slideshow functionality
//
// Example of usage:
// $.fancybox.getInstance().SlideShow.start()
//
// ==========================================================================
(function(document, $) {
    "use strict";

    $.extend(true, $.fancybox.defaults, {
        btnTpl: {
            slideShow:
            '<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}">' +
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6.5 5.4v13.2l11-6.6z"/></svg>' +
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.33 5.75h2.2v12.5h-2.2V5.75zm5.15 0h2.2v12.5h-2.2V5.75z"/></svg>' +
            "</button>"
        },
        slideShow: {
            autoStart: false,
            speed: 3000,
            progress: true
        }
    });

    var SlideShow = function(instance) {
        this.instance = instance;
        this.init();
    };

    $.extend(SlideShow.prototype, {
        timer: null,
        isActive: false,
        $button: null,

        init: function() {
            var self = this,
                instance = self.instance,
                opts = instance.group[instance.currIndex].opts.slideShow;

            self.$button = instance.$refs.toolbar.find("[data-fancybox-play]").on("click", function() {
                self.toggle();
            });

            if (instance.group.length < 2 || !opts) {
                self.$button.hide();
            } else if (opts.progress) {
                self.$progress = $('<div class="fancybox-progress"></div>').appendTo(instance.$refs.inner);
            }
        },

        set: function(force) {
            var self = this,
                instance = self.instance,
                current = instance.current;

            // Check if reached last element
            if (current && (force === true || current.opts.loop || instance.currIndex < instance.group.length - 1)) {
                if (self.isActive && current.contentType !== "video") {
                    if (self.$progress) {
                        $.fancybox.animate(self.$progress.show(), {scaleX: 1}, current.opts.slideShow.speed);
                    }

                    self.timer = setTimeout(function() {
                        if (!instance.current.opts.loop && instance.current.index == instance.group.length - 1) {
                            instance.jumpTo(0);
                        } else {
                            instance.next();
                        }
                    }, current.opts.slideShow.speed);
                }
            } else {
                self.stop();
                instance.idleSecondsCounter = 0;
                instance.showControls();
            }
        },

        clear: function() {
            var self = this;

            clearTimeout(self.timer);

            self.timer = null;

            if (self.$progress) {
                self.$progress.removeAttr("style").hide();
            }
        },

        start: function() {
            var self = this,
                current = self.instance.current;

            if (current) {
                self.$button
                    .attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_STOP)
                    .removeClass("fancybox-button--play")
                    .addClass("fancybox-button--pause");

                self.isActive = true;

                if (current.isComplete) {
                    self.set(true);
                }

                self.instance.trigger("onSlideShowChange", true);
            }
        },

        stop: function() {
            var self = this,
                current = self.instance.current;

            self.clear();

            self.$button
                .attr("title", (current.opts.i18n[current.opts.lang] || current.opts.i18n.en).PLAY_START)
                .removeClass("fancybox-button--pause")
                .addClass("fancybox-button--play");

            self.isActive = false;

            self.instance.trigger("onSlideShowChange", false);

            if (self.$progress) {
                self.$progress.removeAttr("style").hide();
            }
        },

        toggle: function() {
            var self = this;

            if (self.isActive) {
                self.stop();
            } else {
                self.start();
            }
        }
    });

    $(document).on({
        "onInit.fb": function(e, instance) {
            if (instance && !instance.SlideShow) {
                instance.SlideShow = new SlideShow(instance);
            }
        },

        "beforeShow.fb": function(e, instance, current, firstRun) {
            var SlideShow = instance && instance.SlideShow;

            if (firstRun) {
                if (SlideShow && current.opts.slideShow.autoStart) {
                    SlideShow.start();
                }
            } else if (SlideShow && SlideShow.isActive) {
                SlideShow.clear();
            }
        },

        "afterShow.fb": function(e, instance, current) {
            var SlideShow = instance && instance.SlideShow;

            if (SlideShow && SlideShow.isActive) {
                SlideShow.set();
            }
        },

        "afterKeydown.fb": function(e, instance, current, keypress, keycode) {
            var SlideShow = instance && instance.SlideShow;

            // "P" or Spacebar
            if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is("button,a,input")) {
                keypress.preventDefault();

                SlideShow.toggle();
            }
        },

        "beforeClose.fb onDeactivate.fb": function(e, instance) {
            var SlideShow = instance && instance.SlideShow;

            if (SlideShow) {
                SlideShow.stop();
            }
        }
    });

    // Page Visibility API to pause slideshow when window is not active
    $(document).on("visibilitychange", function() {
        var instance = $.fancybox.getInstance(),
            SlideShow = instance && instance.SlideShow;

        if (SlideShow && SlideShow.isActive) {
            if (document.hidden) {
                SlideShow.clear();
            } else {
                SlideShow.set();
            }
        }
    });
})(document, jQuery);

// ==========================================================================
//
// FullScreen
// Adds fullscreen functionality
//
// ==========================================================================
(function(document, $) {
    "use strict";

    // Collection of methods supported by user browser
    var fn = (function() {
        var fnMap = [
            ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
            // new WebKit
            [
                "webkitRequestFullscreen",
                "webkitExitFullscreen",
                "webkitFullscreenElement",
                "webkitFullscreenEnabled",
                "webkitfullscreenchange",
                "webkitfullscreenerror"
            ],
            // old WebKit (Safari 5.1)
            [
                "webkitRequestFullScreen",
                "webkitCancelFullScreen",
                "webkitCurrentFullScreenElement",
                "webkitCancelFullScreen",
                "webkitfullscreenchange",
                "webkitfullscreenerror"
            ],
            [
                "mozRequestFullScreen",
                "mozCancelFullScreen",
                "mozFullScreenElement",
                "mozFullScreenEnabled",
                "mozfullscreenchange",
                "mozfullscreenerror"
            ],
            ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
        ];

        var ret = {};

        for (var i = 0; i < fnMap.length; i++) {
            var val = fnMap[i];

            if (val && val[1] in document) {
                for (var j = 0; j < val.length; j++) {
                    ret[fnMap[0][j]] = val[j];
                }

                return ret;
            }
        }

        return false;
    })();

    if (fn) {
        var FullScreen = {
            request: function(elem) {
                elem = elem || document.documentElement;

                elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);
            },
            exit: function() {
                document[fn.exitFullscreen]();
            },
            toggle: function(elem) {
                elem = elem || document.documentElement;

                if (this.isFullscreen()) {
                    this.exit();
                } else {
                    this.request(elem);
                }
            },
            isFullscreen: function() {
                return Boolean(document[fn.fullscreenElement]);
            },
            enabled: function() {
                return Boolean(document[fn.fullscreenEnabled]);
            }
        };

        $.extend(true, $.fancybox.defaults, {
            btnTpl: {
                fullScreen:
                '<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fsenter" title="{{FULL_SCREEN}}">' +
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>' +
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5zm3-8H5v2h5V5H8zm6 11h2v-3h3v-2h-5zm2-11V5h-2v5h5V8z"/></svg>' +
                "</button>"
            },
            fullScreen: {
                autoStart: false
            }
        });

        $(document).on(fn.fullscreenchange, function() {
            var isFullscreen = FullScreen.isFullscreen(),
                instance = $.fancybox.getInstance();

            if (instance) {
                // If image is zooming, then force to stop and reposition properly
                if (instance.current && instance.current.type === "image" && instance.isAnimating) {
                    instance.isAnimating = false;

                    instance.update(true, true, 0);

                    if (!instance.isComplete) {
                        instance.complete();
                    }
                }

                instance.trigger("onFullscreenChange", isFullscreen);

                instance.$refs.container.toggleClass("fancybox-is-fullscreen", isFullscreen);

                instance.$refs.toolbar
                    .find("[data-fancybox-fullscreen]")
                    .toggleClass("fancybox-button--fsenter", !isFullscreen)
                    .toggleClass("fancybox-button--fsexit", isFullscreen);
            }
        });
    }

    $(document).on({
        "onInit.fb": function(e, instance) {
            var $container;

            if (!fn) {
                instance.$refs.toolbar.find("[data-fancybox-fullscreen]").remove();

                return;
            }

            if (instance && instance.group[instance.currIndex].opts.fullScreen) {
                $container = instance.$refs.container;

                $container.on("click.fb-fullscreen", "[data-fancybox-fullscreen]", function(e) {
                    e.stopPropagation();
                    e.preventDefault();

                    FullScreen.toggle();
                });

                if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {
                    FullScreen.request();
                }

                // Expose API
                instance.FullScreen = FullScreen;
            } else if (instance) {
                instance.$refs.toolbar.find("[data-fancybox-fullscreen]").hide();
            }
        },

        "afterKeydown.fb": function(e, instance, current, keypress, keycode) {
            // "F"
            if (instance && instance.FullScreen && keycode === 70) {
                keypress.preventDefault();

                instance.FullScreen.toggle();
            }
        },

        "beforeClose.fb": function(e, instance) {
            if (instance && instance.FullScreen && instance.$refs.container.hasClass("fancybox-is-fullscreen")) {
                FullScreen.exit();
            }
        }
    });
})(document, jQuery);

// ==========================================================================
//
// Thumbs
// Displays thumbnails in a grid
//
// ==========================================================================
(function(document, $) {
    "use strict";

    var CLASS = "fancybox-thumbs",
        CLASS_ACTIVE = CLASS + "-active";

    // Make sure there are default values
    $.fancybox.defaults = $.extend(
        true,
        {
            btnTpl: {
                thumbs:
                '<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}">' +
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.59 14.59h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76h-3.76v-3.76zm-4.47 0h3.76v3.76H5.65v-3.76zm8.94-4.47h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76h-3.76V5.65zm-4.47 0h3.76v3.76H5.65V5.65z"/></svg>' +
                "</button>"
            },
            thumbs: {
                autoStart: false, // Display thumbnails on opening
                hideOnClose: true, // Hide thumbnail grid when closing animation starts
                parentEl: ".fancybox-container", // Container is injected into this element
                axis: "y" // Vertical (y) or horizontal (x) scrolling
            }
        },
        $.fancybox.defaults
    );

    var FancyThumbs = function(instance) {
        this.init(instance);
    };

    $.extend(FancyThumbs.prototype, {
        $button: null,
        $grid: null,
        $list: null,
        isVisible: false,
        isActive: false,

        init: function(instance) {
            var self = this,
                group = instance.group,
                enabled = 0;

            self.instance = instance;
            self.opts = group[instance.currIndex].opts.thumbs;

            instance.Thumbs = self;

            self.$button = instance.$refs.toolbar.find("[data-fancybox-thumbs]");

            // Enable thumbs if at least two group items have thumbnails
            for (var i = 0, len = group.length; i < len; i++) {
                if (group[i].thumb) {
                    enabled++;
                }

                if (enabled > 1) {
                    break;
                }
            }

            if (enabled > 1 && !!self.opts) {
                self.$button.removeAttr("style").on("click", function() {
                    self.toggle();
                });

                self.isActive = true;
            } else {
                self.$button.hide();
            }
        },

        create: function() {
            var self = this,
                instance = self.instance,
                parentEl = self.opts.parentEl,
                list = [],
                src;

            if (!self.$grid) {
                // Create main element
                self.$grid = $('<div class="' + CLASS + " " + CLASS + "-" + self.opts.axis + '"></div>').appendTo(
                    instance.$refs.container
                        .find(parentEl)
                        .addBack()
                        .filter(parentEl)
                );

                // Add "click" event that performs gallery navigation
                self.$grid.on("click", "a", function() {
                    instance.jumpTo($(this).attr("data-index"));
                });
            }

            // Build the list
            if (!self.$list) {
                self.$list = $('<div class="' + CLASS + '__list">').appendTo(self.$grid);
            }

            $.each(instance.group, function(i, item) {
                src = item.thumb;

                if (!src && item.type === "image") {
                    src = item.src;
                }

                list.push(
                    '<a href="javascript:;" tabindex="0" data-index="' +
                    i +
                    '"' +
                    (src && src.length ? ' style="background-image:url(' + src + ')"' : 'class="fancybox-thumbs-missing"') +
                    "></a>"
                );
            });

            self.$list[0].innerHTML = list.join("");

            if (self.opts.axis === "x") {
                // Set fixed width for list element to enable horizontal scrolling
                self.$list.width(
                    parseInt(self.$grid.css("padding-right"), 10) +
                    instance.group.length *
                    self.$list
                        .children()
                        .eq(0)
                        .outerWidth(true)
                );
            }
        },

        focus: function(duration) {
            var self = this,
                $list = self.$list,
                $grid = self.$grid,
                thumb,
                thumbPos;

            if (!self.instance.current) {
                return;
            }

            thumb = $list
                .children()
                .removeClass(CLASS_ACTIVE)
                .filter('[data-index="' + self.instance.current.index + '"]')
                .addClass(CLASS_ACTIVE);

            thumbPos = thumb.position();

            // Check if need to scroll to make current thumb visible
            if (self.opts.axis === "y" && (thumbPos.top < 0 || thumbPos.top > $list.height() - thumb.outerHeight())) {
                $list.stop().animate(
                    {
                        scrollTop: $list.scrollTop() + thumbPos.top
                    },
                    duration
                );
            } else if (
                self.opts.axis === "x" &&
                (thumbPos.left < $grid.scrollLeft() || thumbPos.left > $grid.scrollLeft() + ($grid.width() - thumb.outerWidth()))
            ) {
                $list
                    .parent()
                    .stop()
                    .animate(
                        {
                            scrollLeft: thumbPos.left
                        },
                        duration
                    );
            }
        },

        update: function() {
            var that = this;
            that.instance.$refs.container.toggleClass("fancybox-show-thumbs", this.isVisible);

            if (that.isVisible) {
                if (!that.$grid) {
                    that.create();
                }

                that.instance.trigger("onThumbsShow");

                that.focus(0);
            } else if (that.$grid) {
                that.instance.trigger("onThumbsHide");
            }

            // Update content position
            that.instance.update();
        },

        hide: function() {
            this.isVisible = false;
            this.update();
        },

        show: function() {
            this.isVisible = true;
            this.update();
        },

        toggle: function() {
            this.isVisible = !this.isVisible;
            this.update();
        }
    });

    $(document).on({
        "onInit.fb": function(e, instance) {
            var Thumbs;

            if (instance && !instance.Thumbs) {
                Thumbs = new FancyThumbs(instance);

                if (Thumbs.isActive && Thumbs.opts.autoStart === true) {
                    Thumbs.show();
                }
            }
        },

        "beforeShow.fb": function(e, instance, item, firstRun) {
            var Thumbs = instance && instance.Thumbs;

            if (Thumbs && Thumbs.isVisible) {
                Thumbs.focus(firstRun ? 0 : 250);
            }
        },

        "afterKeydown.fb": function(e, instance, current, keypress, keycode) {
            var Thumbs = instance && instance.Thumbs;

            // "G"
            if (Thumbs && Thumbs.isActive && keycode === 71) {
                keypress.preventDefault();

                Thumbs.toggle();
            }
        },

        "beforeClose.fb": function(e, instance) {
            var Thumbs = instance && instance.Thumbs;

            if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {
                Thumbs.$grid.hide();
            }
        }
    });
})(document, jQuery);

//// ==========================================================================
//
// Share
// Displays simple form for sharing current url
//
// ==========================================================================
(function(document, $) {
    "use strict";

    $.extend(true, $.fancybox.defaults, {
        btnTpl: {
            share:
            '<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}">' +
            '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M2.55 19c1.4-8.4 9.1-9.8 11.9-9.8V5l7 7-7 6.3v-3.5c-2.8 0-10.5 2.1-11.9 4.2z"/></svg>' +
            "</button>"
        },
        share: {
            url: function(instance, item) {
                return (
                    (!instance.currentHash && !(item.type === "inline" || item.type === "html") ? item.origSrc || item.src : false) || window.location
                );
            },
            tpl:
            '<div class="fancybox-share">' +
            "<h1>{{SHARE}}</h1>" +
            "<p>" +
            '<a class="fancybox-share__button fancybox-share__button--fb" href="https://www.facebook.com/sharer/sharer.php?u={{url}}">' +
            '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m287 456v-299c0-21 6-35 35-35h38v-63c-7-1-29-3-55-3-54 0-91 33-91 94v306m143-254h-205v72h196" /></svg>' +
            "<span>Facebook</span>" +
            "</a>" +
            '<a class="fancybox-share__button fancybox-share__button--tw" href="https://twitter.com/intent/tweet?url={{url}}&text={{descr}}">' +
            '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m456 133c-14 7-31 11-47 13 17-10 30-27 37-46-15 10-34 16-52 20-61-62-157-7-141 75-68-3-129-35-169-85-22 37-11 86 26 109-13 0-26-4-37-9 0 39 28 72 65 80-12 3-25 4-37 2 10 33 41 57 77 57-42 30-77 38-122 34 170 111 378-32 359-208 16-11 30-25 41-42z" /></svg>' +
            "<span>Twitter</span>" +
            "</a>" +
            '<a class="fancybox-share__button fancybox-share__button--pt" href="https://www.pinterest.com/pin/create/button/?url={{url}}&description={{descr}}&media={{media}}">' +
            '<svg viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m265 56c-109 0-164 78-164 144 0 39 15 74 47 87 5 2 10 0 12-5l4-19c2-6 1-8-3-13-9-11-15-25-15-45 0-58 43-110 113-110 62 0 96 38 96 88 0 67-30 122-73 122-24 0-42-19-36-44 6-29 20-60 20-81 0-19-10-35-31-35-25 0-44 26-44 60 0 21 7 36 7 36l-30 125c-8 37-1 83 0 87 0 3 4 4 5 2 2-3 32-39 42-75l16-64c8 16 31 29 56 29 74 0 124-67 124-157 0-69-58-132-146-132z" fill="#fff"/></svg>' +
            "<span>Pinterest</span>" +
            "</a>" +
            "</p>" +
            '<p><input class="fancybox-share__input" type="text" value="{{url_raw}}" onclick="select()" /></p>' +
            "</div>"
        }
    });

    function escapeHtml(string) {
        var entityMap = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
            "/": "&#x2F;",
            "`": "&#x60;",
            "=": "&#x3D;"
        };

        return String(string).replace(/[&<>"'`=\/]/g, function(s) {
            return entityMap[s];
        });
    }

    $(document).on("click", "[data-fancybox-share]", function() {
        var instance = $.fancybox.getInstance(),
            current = instance.current || null,
            url,
            tpl;

        if (!current) {
            return;
        }

        if ($.type(current.opts.share.url) === "function") {
            url = current.opts.share.url.apply(current, [instance, current]);
        }

        tpl = current.opts.share.tpl
            .replace(/\{\{media\}\}/g, current.type === "image" ? encodeURIComponent(current.src) : "")
            .replace(/\{\{url\}\}/g, encodeURIComponent(url))
            .replace(/\{\{url_raw\}\}/g, escapeHtml(url))
            .replace(/\{\{descr\}\}/g, instance.$caption ? encodeURIComponent(instance.$caption.text()) : "");

        $.fancybox.open({
            src: instance.translate(instance, tpl),
            type: "html",
            opts: {
                touch: false,
                animationEffect: false,
                afterLoad: function(shareInstance, shareCurrent) {
                    // Close self if parent instance is closing
                    instance.$refs.container.one("beforeClose.fb", function() {
                        shareInstance.close(null, 0);
                    });

                    // Opening links in a popup window
                    shareCurrent.$content.find(".fancybox-share__button").click(function() {
                        window.open(this.href, "Share", "width=550, height=450");
                        return false;
                    });
                },
                mobile: {
                    autoFocus: false
                }
            }
        });
    });
})(document, jQuery);

// ==========================================================================
//
// Hash
// Enables linking to each modal
//
// ==========================================================================
(function(window, document, $) {
    "use strict";

    // Simple $.escapeSelector polyfill (for jQuery prior v3)
    if (!$.escapeSelector) {
        $.escapeSelector = function(sel) {
            var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
            var fcssescape = function(ch, asCodePoint) {
                if (asCodePoint) {
                    // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                    if (ch === "\0") {
                        return "\uFFFD";
                    }

                    // Control characters and (dependent upon position) numbers get escaped as code points
                    return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                }

                // Other potentially-special ASCII characters get backslash-escaped
                return "\\" + ch;
            };

            return (sel + "").replace(rcssescape, fcssescape);
        };
    }

    // Get info about gallery name and current index from url
    function parseUrl() {
        var hash = window.location.hash.substr(1),
            rez = hash.split("-"),
            index = rez.length > 1 && /^\+?\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1,
            gallery = rez.join("-");

        return {
            hash: hash,
            /* Index is starting from 1 */
            index: index < 1 ? 1 : index,
            gallery: gallery
        };
    }

    // Trigger click evnt on links to open new fancyBox instance
    function triggerFromUrl(url) {
        if (url.gallery !== "") {
            // If we can find element matching 'data-fancybox' atribute,
            // then triggering click event should start fancyBox
            $("[data-fancybox='" + $.escapeSelector(url.gallery) + "']")
                .eq(url.index - 1)
                .focus()
                .trigger("click.fb-start");
        }
    }

    // Get gallery name from current instance
    function getGalleryID(instance) {
        var opts, ret;

        if (!instance) {
            return false;
        }

        opts = instance.current ? instance.current.opts : instance.opts;
        ret = opts.hash || (opts.$orig ? opts.$orig.data("fancybox") || opts.$orig.data("fancybox-trigger") : "");

        return ret === "" ? false : ret;
    }

    // Start when DOM becomes ready
    $(function() {
        // Check if user has disabled this module
        if ($.fancybox.defaults.hash === false) {
            return;
        }

        // Update hash when opening/closing fancyBox
        $(document).on({
            "onInit.fb": function(e, instance) {
                var url, gallery;

                if (instance.group[instance.currIndex].opts.hash === false) {
                    return;
                }

                url = parseUrl();
                gallery = getGalleryID(instance);

                // Make sure gallery start index matches index from hash
                if (gallery && url.gallery && gallery == url.gallery) {
                    instance.currIndex = url.index - 1;
                }
            },

            "beforeShow.fb": function(e, instance, current, firstRun) {
                var gallery;

                if (!current || current.opts.hash === false) {
                    return;
                }

                // Check if need to update window hash
                gallery = getGalleryID(instance);

                if (!gallery) {
                    return;
                }

                // Variable containing last hash value set by fancyBox
                // It will be used to determine if fancyBox needs to close after hash change is detected
                instance.currentHash = gallery + (instance.group.length > 1 ? "-" + (current.index + 1) : "");

                // If current hash is the same (this instance most likely is opened by hashchange), then do nothing
                if (window.location.hash === "#" + instance.currentHash) {
                    return;
                }

                if (firstRun && !instance.origHash) {
                    instance.origHash = window.location.hash;
                }

                if (instance.hashTimer) {
                    clearTimeout(instance.hashTimer);
                }

                // Update hash
                instance.hashTimer = setTimeout(function() {
                    if ("replaceState" in window.history) {
                        window.history[firstRun ? "pushState" : "replaceState"](
                            {},
                            document.title,
                            window.location.pathname + window.location.search + "#" + instance.currentHash
                        );

                        if (firstRun) {
                            instance.hasCreatedHistory = true;
                        }
                    } else {
                        window.location.hash = instance.currentHash;
                    }

                    instance.hashTimer = null;
                }, 300);
            },

            "beforeClose.fb": function(e, instance, current) {
                if (current.opts.hash === false) {
                    return;
                }

                clearTimeout(instance.hashTimer);

                // Goto previous history entry
                if (instance.currentHash && instance.hasCreatedHistory) {
                    window.history.back();
                } else if (instance.currentHash) {
                    if ("replaceState" in window.history) {
                        window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (instance.origHash || ""));
                    } else {
                        window.location.hash = instance.origHash;
                    }
                }

                instance.currentHash = null;
            }
        });

        // Check if need to start/close after url has changed
        $(window).on("hashchange.fb", function() {
            var url = parseUrl(),
                fb = null;

            // Find last fancyBox instance that has "hash"
            $.each(
                $(".fancybox-container")
                    .get()
                    .reverse(),
                function(index, value) {
                    var tmp = $(value).data("FancyBox");

                    if (tmp && tmp.currentHash) {
                        fb = tmp;
                        return false;
                    }
                }
            );

            if (fb) {
                // Now, compare hash values
                if (fb.currentHash !== url.gallery + "-" + url.index && !(url.index === 1 && fb.currentHash == url.gallery)) {
                    fb.currentHash = null;

                    fb.close();
                }
            } else if (url.gallery !== "") {
                triggerFromUrl(url);
            }
        });

        // Check current hash and trigger click event on matching element to start fancyBox, if needed
        setTimeout(function() {
            if (!$.fancybox.getInstance()) {
                triggerFromUrl(parseUrl());
            }
        }, 50);
    });
})(window, document, jQuery);

// ==========================================================================
//
// Wheel
// Basic mouse weheel support for gallery navigation
//
// ==========================================================================
(function(document, $) {
    "use strict";

    var prevTime = new Date().getTime();

    $(document).on({
        "onInit.fb": function(e, instance, current) {
            instance.$refs.stage.on("mousewheel DOMMouseScroll wheel MozMousePixelScroll", function(e) {
                var current = instance.current,
                    currTime = new Date().getTime();

                if (instance.group.length < 2 || current.opts.wheel === false || (current.opts.wheel === "auto" && current.type !== "image")) {
                    return;
                }

                e.preventDefault();
                e.stopPropagation();

                if (current.$slide.hasClass("fancybox-animated")) {
                    return;
                }

                e = e.originalEvent || e;

                if (currTime - prevTime < 250) {
                    return;
                }

                prevTime = currTime;

                instance[(-e.deltaY || -e.deltaX || e.wheelDelta || -e.detail) < 0 ? "next" : "previous"]();
            });
        }
    });
})(document, jQuery);/*!
 * jQuery imagesLoaded plugin v2.1.1
 * http://github.com/desandro/imagesloaded
 *
 * MIT License. by Paul Irish et al.
 */

/*jshint curly: true, eqeqeq: true, noempty: true, strict: true, undef: true, browser: true */
/*global jQuery: false */

;(function($, undefined) {
'use strict';

// blank image data-uri bypasses webkit log warning (thx doug jones)
var BLANK = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

$.fn.imagesLoaded = function( callback ) {
	var $this = this,
		deferred = $.isFunction($.Deferred) ? $.Deferred() : 0,
		hasNotify = $.isFunction(deferred.notify),
		$images = $this.find('img').add( $this.filter('img') ),
		loaded = [],
		proper = [],
		broken = [];

	// Register deferred callbacks
	if ($.isPlainObject(callback)) {
		$.each(callback, function (key, value) {
			if (key === 'callback') {
				callback = value;
			} else if (deferred) {
				deferred[key](value);
			}
		});
	}

	function doneLoading() {
		var $proper = $(proper),
			$broken = $(broken);

		if ( deferred ) {
			if ( broken.length ) {
				deferred.reject( $images, $proper, $broken );
			} else {
				deferred.resolve( $images );
			}
		}

		if ( $.isFunction( callback ) ) {
			callback.call( $this, $images, $proper, $broken );
		}
	}

	function imgLoadedHandler( event ) {
		imgLoaded( event.target, event.type === 'error' );
	}

	function imgLoaded( img, isBroken ) {
		// don't proceed if BLANK image, or image is already loaded
		if ( img.src === BLANK || $.inArray( img, loaded ) !== -1 ) {
			return;
		}

		// store element in loaded images array
		loaded.push( img );

		// keep track of broken and properly loaded images
		if ( isBroken ) {
			broken.push( img );
		} else {
			proper.push( img );
		}

		// cache image and its state for future calls
		$.data( img, 'imagesLoaded', { isBroken: isBroken, src: img.src } );

		// trigger deferred progress method if present
		if ( hasNotify ) {
			deferred.notifyWith( $(img), [ isBroken, $images, $(proper), $(broken) ] );
		}

		// call doneLoading and clean listeners if all images are loaded
		if ( $images.length === loaded.length ) {
			setTimeout( doneLoading );
			$images.unbind( '.imagesLoaded', imgLoadedHandler );
		}
	}

	// if no images, trigger immediately
	if ( !$images.length ) {
		doneLoading();
	} else {
		$images.bind( 'load.imagesLoaded error.imagesLoaded', imgLoadedHandler )
		.each( function( i, el ) {
			var src = el.src;

			// find out if this image has been already checked for status
			// if it was, and src has not changed, call imgLoaded on it
			var cached = $.data( el, 'imagesLoaded' );
			if ( cached && cached.src === src ) {
				imgLoaded( el, cached.isBroken );
				return;
			}

			// if complete is true and browser supports natural sizes, try
			// to check for image status manually
			if ( el.complete && el.naturalWidth !== undefined ) {
				imgLoaded( el, el.naturalWidth === 0 || el.naturalHeight === 0 );
				return;
			}

			// cached images don't fire load sometimes, so we reset src, but only when
			// dealing with IE, or image is complete (loaded) and failed manual check
			// webkit hack from http://groups.google.com/group/jquery-dev/browse_thread/thread/eee6ab7b2da50e1f
			if ( el.readyState || el.complete ) {
				el.src = BLANK;
				el.src = src;
			}
		});
	}

	return deferred ? deferred.promise( $this ) : $this;
};

})(jQuery);/*!
 * jScrollPane - v2.0.0beta11 - 2011-07-04
 * http://jscrollpane.kelvinluck.com/
 *
 * Copyright (c) 2010 Kelvin Luck
 * Dual licensed under the MIT and GPL licenses.
 */

// Script: jScrollPane - cross browser customisable scrollbars
//
// *Version: 2.0.0beta11, Last updated: 2011-07-04*
//
// Project Home - http://jscrollpane.kelvinluck.com/
// GitHub       - http://github.com/vitch/jScrollPane
// Source       - http://github.com/vitch/jScrollPane/raw/master/script/jquery.jscrollpane.js
// (Minified)   - http://github.com/vitch/jScrollPane/raw/master/script/jquery.jscrollpane.min.js
//
// About: License
//
// Copyright (c) 2011 Kelvin Luck
// Dual licensed under the MIT or GPL Version 2 licenses.
// http://jscrollpane.kelvinluck.com/MIT-LICENSE.txt
// http://jscrollpane.kelvinluck.com/GPL-LICENSE.txt
//
// About: Examples
//
// All examples and demos are available through the jScrollPane example site at:
// http://jscrollpane.kelvinluck.com/
//
// About: Support and Testing
//
// This plugin is tested on the browsers below and has been found to work reliably on them. If you run
// into a problem on one of the supported browsers then please visit the support section on the jScrollPane
// website (http://jscrollpane.kelvinluck.com/) for more information on getting support. You are also
// welcome to fork the project on GitHub if you can contribute a fix for a given issue. 
//
// jQuery Versions - tested in 1.4.2+ - reported to work in 1.3.x
// Browsers Tested - Firefox 3.6.8, Safari 5, Opera 10.6, Chrome 5.0, IE 6, 7, 8
//
// About: Release History
//
// 2.0.0beta11 - (in progress) 
// 2.0.0beta10 - (2011-04-17) cleaner required size calculation, improved keyboard support, stickToBottom/Left, other small fixes
// 2.0.0beta9 - (2011-01-31) new API methods, bug fixes and correct keyboard support for FF/OSX
// 2.0.0beta8 - (2011-01-29) touchscreen support, improved keyboard support
// 2.0.0beta7 - (2011-01-23) scroll speed consistent (thanks Aivo Paas)
// 2.0.0beta6 - (2010-12-07) scrollToElement horizontal support
// 2.0.0beta5 - (2010-10-18) jQuery 1.4.3 support, various bug fixes
// 2.0.0beta4 - (2010-09-17) clickOnTrack support, bug fixes
// 2.0.0beta3 - (2010-08-27) Horizontal mousewheel, mwheelIntent, keyboard support, bug fixes
// 2.0.0beta2 - (2010-08-21) Bug fixes
// 2.0.0beta1 - (2010-08-17) Rewrite to follow modern best practices and enable horizontal scrolling, initially hidden
//							 elements and dynamically sized elements.
// 1.x - (2006-12-31 - 2010-07-31) Initial version, hosted at googlecode, deprecated

(function($,window,undefined){

	$.fn.jScrollPane = function(settings)
	{
		// JScrollPane "class" - public methods are available through $('selector').data('jsp')
		function JScrollPane(elem, s)
		{
			var settings, jsp = this, pane, paneWidth, paneHeight, container, contentWidth, contentHeight,
				percentInViewH, percentInViewV, isScrollableV, isScrollableH, verticalDrag, dragMaxY,
				verticalDragPosition, horizontalDrag, dragMaxX, horizontalDragPosition,
				verticalBar, verticalTrack, scrollbarWidth, verticalTrackHeight, verticalDragHeight, arrowUp, arrowDown,
				horizontalBar, horizontalTrack, horizontalTrackWidth, horizontalDragWidth, arrowLeft, arrowRight,
				reinitialiseInterval, originalPadding, originalPaddingTotalWidth, previousContentWidth,
				wasAtTop = true, wasAtLeft = true, wasAtBottom = false, wasAtRight = false,
				originalElement = elem.clone(false, false).empty(),
				mwEvent = $.fn.mwheelIntent ? 'mwheelIntent.jsp' : 'mousewheel.jsp';

			originalPadding = elem.css('paddingTop') + ' ' +
								elem.css('paddingRight') + ' ' +
								elem.css('paddingBottom') + ' ' +
								elem.css('paddingLeft');
			originalPaddingTotalWidth = (parseInt(elem.css('paddingLeft'), 10) || 0) +
										(parseInt(elem.css('paddingRight'), 10) || 0);

			function initialise(s)
			{

				var /*firstChild, lastChild, */isMaintainingPositon, lastContentX, lastContentY,
						hasContainingSpaceChanged, originalScrollTop, originalScrollLeft,
						maintainAtBottom = false, maintainAtRight = false;

				settings = s;

				if (pane === undefined) {
					originalScrollTop = elem.scrollTop();
					originalScrollLeft = elem.scrollLeft();

					elem.css(
						{
							overflow: 'hidden',
							padding: 0
						}
					);
					// TODO: Deal with where width/ height is 0 as it probably means the element is hidden and we should
					// come back to it later and check once it is unhidden...
                                        paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
                                        paneHeight = elem.innerHeight();

					elem.width(paneWidth);
					
					pane = $('<div class="jspPane" />').css('padding', originalPadding).append(elem.children());
					container = $('<div class="jspContainer" />')
						.css({
							'width': paneWidth + 'px',
							'height': paneHeight + 'px'
						}
					).append(pane).appendTo(elem);

					/*
					// Move any margins from the first and last children up to the container so they can still
					// collapse with neighbouring elements as they would before jScrollPane 
					firstChild = pane.find(':first-child');
					lastChild = pane.find(':last-child');
					elem.css(
						{
							'margin-top': firstChild.css('margin-top'),
							'margin-bottom': lastChild.css('margin-bottom')
						}
					);
					firstChild.css('margin-top', 0);
					lastChild.css('margin-bottom', 0);
					*/
				} else {
					elem.css('width', '');
                                        				
					maintainAtBottom = settings.stickToBottom && isCloseToBottom();
					maintainAtRight  = settings.stickToRight  && isCloseToRight();

					hasContainingSpaceChanged = elem.innerWidth() + originalPaddingTotalWidth != paneWidth || elem.outerHeight() != paneHeight;
                                        
					if (hasContainingSpaceChanged) {
						paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
						paneHeight = elem.innerHeight();
						container.css({
							width: paneWidth + 'px',
							height: paneHeight + 'px'
						});
					}

					// If nothing changed since last check...
					if (!hasContainingSpaceChanged && previousContentWidth == contentWidth && pane.outerHeight() == contentHeight) {
						elem.width(paneWidth);
                                                return;
					}
					previousContentWidth = contentWidth;
					pane.css('width', '');
					elem.width(paneWidth);
                                        
					container.find('>.jspVerticalBar,>.jspHorizontalBar').remove().end();
				}

				pane.css('overflow', 'auto');
				if (s.contentWidth) {
					contentWidth = s.contentWidth;
				} else {
					contentWidth = pane[0].scrollWidth;
				}
				contentHeight = pane[0].scrollHeight;
				pane.css('overflow', '');

				percentInViewH = contentWidth / paneWidth;
				percentInViewV = contentHeight / paneHeight;
				isScrollableV = percentInViewV > 1;

				isScrollableH = percentInViewH > 1;

				//console.log(paneWidth, paneHeight, contentWidth, contentHeight, percentInViewH, percentInViewV, isScrollableH, isScrollableV);

				if (!(isScrollableH || isScrollableV)) {
					elem.removeClass('jspScrollable');
					pane.css({
						top: 0,
						width: container.width() - originalPaddingTotalWidth
					});
                                        removeMousewheel();
					removeFocusHandler();
					removeKeyboardNav();
					removeClickOnTrack();
					unhijackInternalLinks();
				} else {
					elem.addClass('jspScrollable');

					isMaintainingPositon = settings.maintainPosition && (verticalDragPosition || horizontalDragPosition);
					if (isMaintainingPositon) {
						lastContentX = contentPositionX();
						lastContentY = contentPositionY();
					}

					initialiseVerticalScroll();
					initialiseHorizontalScroll();
					resizeScrollbars();

					if (isMaintainingPositon) {
						scrollToX(maintainAtRight  ? (contentWidth  - paneWidth ) : lastContentX, false);
						scrollToY(maintainAtBottom ? (contentHeight - paneHeight) : lastContentY, false);
					}

					initFocusHandler();
					initMousewheel();
					initTouch();
					
					if (settings.enableKeyboardNavigation) {
						initKeyboardNav();
					}
					if (settings.clickOnTrack) {
						initClickOnTrack();
					}
					
					observeHash();
					if (settings.hijackInternalLinks) {
						hijackInternalLinks();
					}
				}

				if (settings.autoReinitialise && !reinitialiseInterval) {
					reinitialiseInterval = setInterval(
						function()
						{
							initialise(settings);
						},
						settings.autoReinitialiseDelay
					);
				} else if (!settings.autoReinitialise && reinitialiseInterval) {
					clearInterval(reinitialiseInterval);
				}

				originalScrollTop && elem.scrollTop(0) && scrollToY(originalScrollTop, false);
				originalScrollLeft && elem.scrollLeft(0) && scrollToX(originalScrollLeft, false);

				elem.trigger('jsp-initialised', [isScrollableH || isScrollableV]);
			}

			function initialiseVerticalScroll()
			{
				if (isScrollableV) {

					container.append(
						$('<div class="jspVerticalBar" />').append(
							$('<div class="jspCap jspCapTop" />'),
							$('<div class="jspTrack" />').append(
								$('<div class="jspDrag" />').append(
									$('<div class="jspDragTop" />'),
									$('<div class="jspDragBottom" />')
								)
							),
							$('<div class="jspCap jspCapBottom" />')
						)
					);

					verticalBar = container.find('>.jspVerticalBar');
					verticalTrack = verticalBar.find('>.jspTrack');
					verticalDrag = verticalTrack.find('>.jspDrag');

					if (settings.showArrows) {
						arrowUp = $('<a class="jspArrow jspArrowUp" />').bind(
							'mousedown.jsp', getArrowScroll(0, -1)
						).bind('click.jsp', nil);
						arrowDown = $('<a class="jspArrow jspArrowDown" />').bind(
							'mousedown.jsp', getArrowScroll(0, 1)
						).bind('click.jsp', nil);
						if (settings.arrowScrollOnHover) {
							arrowUp.bind('mouseover.jsp', getArrowScroll(0, -1, arrowUp));
							arrowDown.bind('mouseover.jsp', getArrowScroll(0, 1, arrowDown));
						}

						appendArrows(verticalTrack, settings.verticalArrowPositions, arrowUp, arrowDown);
					}

					verticalTrackHeight = paneHeight;
					container.find('>.jspVerticalBar>.jspCap:visible,>.jspVerticalBar>.jspArrow').each(
						function()
						{
							verticalTrackHeight -= $(this).outerHeight();
						}
					);


					verticalDrag.hover(
						function()
						{
							verticalDrag.addClass('jspHover');
						},
						function()
						{
							verticalDrag.removeClass('jspHover');
						}
					).bind(
						'mousedown.jsp',
						function(e)
						{
							// Stop IE from allowing text selection
							$('html').bind('dragstart.jsp selectstart.jsp', nil);

							verticalDrag.addClass('jspActive');

							var startY = e.pageY - verticalDrag.position().top;

							$('html').bind(
								'mousemove.jsp',
								function(e)
								{
									positionDragY(e.pageY - startY, false);
								}
							).bind('mouseup.jsp mouseleave.jsp', cancelDrag);
							return false;
						}
					);
					sizeVerticalScrollbar();
				}
			}

			function sizeVerticalScrollbar()
			{
				verticalTrack.height(verticalTrackHeight + 'px');
				verticalDragPosition = 0;
				scrollbarWidth = settings.verticalGutter + verticalTrack.outerWidth();

				// Make the pane thinner to allow for the vertical scrollbar
				pane.width(paneWidth - scrollbarWidth - originalPaddingTotalWidth);

				// Add margin to the left of the pane if scrollbars are on that side (to position
				// the scrollbar on the left or right set it's left or right property in CSS)
				try {
					if (verticalBar.position().left === 0) {
						pane.css('margin-left', scrollbarWidth + 'px');
					}
				} catch (err) {
				}
			}

			function initialiseHorizontalScroll()
			{
				if (isScrollableH) {

					container.append(
						$('<div class="jspHorizontalBar" />').append(
							$('<div class="jspCap jspCapLeft" />'),
							$('<div class="jspTrack" />').append(
								$('<div class="jspDrag" />').append(
									$('<div class="jspDragLeft" />'),
									$('<div class="jspDragRight" />')
								)
							),
							$('<div class="jspCap jspCapRight" />')
						)
					);

					horizontalBar = container.find('>.jspHorizontalBar');
					horizontalTrack = horizontalBar.find('>.jspTrack');
					horizontalDrag = horizontalTrack.find('>.jspDrag');

					if (settings.showArrows) {
						arrowLeft = $('<a class="jspArrow jspArrowLeft" />').bind(
							'mousedown.jsp', getArrowScroll(-1, 0)
						).bind('click.jsp', nil);
						arrowRight = $('<a class="jspArrow jspArrowRight" />').bind(
							'mousedown.jsp', getArrowScroll(1, 0)
						).bind('click.jsp', nil);
						if (settings.arrowScrollOnHover) {
							arrowLeft.bind('mouseover.jsp', getArrowScroll(-1, 0, arrowLeft));
							arrowRight.bind('mouseover.jsp', getArrowScroll(1, 0, arrowRight));
						}
						appendArrows(horizontalTrack, settings.horizontalArrowPositions, arrowLeft, arrowRight);
					}

					horizontalDrag.hover(
						function()
						{
							horizontalDrag.addClass('jspHover');
						},
						function()
						{
							horizontalDrag.removeClass('jspHover');
						}
					).bind(
						'mousedown.jsp',
						function(e)
						{
							// Stop IE from allowing text selection
							$('html').bind('dragstart.jsp selectstart.jsp', nil);

							horizontalDrag.addClass('jspActive');

							var startX = e.pageX - horizontalDrag.position().left;

							$('html').bind(
								'mousemove.jsp',
								function(e)
								{
									positionDragX(e.pageX - startX, false);
								}
							).bind('mouseup.jsp mouseleave.jsp', cancelDrag);
							return false;
						}
					);
					horizontalTrackWidth = container.innerWidth();
					sizeHorizontalScrollbar();
				}
			}

			function sizeHorizontalScrollbar()
			{
				container.find('>.jspHorizontalBar>.jspCap:visible,>.jspHorizontalBar>.jspArrow').each(
					function()
					{
						horizontalTrackWidth -= $(this).outerWidth();
					}
				);

				horizontalTrack.width(horizontalTrackWidth + 'px');
				horizontalDragPosition = 0;
			}

			function resizeScrollbars()
			{
				if (isScrollableH && isScrollableV) {
					var horizontalTrackHeight = horizontalTrack.outerHeight(),
						verticalTrackWidth = verticalTrack.outerWidth();
					verticalTrackHeight -= horizontalTrackHeight;
					$(horizontalBar).find('>.jspCap:visible,>.jspArrow').each(
						function()
						{
							horizontalTrackWidth += $(this).outerWidth();
						}
					);
					horizontalTrackWidth -= verticalTrackWidth;
					paneHeight -= verticalTrackWidth;
					paneWidth -= horizontalTrackHeight;
					horizontalTrack.parent().append(
						$('<div class="jspCorner" />').css('width', horizontalTrackHeight + 'px')
					);
					sizeVerticalScrollbar();
					sizeHorizontalScrollbar();
				}
				// reflow content
				if (isScrollableH) {
					pane.width((container.outerWidth() - originalPaddingTotalWidth) + 'px');
				}
				contentHeight = pane.outerHeight();
				percentInViewV = contentHeight / paneHeight;

				if (isScrollableH) {
					horizontalDragWidth = Math.ceil(1 / percentInViewH * horizontalTrackWidth);
					if (horizontalDragWidth > settings.horizontalDragMaxWidth) {
						horizontalDragWidth = settings.horizontalDragMaxWidth;
					} else if (horizontalDragWidth < settings.horizontalDragMinWidth) {
						horizontalDragWidth = settings.horizontalDragMinWidth;
					}
					horizontalDrag.width(horizontalDragWidth + 'px');
					dragMaxX = horizontalTrackWidth - horizontalDragWidth;
					_positionDragX(horizontalDragPosition); // To update the state for the arrow buttons
				}
				if (isScrollableV) {
					verticalDragHeight = Math.ceil(1 / percentInViewV * verticalTrackHeight);
					if (verticalDragHeight > settings.verticalDragMaxHeight) {
						verticalDragHeight = settings.verticalDragMaxHeight;
					} else if (verticalDragHeight < settings.verticalDragMinHeight) {
						verticalDragHeight = settings.verticalDragMinHeight;
					}
					verticalDrag.height(verticalDragHeight + 'px');
					dragMaxY = verticalTrackHeight - verticalDragHeight;
					_positionDragY(verticalDragPosition); // To update the state for the arrow buttons
				}
			}

			function appendArrows(ele, p, a1, a2)
			{
				var p1 = "before", p2 = "after", aTemp;
				
				// Sniff for mac... Is there a better way to determine whether the arrows would naturally appear
				// at the top or the bottom of the bar?
				if (p == "os") {
					p = /Mac/.test(navigator.platform) ? "after" : "split";
				}
				if (p == p1) {
					p2 = p;
				} else if (p == p2) {
					p1 = p;
					aTemp = a1;
					a1 = a2;
					a2 = aTemp;
				}

				ele[p1](a1)[p2](a2);
			}

			function getArrowScroll(dirX, dirY, ele)
			{
				return function()
				{
					arrowScroll(dirX, dirY, this, ele);
					this.blur();
					return false;
				};
			}

			function arrowScroll(dirX, dirY, arrow, ele)
			{
				arrow = $(arrow).addClass('jspActive');

				var eve,
					scrollTimeout,
					isFirst = true,
					doScroll = function()
					{
						if (dirX !== 0) {
							jsp.scrollByX(dirX * settings.arrowButtonSpeed);
						}
						if (dirY !== 0) {
							jsp.scrollByY(dirY * settings.arrowButtonSpeed);
						}
						scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.arrowRepeatFreq);
						isFirst = false;
					};

				doScroll();

				eve = ele ? 'mouseout.jsp' : 'mouseup.jsp';
				ele = ele || $('html');
				ele.bind(
					eve,
					function()
					{
						arrow.removeClass('jspActive');
						scrollTimeout && clearTimeout(scrollTimeout);
						scrollTimeout = null;
						ele.unbind(eve);
					}
				);
			}

			function initClickOnTrack()
			{
				removeClickOnTrack();
				if (isScrollableV) {
					verticalTrack.bind(
						'mousedown.jsp',
						function(e)
						{
							if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
								var clickedTrack = $(this),
									offset = clickedTrack.offset(),
									direction = e.pageY - offset.top - verticalDragPosition,
									scrollTimeout,
									isFirst = true,
									doScroll = function()
									{
										var offset = clickedTrack.offset(),
											pos = e.pageY - offset.top - verticalDragHeight / 2,
											contentDragY = paneHeight * settings.scrollPagePercent,
											dragY = dragMaxY * contentDragY / (contentHeight - paneHeight);
										if (direction < 0) {
											if (verticalDragPosition - dragY > pos) {
												jsp.scrollByY(-contentDragY);
											} else {
												positionDragY(pos);
											}
										} else if (direction > 0) {
											if (verticalDragPosition + dragY < pos) {
												jsp.scrollByY(contentDragY);
											} else {
												positionDragY(pos);
											}
										} else {
											cancelClick();
											return;
										}
										scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
										isFirst = false;
									},
									cancelClick = function()
									{
										scrollTimeout && clearTimeout(scrollTimeout);
										scrollTimeout = null;
										$(document).unbind('mouseup.jsp', cancelClick);
									};
								doScroll();
								$(document).bind('mouseup.jsp', cancelClick);
								return false;
							}
						}
					);
				}
				
				if (isScrollableH) {
					horizontalTrack.bind(
						'mousedown.jsp',
						function(e)
						{
							if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
								var clickedTrack = $(this),
									offset = clickedTrack.offset(),
									direction = e.pageX - offset.left - horizontalDragPosition,
									scrollTimeout,
									isFirst = true,
									doScroll = function()
									{
										var offset = clickedTrack.offset(),
											pos = e.pageX - offset.left - horizontalDragWidth / 2,
											contentDragX = paneWidth * settings.scrollPagePercent,
											dragX = dragMaxX * contentDragX / (contentWidth - paneWidth);
										if (direction < 0) {
											if (horizontalDragPosition - dragX > pos) {
												jsp.scrollByX(-contentDragX);
											} else {
												positionDragX(pos);
											}
										} else if (direction > 0) {
											if (horizontalDragPosition + dragX < pos) {
												jsp.scrollByX(contentDragX);
											} else {
												positionDragX(pos);
											}
										} else {
											cancelClick();
											return;
										}
										scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
										isFirst = false;
									},
									cancelClick = function()
									{
										scrollTimeout && clearTimeout(scrollTimeout);
										scrollTimeout = null;
										$(document).unbind('mouseup.jsp', cancelClick);
									};
								doScroll();
								$(document).bind('mouseup.jsp', cancelClick);
								return false;
							}
						}
					);
				}
			}

			function removeClickOnTrack()
			{
				if (horizontalTrack) {
					horizontalTrack.unbind('mousedown.jsp');
				}
				if (verticalTrack) {
					verticalTrack.unbind('mousedown.jsp');
				}
			}

			function cancelDrag()
			{
				$('html').unbind('dragstart.jsp selectstart.jsp mousemove.jsp mouseup.jsp mouseleave.jsp');

				if (verticalDrag) {
					verticalDrag.removeClass('jspActive');
				}
				if (horizontalDrag) {
					horizontalDrag.removeClass('jspActive');
				}
			}

			function positionDragY(destY, animate)
			{
				if (!isScrollableV) {
					return;
				}
				if (destY < 0) {
					destY = 0;
				} else if (destY > dragMaxY) {
					destY = dragMaxY;
				}

				// can't just check if(animate) because false is a valid value that could be passed in...
				if (animate === undefined) {
					animate = settings.animateScroll;
				}
				if (animate) {
					jsp.animate(verticalDrag, 'top', destY,	_positionDragY);
				} else {
					verticalDrag.css('top', destY);
					_positionDragY(destY);
				}

			}

			function _positionDragY(destY)
			{
				if (destY === undefined) {
					destY = verticalDrag.position().top;
				}

				container.scrollTop(0);
				verticalDragPosition = destY;

				var isAtTop = verticalDragPosition === 0,
					isAtBottom = verticalDragPosition == dragMaxY,
					percentScrolled = destY/ dragMaxY,
					destTop = -percentScrolled * (contentHeight - paneHeight);

				if (wasAtTop != isAtTop || wasAtBottom != isAtBottom) {
					wasAtTop = isAtTop;
					wasAtBottom = isAtBottom;
					elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
				}
				
				updateVerticalArrows(isAtTop, isAtBottom);
				pane.css('top', destTop);
				elem.trigger('jsp-scroll-y', [-destTop, isAtTop, isAtBottom]).trigger('scroll');
			}

			function positionDragX(destX, animate)
			{
				if (!isScrollableH) {
					return;
				}
				if (destX < 0) {
					destX = 0;
				} else if (destX > dragMaxX) {
					destX = dragMaxX;
				}

				if (animate === undefined) {
					animate = settings.animateScroll;
				}
				if (animate) {
					jsp.animate(horizontalDrag, 'left', destX,	_positionDragX);
				} else {
					horizontalDrag.css('left', destX);
					_positionDragX(destX);
				}
			}

			function _positionDragX(destX)
			{
				if (destX === undefined) {
					destX = horizontalDrag.position().left;
				}

				container.scrollTop(0);
				horizontalDragPosition = destX;

				var isAtLeft = horizontalDragPosition === 0,
					isAtRight = horizontalDragPosition == dragMaxX,
					percentScrolled = destX / dragMaxX,
					destLeft = -percentScrolled * (contentWidth - paneWidth);

				if (wasAtLeft != isAtLeft || wasAtRight != isAtRight) {
					wasAtLeft = isAtLeft;
					wasAtRight = isAtRight;
					elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
				}
				
				updateHorizontalArrows(isAtLeft, isAtRight);
				pane.css('left', destLeft);
				elem.trigger('jsp-scroll-x', [-destLeft, isAtLeft, isAtRight]).trigger('scroll');
			}

			function updateVerticalArrows(isAtTop, isAtBottom)
			{
				if (settings.showArrows) {
					arrowUp[isAtTop ? 'addClass' : 'removeClass']('jspDisabled');
					arrowDown[isAtBottom ? 'addClass' : 'removeClass']('jspDisabled');
				}
			}

			function updateHorizontalArrows(isAtLeft, isAtRight)
			{
				if (settings.showArrows) {
					arrowLeft[isAtLeft ? 'addClass' : 'removeClass']('jspDisabled');
					arrowRight[isAtRight ? 'addClass' : 'removeClass']('jspDisabled');
				}
			}

			function scrollToY(destY, animate)
			{
				var percentScrolled = destY / (contentHeight - paneHeight);
				positionDragY(percentScrolled * dragMaxY, animate);
			}

			function scrollToX(destX, animate)
			{
				var percentScrolled = destX / (contentWidth - paneWidth);
				positionDragX(percentScrolled * dragMaxX, animate);
			}

			function scrollToElement(ele, stickToTop, animate)
			{
				var e, eleHeight, eleWidth, eleTop = 0, eleLeft = 0, viewportTop, viewportLeft, maxVisibleEleTop, maxVisibleEleLeft, destY, destX;

				// Legal hash values aren't necessarily legal jQuery selectors so we need to catch any
				// errors from the lookup...
				try {
					e = $(ele);
				} catch (err) {
					return;
				}
				eleHeight = e.outerHeight();
				eleWidth= e.outerWidth();

				container.scrollTop(0);
				container.scrollLeft(0);
				
				// loop through parents adding the offset top of any elements that are relatively positioned between
				// the focused element and the jspPane so we can get the true distance from the top
				// of the focused element to the top of the scrollpane...
				while (!e.is('.jspPane')) {
					eleTop += e.position().top;
					eleLeft += e.position().left;
					e = e.offsetParent();
					if (/^body|html$/i.test(e[0].nodeName)) {
						// we ended up too high in the document structure. Quit!
						return;
					}
				}

				viewportTop = contentPositionY();
				maxVisibleEleTop = viewportTop + paneHeight;
				if (eleTop < viewportTop || stickToTop) { // element is above viewport
					destY = eleTop - settings.verticalGutter;
				} else if (eleTop + eleHeight > maxVisibleEleTop) { // element is below viewport
					destY = eleTop - paneHeight + eleHeight + settings.verticalGutter;
				}
				if (destY) {
					scrollToY(destY, animate);
				}
				
				viewportLeft = contentPositionX();
	            maxVisibleEleLeft = viewportLeft + paneWidth;
	            if (eleLeft < viewportLeft || stickToTop) { // element is to the left of viewport
	                destX = eleLeft - settings.horizontalGutter;
	            } else if (eleLeft + eleWidth > maxVisibleEleLeft) { // element is to the right viewport
	                destX = eleLeft - paneWidth + eleWidth + settings.horizontalGutter;
	            }
	            if (destX) {
	                scrollToX(destX, animate);
	            }

			}

			function contentPositionX()
			{
				return -pane.position().left;
			}

			function contentPositionY()
			{
				return -pane.position().top;
			}

			function isCloseToBottom()
			{
				var scrollableHeight = contentHeight - paneHeight;
				return (scrollableHeight > 20) && (scrollableHeight - contentPositionY() < 10);
			}

			function isCloseToRight()
			{
				var scrollableWidth = contentWidth - paneWidth;
				return (scrollableWidth > 20) && (scrollableWidth - contentPositionX() < 10);
			}

			function initMousewheel()
			{
				container.unbind(mwEvent).bind(
					mwEvent,
					function (event, delta, deltaX, deltaY) {
						var dX = horizontalDragPosition, dY = verticalDragPosition;
						jsp.scrollBy(deltaX * settings.mouseWheelSpeed, -deltaY * settings.mouseWheelSpeed, false);
						// return true if there was no movement so rest of screen can scroll
						return dX == horizontalDragPosition && dY == verticalDragPosition;
					}
				);
			}

			function removeMousewheel()
			{
				container.unbind(mwEvent);
			}

			function nil()
			{
				return false;
			}

			function initFocusHandler()
			{
				pane.find(':input,a').unbind('focus.jsp').bind(
					'focus.jsp',
					function(e)
					{
						scrollToElement(e.target, false);
					}
				);
			}

			function removeFocusHandler()
			{
				pane.find(':input,a').unbind('focus.jsp');
			}
			
			function initKeyboardNav()
			{
				var keyDown, elementHasScrolled, validParents = [];
				isScrollableH && validParents.push(horizontalBar[0]);
				isScrollableV && validParents.push(verticalBar[0]);
				
				// IE also focuses elements that don't have tabindex set.
				pane.focus(
					function()
					{
						elem.focus();
					}
				);
				
				elem.attr('tabindex', 0)
					.unbind('keydown.jsp keypress.jsp')
					.bind(
						'keydown.jsp',
						function(e)
						{
							if (e.target !== this && !(validParents.length && $(e.target).closest(validParents).length)){
								return;
							}
							var dX = horizontalDragPosition, dY = verticalDragPosition;
							switch(e.keyCode) {
								case 40: // down
								case 38: // up
								case 34: // page down
								case 32: // space
								case 33: // page up
								case 39: // right
								case 37: // left
									keyDown = e.keyCode;
									keyDownHandler();
									break;
								case 35: // end
									scrollToY(contentHeight - paneHeight);
									keyDown = null;
									break;
								case 36: // home
									scrollToY(0);
									keyDown = null;
									break;
							}

							elementHasScrolled = e.keyCode == keyDown && dX != horizontalDragPosition || dY != verticalDragPosition;
							return !elementHasScrolled;
						}
					).bind(
						'keypress.jsp', // For FF/ OSX so that we can cancel the repeat key presses if the JSP scrolls...
						function(e)
						{
							if (e.keyCode == keyDown) {
								keyDownHandler();
							}
							return !elementHasScrolled;
						}
					);
				
				if (settings.hideFocus) {
					elem.css('outline', 'none');
					if ('hideFocus' in container[0]){
						elem.attr('hideFocus', true);
					}
				} else {
					elem.css('outline', '');
					if ('hideFocus' in container[0]){
						elem.attr('hideFocus', false);
					}
				}
				
				function keyDownHandler()
				{
					var dX = horizontalDragPosition, dY = verticalDragPosition;
					switch(keyDown) {
						case 40: // down
							jsp.scrollByY(settings.keyboardSpeed, false);
							break;
						case 38: // up
							jsp.scrollByY(-settings.keyboardSpeed, false);
							break;
						case 34: // page down
						case 32: // space
							jsp.scrollByY(paneHeight * settings.scrollPagePercent, false);
							break;
						case 33: // page up
							jsp.scrollByY(-paneHeight * settings.scrollPagePercent, false);
							break;
						case 39: // right
							jsp.scrollByX(settings.keyboardSpeed, false);
							break;
						case 37: // left
							jsp.scrollByX(-settings.keyboardSpeed, false);
							break;
					}

					elementHasScrolled = dX != horizontalDragPosition || dY != verticalDragPosition;
					return elementHasScrolled;
				}
			}
			
			function removeKeyboardNav()
			{
				elem.attr('tabindex', '-1')
					.removeAttr('tabindex')
					.unbind('keydown.jsp keypress.jsp');
			}

			function observeHash()
			{
				if (location.hash && location.hash.length > 1) {
					var e,
						retryInt,
						hash = escape(location.hash) // hash must be escaped to prevent XSS
						;
					try {
						e = $(hash);
					} catch (err) {
						return;
					}

					if (e.length && pane.find(hash)) {
						// nasty workaround but it appears to take a little while before the hash has done its thing
						// to the rendered page so we just wait until the container's scrollTop has been messed up.
						if (container.scrollTop() === 0) {
							retryInt = setInterval(
								function()
								{
									if (container.scrollTop() > 0) {
										scrollToElement(hash, true);
										$(document).scrollTop(container.position().top);
										clearInterval(retryInt);
									}
								},
								50
							);
						} else {
							scrollToElement(hash, true);
							$(document).scrollTop(container.position().top);
						}
					}
				}
			}

			function unhijackInternalLinks()
			{
				$('a.jspHijack').unbind('click.jsp-hijack').removeClass('jspHijack');
			}

			function hijackInternalLinks()
			{
				unhijackInternalLinks();
				$('a[href^=#]').addClass('jspHijack').bind(
					'click.jsp-hijack',
					function()
					{
						var uriParts = this.href.split('#'), hash;
						if (uriParts.length > 1) {
							hash = uriParts[1];
							if (hash.length > 0 && pane.find('#' + hash).length > 0) {
								scrollToElement('#' + hash, true);
								// Need to return false otherwise things mess up... Would be nice to maybe also scroll
								// the window to the top of the scrollpane?
								return false;
							}
						}
					}
				);
			}
			
			// Init touch on iPad, iPhone, iPod, Android
			function initTouch()
			{
				var startX,
					startY,
					touchStartX,
					touchStartY,
					moved,
					moving = false;
  
				container.unbind('touchstart.jsp touchmove.jsp touchend.jsp click.jsp-touchclick').bind(
					'touchstart.jsp',
					function(e)
					{
						var touch = e.originalEvent.touches[0];
						startX = contentPositionX();
						startY = contentPositionY();
						touchStartX = touch.pageX;
						touchStartY = touch.pageY;
						moved = false;
						moving = true;
					}
				).bind(
					'touchmove.jsp',
					function(ev)
					{
						if(!moving) {
							return;
						}
						
						var touchPos = ev.originalEvent.touches[0],
							dX = horizontalDragPosition, dY = verticalDragPosition;
						
						jsp.scrollTo(startX + touchStartX - touchPos.pageX, startY + touchStartY - touchPos.pageY);
						
						moved = moved || Math.abs(touchStartX - touchPos.pageX) > 5 || Math.abs(touchStartY - touchPos.pageY) > 5;
						
						// return true if there was no movement so rest of screen can scroll
						return dX == horizontalDragPosition && dY == verticalDragPosition;
					}
				).bind(
					'touchend.jsp',
					function(e)
					{
						moving = false;
						/*if(moved) {
							return false;
						}*/
					}
				).bind(
					'click.jsp-touchclick',
					function(e)
					{
						if(moved) {
							moved = false;
							return false;
						}
					}
				);
			}
			
			function destroy(){
				var currentY = contentPositionY(),
					currentX = contentPositionX();
				elem.removeClass('jspScrollable').unbind('.jsp');
				elem.replaceWith(originalElement.append(pane.children()));
				originalElement.scrollTop(currentY);
				originalElement.scrollLeft(currentX);
			}

			// Public API
			$.extend(
				jsp,
				{
					// Reinitialises the scroll pane (if it's internal dimensions have changed since the last time it
					// was initialised). The settings object which is passed in will override any settings from the
					// previous time it was initialised - if you don't pass any settings then the ones from the previous
					// initialisation will be used.
					reinitialise: function(s)
					{
						s = $.extend({}, settings, s);
						initialise(s);
					},
					// Scrolls the specified element (a jQuery object, DOM node or jQuery selector string) into view so
					// that it can be seen within the viewport. If stickToTop is true then the element will appear at
					// the top of the viewport, if it is false then the viewport will scroll as little as possible to
					// show the element. You can also specify if you want animation to occur. If you don't provide this
					// argument then the animateScroll value from the settings object is used instead.
					scrollToElement: function(ele, stickToTop, animate)
					{
						scrollToElement(ele, stickToTop, animate);
					},
					// Scrolls the pane so that the specified co-ordinates within the content are at the top left
					// of the viewport. animate is optional and if not passed then the value of animateScroll from
					// the settings object this jScrollPane was initialised with is used.
					scrollTo: function(destX, destY, animate)
					{
						scrollToX(destX, animate);
						scrollToY(destY, animate);
					},
					// Scrolls the pane so that the specified co-ordinate within the content is at the left of the
					// viewport. animate is optional and if not passed then the value of animateScroll from the settings
					// object this jScrollPane was initialised with is used.
					scrollToX: function(destX, animate)
					{
						scrollToX(destX, animate);
					},
					// Scrolls the pane so that the specified co-ordinate within the content is at the top of the
					// viewport. animate is optional and if not passed then the value of animateScroll from the settings
					// object this jScrollPane was initialised with is used.
					scrollToY: function(destY, animate)
					{
						scrollToY(destY, animate);
					},
					// Scrolls the pane to the specified percentage of its maximum horizontal scroll position. animate
					// is optional and if not passed then the value of animateScroll from the settings object this
					// jScrollPane was initialised with is used.
					scrollToPercentX: function(destPercentX, animate)
					{
						scrollToX(destPercentX * (contentWidth - paneWidth), animate);
					},
					// Scrolls the pane to the specified percentage of its maximum vertical scroll position. animate
					// is optional and if not passed then the value of animateScroll from the settings object this
					// jScrollPane was initialised with is used.
					scrollToPercentY: function(destPercentY, animate)
					{
						scrollToY(destPercentY * (contentHeight - paneHeight), animate);
					},
					// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
					// the value of animateScroll from the settings object this jScrollPane was initialised with is used.
					scrollBy: function(deltaX, deltaY, animate)
					{
						jsp.scrollByX(deltaX, animate);
						jsp.scrollByY(deltaY, animate);
					},
					// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
					// the value of animateScroll from the settings object this jScrollPane was initialised with is used.
					scrollByX: function(deltaX, animate)
					{
						var destX = contentPositionX() + Math[deltaX<0 ? 'floor' : 'ceil'](deltaX),
							percentScrolled = destX / (contentWidth - paneWidth);
						positionDragX(percentScrolled * dragMaxX, animate);
					},
					// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
					// the value of animateScroll from the settings object this jScrollPane was initialised with is used.
					scrollByY: function(deltaY, animate)
					{
						var destY = contentPositionY() + Math[deltaY<0 ? 'floor' : 'ceil'](deltaY),
							percentScrolled = destY / (contentHeight - paneHeight);
						positionDragY(percentScrolled * dragMaxY, animate);
					},
					// Positions the horizontal drag at the specified x position (and updates the viewport to reflect
					// this). animate is optional and if not passed then the value of animateScroll from the settings
					// object this jScrollPane was initialised with is used.
					positionDragX: function(x, animate)
					{
						positionDragX(x, animate);
					},
					// Positions the vertical drag at the specified y position (and updates the viewport to reflect
					// this). animate is optional and if not passed then the value of animateScroll from the settings
					// object this jScrollPane was initialised with is used.
					positionDragY: function(y, animate)
					{
						positionDragY(y, animate);
					},
					// This method is called when jScrollPane is trying to animate to a new position. You can override
					// it if you want to provide advanced animation functionality. It is passed the following arguments:
					//  * ele          - the element whose position is being animated
					//  * prop         - the property that is being animated
					//  * value        - the value it's being animated to
					//  * stepCallback - a function that you must execute each time you update the value of the property
					// You can use the default implementation (below) as a starting point for your own implementation.
					animate: function(ele, prop, value, stepCallback)
					{
						var params = {};
						params[prop] = value;
						ele.animate(
							params,
							{
								'duration'	: settings.animateDuration,
								'easing'	: settings.animateEase,
								'queue'		: false,
								'step'		: stepCallback
							}
						);
					},
					// Returns the current x position of the viewport with regards to the content pane.
					getContentPositionX: function()
					{
						return contentPositionX();
					},
					// Returns the current y position of the viewport with regards to the content pane.
					getContentPositionY: function()
					{
						return contentPositionY();
					},
					// Returns the width of the content within the scroll pane.
					getContentWidth: function()
					{
						return contentWidth;
					},
					// Returns the height of the content within the scroll pane.
					getContentHeight: function()
					{
						return contentHeight;
					},
					// Returns the horizontal position of the viewport within the pane content.
					getPercentScrolledX: function()
					{
						return contentPositionX() / (contentWidth - paneWidth);
					},
					// Returns the vertical position of the viewport within the pane content.
					getPercentScrolledY: function()
					{
						return contentPositionY() / (contentHeight - paneHeight);
					},
					// Returns whether or not this scrollpane has a horizontal scrollbar.
					getIsScrollableH: function()
					{
						return isScrollableH;
					},
					// Returns whether or not this scrollpane has a vertical scrollbar.
					getIsScrollableV: function()
					{
						return isScrollableV;
					},
					// Gets a reference to the content pane. It is important that you use this method if you want to
					// edit the content of your jScrollPane as if you access the element directly then you may have some
					// problems (as your original element has had additional elements for the scrollbars etc added into
					// it).
					getContentPane: function()
					{
						return pane;
					},
					// Scrolls this jScrollPane down as far as it can currently scroll. If animate isn't passed then the
					// animateScroll value from settings is used instead.
					scrollToBottom: function(animate)
					{
						positionDragY(dragMaxY, animate);
					},
					// Hijacks the links on the page which link to content inside the scrollpane. If you have changed
					// the content of your page (e.g. via AJAX) and want to make sure any new anchor links to the
					// contents of your scroll pane will work then call this function.
					hijackInternalLinks: function()
					{
						hijackInternalLinks();
					},
					// Removes the jScrollPane and returns the page to the state it was in before jScrollPane was
					// initialised.
					destroy: function()
					{
							destroy();
					}
				}
			);
			
			initialise(s);
		}

		// Pluginifying code...
		settings = $.extend({}, $.fn.jScrollPane.defaults, settings);
		
		// Apply default speed
		$.each(['mouseWheelSpeed', 'arrowButtonSpeed', 'trackClickSpeed', 'keyboardSpeed'], function() {
			settings[this] = settings[this] || settings.speed;
		});

		return this.each(
			function()
			{
				var elem = $(this), jspApi = elem.data('jsp');
				if (jspApi) {
					jspApi.reinitialise(settings);
				} else {
					jspApi = new JScrollPane(elem, settings);
					elem.data('jsp', jspApi);
				}
			}
		);
	};

	$.fn.jScrollPane.defaults = {
		showArrows					: false,
		maintainPosition			: true,
		stickToBottom				: false,
		stickToRight				: false,
		clickOnTrack				: true,
		autoReinitialise			: false,
		autoReinitialiseDelay		: 500,
		verticalDragMinHeight		: 0,
		verticalDragMaxHeight		: 99999,
		horizontalDragMinWidth		: 0,
		horizontalDragMaxWidth		: 99999,
		contentWidth				: undefined,
		animateScroll				: false,
		animateDuration				: 300,
		animateEase					: 'linear',
		hijackInternalLinks			: false,
		verticalGutter				: 4,
		horizontalGutter			: 4,
		mouseWheelSpeed				: 0,
		arrowButtonSpeed			: 0,
		arrowRepeatFreq				: 50,
		arrowScrollOnHover			: false,
		trackClickSpeed				: 0,
		trackClickRepeatFreq		: 70,
		verticalArrowPositions		: 'split',
		horizontalArrowPositions	: 'split',
		enableKeyboardNavigation	: true,
		hideFocus					: false,
		keyboardSpeed				: 0,
		initialDelay                : 300,        // Delay before starting repeating
		speed						: 30,		// Default speed when others falsey
		scrollPagePercent			: .8		// Percent of visible area scrolled when pageUp/Down or track area pressed
	};

})(mrm.$,this);
/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.11
 *
 * Requires: jQuery 1.2.2+
 */

(function (factory) {
	if ( typeof define === 'function' && define.amd ) {
		// AMD. Register as an anonymous module.
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// Node/CommonJS style for Browserify
		module.exports = factory;
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
		toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
			['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
		slice  = Array.prototype.slice,
		nullLowestDeltaTimeout, lowestDelta;

	if ( $.event.fixHooks ) {
		for ( var i = toFix.length; i; ) {
			$.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
		}
	}

	var special = $.event.special.mousewheel = {
		version: '3.1.11',

		setup: function() {
			if ( this.addEventListener ) {
				for ( var i = toBind.length; i; ) {
					this.addEventListener( toBind[--i], handler, false );
				}
			} else {
				this.onmousewheel = handler;
			}
			// Store the line height and page height for this particular element
			$.data(this, 'mousewheel-line-height', special.getLineHeight(this));
			$.data(this, 'mousewheel-page-height', special.getPageHeight(this));
		},

		teardown: function() {
			if ( this.removeEventListener ) {
				for ( var i = toBind.length; i; ) {
					this.removeEventListener( toBind[--i], handler, false );
				}
			} else {
				this.onmousewheel = null;
			}
			// Clean up the data we added to the element
			$.removeData(this, 'mousewheel-line-height');
			$.removeData(this, 'mousewheel-page-height');
		},

		getLineHeight: function(elem) {
			var $parent = $(elem)['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
			if (!$parent.length) {
				$parent = $('body');
			}
			return parseInt($parent.css('fontSize'), 10);
		},

		getPageHeight: function(elem) {
			return $(elem).height();
		},

		settings: {
			adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
			normalizeOffset: true  // calls getBoundingClientRect for each event
		}
	};

	$.fn.extend({
		mousewheel: function(fn) {
			return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
		},

		unmousewheel: function(fn) {
			return this.unbind('mousewheel', fn);
		}
	});


	function handler(event) {
		var orgEvent   = event || window.event,
			args       = slice.call(arguments, 1),
			delta      = 0,
			deltaX     = 0,
			deltaY     = 0,
			absDelta   = 0,
			offsetX    = 0,
			offsetY    = 0;
		event = $.event.fix(orgEvent);
		event.type = 'mousewheel';

		// Old school scrollwheel delta
		if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
		if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
		if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
		if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

		// Firefox < 17 horizontal scrolling related to DOMMouseScroll event
		if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
			deltaX = deltaY * -1;
			deltaY = 0;
		}

		// Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
		delta = deltaY === 0 ? deltaX : deltaY;

		// New school wheel delta (wheel event)
		if ( 'deltaY' in orgEvent ) {
			deltaY = orgEvent.deltaY * -1;
			delta  = deltaY;
		}
		if ( 'deltaX' in orgEvent ) {
			deltaX = orgEvent.deltaX;
			if ( deltaY === 0 ) { delta  = deltaX * -1; }
		}

		// No change actually happened, no reason to go any further
		if ( deltaY === 0 && deltaX === 0 ) { return; }

		// Need to convert lines and pages to pixels if we aren't already in pixels
		// There are three delta modes:
		//   * deltaMode 0 is by pixels, nothing to do
		//   * deltaMode 1 is by lines
		//   * deltaMode 2 is by pages
		if ( orgEvent.deltaMode === 1 ) {
			var lineHeight = $.data(this, 'mousewheel-line-height');
			delta  *= lineHeight;
			deltaY *= lineHeight;
			deltaX *= lineHeight;
		} else if ( orgEvent.deltaMode === 2 ) {
			var pageHeight = $.data(this, 'mousewheel-page-height');
			delta  *= pageHeight;
			deltaY *= pageHeight;
			deltaX *= pageHeight;
		}

		// Store lowest absolute delta to normalize the delta values
		absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

		if ( !lowestDelta || absDelta < lowestDelta ) {
			lowestDelta = absDelta;

			// Adjust older deltas if necessary
			if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
				lowestDelta /= 40;
			}
		}

		// Adjust older deltas if necessary
		if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
			// Divide all the things by 40!
			delta  /= 40;
			deltaX /= 40;
			deltaY /= 40;
		}

		// Get a whole, normalized value for the deltas
		delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
		deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
		deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

		// Normalise offsetX and offsetY properties
		if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
			var boundingRect = this.getBoundingClientRect();
			offsetX = event.clientX - boundingRect.left;
			offsetY = event.clientY - boundingRect.top;
		}

		// Add information to the event object
		event.deltaX = deltaX;
		event.deltaY = deltaY;
		event.deltaFactor = lowestDelta;
		event.offsetX = offsetX;
		event.offsetY = offsetY;
		// Go ahead and set deltaMode to 0 since we converted to pixels
		// Although this is a little odd since we overwrite the deltaX/Y
		// properties with normalized deltas.
		event.deltaMode = 0;

		// Add event and delta to the front of the arguments
		args.unshift(event, delta, deltaX, deltaY);

		// Clearout lowestDelta after sometime to better
		// handle multiple device types that give different
		// a different lowestDelta
		// Ex: trackpad = 3 and mouse wheel = 120
		if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
		nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

		return ($.event.dispatch || $.event.handle).apply(this, args);
	}

	function nullLowestDelta() {
		lowestDelta = null;
	}

	function shouldAdjustOldDeltas(orgEvent, absDelta) {
		// If this is an older event and the delta is divisable by 120,
		// then we are assuming that the browser is treating this as an
		// older mouse wheel event and that we should divide the deltas
		// by 40 to try and get a more usable deltaFactor.
		// Side note, this actually impacts the reported scroll distance
		// in older browsers and can cause scrolling to be slower than native.
		// Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
		return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
	}

}));/*
* Placeholder plugin for jQuery
* ---
* Copyright 2010, Daniel Stocks (http://webcloud.se)
* Released under the MIT, BSD, and GPL Licenses.
*/
(function($) {
    function Placeholder(input) {
        this.input = input;
        if (input.attr('type') == 'password') {
            this.handlePassword();
        }
        // Prevent placeholder values from submitting
        $(input[0].form).submit(function() {
            if (input.hasClass('placeholder') && input[0].value == input.attr('placeholder')) {
                input[0].value = '';
            }
        });
    }
    Placeholder.prototype = {
        show : function(loading) {
            // FF and IE saves values when you refresh the page. If the user refreshes the page with
            // the placeholders showing they will be the default values and the input fields won't be empty.
            if (this.input[0].value === '' || (loading && this.valueIsPlaceholder())) {
                if (this.isPassword) {
                    try {
                        this.input[0].setAttribute('type', 'text');
                    } catch (e) {
                        this.input.before(this.fakePassword.show()).hide();
                    }
                }
                this.input.addClass('placeholder');
                this.input[0].value = this.input.attr('placeholder');
            }
        },
        hide : function() {
            if (this.valueIsPlaceholder() && this.input.hasClass('placeholder')) {
                this.input.removeClass('placeholder');
                this.input[0].value = '';
                if (this.isPassword) {
                    try {
                        this.input[0].setAttribute('type', 'password');
                    } catch (e) { }
                    // Restore focus for Opera and IE
                    this.input.show();
                    this.input[0].focus();
                }
            }
        },
        valueIsPlaceholder : function() {
            return this.input[0].value == this.input.attr('placeholder');
        },
        handlePassword: function() {
            var input = this.input;
            input.attr('realType', 'password');
            this.isPassword = true;
            // IE < 9 doesn't allow changing the type of password inputs
            if ($.browser.msie && input[0].outerHTML) {
                var fakeHTML = $(input[0].outerHTML.replace(/type=(['"])?password\1/gi, 'type=$1text$1'));
                this.fakePassword = fakeHTML.val(input.attr('placeholder')).addClass('placeholder').focus(function() {
                    input.trigger('focus');
                    $(this).hide();
                });
                $(input[0].form).submit(function() {
                    fakeHTML.remove();
                    input.show()
                });
            }
        }
    };
    var NATIVE_SUPPORT = !!("placeholder" in document.createElement( "input" ));
    $.fn.placeholder = function() {
        return NATIVE_SUPPORT ? this : this.each(function() {
            var input = $(this);
            var placeholder = new Placeholder(input);
            placeholder.show(true);
            input.focus(function() {
                placeholder.hide();
            });
            input.blur(function() {
                placeholder.show(false);
            });

            // On page refresh, IE doesn't re-populate user input
            // until the window.onload event is fired.
            if ($.browser.msie) {
                $(window).load(function() {
                    if(input.val()) {
                        input.removeClass("placeholder");
                    }
                    placeholder.show(true);
                });
                // What's even worse, the text cursor disappears
                // when tabbing between text inputs, here's a fix
                input.focus(function() {
                    if(this.value == "") {
                        var range = this.createTextRange();
                        range.collapse(true);
                        range.moveStart('character', 0);
                        range.select();
                    }
                });
            }
        });
    }
})(mrm.$);/**
          @@@@@@@@@@@@@@
      @@@@@@@@@@@@@@@@@@@@@@
    @@@@@@@@          @@@@@@@@
  @@@@@@@                @@@@@@@
 @@@@@@@                  @@@@@@@
 @@@@@@@                  @@@@@@@
 @@@@@@@@     @          @@@@@@@@
  @@@@@@@@@  @@@       @@@@@@@@@
   @@@@@@@@@@@@@@   @@@@@@@@@@@
     @@@@@@@@@@@@@    @@@@@@@
       @@@@@@@@@@@@     @@@
          @@@@@@
         @@@@
        @@
 *
 * jQuery Reel
 * ===========
 * The 360 plugin for jQuery
 *
 * @license Copyright (c) 2009-2012 Petr Vostrel (http://petr.vostrel.cz/)
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 *
 * jQuery Reel
 * http://jquery.vostrel.cz/reel
 * Version: 1.2
 * Updated: 2012-07-15
 *
 * Requires jQuery 1.5 or higher
 */

/*
 * CDN
 * ---
 * - http://code.vostrel.cz/jquery.reel-bundle.js (recommended)
 * - http://code.vostrel.cz/jquery.reel.js
 * - http://code.vostrel.cz/jquery.reel-debug.js
 * - or http://code.vostrel.cz/jquery.reel-edge.js if you feel like it ;)
 *
 * Optional Plugins
 * ----------------
 * - jQuery.disableTextSelect [B] (James Dempster, http://www.jdempster.com/category/jquery/disabletextselect/)
 * - jQuery.mouseWheel [B] (Brandon Aaron, http://plugins.jquery.com/project/mousewheel)
 * - or jQuery.event.special.wheel (Three Dub Media, http://blog.threedubmedia.com/2008/08/eventspecialwheel.html)
 *
 * [B] Marked plugins are contained (with permissions) in the "bundle" version from the CDN
 */

mrm.$.reel || (function($, window, document, undefined){

  // One vital requirement is the correct jQuery. Reel requires at least version 1.5
  // and a make sure check is made at the very beginning.
  if (+$().jquery.replace(dot(), __).substr(0, 2) < 15)
    throw 'Too old jQuery for Reel.'

  // `$.reel` (or `jQuery.reel`) namespace is provided for storage of all Reel belongings.
  // It is locally referenced as just `reel` for speedier access.
  var
    reel= $.reel= {

      // ### `$.reel.version`
      //
      // `String` (major.minor.patch), since 1.1
      version: '1.2',

      // Options
      // -------
      //
      // When calling `.reel()` method you have plenty of options (far too many) available.
      // You collect them into one hash and supply them with your call.
      //
      // ___Example:__ For a non-looping Reel with 12 frames:_
      //
      //     .reel({
      //       frames: 12,
      //       looping: false
      //     })
      //
      //
      // All options are optional and if omitted, default value is used instead.
      // Defaults are being housed as members of `$.reel.def` hash.
      // If you customize any default value therein, all subsequent `.reel()` calls
      // will use the new value as default.
      //
      // ___Example:__ Change default initial frame to 5th:_
      //
      //     $.reel.def.frame = 5
      //

      // ### `$.reel.def` ######
      // `Object`, since 1.1
      //
      def: {
        // ---
        // ### Basic Definition ######
        //
        // Reel is just fine with you not setting any options, however if you don't have
        // 36 frames or beginning at frame 1, you will want to set total number
        // of `frames` and pick a different starting `frame`.
        //

        // #### `frame` Option ####
        // `Number` (frames), since 1.0
        //
        frame:                  1,

        // #### `frames` Option ####
        // `Number` (frames), since 1.0
        //
        frames:                36,

        // ~~~
        //
        // Another common characteristics of any Reel is whether it `loops` and covers
        // entire 360 or not.
        //

        // #### `loops` Option ####
        // `Boolean`, since 1.0
        //
        loops:               true,


        // ---
        // ### Interaction ######
        //
        // Using boolean switches many user interaction aspects can be turned on and off.
        // You can disable the mouse wheel control with `wheelable`, the drag & throw
        // action with `throwable`, disallow the dragging completely with `draggable`,
        // on "touchy" devices you can disable the browser's decision to scroll the page
        // instead of Reel script and you can of course disable the stepping of Reel by
        // clicking on either half of the image with `steppable`.
        //
        // You can even enable `clickfree` operation,
        // which will cause Reel to bind to mouse enter/leave events instead of mouse down/up,
        // thus allowing a click-free dragging.
        //

        // #### `clickfree` Option ####
        // `Boolean`, since 1.1
        //
        clickfree:          false,

        // #### `draggable` Option ####
        // `Boolean`, since 1.1
        //
        draggable:           true,

        // #### `scrollable` Option ####
        // [NEW] `Boolean`, since 1.2
        //
        scrollable:          true,

        // #### `steppable` Option ####
        // [NEW] `Boolean`, since 1.2
        //
        steppable:           true,

        // #### `throwable` Option ####
        // `Boolean`, since 1.1
        //
        throwable:           true,

        // #### `wheelable` Option ####
        // `Boolean`, since 1.1
        //
        wheelable:           true,


        // ---
        // ### Order of Images ######
        //
        // Reel presumes counter-clockwise order of the pictures taken. If the neerer facing
        // side doesn't follow your cursor/finger, you did clockwise. Use the `cw` option to
        // correct this.
        //

        // #### `cw` Option ####
        // `Boolean`, since 1.1
        //
        cw:                 false,


        // ---
        // ### Sensitivity ######
        //
        // In Reel sensitivity is set through the `revolution` parameter, which represents horizontal
        // dragging distance one must cover to perform one full revolution. By default this value
        // is calculated based on the setup you have - it is either twice the width of the image
        // or half the width of stitched panorama. You may also set your own.
        //
        // Optionally `revolution` can be set as an Object with `x` member for horizontal revolution
        // and/or `y` member for vertical revolution in multi-row movies.
        //

        // #### `revolution` Option ####
        // `Number` (pixels) or `Object`, since 1.1, `Object` support since 1.2
        //
        revolution:     undefined,


        // ---
        // ### Rectilinear Panorama ######
        //
        // The easiest of all is the stitched panorama mode. For this mode, instead of the sprite,
        // a single seamlessly stitched stretched image is used and the view scrolls the image.
        // This mode is triggered by setting a pixel width of the `stitched` image.
        //

        // #### `stitched` Option ####
        // `Number` (pixels), since 1.0
        //
        stitched:               0,


        // ---
        // ### Directional Mode ######
        //
        // As you may have noticed on Reel's homepage or in [this example][logo]
        // when you drag the arrow will point to either direction. In such `directional` mode, the sprite
        // is actually 2 in 1 - one file contains two sprites one tightly following the other, one
        // for visually going one way (`A`) and one for the other (`B`).
        //
        //     A01 A02 A03 A04 A05 A06
        //     A07 A08 A09 A10 A11 A12
        //     A13 A14 A15 B01 B02 B03
        //     B04 B05 B06 B07 B08 B09
        //     B10 B11 B12 B13 B14 B15
        //
        // Switching between `A` and `B` frames is based on direction of the drag. Directional mode isn't
        // limited to sprites only, sequences also apply. The figure below shows the very same setup like
        // the above figure, only translated into actual frames of the sequence.
        //
        //     001 002 003 004 005 006
        //     007 008 009 010 011 012
        //     013 014 015 016 017 018
        //     019 020 021 022 023 024
        //     025 026 027 028 029 030
        //
        // Frame `016` represents the `B01` so it actually is first frame of the other direction.
        //

        // #### `directional` Option ####
        // `Boolean`, since 1.1
        //
        directional:        false,


        // ---
        // ### Multi-Row Mode ######
        //
        // As `example/object-movie-multirow-sequence` very nicely demonstrates, in multi-row arrangement you
        // can perform two-axis manipulation allowing you to add one or more vertical angles. Think of it as
        // a layered cake, each new elevation of the camera during shooting creates one layer of the cake -
        // - a _row_. One plain horizontal object movie full spin is one row:
        //
        //     A01 A02 A03 A04 A05 A06
        //     A07 A08 A09 A10 A11 A12
        //     A13 A14 A15
        //
        // Second row tightly follows after the first one:
        //
        //     A01 A02 A03 A04 A05 A06
        //     A07 A08 A09 A10 A11 A12
        //     A13 A14 A15 B01 B02 B03
        //     B04 B05 B06 B07 B08 B09
        //     B10 B11 B12 B13 B14 B15
        //     C01...
        //
        // This way you stack up any number of __`rows`__ you wish and set the initial `row` to start with.
        // Again, not limited to sprites, sequences also apply.
        //

        // #### `row` Option ####
        // `Number` (rows), since 1.1
        //
        row:                    1,

        // #### `rows` Option ####
        // `Number` (rows), since 1.1
        //
        rows:                   0,


        // ---
        // ### Dual-Orbit Mode ######
        //
        // Special form of multi-axis movie is the dual-axis mode. In this mode the object offers two plain
        // spins - horizontal and vertical orbits combined together crossing each other at the `frame`
        // forming sort of a cross if envisioned. [This example][phone] demonstrate this setup. When the
        // phone in the example is facing you (marked in the example with green square in the top right),
        // you are at the center. That is within the distance (in frames) defined by the `orbital` option.
        // Translation from horizontal to vertical orbit can be achieved on this sweet-spot. By default
        // horizontal orbit is chosen first, unless `vertical` option is used against.
        //
        // In case the image doesn't follow the vertical drag, you may have your vertical orbit `inversed`.
        //
        // Technically it is just a two-layer movie:
        //
        //     A01 A02 A03 A04 A05 A06
        //     A07 A08 A09 A10 A11 A12
        //     A13 A14 A15 B01 B02 B03
        //     B04 B05 B06 B07 B08 B09
        //     B10 B11 B12 B13 B14 B15
        //

        // #### `orbital` Option ####
        // `Number` (frames), since 1.1
        //
        orbital:                0,

        // #### `vertical` Option ####
        // `Boolean`, since 1.1
        //
        vertical:           false,

        // #### `inversed` Option ####
        // `Boolean`, since 1.1
        //
        inversed:           false,


        // ---
        // ### Sprite Layout ######
        //
        // For both object movies and panoramas Reel presumes you use a combined _Sprite_ to hold all your
        // frames in a single file. This powerful technique of using a sheet of several individual images
        // has many advantages in terms of compactness, loading, caching, etc. However, know your enemy,
        // be also aware of the limitations, which stem from memory limits of mobile
        // (learn more in [FAQ](https://github.com/pisi/Reel/wiki/FAQ)).
        //
        // Inside the sprite, individual frames are laid down one by one, to the right of the previous one
        // in a straight _Line_:
        //
        //     01 02 03 04 05 06
        //     07...
        //
        // Horizontal length of the line is reffered to as `footage`. Unless frames `spacing` in pixels
        // is set, edges of frames must touch.
        //
        //     01 02 03 04 05 06
        //     07 08 09 10 11 12
        //     13 14 15 16 17 18
        //     19 20 21 22 23 24
        //     25 26 27 28 29 30
        //     31 32 33 34 35 36
        //
        // This is what you'll get by calling `.reel()` without any options. All frames laid out 6 in line.
        // By default nicely even 6 x 6 grid like, which also inherits the aspect ratio of your frames.
        //
        // By setting `horizontal` to `false`, instead of forming lines, frames are expected to form
        // _Columns_. All starts at the top left corner in both cases.
        //
        //     01 07 13 19 25 31
        //     02 08 14 20 26 32
        //     03 09 15 21 27 33
        //     04 10 16 22 28 34
        //     05 11 17 23 29 35
        //     06 12 18 24 30 36
        //
        // URL for the sprite image file is being build from the name of the original `<img>` `src` image
        // by adding a `suffix` to it. By default this results in `"object-reel.jpg"` for `"object.jpg"`.
        // You can also take full control over the sprite `image` URL that will be used.
        //

        // #### `footage` Option ####
        // `Number` (frames), since 1.0
        //
        footage:                6,

        // #### `spacing` Option ####
        // `Number` (pixels), since 1.0
        //
        spacing:                0,

        // #### `horizontal` Option ####
        // `Boolean`, since 1.0
        //
        horizontal:          true,

        // #### `suffix` Option ####
        // `String`, since 1.0
        //
        suffix:           '-reel',

        // #### `image` Option ####
        // `String`, since 1.1
        //
        image:          undefined,


        // ---
        // ### Sequence ######
        //
        // Collection of individual frame images is called _Sequence_ and it this way one HTTP request per
        // frame is made carried out as opposed to sprite with one request per entire sprite. Define it with
        // string like: `"image_###.jpg"`. The `#` placeholders will be replaced with a numeric +1 counter
        // padded to the placeholders length.
        // Learn more about [sequences](Sequences).
        //
        // In case you work with hashed filenames like `64bc654d21cb.jpg`, where no counter element can
        // be indentified, or you prefer direct control, `images` can also accept array of plain URL strings.
        //
        // All images are retrieved from a specified `path`.
        //

        // #### `images` Option ####
        // [IMPROVED] `String` or `Array`, since 1.1
        //
        images:                '',

        // #### `path` Option ####
        // `String` (URL path), since 1.1
        //
        path:                  '',


        // ---
        // ### Images Preload Order ######
        //
        // Given sequence images can be additionally reordered to achieve a perceived faster preloading.
        // Value given to `preload` option must match a name of a pre-registered function within
        // `$.reel.preload` object. There are two functions built-in:
        //
        // - `"fidelity"` - non-linear way that ensures even spreading of preloaded images around the entire
        //   revolution leaving the gaps in-between as small as possible. This results in a gradually
        //   increasing fidelity of the image rather than having one large shrinking gap. This is the default
        //   behavior.
        // - `"linear"` - linear order of preloading
        //

        // #### `preload` Option ####
        // [NEW] `String`, since 1.2
        //
        preload:       'fidelity',


        // ---
        // ### Animation ######
        //
        // Your object movie or a panorama can perform an autonomous sustained motion in one direction.
        // When `speed` is set in revolutions per second (Hz), after a given `delay` the instance will
        // animate and advance frames by itself.
        //
        //     t
        //     |-------|-----------
        //       Delay    Animation
        //
        // Start and resume of animation happens when given `timeout` has elapsed since user became idle.
        //
        //     t
        //     |-----------|= == ==  = === = = |          |-----------
        //       Animation    User interaction    Timeout    Animation
        //
        // When a scene doesn't loop (see `loops`) and the animation reaches one end, it stays there
        // for a while and then reversing the direction of the animation it bounces back towards the other
        // end. The time spent on the edge can be customized with `rebound`.
        //

        // #### `speed` Option ####
        // `Number` (Hz), since 1.1
        //
        speed:                  0,

        // #### `delay` Option ####
        // `Number` (seconds), since 1.1
        //
        delay:                  0,

        // #### `timeout` Option ####
        // `Number` (seconds), since 1.1
        //
        timeout:                2,

        // #### `rebound` Option ####
        // `Number` (seconds), since 1.1
        //
        rebound:              0.5,


        // ---
        // ### Opening Animation ######
        //
        // Chance is you want the object to spin a little to attract attention and then stop and wait
        // for the user to engage. This is called "opening animation" and it is performed for given number
        // of seconds (`opening`) at dedicated `entry` speed. The `entry` speed defaults to value of `speed`
        // option. After the opening animation has passed, regular animation procedure begins starting with
        // the delay (if any).
        //
        //     t
        //     |--------|-------|-----------
        //       Opening   Delay    Animation
        //

        // #### `entry` Option ####
        // `Number` (Hz), since 1.1
        //
        entry:          undefined,

        // #### `opening` Option ####
        // `Number` (seconds), since 1.1
        //
        opening:                0,


        // ---
        // ### Momentum ######
        //
        // Often also called inertial motion is a result of measuring a velocity of dragging. This velocity
        // builds up momentum, so when a drag is released, the image still retains the momentum and continues
        // to spin on itself. Naturally the momentum soon wears off as `brake` is being applied.
        //
        // One can utilize this momentum for a different kind of an opening animation. By setting initial
        // `velocity`, the instance gets artificial momentum and spins to slow down to stop.
        //

        // #### `brake` Option ####
        // `Number`, since 1.1, where it also has a different default `0.5`
        //
        brake:               0.23,

        // #### `velocity` Option ####
        // [NEW] `Number`, since 1.2
        //
        velocity:               0,


        // ---
        // ### Ticker ######
        //
        // For purposes of animation, Reel starts and maintains a timer device which emits ticks timing all
        // animations. There is only one ticker running in the document and all instances subscribe to this
        // one ticker. Ticker is equipped with a mechanism, which compensates for the  measured costs
        // of running Reels to ensure the ticker ticks on time. The `tempo` (in Hz) of the ticker can be
        // specified.
        //
        // Please note, that ticker is synchronized with a _leader_, the oldest living instance on page,
        // and adjusts to his tempo.
        //

        // #### `tempo` Option ####
        // `Number` (Hz, ticks per second), since 1.1
        //
        tempo:                 36,

        // ~~~
        //
        // Since many mobile devices are sometimes considerably underpowered in comparison with desktops,
        // they often can keep up with the 36 Hz rhythm. In Reel these are called __lazy devices__
        // and everything mobile qualifies as lazy for the sake of the battery and interaction fluency.
        // The ticker is under-clocked for them by a `laziness` factor, which is used to divide the `tempo`.
        // Default `laziness` of `6` will effectively use 6 Hz instead (6 = 36 / 6) on lazy devices.
        //

        // #### `laziness` Option ####
        // `Number`, since 1.1
        //
        laziness:               6,


        // ---
        // ### Customization ######
        //
        // You can customize Reel on both functional and visual front. The most visible thing you can
        // customize is probably the `cursor`, size of the `preloader`, perhaps add visual `indicator`(s)
        // of Reel's position within the range. You can also set custom `hint` for the tooltip, which appears
        // when you mouse over the image area. Last but not least you can also add custom class name `klass`
        // to the instance.
        //

        // #### `cursor` Option ####
        // [NEW] `String`, since 1.2
        cursor:         undefined,

        // #### `hint` Option ####
        // `String`, since 1.0
        hint:                  '',

        // #### `indicator` Option ####
        // `Number` (pixels), since 1.0
        indicator:              0,

        // #### `klass` Option ####
        // `String`, since 1.0
        klass:                 '',

        // #### `preloader` Option ####
        // `Number` (pixels), since 1.1
        preloader:              2,

        // ~~~
        //
        // You can use custom attributes (`attr`) on the node - it accepts the same name-value pairs object
        // jQuery `.attr()` does. In case you want to delegate full interaction control over the instance
        // to some other DOM element(s) on page, you can with `area`.
        //

        // #### `area` Option ####
        // `jQuery`, since 1.1
        area:           undefined,

        // #### `attr` Option ####
        // [NEW] `Object`, since 1.2
        attr:                  {},


        // ---
        // ### Annotations ######
        //
        // To further visually describe your scene you can place all kinds of in-picture HTML annotations
        // by defining an `annotations` object. Learn more about [Annotations][1] in a dedicated article.
        //
        // [1]:https://github.com/pisi/Reel/wiki/Annotations
        //

        // #### `annotations` Option ####
        // [NEW] `Object`, since 1.2
        annotations:    undefined,


        // ---
        // ### Mathematics ######
        //
        // When reeling, instance conforms to a graph function, which defines whether it will loop
        // (`$.reel.math.hatch`) or it won't (`$.reel.math.envelope`). My math is far from flawless
        // and I'm sure there are much better ways how to handle things. the `graph` option is there for you
        // shall you need it. It accepts a function, which should process given criteria and return
        // a fraction of 1.
        //
        //     function( x, start, revolution, lo, hi, cwness, y ){
        //       return fraction  // 0.0 - 1.0
        //     }
        //

        // #### `graph` Option ####
        // `Function`, since 1.1
        graph:          undefined,


        // ---
        // ### Monitor ######
        //
        // Specify a string data key and you will see its real-time value dumped in the upper-left corner
        // of the viewport. Its visual can be customized by CSS using `.jquery-reel-monitor` selector.
        //

        // #### `monitor` Option ####
        // `String` (data key), since 1.1
        monitor:        undefined,


        // ---
        // ### Deprecated Options ######
        //
        // Two options are currently deprecated in version 1.2. Learn more about [Deprecations][1]
        //
        // [1]:https://github.com/pisi/Reel/wiki/Deprecations
        //

        // #### `step` Option ####
        // `Number`, since 1.1
        step:           undefined, // use `frame` instead

        // #### `steps` Option ####
        // `Number`, since 1.1
        steps:          undefined // use `frames` instead

      },

      // -------
      // Methods
      // -------
      //
      // Reel's methods extend jQuery core functions with members of its `$.reel.fn` object. Despite Reel
      // being a typical one-method plug-in with its `.reel()` function, for convenience it also offers
      // its dipolar twin `.unreel()`.
      //

      // ### `$.reel.fn` ######
      // returns `Object`, since 1.1
      fn: {
        // ------------
        // Construction
        // ------------
        //
        // `.reel()` method is the core of Reel and similar to some jQuery functions, this one is three-fold.
        // It either performs the following builder's duty or the [data duty](#Data).
        //

        // ### `.reel()` Method ######
        // returns `jQuery`, since 1.0
        //
        reel: function(){
          // The decision on what to actually do is made upon given arguments.
          var
            args= arguments,
            t= $(this),
            data= t.data(),
            name= args[0] || {},
            value= args[1]

          if (typeof name == 'object'){
          var
            // Establish local `opt` object made by extending the defaults.
            opt= $.extend({}, reel.def, name),
            // Limit the given jQuery collection to `<img>` tags.
            applicable= (function(tags){
              var
                pass= []
              tags.filter(_img_).each(function(ix){
                // Verify they have a workable set of properties. They need to have at least:
                //
                // - non-empty `src` attribute defined
                // - non-zero `width` and `height` attributes defined
                var
                  $this= $(this),
                  src= opt.images.length && opt.images || opt.sequence || opt.image || opt.attr.src || $this.attr('src'),
                  width= number(opt.attr.width || $this.css(_width_)),
                  height= number(opt.attr.height || $this.css(_height_))
                if (src && src != __ && width && height) pass.push($this);
              });
              // If a Reel instance already, tear it down first.
              tags.filter(dot(klass)).each(function(ix){
                pass.push($(this).unreel());
              });
              return $(pass);
            })(this),
            instances= []

          // Backward-compatibility of [deprecated] legacy options
          opt.step && (opt.frame= opt.step);
          opt.steps && (opt.frames= opt.steps);

          applicable.each(function(){
            var
              t= $(this),

              // Quick data interface
              set= function(name, value){ return t.reel(name, value) && value },
              get= function(name){ return t.reel(name) },

              on= {

                // --------------
                // Initialization
                // --------------
                //
                // This internally called private pseudo-handler:
                //
                // - initiates all data store keys
                // - binds to ticker
                // - triggers `"setup` Event when finished
                //
                setup: function(e){
                  if (t.hasClass(klass)) return;
                  set(_options_, opt);
                  var
                    src= t.attr(opt.attr).attr('src'),
                    id= set(_id_, t.attr(_id_) || t.attr(_id_, klass+'-'+(+new Date())).attr(_id_)),
                    styles= t.attr(_style_),
                    data= $.extend({}, t.data()),
                    sequence= reel.re.sequence.exec(opt.images),
                    images= set(_images_, sequence ? reel.sequence(sequence, opt, get) : opt.images || []),
                    stitched= opt.stitched,
                    loops= opt.loops,
                    size= { x: number(t.css(_width_) || opt.attr.width), y: number(t.css(_height_) || opt.attr.height) },
                    frames= set(_frames_, opt.orbital && opt.footage || opt.rows <= 1 && images.length || opt.frames),
                    multirow= opt.rows > 1 || opt.orbital,
                    revolution= opt.revolution,
                    revolution_x= set(_revolution_, axis('x', revolution) || stitched / 2 || size.x * 2),
                    revolution_y= set(_revolution_y_, !multirow ? 0 : (axis('y', revolution) || (opt.rows > 3 ? size.y : size.y / (5 - opt.rows)))),
                    rows= stitched ? 1 : ceil(frames / opt.footage),
                    stage_id= hash(id+opt.suffix),
                    classes= t[0].className || __,
                    $overlay= $(tag(_div_), { id: stage_id.substr(1), 'class': classes+___+overlay_klass+___+frame_klass+'0' }),
                    $instance= t.wrap($overlay.addClass(opt.klass)).attr({ 'class': klass }),
                    instances_count= instances.push(add_instance($instance)[0]),
                    $overlay= $instance.parent().bind(on.instance)
                  set(_image_, images.length ? __ : opt.image || src.replace(reel.re.image, '$1' + opt.suffix + '.$2'));
                  set(_cached_, []);
                  set(_spacing_, opt.spacing);
                  set(_rows_, rows);
                  set(_dimensions_, size);
                  set(_bit_, 1 / (frames - (loops && !stitched ? 0 : 1)));
                  set(_stitched_, stitched);
                  set(_stitched_travel_, stitched - (loops ? 0 : size.x));
                  set(_stitched_shift_, 0);
                  set(_stage_, stage_id);
                  set(_backwards_, set(_speed_, opt.speed) < 0);
                  set(_velocity_, opt.velocity || 0);
                  set(_vertical_, opt.vertical);
                  set(_preloaded_, 0);
                  set(_cwish_, negative_when(1, !opt.cw && !stitched));
                  set(_clicked_location_, {});
                  set(_clicked_, false);
                  set(_clicked_on_, set(_clicked_tier_, 0));
                  set(_lo_, set(_hi_, 0));
                  set(_reeling_, false);
                  set(_opening_, false);
                  set(_brake_, opt.brake);
                  set(_center_, !!opt.orbital);
                  set(_tempo_, opt.tempo / (reel.lazy? opt.laziness : 1));
                  set(_opening_ticks_, -1);
                  set(_annotations_, opt.annotations || $overlay.unbind(dot(_annotations_)) && {});
                  set(_backup_, {
                    src: src,
                    classes: classes,
                    style: styles || __,
                    data: data
                  });
                  opt.steppable || $overlay.unbind('up.steppable');
                  opt.indicator || $overlay.unbind('.indicator');
                  css(__, { width: size.x, height: size.y, overflow: _hidden_, position: 'relative' });
                  css(____+___+dot(klass), { display: _block_ });
                  pool.bind(on.pool);
                  t.trigger('setup');
                },

                // ---------------------
                // Initialization Events
                // ---------------------
                //
                // Reel is completely event-driven meaning there are many events, which can be called
                // (triggered). By binding event handler to any of the events you can easily hook on to any
                // event to inject your custom behavior where and when this event was triggered.
                // _For example to make `#image` element reel and execute some code right after the newly
                // created instance is initialized and completely loaded:_
                //
                //     $("#image")
                //     .reel()
                //     .bind("loaded", function(ev){
                //       // Your code
                //     })
                //

                // Events bound to all individual instances.
                //
                instance: {

                  // ### `teardown` Event ######
                  // `Event`, since 1.1
                  //
                  // This event does do how it sounds like. It will teardown an instance with all its
                  // belongings leaving no trace.
                  //
                  // - It reconstructs the original `<img>` element,
                  // - wipes out the data store,
                  // - removes instance stylesheet
                  // - and unbinds all its events.
                  //
                  teardown: function(e){
                    var
                      backup= t.data(_backup_)
                    t.parent().unbind(on.instance);
                    get(_style_).remove();
                    get(_area_).unbind(ns).enableTextSelect();
                    remove_instance(t.unbind(ns).removeData().siblings().unbind(ns).remove().end().attr({
                     'class': backup.classes,
                      src: backup.src,
                      style: backup.style
                    }).data(backup.data).unwrap());
                    no_bias();
                    pool.unbind(on.pool);
                    pools.unbind(pns);
                  },

                  // ### `setup` Event ######
                  // `Event`, since 1.0
                  //
                  // `"setup` Event continues with what has been started by the private `on.setup()`
                  // handler.
                  //
                  // - It prepares all additional on-stage DOM elements,
                  // - and cursors for the instance stylesheet.
                  //
                  setup: function(e){
                    var
                      space= get(_dimensions_),
                      frames= get(_frames_),
                      id= t.attr(_id_),
                      $overlay= t.parent()
                      area= set(_area_, $(opt.area || $overlay ))
                    if (touchy){
                      // workaround for downsizing-sprites-bug-in-iPhoneOS inspired by Katrin Ackermann
                      css(___+dot(klass), { WebkitUserSelect: _none_, WebkitBackgroundSize: get(_images_).length
                        ? undefined : get(_stitched_) && px(get(_stitched_))+___+px(space.y)
                        || px(space.x * opt.footage)+___+px(space.y * get(_rows_) * (opt.rows || 1) * (opt.directional? 2:1))
                      });
                      area
                        .bind(_touchstart_, press())
                    }else{
                      var
                        cursor= opt.cursor == _hand_ ? drag_cursor : opt.cursor || reel_cursor,
                        cursor_down= opt.cursor == _hand_ ? drag_cursor_down+___+'!important' : undefined
                      css(__, { cursor: cdn(cursor) });
                      css(dot(loading_klass), { cursor: 'wait' });
                      css(dot(panning_klass)+____+dot(panning_klass)+' *', { cursor: cdn(cursor_down || cursor) }, true);
                      area
                        .bind(opt.wheelable ? _mousewheel_ : __, function(e, delta){ return e.preventDefault() || !delta || t.trigger('wheel', [delta]) && false })
                        .bind(opt.clickfree ? _mouseenter_ : _mousedown_, press())
                        .disableTextSelect();
                    }
                    function press(r){ return function(e){ if (e.button == DRAG_BUTTON) return e.preventDefault() || t.trigger('down', [finger(e).clientX, finger(e).clientY]) && r }}
                    opt.hint && area.attr('title', opt.hint);
                    opt.indicator && $overlay.append(indicator('x'));
                    opt.rows > 1 && opt.indicator && $overlay.append(indicator('y'));
                    opt.monitor && $overlay.append($monitor= $(tag(_div_), { 'class': monitor_klass }))
                                && css(___+dot(monitor_klass), { position: _absolute_, left: 0, top: 0 });
                    css(___+dot(cached_klass), { display: _none_ });
                  },

                  // ### `preload` Event ######
                  // `Event`, since 1.1
                  //
                  // Reel keeps a cache of all images it needs for its operation. Either a sprite or all
                  // sequence images. Physically, this cache is made up of a hidden `<img>` sibling for each
                  // preloaded image. It first determines the order of requesting the images and then
                  // asynchronously loads all of them.
                  //
                  preload: function(e){
                  /*
                  - preloads all frames and sprites
                  */
                    var
                      space= get(_dimensions_),
                      $overlay= t.parent(),
                      images= get(_images_),
                      is_sprite= !images.length,
                      frames= get(_frames_),
                      order= reel.preload[opt.preload] || reel.preload[reel.def.preload],
                      preload= is_sprite ? [get(_image_)] : order(images.slice(0), opt, get),
                      to_load= preload.length,
                      preloaded= set(_preloaded_, is_sprite ? 0.5 : 0),
                      uris= []
                    $overlay.addClass(loading_klass).append(preloader());
                    // It also finalizes the instance stylesheet and prepends it to the head.
                    set(_style_, $('<'+_style_+' type="text/css">'+css.rules.join('\n')+'</'+_style_+'>').prependTo(_head_));
                    t.trigger('stop');
                    while(preload.length){
                      var
                        uri= opt.path+preload.shift(),
                        width= space.x * (!is_sprite ? 1 : opt.footage),
                        height= space.y * (!is_sprite ? 1 : frames / opt.footage) * (!opt.directional ? 1 : 2),
                        $img= $(tag(_img_)).attr({ 'class': cached_klass, width: width, height: height }).appendTo($overlay)
                      // Each image, which finishes the load triggers `"preloaded` Event.
                      $img.bind('load error abort', function(){
                        return !!$(this).parent().length && t.trigger('preloaded') && false;
                      });
                      load(uri, $img);
                      uris.push(uri);
                    }
                    set(_cached_, uris);
                    function load(uri, $img){ setTimeout(function(){
                      $img.parent().length && $img.attr({ src: reen(uri) });
                    }, (to_load - preload.length) * 2) }
                  },

                  // ### `preloaded` Event ######
                  // `Event`, since 1.1
                  //
                  // This event is fired by every preloaded image and adjusts the preloader indicator's
                  // target position. Once all images are preloaded, `"loaded` Event is triggered.
                  //
                  preloaded: function(e){
                    var
                      images= get(_images_).length || 1,
                      preloaded= set(_preloaded_, min(get(_preloaded_) + 1, images))
                    if (preloaded === images){
                      t.parent().removeClass(loading_klass).unbind(_preloaded_, on.instance.preloaded);
                      t.trigger('loaded');
                    }
                    if (preloaded === 1) var
                      frame= t.trigger('frameChange', [undefined, get(_frame_)])
                  },

                  // ### `loaded` Event ######
                  // `Event`, since 1.1
                  //
                  // `"loaded` Event is the one announcing when the instance is "locked and loaded".
                  // At this time, all is prepared, preloaded and configured for user interaction
                  // or animation.
                  //
                  loaded: function(e){
                    get(_images_).length > 1 || t.css({ backgroundImage: url(opt.path+get(_image_)) }).attr({ src: cdn(transparent) });
                  },

                  // ----------------
                  // Animation Events
                  // ----------------

                  // ### `opening` Event ######
                  // `Event`, since 1.1
                  //
                  // When [opening animation](#Opening-Animation) is configured for the instance, `"opening"`
                  // event engages the animation by pre-calculating some of its properties, which will make
                  // the tick handler
                  //
                  opening: function(e){
                  /*
                  - initiates opening animation
                  - or simply plays the reel when without opening
                  */
                    if (!opt.opening) return t.trigger('openingDone');
                    var
                      opening= set(_opening_, true),
                      stopped= set(_stopped_, !get(_speed_)),
                      speed= opt.entry || opt.speed,
                      end= get(_fraction_),
                      duration= opt.opening,
                      start= set(_fraction_, end - speed * opt.opening),
                      ticks= set(_opening_ticks_, ceil(duration * leader(_tempo_)))
                  },

                  // ### `openingDone` Event ######
                  // `Event`, since 1.1
                  //
                  // `"openingDone"` is fired onceWhen [opening animation](#Opening-Animation) is configured for the instance, `"opening"`
                  // event engages the animation by pre-calculating some of its properties, which will make
                  // the tick handler
                  //
                  openingDone: function(e){
                    var
                      playing= set(_playing_, false),
                      opening= set(_opening_, false),
                      evnt= _tick_+dot(_opening_)
                    pool.unbind(evnt, on.pool[evnt]);
                    if (opt.delay > 0) delay= setTimeout(function(){ t.trigger('play') }, opt.delay * 1000)
                    else t.trigger('play');
                  },

                  // -----------------------
                  // Playback Control Events
                  // -----------------------

                  // ### `play` Event ######
                  // `Event`, since 1.1
                  //
                  // `"play` Event can optionally accept a `speed` parameter (in Hz) to change the animation
                  // speed on the fly.
                  //
                  play: function(e, speed){
                    var
                      speed= set(_speed_, speed || get(_speed_)),
                      backwards= set(_backwards_, speed < 0),
                      playing= set(_playing_, !!speed),
                      stopped= set(_stopped_, !playing)
                    idle();
                  },

                  // ### `pause` Event ######
                  // `Event`, since 1.1
                  pause: function(e){
                    var
                      playing= set(_playing_, false)
                    unidle();
                  },

                  // ### `stop` Event ######
                  // `Event`, since 1.1
                  stop: function(e){
                    var
                      stopped= set(_stopped_, true),
                      playing= set(_playing_, !stopped)
                  },

                  // ------------------------
                  // Human Interaction Events
                  // ------------------------

                  // ### `down` Event ######
                  // `Event`, since 1.1
                  //
                  // Marks the very beginning of touch or mouse interaction. It receives `x` and `y`
                  // coordinates in arguments. It:
                  //
                  // - calibrates the center point (origin),
                  // - considers user active not idle,
                  // - flags the `<html>` tag with `.reel-panning` class name,
                  // - and binds dragging events for move and lift. These
                  // are usually bound to the pool (document itself) to get a consistent treating regardless
                  // the event target element. However in click-free mode, it binds directly to the instance.
                  //
                  down: function(e, x, y){
                    if (opt.draggable){
                      var
                        clicked= set(_clicked_, get(_frame_)),
                        velocity= set(_velocity_, 0),
                        scrollable= !get(_reeling_) || opt.rows <= 1 || !opt.orbital || opt.scrollable,
                        origin= last= recenter_mouse(get(_revolution_), x, y)
                      unidle();
                      no_bias();
                      panned= false;
                      $(_html_, pools).addClass(panning_klass);
                      // Browser events differ for touch and mouse, but both of them are treated equally and
                      // forwarded to the same `"pan"` or `"up` Events.
                      if (touchy){
                        pools
                        .bind(_touchmove_, drag(!scrollable))
                        .bind(_touchend_+___+_touchcancel_, lift())
                      }else{
                        (opt.clickfree ? get(_area_) : pools)
                        .bind(_mousemove_, drag())
                        .bind(opt.clickfree ? _mouseleave_ : _mouseup_, lift())
                      }
                    }
                    function drag(r){ return function(e){ e.preventDefault(); t.trigger('pan', [finger(e).clientX, finger(e).clientY, e]); return r }}
                    function lift(r){ return function(e){ e.preventDefault(); t.trigger('up', [e]); return r }}
                  },

                  // ### `up` Event ######
                  // `Event`, since 1.1
                  //
                  // This marks the termination of user's interaction. She either released the mouse button
                  // or lift the finger of the touch screen. This event handler:
                  //
                  // - calculates the velocity of the drag at that very moment,
                  // - removes the `.reel-panning` class from `<body>`,
                  // - and unbinds dragging events from the pool.
                  //
                  up: function(e, ev){
                    if (!opt.draggable) return;
                    var
                      clicked= set(_clicked_, false),
                      reeling= set(_reeling_, false),
                      velocity= set(_velocity_, !opt.throwable ? 0 : abs(bias[0] + bias[1]) / 60),
                      brakes= braking= velocity ? 1 : 0
                    unidle();
                    no_bias();
                    $(_html_, pools).removeClass(panning_klass);
                    (opt.clickfree ? get(_area_) : pools).unbind(pns);
                  },

                  // ### `pan` Event ######
                  // [RENAMED] `Event`, since 1.2
                  //
                  // Regardles the actual source of movement (mouse or touch), this event is always triggered
                  // in response and similar to the `"down` Event it receives `x` and `y` coordinates
                  // in arguments and in addition it is passed a reference to the original browser event.
                  // This handler:
                  //
                  // - syncs with timer to achieve good performance,
                  // - calculates the distance from drag center and applies graph on it to get `fraction`,
                  // - recenters the drag when dragged over limits,
                  // - detects the direction of the motion,
                  // - and builds up inertial motion bias.
                  //
                  // Historically `pan` was once called `slide` (conflicted with Mootools - [GH-51][1])
                  // or `drag` (that conflicted with MSIE).
                  //
                  // [1]:https://github.com/pisi/Reel/issues/51
                  //
                  pan: function(e, x, y, ev){
                    if (opt.draggable && slidable){
                      slidable= false;
                      unidle();
                      var
                        host_offset= ev && !$(ev.currentTarget).is(pool) && $iframe.offset() || { left: 0, top: 0 },
                        x= x - host_offset.left,
                        y= y - host_offset.top,
                        delta= { x: x - last.x, y: y - last.y }
                      if (abs(delta.x) > 0 || abs(delta.y) > 0){
                        panned= true;
                        last= { x: x, y: y };
                        var
                          revolution= get(_revolution_),
                          origin= get(_clicked_location_),
                          vertical= get(_vertical_),
                          fraction= set(_fraction_, graph(vertical ? y - origin.y : x - origin.x, get(_clicked_on_), revolution, get(_lo_), get(_hi_), get(_cwish_), vertical ? y - origin.y : x - origin.x)),
                          reeling= set(_reeling_, get(_reeling_) || get(_frame_) != get(_clicked_)),
                          motion= to_bias(vertical ? delta.y : delta.x || 0),
                          backwards= motion && set(_backwards_, motion < 0)
                        if (opt.orbital && get(_center_)) var
                          vertical= set(_vertical_, abs(y - origin.y) > abs(x - origin.x)),
                          origin= recenter_mouse(revolution, x, y)
                        if (opt.rows > 1) var
                          space_y= get(_dimensions_).y,
                          revolution_y= get(_revolution_y_),
                          start= get(_clicked_tier_),
                          lo= - start * revolution_y,
                          tier= set(_tier_, reel.math.envelope(y - origin.y, start, revolution_y, lo, lo + revolution_y, -1))
                        if (!(fraction % 1) && !opt.loops) var
                          origin= recenter_mouse(revolution, x, y)
                      }
                    }
                  },

                  // ### `wheel` Event ######
                  // `Event`, since 1.0
                  //
                  // Maps Reel to mouse wheel position change event which is provided by a nifty plug-in
                  // written by Brandon Aaron - the [Mousewheel plug-in][1], which you will need to enable
                  // the mousewheel wheel for reeling. You can also choose to use [Wheel Special Event
                  // plug-in][2] by Three Dub Media instead. Either way `"wheel` Event handler receives
                  // the positive or negative wheeled distance in arguments. This event:
                  //
                  // - calculates wheel input delta and adjusts the `fraction` using the graph,
                  // - recenters the "drag" each and every time,
                  // - detects motion direction,
                  // - and nullifies the velocity.
                  //
                  // [1]:https://github.com/brandonaaron/jquery-mousewheel
                  // [2]:http://blog.threedubmedia.com/2008/08/eventspecialwheel.html
                  //
                  wheel: function(e, distance){
                    if (!distance) return;
                    wheeled= true;
                    var
                      delta= ceil(math.sqrt(abs(distance)) / 2),
                      delta= negative_when(delta, distance > 0),
                      revolution= 0.0833 * get(_revolution_), // Wheel's revolution is 1/12 of full revolution
                      origin= recenter_mouse(revolution),
                      backwards= delta && set(_backwards_, delta < 0),
                      velocity= set(_velocity_, 0),
                      fraction= set(_fraction_, graph(delta, get(_clicked_on_), revolution, get(_lo_), get(_hi_), get(_cwish_)))
                    unidle();
                    t.trigger('up')
                    return false;
                  },

                  // ------------------
                  // Data Change Events
                  // ------------------
                  //
                  // Besides Reel being event-driven, it also is data-driven respectively data-change-driven
                  // meaning that there is a mechanism in place, which detects real changes in data being
                  // stored with `.reel(name, value)`. Learn more about [data changes](#Changes).
                  //
                  // These data change bindings are for internal use only and you don't ever trigger them
                  // per se, you change data and that will trigger respective change event. If the value
                  // being stored is the same as the one already stored, nothing will be triggered.
                  // _For example to change Reel's `frame` you don't trigger `"frameChange"` and instead
                  // you do:
                  //
                  //     .reel("frame", 15)
                  //
                  // Change events always receive the actual data key value in the third argument.
                  // _For example this will log each viewed frame number into the developers console.
                  //
                  //     .bind("frameChange", function(e, d, frame){
                  //         console.log(frame)
                  //     })
                  //

                  // ### `fractionChange` Event ######
                  // `Event`, since 1.0
                  //
                  // Internally Reel doesn't really work with the frames you set it up with. It uses
                  // __fraction__, which is a numeric value ranging from 0.0 to 1.0. When `fraction` changes
                  // this handler basically calculates and sets new value of `frame`.
                  //
                  fractionChange: function(e, set_fraction, fraction){
                    if (set_fraction !== undefined) return deprecated(set(_fraction_, set_fraction));
                    var
                      frame= 1 + floor(fraction / get(_bit_)),
                      multirow= opt.rows > 1,
                      orbital= opt.orbital,
                      center= set(_center_, !!orbital && (frame <= orbital || frame >= opt.footage - orbital + 2))
                    if (multirow) var
                      frame= frame + (get(_row_) - 1) * get(_frames_)
                    var
                      frame= set(_frame_, frame)
                  },

                  // ### `tierChange` Event ######
                  // `Event`, since 1.2
                  //
                  // The situation of `tier` is very much similar to the one of `fraction`. In multi-row
                  // movies, __tier__ is an internal value for the vertical axis. Its value also ranges from
                  // 0.0 to 1.0. Handler calculates and sets new value of `frame`.
                  //
                  tierChange: function(e, deprecated_set, tier){
                    if (deprecated_set === undefined) var
                      row= set(_row_, round(interpolate(tier, 1, opt.rows))),
                      frames= get(_frames_),
                      frame= get(_frame_) % frames || frames,
                      frame= set(_frame_, frame + row * frames - frames)
                  },

                  // ### `rowChange` Event ######
                  // `Event`, since 1.1
                  //
                  // The physical vertical position of Reel is expressed in __rows__ and ranges
                  // from 1 to the total number of rows defined with [`rows`](#rows-Option). This handler
                  // only converts `row` value to `tier` and sets it.
                  //
                  rowChange: function(e, set_row, row){
                    if (set_row !== undefined) return set(_row_, set_row);
                    var
                      tier= set(_tier_, 1 / (opt.rows - 1) * (row - 1))
                  },

                  // ### `frameChange` Event ######
                  // `Event`, since 1.0
                  //
                  // The physical horizontal position of Reel is expressed in __frames__ and ranges
                  // from 1 to the total number of frames configured with [`frames`](#frames-Option).
                  // This handler converts `row` value to `tier` and sets it. This default handler:
                  //
                  // - flags the instance's outter wrapper with `.frame-X` class name
                  //   (where `X` is the actual frame number),
                  // - calculates and eventually sets `fraction` (and `tier` for multi-rows) from given frame,
                  // - for sequences, it switches the `<img>`'s `src` to the right frame,
                  // - for sprites it recalculates sprite's 'background position shift and applies it.
                  //
                  frameChange: function(e, set_frame, frame){
                    if (set_frame !== undefined) return deprecated(set(_frame_, set_frame));
                    this.className= this.className.replace(reel.re.frame_klass, frame_klass + frame);
                    var
                      frames= get(_frames_),
                      base= frame % frames || frames,
                      ready= !!get(_preloaded_),
                      frame_row= (frame - base) / frames + 1,
                      frame_tier= (frame_row - 1) / (opt.rows - 1),
                      tier_row= round(interpolate(frame_tier, 1, opt.rows)),
                      tier= ready && tier_row === get(_row_) ? get(_tier_) : set(_tier_, frame_tier),
                      frame_fraction= min((base - 1) / (frames - 1), 0.9999),
                      row_shift= get(_row_) * frames - frames,
                      fraction_frame= round(interpolate(frame_fraction, row_shift + 1, row_shift + frames)),
                      same_spot= abs((get(_fraction_) || 0) - frame_fraction) < 1 / (get(_frames_) - 1),
                      fraction= ready && (fraction_frame === frame && same_spot) ? get(_fraction_) : set(_fraction_, frame_fraction),
                      footage= opt.footage
                    if (opt.orbital && get(_vertical_)) var
                      frame= opt.inversed ? footage + 1 - frame : frame,
                      frame= frame + footage
                    var
                      horizontal= opt.horizontal,
                      images= get(_images_),
                      is_sprite= !images.length,
                      space= get(_dimensions_)
                    if (!is_sprite){
                      var
                        frameshot= images[frame - 1]
                      ready && t.attr({ src: reen(opt.path + frameshot) })
                    }else{
                      if (!opt.stitched) var
                        minor= (frame % footage) - 1,
                        minor= minor < 0 ? footage - 1 : minor,
                        major= floor((frame - 0.1) / footage),
                        major= major + (opt.rows > 1 ? 0 : (get(_backwards_) ? 0 : get(_rows_))),
                        spacing= get(_spacing_),
                        a= major * ((horizontal ? space.y : space.x) + spacing),
                        b= minor * ((horizontal ? space.x : space.y) + spacing),
                        shift= images.length ? [0, 0] : horizontal ? [px(-b), px(-a)] : [px(-a), px(-b)]
                      else var
                        x= set(_stitched_shift_, round(interpolate(frame_fraction, 0, get(_stitched_travel_))) % opt.stitched),
                        y= 0,
                        shift= [px(-x), px(y)]
                      t.css({ backgroundPosition: shift.join(___) })
                    }
                  },

                  // ---------
                  // Indicator
                  // ---------
                  //
                  // When configured with the [`indicator`](#indicator-Option) option, Reel adds to the scene
                  // a visual indicator in a form of a black rectangle traveling along the bottom edge
                  // of the image. It bears two distinct messages:
                  //
                  // - its horizontal position accurately reflects actual `fraction`
                  // - and its width reflect one frame's share on the whole (more frames mean narrower
                  //   indicator).
                  //
                  'fractionChange.indicator': function(e, deprecated_set, fraction){
                    if (deprecated_set === undefined && opt.indicator) var
                      space= get(_dimensions_),
                      travel= opt.orbital && get(_vertical_) ? space.y : space.x,
                      slots= opt.orbital ? opt.footage : opt.images.length || get(_frames_),
                      size= opt.indicator,
                      weight= ceil(travel / slots),
                      travel= travel - weight,
                      indicate= round(interpolate(fraction, 0, travel)),
                      indicate= !opt.cw || opt.stitched ? indicate : travel - indicate,
                      $indicator= indicator.$x.css(get(_vertical_)
                      ? { left: 0, top: px(indicate), bottom: _auto_, width: size, height: weight }
                      : { bottom: 0, left: px(indicate), top: _auto_, width: weight, height: size })
                  },

                  // For multi-row object movies, there's a second indicator sticked to the left edge
                  // and communicates:
                  //
                  // - its vertical position accurately reflects actual `tier`
                  // - and its height reflect one row's share on the whole (more rows mean narrower
                  //   indicator).
                  //
                  'tierChange.indicator': function(e, deprecated_set, tier){
                    if (deprecated_set === undefined && opt.rows > 1 && opt.indicator) var
                      space= get(_dimensions_),
                      travel= space.y,
                      slots= opt.rows,
                      size= opt.indicator,
                      weight= ceil(travel / opt.rows),
                      travel= travel - weight,
                      indicate= round(tier * travel),
                      $yindicator= indicator.$y.css({ left: 0, top: indicate, width: size, height: weight })
                  },

                  // Indicators are bound to `fraction` or `row` changes, meaning they alone can consume
                  // more CPU resources than the entire Reel scene. Use them for development only.
                  //

                  // -----------------
                  // [NEW] Annotations
                  // -----------------
                  //
                  // If you want to annotate features of your scene to better describe the subject,
                  // there's annotations for you. Annotations feature allows you to place virtually any
                  // HTML content over or into the image and have its position and visibility synchronized
                  // with the position of Reel. These two easy looking handlers do a lot more than to fit
                  // in here.
                  //
                  // Learn more about [Annotations][1] in the wiki, where a great care has been taken
                  // to in-depth explain this new exciting functionality.
                  //
                  // [1]:https://github.com/pisi/Reel/wiki/Annotations
                  //
                  'setup.annotations': function(e){
                    var
                      space= get(_dimensions_),
                      $overlay= t.parent(),
                      film_css= { position: _absolute_, width: space.x, height: space.y, left: 0, top: 0 }
                    $.each(get(_annotations_), function(ida, note){
                      var
                        $note= typeof note.node == _string_ ? $(note.node) : note.node || {},
                        $note= $note.jquery ? $note : $(tag(_div_), $note),
                        $note= $note.attr({ id: ida }).addClass(annotation_klass),
                        $image= note.image ? $(tag(_img_), note.image) : $(),
                        $link= note.link ? $(tag('a'), note.link).click(function(){ return false }) : $()
                      css(hash(ida), { display: _none_, position: _absolute_ }, true);
                      note.image || note.link && $note.append($link);
                      note.link || note.image && $note.append($image);
                      note.link && note.image && $note.append($link.append($image));
                      $note.appendTo($overlay);
                    });
                  },
                  'frameChange.annotations': function(e, deprecation, frame){
                    var
                      space= get(_dimensions_),
                      stitched= opt.stitched,
                      ss= get(_stitched_shift_)
                    if (!get(_preloaded_)) return;
                    if (deprecation === undefined) $.each(get(_annotations_), function(ida, note){
                      var
                        $note= $(hash(ida)),
                        start= note.start || 1,
                        end= note.end,
                        offset= frame - 1,
                        at= note.at ? (note.at[offset] == '+') : false,
                        offset= note.at ? offset : offset - start + 1,
                        x= typeof note.x!=_object_ ? note.x : note.x[offset],
                        y= typeof note.y!=_object_ ? note.y : note.y[offset],
                        placed= x !== undefined && y !== undefined,
                        visible= placed && (note.at ? at : (offset >= 0 && (!end || offset <= end - start)))
                      if (stitched) var
                        on_edge= x < space.x && ss > stitched - space.x,
                        after_edge= x > stitched - space.x && ss >= 0 && ss < space.x,
                        x= !on_edge ? x : x + stitched,
                        x= !after_edge ? x : x - stitched,
                        x= x - ss
                      var
                        style= { display: visible ? _block_:_none_, left: px(x), top: px(y) }
                      $note.css(style);
                    });
                  },
                  'up.annotations': function(e, ev){
                    if (panned || wheeled) return;
                    var
                      $target= $(ev.target),
                      $link= ($target.is('a') ? $target : $target.parents('a')),
                      href= $link.attr('href'),
                      target= $link.attr('target') || 'self'
                    if (!href) return;
                    if (target == '_blank') panned= !!window.open(href)
                    else panned= !!(window[target].location.href= href)
                  },

                  // ---------------------------
                  // [NEW] Click Stepping Events
                  // ---------------------------
                  //
                  // For devices without drag support or for developers, who want to use some sort
                  // of left & right buttons on their site to control your instance from outside, Reel
                  // supports ordinary click with added detection of left half or right half and resulting
                  // triggering of `stepLeft` and `stepRight` events respectively.
                  //

                  // This behavior can be disabled by the [`steppable`](#steppable-Option) option.
                  //
                  'up.steppable': function(e, ev){
                    if (panned || wheeled) return;
                    t.trigger(get(_clicked_location_).x - t.offset().left > 0.5 * get(_dimensions_).x ? 'stepRight' : 'stepLeft')
                  },
                  'stepLeft stepRight': function(e){
                    unidle();
                  },

                  // ### `stepLeft` Event ######
                  // `Event`, since 1.2
                  stepLeft: function(e){
                    set(_backwards_, false);
                    set(_fraction_, get(_fraction_) - get(_bit_) * get(_cwish_));
                  },

                  // ### `stepRight` Event ######
                  // `Event`, since 1.2
                  stepRight: function(e){
                    set(_backwards_, true);
                    set(_fraction_, get(_fraction_) + get(_bit_) * get(_cwish_));
                  },

                  // ----------------
                  // Follow-up Events
                  // ----------------
                  //
                  // When some event as a result triggers another event, it preferably is not triggered
                  // directly, because it would disallow preventing the event propagation / chaining
                  // to happen. Instead a followup handler is bound to the first event and it triggers the
                  // second one.
                  //
                  'setup.fu': function(e){
                    var
                      frame= set(_frame_, opt.frame + (opt.row - 1) * get(_frames_))
                    t.trigger('preload')
                  },
                  'wheel.fu': function(){ wheeled= false },
                  'clean.fu': function(){ t.trigger('teardown') },
                  'loaded.fu': function(){ t.trigger('opening') }
                },

                // -------------
                // Tick Handlers
                // -------------

                // As opposed to the events bound to the instance itself, there is a [ticker](#Ticker)
                // in place, which emits `tick.reel` event on the document level by default every 1/36
                // of a second and drives all the animations. Three handlers currently bind each instance
                // to the tick.
                //
                pool: {

                  // This handler has a responsibility of continuously updating the preloading indicator
                  // until all images are loaded and to unbind itself then.
                  //
                  'tick.reel.preload': function(e){
                    var
                      space= get(_dimensions_),
                      current= number(preloader.$.css(_width_)),
                      images= get(_images_).length || 1,
                      target= round(1 / images * get(_preloaded_) * space.x)
                    preloader.$.css({ width: current + (target - current) / 3 + 1 })
                    if (get(_preloaded_) === images && current > space.x - 1){
                      preloader.$.fadeOut(300, function(){ preloader.$.remove() });
                      pool.unbind(_tick_+dot(_preload_), on.pool[_tick_+dot(_preload_)]);
                    }
                  },

                  // This handler binds to the document's ticks at all times, regardless the situation.
                  // It serves several tasks:
                  //
                  // - keeps track of how long the instance is being operated by the user,
                  // - or for how long it is braking the velocity inertia,
                  // - decreases gained velocity by applying power of the [`brake`](#brake-Option) option,
                  // - flags the instance as `slidable` again, so that `pan` event handler can be executed
                  //   again,
                  // - updates the [`monitor`](#monitor-Option) value,
                  // - bounces off the edges for non-looping panoramas,
                  // - and most importantly it animates the Reel if [`speed`](#speed-Option) is configured.
                  //
                  'tick.reel': function(e){
                    var
                      velocity= get(_velocity_),
                      leader_tempo= leader(_tempo_)
                    if (braking) var
                      braked= velocity - (get(_brake_) / leader_tempo * braking),
                      velocity= set(_velocity_, braked > 0.1 ? braked : (braking= operated= 0))
                    opt.monitor && $monitor.text(get(opt.monitor));
                    velocity && braking++;
                    operated && operated++;
                    to_bias(0);
                    slidable= true;
                    if (operated && !velocity) return mute(e);
                    if (get(_clicked_)) return mute(e, unidle());
                    if (get(_opening_ticks_) > 0) return;
                    if (!opt.loops && opt.rebound) var
                      edgy= !operated && !(get(_fraction_) % 1) ? on_edge++ : (on_edge= 0),
                      bounce= on_edge >= opt.rebound * 1000 / leader_tempo,
                      backwards= bounce && set(_backwards_, !get(_backwards_))
                    var
                      direction= get(_cwish_) * negative_when(1, get(_backwards_)),
                      step= (!get(_playing_) ? velocity : abs(get(_speed_)) + velocity) / leader(_tempo_),
                      fraction= set(_fraction_, get(_fraction_) - step * direction)
                  },

                  // This handler performs the opening animation duty when during it the normal animation
                  // is halted until the opening finishes.
                  //
                  'tick.reel.opening': function(e){
                    if (!get(_opening_)) return;
                    var
                      speed= opt.entry || opt.speed,
                      step= speed / leader(_tempo_) * (opt.cw? -1:1),
                      ticks= set(_opening_ticks_, get(_opening_ticks_) - 1),
                      fraction= set(_fraction_, get(_fraction_) + step)
                    ticks || t.trigger('openingDone');
                  }
                }
              },

              // ------------------------
              // Instance Private Helpers
              // ------------------------

              // - Events propagation stopper / muter
              //
              mute= function(e, result){ return e.stopImmediatePropagation() || result },

              // - User idle control
              //
              operated,
              braking= 0,
              idle= function(){ return operated= 0 },
              unidle= function(){
                clearTimeout(delay);
                pool.unbind(_tick_+dot(_opening_), on.pool[_tick_+dot(_opening_)]);
                set(_opening_ticks_, 0);
                return operated= -opt.timeout * leader(_tempo_)
              },
              panned= false,
              wheeled= false,
              delay, // openingDone's delayed play pointer

              // - Constructors of UI elements
              //
              $monitor= $(),
              preloader= function(){
                css(___+dot(preloader_klass), {
                  position: _absolute_,
                  left: 0, top: get(_dimensions_).y - opt.preloader,
                  height: opt.preloader,
                  overflow: _hidden_,
                  backgroundColor: '#000'
                });
                return preloader.$= $(tag(_div_), { 'class': preloader_klass })
              },
              indicator= function(axis){
                css(___+dot(indicator_klass)+dot(axis), {
                  position: _absolute_,
                  width: 0, height: 0,
                  overflow: _hidden_,
                  backgroundColor: '#000'
                });
                return indicator['$'+axis]= $(tag(_div_), { 'class': indicator_klass+___+axis })
              },

              // - CSS rules & stylesheet
              //
              css= function(selector, definition, global){
                var
                  stage= global ? __ : get(_stage_),
                  selector= selector.replace(/^/, stage).replace(____, ____+stage)
                return css.rules.push(selector+cssize(definition)) && definition
                function cssize(values){
                  var rules= [];
                  $.each(values, function(key, value){ rules.push(key.replace(/([A-Z])/g, '-$1').toLowerCase()+':'+px(value)+';') });
                  return '{'+rules.join(__)+'}'
                }
              },
              $style,

              // - Inertia rotation control
              //
              on_edge= 0,
              last= { x: 0, y: 0 },
              to_bias= function(value){ return bias.push(value) && bias.shift() && value },
              no_bias= function(){ return bias= [0,0] },
              bias= no_bias(),

              // - Graph function to be used
              //
              graph= opt.graph || reel.math[opt.loops ? 'hatch' : 'envelope'],
              normal= reel.normal,

              // - Interaction graph's zero point reset
              //
              recenter_mouse= function(revolution, x, y){
                var
                  fraction= set(_clicked_on_, get(_fraction_)),
                  tier= set(_clicked_tier_, get(_tier_))
                set(_lo_, opt.loops ? 0 : - fraction * revolution);
                set(_hi_, opt.loops ? revolution : revolution - fraction * revolution);
                return x && set(_clicked_location_, { x: x, y: y }) || undefined
              },
              slidable= true,

              // ~~~
              //
              // Global events are bound to the pool (`document`), but to make it work inside an `<iframe>`
              // we need to bind to the parent document too to maintain the dragging even outside the area
              // of the `<iframe>`.
              //
              pools
            try{ pools= $.unique(pool.add(window.top.document)) }
            catch(e){ pools= pool }

            // A private flag `$iframe` is established to indicate Reel being viewed inside `<iframe>`.
            //
            var
              $iframe= top === self ? $() : (function sense_iframe($ifr){
                $('iframe', pools.last()).each(function(){
                  try{ if ($(this).contents().find(_head_).html() == $(_head_).html()) return ($ifr= $(this)) && false }
                  catch(e){}
                })
                return $ifr
              })()
            css.rules= [];
            on.setup();
          });

          // ~~~
          //
          // Reel maintains a ticker, which guides all animations. There's only one ticker per document
          // and all instances bind to it. Ticker's mechanism measures and compares times before and after
          // the `tick.reel` event trigger to estimate the time spent on executing `tick.reel`'s handlers.
          // The actual timeout time is then adjusted by the amount to run as close to expected tempo
          // as possible.
          //
          ticker= ticker || (function tick(){
            var
              start= +new Date(),
              tempo= leader(_tempo_)
            if (!tempo) return ticker= null;
            pool.trigger(_tick_);
            reel.cost= (+new Date() + reel.cost - start) / 2;
            return ticker= setTimeout(tick, max(4, 1000 / tempo - reel.cost));
          })();

          return $(instances);
          }else{

            // ----
            // Data
            // ----
            //
            // Reel stores all its inner state values with the standard DOM [data interface][1] interface
            // while adding an additional change-detecting event layer, which makes Reel entirely data-driven.
            //
            // [1]:http://api.jquery.com/data
            //
            // _For example let's find out on what frame a Reel instance currently is:_
            //
            //     .reel('frame') // Returns the frame number
            //
            // Think of `.reel()` as a synonym for `.data()`. Note, that you can therefore easily inspect
            // the entire datastore with `.data()` (without arguments). Use it for debugging only.
            // For real-time data watch use [`monitor`](#Monitor) option instead of manually hooking into
            // the data.
            //

            // #### `.reel( name )` ######
            // can return anything, since 1.2
            //
            if (typeof name == 'string'){
              if (args.length == 1){
                var
                  value= data[name]
                t.trigger('recall', [name, value]);
                return value;
              }

              // ---
              // ### Write Access ###
              //
              // You can store any value the very same way by passing the value as the second function
              // argument. _For example let's say you want to jump to frame 12:_
              //
              //     .reel('frame', 12)
              //
              // Only a handful of data keys is suitable for external manipulation. These include `area`,
              // `backwards`, `brake`, __`fraction`__, __`frame`__, `playing`, `reeling`, __`row`__, `speed`,
              // `stopped`, `velocity` and `vertical`. Use the rest of the keys for reading only, you can
              // mess up easily changing them.
              //

              // #### `.reel( name, value )` ######
              // returns `jQuery`, since 1.2
              //
              else{
                if (value !== undefined){
                  try{ value= reel.normal[name](value, data) }catch(e){ }

                  // ---
                  // ### Changes ######
                  //
                  // Any value that does not equal (`===`) the old value is considered _new value_ and
                  // in such a case Reel will trigger a _change event_ to announce the change. The event
                  // type takes form of _`key`_`Change`, where _`key`_ will be the data key/name you've
                  // just assigned.
                  // _For example, setting `"frame"` to `12` in the above example will trigger
                  // `"frameChange"`._
                  //
                  // Some of these _change events_ (like `frame` or `fraction`) have a
                  // default handler attached.
                  //
                  // You can easily bind to any of the data key change with standard event
                  // binding methods. _For example, let's say you want to react on instance
                  // being manipulated by the user - whether it is __reeling__:_
                  //
                  //     .bind('reelingChange', function(evnt, nothing, reeling){
                  //       if (reeling) console.log('Rock & reel!')
                  //       else console.log('Not reeling...')
                  //     })
                  //

                  // The handler function will be executed every time the value changes and
                  // it will be supplied with three arguments. First one is the event object
                  // as usual, second is `undefined` and the third will be the actual value.
                  // In this case it was a boolean type value.
                  // If the second argument is not `undefined` it is the backward compatible
                  // "before" event triggered from outside Reel.
                  //
                  if (data[name] !== value) t.trigger(name+'Change', [ undefined, data[name]= value ]);
                }
                return t.trigger('store', [name, value]);
              }
            }
          }
        },

        // -----------
        // Destruction
        // -----------
        //
        // The evil-twin of `.reel()`. Tears down and wipes off entire instance.
        //

        // ### `.unreel()` Method ######
        // returns `jQuery`, since 1.2
        //
        unreel: function(){
          return this.trigger('teardown');
        }
      },

      // -------------------
      // Regular Expressions
      // -------------------
      //
      // Few regular expressions is used here and there mostly for options validation and verification
      // levels of user agent's capabilities.
      //

      // ### `$.reel.re` ######
      // `RegExp`, since 1.1
      //
      re: {
        /* Valid image file format */
        image:         /^(.*)\.(jpg|jpeg|png|gif)\??.*$/,
        /* Multi touch devices */
        touchy_agent:  /iphone|ipod|ipad|android|fennec|rim tablet/i,
        /* Lazy (low-CPU mobile devices) */
        lazy_agent:    /\(iphone|ipod|android|fennec|blackberry/i,
        /* Format of frame class flag on the instance */
        frame_klass:   /frame-\d+/,
        /* [Sequence](#Sequence) string format */
        sequence:      /(^[^#|]*([#]+)[^#|]*)($|[|]([0-9]+)\.\.([0-9]+))($|[|]([0-9]+)$)/
      },

      // ------------------------
      // Content Delivery Network
      // ------------------------
      //
      // [CDN][1] is used for distributing mouse cursors to all instances running world-wide. It runs
      // on Google cloud infrastructure. If you want to ease up on the servers, please consider setting up
      // your own location with the cursors.
      //
      // [1]:https://github.com/pisi/Reel/wiki/CDN
      //

      // ### `$.reel.cdn` ######
      // `String` (URL path), since 1.1
      //
      cdn: 'http://code.vostrel.cz/',

      // -----------
      // Math Behind
      // -----------
      //
      // Surprisingly there's very little math behind Reel, just two equations (graph functions). These two
      // functions receive the same set of options.

      // ### `$.reel.math` ######
      // `Object`, since 1.1
      //
      math: {

        //     1 |  ********
        //       |          **
        //       |            **
        //       |              **
        //       |                **
        //       |                  ********
        //     0  ----------------------------
        //
        envelope: function(x, start, revolution, lo, hi, cwness, y){
          return start + min_max(lo, hi, - x * cwness) / revolution
        },

        //     1 |        **          **
        //       |          **          **
        //       |            **          **
        //       |  **          **
        //       |    **          **
        //       |      **          **
        //     0  ----------------------------
        //
        hatch: function(x, start, revolution, lo, hi, cwness, y){
          var
            x= (x < lo ? hi : 0) + x % hi, // Looping
            fraction= start + (- x * cwness) / revolution
          return fraction - floor(fraction)
        },

        // And an equation for interpolating `fraction` (and `tier`) value into `frame` and `row`.
        //
        interpolate: function(fraction, lo, hi){
          return lo + fraction * (hi - lo)
        }
      },

      // ----------------
      // Preloading Modes
      // ----------------
      //
      // Reel doesn't load frames in a linear manner from first to last (alhough it can if configured
      // that way with the [`preload`](#preload-Option) option). Reel will take the linear configured
      // sequence and hand it over to one of `$.reel.preload` functions, along with reference to options
      // and the RO data intearface, and it expects the function to reorder the incoming Array and return
      // it back.

      // ### `$.reel.preload` ######
      // `Object`, since 1.2
      //
      preload: {

        // The best (and default) option is the `fidelity` processor, which is designed for a faster and
        // better perceived loading.
        //
        // ![Example](https://camo.githubapp.com/74b73060a50f3cbaf522ec31530d34e3fa5cbcb9/687474703a2f2f6a71756572792e766f737472656c2e637a2f7265656c2f7363617474657265642e6c6f6164696e672e676966)
        //
        fidelity: function(sequence, opt, get){
          var
            rows= opt.orbital ? 2 : opt.rows || 1,
            frames= opt.orbital ? opt.footage : get(_frames_),
            start= (opt.row-1) * frames,
            values= new Array().concat(sequence),
            present= new Array(sequence.length + 1),
            priority= rows < 2 ? [] : values.slice(start, start + frames)
          return spread(priority, 1, start).concat(spread(values, rows, 0))

          function spread(sequence, rows, offset){
            if (!sequence.length) return [];
            var
              order= [],
              passes= 4 * rows,
              start= opt.frame,
              frames= sequence.length,
              plus= true,
              granule= frames / passes
            for(var i= 0; i < passes; i++)
              add(start + round(i * granule));
            while(granule > 1)
              for(var i= 0, length= order.length, granule= granule / 2, p= plus= !plus; i < length; i++)
                add(order[i] + (plus? 1:-1) * round(granule));
            for(var i=0; i <= frames; i++) add(i);
            for(var i= 0; i < order.length; i++)
              order[i]= sequence[order[i] - 1];
            return order
            function add(frame){
              while(!(frame >= 1 && frame <= frames))
                frame+= frame < 1 ? +frames : -frames;
              return present[offset + frame] || (present[offset + frame]= !!order.push(frame))
            }
          }
        },

        // ~~~
        //
        // You can opt for a `linear` loading order too, but that has a drawback of leaving large gap
        // of unloaded frames.
        //
        linear: function(sequence, opt, get){
          return sequence
        }
      },

      // ------------------------
      // Data Value Normalization
      // ------------------------
      //
      // On all data values being stored with `.reel()` an attempt is made to normalize the value. Like
      // for example normalization of frame `55` when there's just `45` frames total. These are the built-in
      // normalizations. Normalization function has the same name as the data key it is assigned to
      // and is given the raw value in arguments, along with reference to the instances data object,
      // and it has to return the normalized value.
      //

      // ### `$.reel.normal` ######
      // `Object`, since 1.2
      //
      normal: {
        fraction: function(fraction, data){
          return data[_options_].loops ? fraction - floor(fraction) : min_max(0, 1, fraction)
        },
        tier: function(tier, data){
          return min_max(0, 1, tier)
        },
        row: function(row, data){
          return round(min_max(1, data[_options_].rows, row))
        },
        frame: function(frame, data){
          var
            opt= data[_options_],
            frames= data[_frames_] * (opt.orbital ? 2 : opt.rows || 1),
            result= round(opt.loops ? frame % frames || frames : min_max(1, frames, frame))
          return result < 0 ? result + frames : result
        }
      },

      // -----------------
      // Sequence Build-up
      // -----------------
      //
      // When configured with a String value for [`images`](#images-Option) like `image##.jpg`, it first has
      // to be converted into an actual Array by engaging the counter placeholder.
      //

      // ### `$.reel.sequence()` ######
      // `Function`, since 1.2
      //
      sequence: function(sequence, opt){
        if (sequence.length <= 1) return opt.images;
        var
          images= [],
          url= sequence[1],
          placeholder= sequence[2],
          start= +sequence[4] || 1,
          rows= opt.orbital ? 2 : opt.rows || 1,
          frames= opt.orbital ? opt.footage : opt.frames,
          end= +(sequence[5] || rows * frames),
          total= end - start,
          increment= +sequence[7] || 1,
          counter= 0
        while(counter < end){
          images.push(url.replace(placeholder, pad((start + counter + __), placeholder.length, '0')));
          counter+= increment;
        }
        return images;
      },

      // --------------
      // Reel Instances
      // --------------
      //
      // `$.reel.instances` holds an inventory of all running instances in the DOM document.

      // ### `$.reel.instances` ######
      // `jQuery`, since 1.1
      //
      instances: $(),

      // For ticker-synchronization-related purposes Reel maintains a reference to the leaders data object
      // all the time.
      //

      // ### `$.reel.leader` ######
      // `Object` (DOM data), since 1.1
      //
      leader: leader,

      //
      // `$.reel.cost` holds document-wide costs in miliseconds of running all Reel instances. It is used
      // to adjust actual timeout of the ticker.

      // ### `$.reel.cost` ######
      // `Number`, since 1.1
      //
      cost: 0
    },

    // ------------------------
    // Private-scoped Variables
    // ------------------------
    //
    pool= $(document),
    browser_version= +$.browser.version.split(dot()).slice(0,2).join(dot()),
    ie= $.browser.msie,
    knows_data_urls= !ie || (ie && browser_version > 6),
    client= navigator.userAgent,
    ticker,

    // ---------------
    // CSS Class Names
    // ---------------

    // These are all the class names assigned by Reel to various DOM elements during initialization of the UI
    // and they all share same base `"reel"`, which in isolation also is the class of the `<img>` node you
    // converted into Reel.
    klass= 'reel',

    // Rest of the class names only extend this base class forming for example `.reel-overlay`, a class
    // assigned to the outter instance wrapper (`<img>`'s injected parent).
    //
    overlay_klass= klass + '-overlay',
    indicator_klass= klass + '-indicator',
    preloader_klass= klass + '-preloader',
    cached_klass= klass + '-cached',
    monitor_klass= klass + '-monitor',
    annotation_klass= klass + '-annotation',
    panning_klass= klass + '-panning',
    loading_klass= klass + '-loading',

    // The instance wrapper is flagged with actual frame number using a this class. _For example Reel
    // on frame 10 will bear a class name `.frame-10`.
    //
    frame_klass= 'frame-',

    // --------------------------------
    // Shortcuts And Minification Cache
    // --------------------------------

    // Several math functions are referenced inside the private scope to yield smaller filesize
    // when the code is minified.
    //
    math= Math,
    round= math.round, floor= math.floor, ceil= math.ceil,
    min= math.min, max= math.max, abs= math.abs,
    number= parseInt,
    interpolate= reel.math.interpolate,

    // For the very same reason all storage key Strings are cached into local vars.
    //
    _annotations_= 'annotations',
    _area_= 'area', _auto_= 'auto', _backup_= 'backup', _backwards_= 'backwards', _bit_= 'bit', _brake_= 'brake', _cached_= 'cached', _center_= 'center',
    _clicked_= 'clicked', _clicked_location_= 'clicked_location', _clicked_on_= 'clicked_on', _clicked_tier_= 'clicked_tier',
    _cwish_= 'cwish', _dimensions_= 'dimensions', _fraction_= 'fraction', _frame_= 'frame',
    _frames_= 'frames', _hi_= 'hi', _hidden_= 'hidden', _image_= 'image', _images_= 'images', _opening_= 'opening', _opening_ticks_= _opening_+'_ticks',
    _lo_= 'lo', _options_= 'options', _playing_= 'playing', _preloaded_= 'preloaded', _reeling_= 'reeling', _revolution_= 'revolution',
    _revolution_y_= 'revolution_y', _row_= 'row', _rows_= 'rows', _spacing_= 'spacing', _speed_= 'speed', _stage_= 'stage', _stitched_= 'stitched',
    _stitched_shift_= 'stitched_shift', _stitched_travel_= 'stitched_travel', _stopped_= 'stopped', _style_= 'style', _tempo_= 'tempo', _tier_= 'tier',
    _velocity_= 'velocity', _vertical_= 'vertical',

    // And the same goes for browser events too.
    //
    ns= dot(klass),
    pns= dot('pan') + ns,
    _touch_= 'touch', _mouse_= 'mouse',
    _mousedown_= _mouse_+'down'+ns, _mouseenter_= _mouse_+'enter'+ns,
    _mouseleave_= _mouse_+'leave'+pns, _mousemove_= _mouse_+'move'+pns, _mouseup_= _mouse_+'up'+pns,
    _mousewheel_= _mouse_+'wheel'+ns, _tick_= 'tick'+ns, _touchcancel_= _touch_+'cancel'+pns,
    _touchend_= _touch_+'end'+pns, _touchstart_= _touch_+'start'+ns, _touchmove_= _touch_+'move'+pns,

    // And some other frequently used Strings.
    //
    __= '', ___= ' ', ____=',', _absolute_= 'absolute', _block_= 'block', _cdn_= '@CDN@', _div_= 'div',
    _hand_= 'hand', _head_= 'head', _height_= 'height', _html_= 'html', _id_= 'id',
    _img_= 'img', _jquery_reel_= 'jquery.'+klass, _move_= 'move', _none_= 'none', _object_= 'object',
    _preload_= 'preload', _string_= 'string',
    _width_= 'width',

    // ---------------
    // Image Resources
    // ---------------

    // Alhough we do what we can to hide the fact, Reel actually needs a few image resources to support
    // some of its actions. First, we may need a transparent image for the original `<img>` to uncover
    // the sprite applied to its background. This one is embedded in the code as it is very small.
    //
    transparent= knows_data_urls ? embedded('CAAIAIAAAAAAAAAAACH5BAEAAAAALAAAAAAIAAgAAAIHhI+py+1dAAA7') : _cdn_+'blank.gif',

    // Proper cross-browser cursors however need to come in an odd format, which essentially is not
    // compressed at all and this means bigger filesize. While it is no more than ~15k, it is unfit
    // for embedding directly here, so a [`CDN`](#Content-Delivery-Network) is employed to retrieve
    // the images from in an effective gzipped and cachable manner.
    //
    reel_cursor= url(_cdn_+_jquery_reel_+'.cur')+____+_move_,
    drag_cursor= url(_cdn_+_jquery_reel_+'-drag.cur')+____+_move_,
    drag_cursor_down= url(_cdn_+_jquery_reel_+'-drag-down.cur')+____+_move_,

    // ~~~
    //
    // We then only identify the user's browser's capabilities and route around a MSIE's left button
    // identification quirk (IE 8- reports left as right).
    touchy= reel.touchy= (reel.re.touchy_agent).test(client),
    lazy= reel.lazy= (reel.re.lazy_agent).test(client),

    DRAG_BUTTON= touchy ? undefined : (ie && browser_version <= 8) ? 1 : 0,

    // ~~~
    //
    // So far jQuery doesn't have a proper built-in mechanism to detect/report DOM node removal.
    // But internally, jQuery calls `$.cleanData()` to flush the DOM data and minimize memory leaks.
    // Reel wraps this function and as a result `clean` event handler is triggered for every element.
    // Note, that the `clean` event does not bubble.
    //
    cleanData= $.cleanData,
    cleanDataEvent= $.cleanData= function(elements){
      cleanData($(elements).each(function(){ $(this).triggerHandler('clean'); }));
    }

  // If the optional disableTextSelect plugin is not used, this will fill in the holes, where Reel expects
  // ground.
  double_for('disableTextSelect enableTextSelect'.split(/ /));

  // Expose plugin functions as jQuery methods
  $.extend($.fn, reel.fn);

  // Very useful helpers
  function add_instance($instance){ return (reel.instances.push($instance[0])) && $instance }
  function remove_instance($instance){ return (reel.instances= reel.instances.not(hash($instance.attr(_id_)))) && $instance }
  function leader(key){ return reel.instances.first().data(key) }
  function embedded(image){ return 'data:image/gif;base64,R0lGODlh' + image }
  function tag(string){ return '<' + string + '/>' }
  function dot(string){ return '.' + (string || '') }
  function cdn(path){ return path.replace(_cdn_, reel.cdn) }
  function url(location){ return 'url(\'' + reen(location) + '\')' }
  function axis(key, value){ return typeof value == _object_ ? value[key] : value }
  function min_max(minimum, maximum, number){ return max(minimum, min(maximum, number)) }
  function double_for(methods){ $.each(methods, pretend);
    function pretend(){ if (!$.fn[this]) $.fn[this]= function(){ return this }}
  }
  function negative_when(value, condition){ return abs(value) * (condition ? -1 : 1) }
  function finger(e){ return touchy ? e.touch || e.originalEvent.touches[0] : e }
  function px(value){ return value === undefined ? 0 : typeof value == _string_ ? value : value + 'px' }
  function hash(value){ return '#' + value }
  function pad(string, len, fill){ while (string.length < len) string= fill + string; return string }
  function reen(uri){ return encodeURI(decodeURI(uri)) }
  function deprecated(input){ try{ console.warn('Deprecation - Please consult https://github.com/pisi/Reel/wiki/Deprecations') }catch(e){} return input }
})(mrm.$, window, document);
/*
 * MIT LICENSE
 * Copyright (c) 2009-2011 Devon Govett.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated 
 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation 
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
 * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions 
 * of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
 * THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

(function($) {
	$.fn.ellipsis = function(enableUpdating){
		var s = document.documentElement.style;
		if (!('textOverflow' in s || 'OTextOverflow' in s)) {
			return this.each(function(){
				var el = $(this);
				if(el.css("overflow") == "hidden"){
					var originalText = el.html();
					var w = el.width();
					
					var t = $(this.cloneNode(true)).hide().css({
						'position': 'absolute',
						'width': 'auto',
						'overflow': 'visible',
						'max-width': 'inherit'
					});
					el.after(t);
					
					var text = originalText;
					while(text.length > 0 && t.width() > el.width()){
						text = text.substr(0, text.length - 1);
						t.html(text + "...");
					}
					el.html(t.html());
					
					t.remove();
					
					if(enableUpdating == true){
						var oldW = el.width();
						setInterval(function(){
							if(el.width() != oldW){
								oldW = el.width();
								el.html(originalText);
								el.ellipsis();
							}
						}, 200);
					}
				}
			});
		} else return this;
	};
})(mrm.$);/*
 * jQuery Tooltip plugin 1.3
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-tooltip/
 * http://docs.jquery.com/Plugins/Tooltip
 *
 * Copyright (c) 2006 - 2008 Jrn Zaefferer
 *
 * $Id: jquery.tooltip.js 5741 2008-06-21 15:22:16Z joern.zaefferer $
 * 
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */
 
;(function($) {
	
		// the tooltip element
	var helper = {},
		// the current tooltipped element
		current,
		// the title of the current element, used for restoring
		title,
		// timeout id for delayed tooltips
		tID,
		// IE 5.5 or 6
		IE = $.browser.msie && /MSIE\s(5\.5|6\.)/.test(navigator.userAgent),
		// flag for mouse tracking
		track = false;
	
	$.tooltip = {
		blocked: false,
		defaults: {
			delay: 200,
			fade: false,
			showURL: true,
			extraClass: "",
			top: 15,
			left: 15,
			id: "tooltip"
		},
		block: function() {
			$.tooltip.blocked = !$.tooltip.blocked;
		}
	};
	
	$.fn.extend({
		tooltip: function(settings) {
			settings = $.extend({}, $.tooltip.defaults, settings);
			createHelper(settings);
			return this.each(function() {
					$.data(this, "tooltip", settings);
					this.tOpacity = helper.parent.css("opacity");
					// copy tooltip into its own expando and remove the title
					this.tooltipText = this.title;
					$(this).removeAttr("title");
					// also remove alt attribute to prevent default tooltip in IE
					this.alt = "";
				})
				.mouseover(save)
				.mouseout(hide)
				.click(hide);
		},
		fixPNG: IE ? function() {
			return this.each(function () {
				var image = $(this).css('backgroundImage');
				if (image.match(/^url\(["']?(.*\.png)["']?\)$/i)) {
					image = RegExp.$1;
					$(this).css({
						'backgroundImage': 'none',
						'filter': "progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=crop, src='" + image + "')"
					}).each(function () {
						var position = $(this).css('position');
						if (position != 'absolute' && position != 'relative')
							$(this).css('position', 'relative');
					});
				}
			});
		} : function() { return this; },
		unfixPNG: IE ? function() {
			return this.each(function () {
				$(this).css({'filter': '', backgroundImage: ''});
			});
		} : function() { return this; },
		hideWhenEmpty: function() {
			return this.each(function() {
				$(this)[ $(this).html() ? "show" : "hide" ]();
			});
		},
		url: function() {
			return this.attr('href') || this.attr('src');
		}
	});
	
	function createHelper(settings) {
		// there can be only one tooltip helper
		if( helper.parent )
			return;
		// create the helper, h3 for title, div for url
		helper.parent = $('<div id="' + settings.id + '"><h3></h3><div class="body"></div><div class="url"></div></div>')
			// add to document
			.appendTo(document.body)
			// hide it at first
			.hide();
			
		// apply bgiframe if available
		if ( $.fn.bgiframe )
			helper.parent.bgiframe();
		
		// save references to title and url elements
		helper.title = $('h3', helper.parent);
		helper.body = $('div.body', helper.parent);
		helper.url = $('div.url', helper.parent);
	}
	
	function settings(element) {
		return $.data(element, "tooltip");
	}
	
	// main event handler to start showing tooltips
	function handle(event) {
		// show helper, either with timeout or on instant
		if( settings(this).delay )
			tID = setTimeout(show, settings(this).delay);
		else
			show();
		
		// if selected, update the helper position when the mouse moves
		track = !!settings(this).track;
		$(document.body).bind('mousemove', update);
			
		// update at least once
		update(event);
	}
	
	// save elements title before the tooltip is displayed
	function save() {
		// if this is the current source, or it has no title (occurs with click event), stop
		if ( $.tooltip.blocked || this == current || (!this.tooltipText && !settings(this).bodyHandler) )
			return;

		// save current
		current = this;
		title = this.tooltipText;
		
		if ( settings(this).bodyHandler ) {
			helper.title.hide();
			var bodyContent = settings(this).bodyHandler.call(this);
			if (bodyContent.nodeType || bodyContent.jquery) {
				helper.body.empty().append(bodyContent)
			} else {
				helper.body.html( bodyContent );
			}
			helper.body.show();
		} else if ( settings(this).showBody ) {
			var parts = title.split(settings(this).showBody);
			helper.title.html(parts.shift()).show();
			helper.body.empty();
			for(var i = 0, part; (part = parts[i]); i++) {
				if(i > 0)
					helper.body.append("<br/>");
				helper.body.append(part);
			}
			helper.body.hideWhenEmpty();
		} else {
			helper.title.html(title).show();
			helper.body.hide();
		}
		
		// if element has href or src, add and show it, otherwise hide it
		if( settings(this).showURL && $(this).url() )
			helper.url.html( $(this).url().replace('http://', '') ).show();
		else 
			helper.url.hide();
		
		// add an optional class for this tip
		helper.parent.addClass(settings(this).extraClass);

		// fix PNG background for IE
		if (settings(this).fixPNG )
			helper.parent.fixPNG();
			
		handle.apply(this, arguments);
	}
	
	// delete timeout and show helper
	function show() {
		tID = null;
		if ((!IE || !$.fn.bgiframe) && settings(current).fade) {
			if (helper.parent.is(":animated"))
				helper.parent.stop().show().fadeTo(settings(current).fade, current.tOpacity);
			else
				helper.parent.is(':visible') ? helper.parent.fadeTo(settings(current).fade, current.tOpacity) : helper.parent.fadeIn(settings(current).fade);
		} else {
			helper.parent.show();
		}
		update();
	}
	
	/**
	 * callback for mousemove
	 * updates the helper position
	 * removes itself when no current element
	 */
	function update(event)	{
		if($.tooltip.blocked)
			return;
		
		if (event && event.target.tagName == "OPTION") {
			return;
		}
		
		// stop updating when tracking is disabled and the tooltip is visible
		if ( !track && helper.parent.is(":visible")) {
			$(document.body).unbind('mousemove', update)
		}
		
		// if no current element is available, remove this listener
		if( current == null ) {
			$(document.body).unbind('mousemove', update);
			return;	
		}
		
		// remove position helper classes
		helper.parent.removeClass("viewport-right").removeClass("viewport-bottom");
		
		var left = helper.parent[0].offsetLeft;
		var top = helper.parent[0].offsetTop;
		if (event) {
			// position the helper 15 pixel to bottom right, starting from mouse position
			left = event.pageX + settings(current).left;
			top = event.pageY + settings(current).top;
			var right='auto';
			if (settings(current).positionLeft) {
				right = $(window).width() - left;
				left = 'auto';
			}
			helper.parent.css({
				left: left,
				right: right,
				top: top
			});
		}
		
		var v = viewport(),
			h = helper.parent[0];
		// check horizontal position
		if (v.x + v.cx < h.offsetLeft + h.offsetWidth) {
			left -= h.offsetWidth + 20 + settings(current).left;
			helper.parent.css({left: left + 'px'}).addClass("viewport-right");
		}
		// check vertical position
		if (v.y + v.cy < h.offsetTop + h.offsetHeight) {
			top -= h.offsetHeight + 20 + settings(current).top;
			helper.parent.css({top: top + 'px'}).addClass("viewport-bottom");
		}
	}
	
	function viewport() {
		return {
			x: $(window).scrollLeft(),
			y: $(window).scrollTop(),
			cx: $(window).width(),
			cy: $(window).height()
		};
	}
	
	// hide helper and restore added classes and the title
	function hide(event) {
		if($.tooltip.blocked)
			return;
		// clear timeout if possible
		if(tID)
			clearTimeout(tID);
		// no more current element
		current = null;
		
		var tsettings = settings(this);
		function complete() {
			helper.parent.removeClass( tsettings.extraClass ).hide().css("opacity", "");
		}
		if ((!IE || !$.fn.bgiframe) && tsettings.fade) {
			if (helper.parent.is(':animated'))
				helper.parent.stop().fadeTo(tsettings.fade, 0, complete);
			else
				helper.parent.stop().fadeOut(tsettings.fade, complete);
		} else
			complete();
		
		if( settings(this).fixPNG )
			helper.parent.unfixPNG();
	}
	
})(mrm.$);
/*
* jQuery UI Deets v1.0.1
* Copyright (c) 2012, Gregory Waxman. All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
*	1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
*	2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
*	3. The names of its contributors may not be used to endorse or promote products derived from this software without specific prior written permission.
*	4. All private modifications should be offered to the author at https://github.com/Akkuma/jquery-deets
*	5. All public forks must notify the author of their existence. Using github to directly fork the project will be considered sufficient notification and will fulfill this obligation.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/(
function ($, undefined) {
    var isDetailsSupported = 'open' in document.createElement('details')
    , $1 = $1 || $
    ;

    function open() {
        var self = this
        , $element = this.element
        , element = $element[0]
        , speed = this.options.speed
        ;

        this._trigger('.opening');
        if (isDetailsSupported) {
            element.open = true;
        }
        else {
            $element.attr('open', 'true');
        }
        this.isOpen = true;

        $element.animate(
            { height: this._detailsHeight },
            { duration: speed,
                complete: function () {
                    self._trigger('.opened');
                }
            }
        );
    }

    function close() {
        var self = this
        , $element = this.element
        , element = $element[0]
        , speed = this.options.speed
        ;
        self._trigger('.closing');
        this.isOpen = false;

        $element.animate(
            { height: this._summaryHeight },
            { duration: speed,
                complete: function () {
                    if (isDetailsSupported) {
                        element.open = false;
                    }
                    else {
                        $element.removeAttr('open');
                    }

                    self._trigger('.closed');
                }
            }
        );
    }

    $.widget("ui.deets", {
        options: {
            speed: 0
        },

        _create: function () {
            if (this.widgetName !== 'deets') {
                $.data(this.element[0], 'deets', this);
            }

            this.isOpen = this.element[0].open || this.element.attr('open');

            if (!isDetailsSupported || this.options.speed) {
                this._polyfillDetails();
            }
            else if (!this.isOpen) {
                this.element.removeClass('closed')
            }
        },

        _polyfillDetails: function () {
            var $element = this.element
            , element = $element[0]
            ;

            this._summaryHeight = $element.find('summary').outerHeight(true);

            this.storeHeights();

            if (!this.isOpen) {
                $element.css({ height: this._summaryHeight });
            }
        },

        storeHeights: function () {
            var $element = this.element
            , element = $element[0]
            ;

            if (!isDetailsSupported) {
                this._detailsHeight = $element.removeClass('closed').outerHeight(true);
            }
            else {
                element.open = true;
                this._detailsHeight = $element.outerHeight(true);
                element.open = this.isOpen;
            }

        },
        open: function () {
            open.call(this);
        },

        close: function () {
            close.call(this);
        },

        toggle: function () {
            (this.isOpen ? close : open).call(this);
        },

        summary: function () {
            return this.element.find('summary').text();
        },

        _destroy: function () {
            $.Widget.prototype.destroy.apply(this, arguments); // default destroy

            !isDetailsSupported && this.element.removeClass("virtual-details");
        }
    });

    $(function () {
        $(document.body).on('click', 'summary', function (e) {
            var data = $.data($1(this).parent()[0], 'deets')
            , speed = data.options.speed
            , func
            ;

            if (!isDetailsSupported || speed) {
                e.preventDefault();
                (!data.isOpen ? open : close).call(data);
            }
        });

        $('details').each(function () {
            var $this = $1(this);

            $this.deets($this.data('deet'));
        });
    });
})(mrm.$);/*
	 2010 by Martin Teufel, OOP SOLUTIONS GmbH & Co. KG
*/
(function($){

  $.setBrowserVersion = function(){
    var browserVersion = $.browser.name+''+$.browser.version.replace(/\./g, "_");

    $('html').addClass(browserVersion);
  };
  
  $.setBrowserVersion();

})(mrm.$);
;(function($) {
	$.fn.dyntable = function(config) {
		var cfg = $.extend(true, {}, $.fn.dyntable.defaults, config || {}),
			selectors  = {
				headRow: !cfg.tbodyHeader ? 'thead tr:not(.groups):last' : 'tr.thead:not(.groups):first',
				groupRow: 'tr.thead.groups',
				bodyRows: !cfg.tbodyHeader ? 'tbody tr' : 'tbody tr:not(.groups)',
				footRows: 'tfoot tr:not(.expanderNav)'
		};

		function cacheTable($table) {
			var tableData = {
				bodyRows: [],
				footRows: []
			};
			$table.find(selectors.bodyRows).each(function() {
				var rowData = [];
				$(this).children().slice(cfg.preserveCols).each(function() {
					rowData.push($(this).html());
				});
				tableData.bodyRows.push(rowData);
			});
			$table.find(selectors.footRows).each(function() {
				var rowData = [];
				$(this).children().slice(cfg.preserveCols).each(function() {
					rowData.push($(this).html());
				});
				tableData.footRows.push(rowData);
			});
			return tableData;
		}

		function fetchColumnHeads($table) {
			var columnHeads = [];

			$table.find(selectors.headRow).children().slice(cfg.preserveCols).each(function() {
				columnHeads.push($(this).text());
			});
			return columnHeads;
		}

		function fetchAndRemoveColumnGroups($table) {
			// Check for optgroups and prepare the options data object for the fillSelect method accordingly
			var $groupRow = $(selectors.groupRow, $table),
				$groupHeaders = $groupRow.eq(0).find('th:gt(0)'),
				groups = [];

			$groupHeaders.each(function() {
				var $group = $(this),
					exclusions = $group.data('excludeDropdowns') !== undefined ? $group.data('excludeDropdowns') : [];

				if ( !$.isArray(exclusions) ) {
					exclusions = [exclusions]; // support number values
				}

				groups.push({
					label: $group.text(),
					length: parseInt($group.attr('colspan'), 10),
					excludeDropdowns: exclusions
				});

			});
			$groupRow.remove();
			return groups;
		}

		function createSelectOptData(columnHeads, columnGroups) {
			var selectOptData = [],
				offset = 0;

			// create the grouped options data if there are groups
			$.each(columnGroups, function() {
				var group = this,
					groupOptions;

				// get the correct slice of options for the optgroup and keep the original indexes (= option value)
				for (var i=0, groupOptions = {}; i < group.length; i++, offset++) {
					groupOptions[offset + 1] = columnHeads[offset];
				}

				selectOptData.push({
					groupLabel: group.label,
					options: groupOptions,
					excludeDropdowns: group.excludeDropdowns
				});

			});

			// if there are no groups, just clone the columnHeads arr
			if (!selectOptData.length) {
				selectOptData = columnHeads.slice(0);
			}

			// the next lines ensure that the index of of '0' is always reserved for the please choose option
			selectOptData.unshift(cfg.dropdownChooseText);
			if (!cfg.dropdownChooseText.length) {
				delete selectOptData[0];
			}
			return selectOptData;
		}

		function createDropdowns(selectOptData, ctxId) {
			var uniqueName = '',
				$selects = $(),
				filteredOptData = [];

			for (var i=0; i<cfg.dynCols; i++) {
				uniqueName = 'dynTabSel' + ctxId + i;
				$selects = $selects.add($('<select />').addClass('dynTable').attr({'name': uniqueName, 'id': uniqueName}));
				filteredOptData.push([]);
			}

			$.each(selectOptData, function(key, value) {
				if (!value) {
					return true;
				}

				$selects.each(function(selectIndex) {
					if ( value.excludeDropdowns && $.inArray(selectIndex, value.excludeDropdowns) > -1 ) {
						return;
					}
					filteredOptData[selectIndex][key] = value;
				});
			});

			$selects.each(function(selectIndex){
				mrm.util.fillSelect($selects.eq(selectIndex), filteredOptData[selectIndex]);
			});
			return $selects;
		}

		function setEventHandler($ctx, $selects, $table, columnHeads, tableCache) {
			$selects.change(function() {
				// separate cells
				if (cfg.mergeEqualCells) {
					separateCells($table);
				}
				populateColumn($table, columnHeads, tableCache, $selects.index($(this)), $(this).val());
				// merge cells
				if (cfg.mergeEqualCells) {
					mergeCells($table);
				}
			});
		}

		function insertDropdowns($ctx, $table, $selects) {
			var $insertRow, injectMethod,
				$label = cfg.dropdownLabelTxt.length ? $('<label />').text(cfg.dropdownLabelTxt) : $(),
				handleForAttr;

			handleForAttr = function() {
				return $(this).closest('ul.dynTabCtrl').find('select:eq(0)').attr('id');
			}

			// provide hook for a user-implemented insert method
			if ($.isFunction(cfg.onInsertDropdown)) {
				cfg.onInsertDropdown($ctx, $selects);
				return;
			}

			if (cfg.outsideDropdown) {
				$ctx.prepend(function() {
					var $inject = $('<ul class="dynTabCtrl" />').append($label).append($selects);
					$inject.children().wrap('<li />');
					return $inject;
				}).find('label').attr('for', handleForAttr);
				return;
			}

			// Create thead if it does not exist and set the appropriate injectMethod
			if ( !$('thead', $table).length ) {
				$table.prepend('<thead><tr /></thead>');
				injectMethod = 'replaceWith'
			} else {
				injectMethod = !cfg.tbodyHeader ? 'before':'after';
			}

			$('thead tr:last', $table)[injectMethod](function() {
				var $inject  = $('<tr class="selects dynTabCtrl" />').append(
					$('<th />').html('&nbsp;').attr('colspan', cfg.preserveCols)
				);
				$selects.before($label).appendTo($inject).wrap('<th />');
				return $inject;
			});

			
			$('thead tr.selects label', $table).attr('for', handleForAttr);
		}

		function populateColumn($table, columnHeads, tableCache, targetCol, dataCol) {
			var cellHtml = '';

			targetCol += cfg.preserveCols;
			dataCol--; // options index is not zero based (0=please choose)

			$(selectors.headRow, $table).children().eq(targetCol).html(
				dataCol > -1 ? cfg.colHeadReplaceTxt || columnHeads[dataCol] : ''
			);

			$(selectors.bodyRows, $table).each(function(rowCount) {
				if (dataCol > -1) {
					cellHtml = tableCache.bodyRows[rowCount][dataCol];
				} // else if dataCol=-1 (please choose) cellHtml remains unchanged ('')
				$(this).children().eq(targetCol).html(cellHtml);
			});

			$(selectors.footRows, $table).each(function(rowCount) {
				if (dataCol > -1) {
					cellHtml = tableCache.footRows[rowCount][dataCol];
				}
				// Dynamic prices from json for Canada
				if (mrm.util.locale.getCountry().toLowerCase()==="ca" && cellHtml !== "") {
					//a(w).filter(".dynPriceEh").attr("id")
					var myDataEh = $(".tbl").data();
					var $cellHtml = $(cellHtml);
					$cellHtml.filter(".dynPriceEh").each(function(){
						var seriesCode = this.id;
						if (myDataEh != undefined && !$.isEmptyObject(myDataEh) && myDataEh[seriesCode] != undefined) {
							// this price = data[series code][region] price
							$(this).find(".priceEh").html(myDataEh[seriesCode][mrm.util.locale.region].formattedPrice);
							//this postal code = mrm.util.location.getPostalCode()
							var postalCode = mrm.util.location.getPostalCode();
							if (postalCode) {
								$(this).find("postalCodeDisplay").html(postalCode);
							}
							// this disclaimers = data[series code][region] disclaimers
							$(this).find("#feeDisclaimer").html(myDataEh[seriesCode][mrm.util.locale.region].feeDisclaimer);
							$(this).find("#cashCreditDisclaimer").html(myDataEh[seriesCode][mrm.util.locale.region].cashCreditDisclaimer);
							$(this).find("#ownerCashDisclaimer").html(myDataEh[seriesCode][mrm.util.locale.region].ownerCashDisclaimer);

						}
					});
					cellHtml = $cellHtml.wrapAll("<div>").parent().html();
				}
				$(this).children().eq(targetCol).html(cellHtml);
			});
		}

		function mergeCells($table){
			$('tbody tr:not(.thead:first-child)', $table).each(function() {
				var $row = $(this),
					$tds = $('td:not(:first-child)', $row),
					$td1 = $tds.eq(0),
					$td2 = $tds.eq(1) || $(),
					$td3 = $tds.eq(2) || $();

				if($td1.html() == $td2.html()) {
					if($td1.html() == $td3.html()){
						$td1.addClass('highlight').attr('colspan', 3);
						$td2.addClass('hidden');
						$td3.addClass('hidden');
					} else {
						$td1.addClass('highlight').attr('colspan', 2);
						$td2.addClass('hidden');
					}
				} else if($td1.html() == $td3.html()) {
					$td1.addClass('highlight');
					$td3.addClass('highlight');
				} else if($td2.html() == $td3.html()) {
					$td2.addClass('highlight').attr('colspan', 2);
					$td3.addClass('hidden');
				}
			});
		}

		function separateCells($table){
			$('tbody tr:not(.thead:first-child) td', $table).removeClass('highlight hidden').attr('colspan', 1);
		}

		function shrinkTable($table) {
			// for thead/tbody/tfoot we assume either as many cells as there are columns in the tbody,
			// or a single one with a colspan (in which case we have to correct the colspan value)
			$('tr', $table).each(function() {
				$(this).children().slice(cfg.preserveCols + cfg.dynCols).remove();
			}).find(":only-child").attr('colspan', cfg.preserveCols + cfg.dynCols);
		}

		function setSelectedOptions($selects) {
			var selVal, $selectOption,
				cfgSi = cfg.selectedIndex;

			for (var i=0; i<cfg.dynCols; i++) {
				selVal = $.isArray(cfgSi) && cfgSi.length > i ? parseInt(cfgSi[i]) : cfg.selectedIndexDefault;

				$selectOption = $selects.eq(i).find('option[value="' + selVal + '"]');
				if (!$selectOption.length) {
					$selectOption = $selects.eq(i).children().first();
				}
				$selectOption.prop('selected', true).trigger('change');
			}
		}

		return this.each(function(ctxId) {
			var $selects, tableCache, columnHeads, selectOptData,
				$ctx          = $(this),
				$table        = $ctx.find('table:eq(0)'),
				columnCount   = $(selectors.headRow, $table).children().length;

			// get dynamic data for Canada
			if (mrm.util.locale.getCountry().toLowerCase()==="ca") {
				var callUrl = "/apps/servlets/bbcdataseries.json?segment=true&year="+cnt_tbl_fs_1_Year+"&carline="+cnt_tbl_fs_1_CarlineCode+"&bodystyle="+cnt_tbl_fs_1_BodystyleCode+"&path="+$('meta[name="contentpath"]').attr('content');
				$.ajax({
					url: callUrl,
					dataType: 'json',
					async: false,
					success: function(data){
						$table.data(data[cnt_tbl_fs_1_Year + "_" + cnt_tbl_fs_1_CarlineCode + "_" + cnt_tbl_fs_1_BodystyleCode]);
						$table.addClass("caData");
						var postalcode = mrm.util.location.getPostalCode();
						if (postalcode) {
							var clippedChangeRegion = $.Event("newClippedRegionEh", {postalCode: postalcode});
							$("body").trigger(clippedChangeRegion);
						}
					}
				});
			}

			//cfg.mergeEqualCells = $ctx.hasClass('tbl_merge');

			// do not even start if the table has not enough columns or the config makes no sense
			if (columnCount < cfg.minCols || columnCount <= cfg.preserveCols || !cfg.dynCols) {
				if (cfg.mergeEqualCells && columnCount <= 4) {
					mergeCells($table);
				}
				return;
			}

			tableCache    = cacheTable($table);
			columnHeads   = fetchColumnHeads($table);
			columnGroups  = fetchAndRemoveColumnGroups($table);
			selectOptData = createSelectOptData(columnHeads, columnGroups);
			$selects      = createDropdowns(selectOptData, ctxId);
			setEventHandler($ctx, $selects, $table, columnHeads, tableCache);
			shrinkTable($table);
			insertDropdowns($ctx, $table, $selects);
			setSelectedOptions($selects);

			// force IE8 to recompute the column-widths
			if( mrm.util.ie8() ) {
				//$table.addClass('dynTabFakeClass').removeClass('dynTabFakeClass'); back to old version, new one not working (anymore?).
				if ($table.prev().length) {
					$table.prev().after($table);
				} else {
					$table.parent().prepend($table);
				}
			}

		});
	};

	$.fn.dyntable.defaults = {
		minCols: 3, // all tables with less than this number of columns will be ignored by the plugin
		dynCols: 1, // how many dynamic columns should be created
		preserveCols: 1, // how many columns should stay untouched
		tbodyHeader: false, // if set to true the column heads are fetched from the first row of tbody instead of thead
		dropdownChooseText: '', // if this text is set it is used for the first option of each select (Please choose)
		colHeadReplaceTxt: '', // 
		dropdownLabelTxt: '', // 
		outsideDropdown: false, // 
		selectedIndex: [], //
		selectedIndexDefault: 1, // 
		onInsertDropdown: false, //
		mergeEqualCells: false // 
	}
})(mrm.$);/**
 * 
 * @author Christian Zindel <christian.zindel@namics.com>
 */

(function($) {
	$.widget("mrm.fancyCarousel", {

		options: { 
			param		: 'default',
			label		: {
				image			: 'Bild',
				textIndicator	: []
			},
			fancybox	: {
				onComplete	:	function() {
					$("#fancybox-outer").touchwipe({
						wipeLeft: function() {
							$.fancybox.prev();
						},
						wipeRight: function() {
							$.fancybox.next();
						}
					});
				}
			},
			caroufredsel: {
			},

			callbacks	: {
			}
		},
		
		_scrollerSelector	: 'dd[class*="indicator_"]',
		_counter 			: 0,
		_id					: '',
		_firstOpen			: true,
		_$carousel			: null,
		_posOffset			: 0,
		_galleryScrolled	: false,
		_enlargeClicked		: false,

		_create: function()
		{
			/*
				The mrm.fancy-carousel.js is currently only used in vi_3 and cnt_mmpar_1 at the moment,
				so i did a quickfix which select only the dd with the "indicator_" class on it, to not
				also catch ALL "dd > ul"s, because share_2 could be now placed into the mmpar.
			*/
			if( this.element.has(this._scrollerSelector + ' > ul').length )
			{
				this._id = Math.random().toString(16).slice(2, 10);
				this._initImageScroller();
			}
		},
	
		_initImageScroller : function()
		{
			this.element.find('> dl.figure > dt a.enlarge').click( $.proxy(this._scrollerEnlarge, this) );

			$('#fancybox-title ol.indicator_dot a').live('click', function(event){
				event.preventDefault();
				$.fancybox.pos( $(event.target).attr('href').replace(/^#/, '') );
			});

			this._initLightBoxGallery();
			this._initCarousel();
		},
		
		_initLightBoxGallery : function()
		{
			var $dd = this.element.find(this._scrollerSelector);

			if( $dd.hasClass('indicator_number') )
			{
				$.extend(this.options.fancybox, {titleFormat : $.proxy(this._titleFormatNumbers, this)});
			}
			else if( $dd.hasClass('indicator_dot') )
			{
				$.extend(this.options.fancybox, {titleFormat : $.proxy(this._titleFormatDots, this)});
			}	
			else if( $dd.hasClass('indicator_text') )
			{
				$.extend(this.options.fancybox, {titleFormat : $.proxy(this._titleFormatText, this)});
			}
			
			if(typeof(this.options.callbacks.onCloseWindow) == 'function')
			{
				$.extend(this.options.fancybox, {onClosed : $.proxy(function(){
					this.options.callbacks.onCloseWindow(this._$carousel.find('li:first a:first').attr('href').split( '/' ).pop());
				}, this)
				});
			}

			var $links = this.element.find('> dl.figure > dd a.lightbox');
			$links.click($.proxy(this._openLightbox, this));
		},
		
		_openLightbox : function(event)
		{
			event.preventDefault();

			if(this._enlargeClicked)
			{
				this._enlargeClicked = false;
				if(typeof(this.options.callbacks.onIconEnlarge) == 'function')
				{
					this.options.callbacks.onIconEnlarge($(event.currentTarget).attr('href').split( '/' ).pop());
				}
			}
			else
			{
				if(typeof(this.options.callbacks.onImageEnlarge) == 'function')
				{
					this.options.callbacks.onImageEnlarge($(event.currentTarget).attr('href').split( '/' ).pop());
				}
			}
			
			this._firstOpen = true;
			var galleryItems = $(event.target).closest('ul').find('a.lightbox').toArray(); // fancybox only accepts an array no jquery object
			$.fancybox(galleryItems, this.options.fancybox);
		},
		
		_initCarousel : function()
		{
			var prefix		= 'cnt_mmpar_1';
			var self = this;

			var $list		= this.element.find(this._scrollerSelector + '> ul');
			var $listItems	= $list.find('> li');
			
			if( $list.find('> li').length < 1) { return; }
			
			var nextId		= prefix + 'next-' + this._id;
			var prevId		= prefix + 'prev-' + this._id;
			var paginationId= prefix + 'pagination-' + this._id;

			$list.before('<span id="'+prevId+'" class="prev"></span>');
			if ( !this.options.caroufredsel.disablePagination ) {
				$list.after('<ol id="' + paginationId + '" class="paging"></ol>');
			}
			$list.after('<p class="indicator">'+this.options.label.image+' <span class="current"></span>/<span class="amount"></span></p>');
			$list.after('<span id="'+nextId+'" class="next"></span>');
			
			// extend options, some must be defined here for correct context
			this.options.caroufredsel.prev = { button : '#' + prevId };
			this.options.caroufredsel.next = { button : '#' + nextId };
			this.options.caroufredsel.pagination.container = '#' + paginationId;
			this.options.caroufredsel.scroll.onAfter = $.proxy(this._onAfterScroll, this);

			var createCallback = this.options.caroufredsel.onCreate;
			this.options.caroufredsel.onCreate = function($items) {
				self._markVisible($items);
				if ($.isFunction(createCallback)) createCallback($items);
			}
			
			// init text_indicator
			if( this.element.find('dd').hasClass('indicator_text') && this.options.label.textIndicator.length > 0 )
			{
				var that = this;
				this.options.caroufredsel.pagination.anchorBuilder = function(nr){
					return '<li><a href="#">' + that.options.label.textIndicator[nr-1] + '</a></li>';
				};
			}

			this._$carousel = $list.mrmCarousel( this.options.caroufredsel );
			
			this._$carousel
				.parent()
					.siblings('p.indicator')
						.find('span.amount')
							.text(this._$carousel.find('li').length)
							.end()
						.find('span.current')
							.text('1');
			
			this.element.find('dl.figure').width( $list.parent().width() );
		},

		/**
		 * Ads class 'ui-helper-visible' to the active slide for easier selection from outside
		 * @param $slide	active/visible slide
		 */
		_markVisible: function ($slide) {
			$slide.addClass('ui-helper-visible').siblings().removeClass('ui-helper-visible');
		},		

		_onAfterScroll: function ($oldItems, $newItems) {
			this._markVisible($newItems);
			this._updateNumericIndicator($oldItems);
		},
		
		_updateNumericIndicator : function( node)
		{
			var newPos = 0;
			this._$carousel.trigger("currentPosition", function( pos ) {
				    newPos = pos + 1;
			});
			this._$carousel.parent().siblings('p.indicator').find('span.current').text(newPos);
			
			if(this._galleryScrolled)
			{
				if(typeof(this.options.callbacks.onArrow) == 'function')
				{
					this.options.callbacks.onArrow(this._$carousel.find('li:first a:first').attr('href').split( '/' ).pop());
				}
				this._galleryScrolled = false;
			}
			else
			{
				if(typeof(this.options.callbacks.onDots) == 'function')
				{
					this.options.callbacks.onDots(this._$carousel.find('li:first img:first').attr('src').split( '/' ).pop());
				}
			}
		},
		
		_scrollerEnlarge : function( event )
		{
			event.preventDefault();

			this._enlargeClicked = true;
			
			var $this = $(event.currentTarget).closest('dt');
			$this.siblings('dd').find('ul > li:first a.lightbox').trigger('click');
		},

		_titleFormatDots : function(title, currentArray, currentIndex, currentOpts)
		{
			this._syncGalleryAndCarousel(currentIndex);
			
			var activeIndex = (currentIndex + this._posOffset) % currentArray.length;
			
			var tx = this._getCaptionText(currentArray[currentIndex], title);
			
			if( currentArray.length < 2) return tx;
			
			tx+= '<ol class="indicator_dot">';
			
			var that = this;
			$.each(currentArray, function(i, value){
				
				if( i == activeIndex )
				{
					tx+= '<li class="active">'+(i+1)+'</li>';
				}
				else
				{
					tx+= '<li><a href="#'+((currentArray.length+(i-that._posOffset))%currentArray.length)+'">'+(i+1)+'</a></li>';
				}
			});
			tx+= '</ol>';
			
			return tx;	
		},
		
		_titleFormatText : function(title, currentArray, currentIndex, currentOpts)
		{
			this._syncGalleryAndCarousel(currentIndex);
			
			var activeIndex = (currentIndex + this._posOffset)%currentArray.length;
			
			var tx = this._getCaptionText(currentArray[currentIndex], title);
			
			if( currentArray.length < 2) return tx;
			
			tx+= '<ol class="indicator_dot">';
			
			var that = this;
			$.each(currentArray, function(i, value){
				
				var label = i+1;
				
				if( that.options.label.textIndicator.length > 0 )
				{
					label = that.options.label.textIndicator[i];
				}
				
				if( i == activeIndex )
				{
					tx+= '<li class="active">'+label+'</li>';
				}
				else
				{
					tx+= '<li><a href="#'+((currentArray.length+(i-that._posOffset))%currentArray.length)+'">'+label+'</a></li>';
				}
			});
			tx+= '</ol>';
			
			return tx;	
		},
		
		_titleFormatNumbers : function(title, currentArray, currentIndex, currentOpts)
		{
			this._syncGalleryAndCarousel(currentIndex);
			
			var tx = this._getCaptionText(currentArray[currentIndex], title);
			
			if( currentArray.length < 2) return tx;
			
			tx+= '<p class="indicator_number">';
			tx+= this.options.label.image;
			tx+= (((currentIndex + this._posOffset)%currentArray.length)+1) + '/' + currentArray.length;
			tx+= '</p>';
			
			return tx;	
		},

		_getCaptionText : function(item, title)
		{
			var $caption = $(item).next('div.caption');
			if( $caption.length )
			{
				return $caption.html();
			}
			else{
				return (title && title.length ? '<p>' + title + '</p>' : '' );
			}
		},
		
		_syncGalleryAndCarousel : function(currentIndex)
		{
			var that = this;
			if(this._firstOpen)
			{
				this._firstOpen = false;
				this._$carousel.trigger("currentPosition", function( pos ) {
				    that._posOffset = pos;
				});
			}
			else
			{
				this._galleryScrolled = true;
				var pos = currentIndex;
				this._$carousel.trigger('slideTo', pos+this._posOffset);
			}
		}

	});
})(mrm.$);
(function ($) {

    // used to assign a unique ID to every generated hidden video
    var instances = 0;
    var allowedVideoTypes = ['youtube', 'bitrate', 'dam', 'brightcove'];
    var flashPreloaded = false;

    var defaults = {
        clickCursor: 'pointer',
        defaultCursor: 'default',
        ignoreDimensions: true, // ignores the dimensions set in .hidden-video and sets it to the dimensions of the parent
        overrideHeight: false,
        overrideWidth: false,
        targetElement: 'self',
        showControls: false,
        controlsTarget: 'self'
    };

    var jwDefaults = {
        autostart:' false',
        controlbar: 'none'
    };

    $.fn.hiddenVideo = function(options, jwOptions) {
        // TODO: utilize autoplay attribute
        // TODO: make click event available before the video is ready

        var $this = $(this);

        var options = $.extend({}, defaults, options);
        var jwOptions = $.extend({}, jwDefaults, jwOptions, {
            flashplayer: mrm.conf.corcmp.mmVideo.playerSwf,
            width: '100%',
            height: '100%'
        });
        if(flashPreloaded === false) {
            flashPreloaded = true;
            var flashPreloadID = 'hiddenvideo-preload';
            var flashPreloadInnerID = flashPreloadID + '_inner';

            $('<div/>', {
                id: flashPreloadID,
                css: {
                    width: '1px',
                    height: '1px',
                    visibility: 'hidden',
                    position: 'absolute',
                    bottom: '0',
                    left: '0'
                }
            }).append($('<div/>', { id:flashPreloadInnerID })).appendTo('body');

            jwplayer(flashPreloadInnerID).setup(jwOptions).onReady(function () {
                $('#' + flashPreloadID).remove();
            });
        }

        return $this.each(function () {
            var videoData = $(this).data();

            // check if the videoData has been set correctly
            if(videoData.url && videoData.type && $.inArray(videoData.type, allowedVideoTypes) > -1) {
                videoData.videoContainerID = 'hiddenvideo-container_' + (++instances);
                videoData.videoContainerInnerID = videoData.videoContainerID + '_inner';
                videoData.videoControlsID = videoData.videoContainerID + '_controls';
                videoData.currentState = 'none';
				videoData.videoId = $(this).parents('[id^="galleryitem"]').attr('id');


                $(this).on('videoPrepare', function(event) {
                    var $self = $(this);
                    var $target = options.targetElement == 'self' ? $(this) : $(options.targetElement);
                    var videoData = $(this).data();

                    if(videoData.currentState == 'none') {
                        videoData.currentState = 'preparing';

                        $('<div/>', {
                            id: videoData.videoContainerID,
							'class': 'hidden-video' ,
                            css: {
                                width: '1px',
                                height: '1px',
                                backgroundColor: '#000',
                                position: 'absolute',
                                top: '0',
                                left: '0',
                                zIndex: 1
                            }
                        }).data('vidId', videoData.videoId).append($('<div/>', { id:videoData.videoContainerInnerID})).appendTo($target);
						//added data vidId so that tracking can find the correct poster image GMDSST-54248

                        // html5 video hiding adjustments
                        if (!mrm.util.flash()) {
                            $('#' + videoData.videoContainerID).css({width:'100%',height:'100%',visibility:'hidden'});
                        }

                        var videoPlayer = jwplayer(videoData.videoContainerInnerID).setup($.extend({}, jwOptions, {
                            file:videoData.url
                        }));

						if($self.siblings('.end_frame_wrap').length){
							$target.find('> div').append($self.siblings('.end_frame_wrap').clone());
							$target.find('#'+videoData.videoContainerInnerID+'_wrapper').addClass('video');
							$this.data('preventAutoClear', true);
						}

                        videoPlayer.onReady(function () {
							setTimeout(function(){
								$self.css('cursor', options.clickCursor);
								$self.on('click', function (event) {
									if (!videoData.activated) {
                                     $self.trigger('videoActivate');
									}
									event.preventDefault();
								});

								if(options.showControls === true) {

									var controlsTarget = options.controlsTarget == 'self' ? $(this) : $(options.controlsTarget);

									// create the controls area
									$('<div/>', {
										'id': videoData.videoControlsID
									}).addClass('hiddenvideo-controls').append(
										'<div class="playpause"></div>'+
										'<div class="progress">'+
											'<div class="progress-inner">'+
											'</div>'+
										'</div>'
									).appendTo(controlsTarget);

									$('#' + videoData.videoControlsID + ' .playpause').on('click', function(event) {
										var videoPlayer = window.document[videoData.videoContainerInnerID];
										videoPlayer.sendEvent('PLAY');
										event.preventDefault();
									});

									videoPlayer.onTime(function(event) {
										$('#' + videoData.videoControlsID + ' .progress-inner').width(Math.round((100/event.duration)*event.position)+'%');
									});
								}

								videoData.currentState = 'prepared';
							}, 250);
                        });

						videoPlayer.onPlay(function(event){
							// force to the correct size for Firefox
							if(($('html').hasClass('firefox') || mrm.util.ie() || $('html').hasClass('unknownX')) && videoData.endFrameCall){
								$(videoPlayer.container).width(videoData.width).height(videoData.height);
							}
							if(typeof(Omniture_s) !== 'undefined') {
								if (event.oldstate === "PAUSED") {
									Omniture_s.Media.play(this.getPlaylistItem().file.split("/").pop(), this.getPosition());
								} else {

									Omniture_s.Media.open(this.getPlaylistItem().file.split('/').pop(), this.getDuration(), this.id);
									Omniture_s.Media.play(this.getPlaylistItem().file.split("/").pop(), this.getPosition());
								}
							}
						});
						videoPlayer.onPause(function (event) {
							var $end_frame = $('#'+videoData.videoContainerID).find('>div').siblings('.end_frame_wrap');
							if ($end_frame.length  && videoPlayer.getPosition() > 1) {
								mrm.ui.video_end_frame.initialize($end_frame, jwOptions, 'replay');
							}
							if(typeof(Omniture_s) !== 'undefined') {
								Omniture_s.Media.stop(this.getPlaylistItem().file.split('/').pop(), this.getPosition());
							}
						});
						videoPlayer.onComplete(function (event) {
							var $end_frame = $('#' + videoData.videoContainerID).find('>div').siblings('.end_frame_wrap');
							if ($end_frame.length) {
								mrm.ui.video_end_frame.initialize($end_frame, jwOptions, 'end');
							}
							if(typeof(Omniture_s) !== 'undefined') {
								Omniture_s.Media.close(this.getPlaylistItem().file.split('/').pop());
							}
						});
					 }
                });

                $(this).on('videoActivate', function(event, autoplay) {
                    var $self = $(this);
                    var $target = options.targetElement == 'self' ? $(this) : $(options.targetElement);
                    var videoData = $(this).data();
                    videoData.activated = true;
                    // stop all players before creating a new one
                    for (var i = jwplayer.getPlayers().length - 1; i >= 0; i--) {
                        try {
                            if (jwplayer.getPlayers()[i].getState() === "PLAYING") {
                                jwplayer.getPlayers()[i].stop(); // changed pause to stop to prevent endframe from showing GMDSST-54245
                            }
                        } catch(e){}
                    }
                    if (videoData.currentState == 'preparing') {
                        // if still preparing, try again in 200ms.
                        window.setTimeout(function(){
                            $self.trigger('videoActivate');
                        }, 200);
                    } else if (videoData.currentState == 'prepared') {
                        videoData.currentState = 'active';

                        var videoPlayer = jwplayer(videoData.videoContainerInnerID);

                        // set the width/height depending on the config
                        if(videoData.width && videoData.height && options.ignoreDimensions === false) {
                            $('#' + videoData.videoContainerID).css('width', videoData.width);
                            $('#' + videoData.videoContainerID).css('height', videoData.height);
                        } else {
                            $('#' + videoData.videoContainerID).css('width', $target.width());
                            $('#' + videoData.videoContainerID).css('height', $target.height());
                        }

                        if(options.overrideHeight !== false) {
                            $('#' + videoData.videoContainerID).css('height', options.overrideHeight);
                        }

                        if(options.overrideWidth !== false) {
                            $('#' + videoData.videoContainerID).css('width', options.overrideWidth);
                        }

                        // show the container and play the video
                        $('#' + videoData.videoContainerID).css('visibility', 'visible');

                        // add active class to controls if activated
                        if(options.showControls === true) {
                            $('#' + videoData.videoControlsID).addClass('active');
                        }

                        videoPlayer.onComplete(function () {
                            // reinit the video when it has finished playing.
							// unless flagged not to
							if(!videoData.preventAutoClear){
	                            $self.trigger('videoClear').trigger('videoPrepare');
							}
                        });

						if(!jwplayer.utils.isIOS()){
							videoPlayer.play();
						}
                    }
                });


                $(this).on('videoClear', function(event) {
                    var $self = $(this);
                    var $target = options.targetElement == 'self' ? $(this) : $(options.targetElement);
                    var videoData = $(this).data();
                    var videoPlayer = jwplayer(videoData.videoContainerInnerID);


                    if(videoData.currentState == 'prepared' || videoData.currentState == 'active') {
                        if (videoPlayer !== null) {
                            videoPlayer.stop();
                            videoPlayer.remove();
                        }
                        if(options.showControls === true) {
                            $('#' + videoData.videoControlsID).remove();
                        }

                        $('#' + videoData.videoContainerID).remove();
                        $target.css('cursor', options.defaultCursor);
                        $target.unbind('click');
                        videoData.currentState = 'none';
                    } else if(videoData.currentState == 'preparing') {
                        setTimeout(function(){
                            $self.trigger('videoClear');
                        }, 100);
                    }
                    videoData.currentState = 'none';
                    videoData.activated = false;
                });
            }
        });
    }


    $.fn.getHiddenVideoPlayerObject = function() {
        var $self = $(this).first();
        var videoData = $self.data();

        if(videoData.currentState !== 'none' && videoData.currentState !== 'undefined') {
            return jwplayer(videoData.videoContainerInnerID);
        } else {
            return false;
        }
    }
})(mrm.$);
;(function($) {
	$.fn.mrmEmbeddedIframe = function (config) {
		var defaultCfg = {
			setWidth: true,
			// these events (array or space-separated) are triggered on the iframe [-> in the parent page] after resizing
			onAfterResizeEvents: ['itemChange', 'updatedDOM'],
			handleIframe: $.noop
		};

		config = $.extend(true, defaultCfg, config || {});

		if ( !$.isArray(config.onAfterResizeEvents) ) {
			config.onAfterResizeEvents = config.onAfterResizeEvents.split(' ');
		} 

		return this.each(function(i) {

			var $iframe = $(this),
				eventName = 'message.mei_' + (new Date()).getTime();

			$(window).on(eventName, function(e) {
				var iframeWin = $iframe.get(0).contentWindow,
					postEvent = e.originalEvent,
					// data      = postEvent.data,
					// overcome IE8 postMessage limitations (no message objects)
					data      = JSON.parse(postEvent.data),
					newSizeUser;

				if ( !iframeWin ) {
					// that way we'll at least garbage collect the handlers of previously expired iframes
					// -> Expired iframe handlers only live until they catch a postMessage
					$(window).off(eventName);
				}

				if ( iframeWin !== postEvent.source ) {
					return;
				}

				// execute user defined callback
				if ( $.isFunction(config.handleIframe) ) {
					newSizeUser = config.handleIframe($iframe, data, e);
				}

				if ( newSizeUser === false ) {
					return;
				} else if ( !$.isPlainObject(newSizeUser) ) {
					newSizeUser = {};
				}

				// resize iframe
				$iframe.height(newSizeUser.height || data.height);

				if ( config.setWidth ) {
					$iframe.width(newSizeUser.width || data.width);
				}

				$.each(config.onAfterResizeEvents, function(i, eventName) {
					$iframe.trigger(eventName);
				});

			});

		});
	}

	$.fn.mrmEmbeddedIframe.initEmbedded = function (config) {

		var defaultCfg = {
			// list of events (as used by jQuery.on()) that should cause the iframe to resize
			resizeEvents: 'load resize',
			getSize: function() {
				var width = $(document).width(),
					height = $(document).height(),
					contentHeight = $('html').height();

				return {
					width : width,
					height: contentHeight < height ? contentHeight : height
				};
			}
		};

		config = $.extend(true, defaultCfg, config || {});

		$(window).on(config.resizeEvents, function(e) {
			var data = config.getSize();

			// window.top.postMessage(data, '*');
			// overcome IE8 postMessage limitations (no message objects)
			window.top.postMessage(JSON.stringify(data), '*');
		});

		// Keep form submits within the layer (thank you page should be embedded too)
		$('form').attr('target', '_self').attr('action', function(i, oldSrc) {
			return $.fn.mrmEmbeddedIframe.applyCurrentSelectors(oldSrc);
		});
	};

	$.fn.mrmEmbeddedIframe.isEmbeddedPage = function () {
		var isFrame = window.location != window.top.location,
			isEmbedded = $('html').hasClass('embedded');

		return !!(isFrame && isEmbedded);
	}

	$.fn.mrmEmbeddedIframe.slingSelectors = {
		contentOnly: 'contentOnly',
		embedded: 'embedded'
	};

	$.fn.mrmEmbeddedIframe.isContentOnlyMode = function () {
		// html class not yet implemented in the cms, but we should use it instead of url parsing
		// return $('html').hasClass('contentOnly'); 

		// in the meantime use this:
		var pattern = new RegExp('\.' + $.fn.mrmEmbeddedIframe.slingSelectors.contentOnly + '\.');
		return pattern.test(window.location);
	}

	/**
	 * Adds a sling selector to a given url
	 * @param {string} url - The url to append the sling selector to. The site/filename part
	 *                       has to end on "html" or "htm" (which is true for our cms generated pages)
	 * @param {mixed} - either a single key or an array of keys in $.fn.mrmEmbeddedIframe.slingSelectors
	 *                  Only selectors registered in that object can be used
	 */
	$.fn.mrmEmbeddedIframe.urlAddSelector = function (url, selector) {
		if ( !$.isArray(selector) ) {
			selector = [selector];
		}

		$.each(selector, function(selectorKey, selector) {
			var pattern = new RegExp('\.' + $.fn.mrmEmbeddedIframe.slingSelectors[selector] + '\.');
			if ( pattern.test(url) ) {
				return true; // continue
			}
			url = url.replace(/(\.html?)/, '.' + $.fn.mrmEmbeddedIframe.slingSelectors[selector] + '$1');
		});

		return url;
	}


	/**
	 * Takes a url and applys .embedded/.contentOnly sling selectors if they are set in the current location
	 * @param {string} url - The url to append the sling selector to. The site/filename part
	 *                       has to end on "html" or "htm" (which is true for our cms generated pages)
	 */
	$.fn.mrmEmbeddedIframe.applyCurrentSelectors = function (url) {
		var selectors = [];

		if ( $.fn.mrmEmbeddedIframe.isEmbeddedPage() ) {
			selectors.push($.fn.mrmEmbeddedIframe.slingSelectors.embedded);
		}

		if ( $.fn.mrmEmbeddedIframe.isContentOnlyMode() ) {
			selectors.push($.fn.mrmEmbeddedIframe.slingSelectors.contentOnly);
		}

		return $.fn.mrmEmbeddedIframe.urlAddSelector( url, selectors );
	}

})(jQuery);/**
 * Implements the onbeforeprint event for all browsers that
 * provide means of detecting it. Works for all the "big browsers" and more.
 * More specificly: Works for all browsers that either support the
 * matchMedia API (http://caniuse.com/#feat=matchmedia) or
 * window.onbeforeprint (IE5+, FF6+)
 *
 * If neither matchMedia nor onbeforeprint is supported, then there is afaik just no way
 * to detect the print request (at the time of this beeing written in September 2013)
 *
 * The detection is based on this article
 * http://tjvantoll.com/2012/06/15/detecting-print-requests-with-javascript/
 *
 * Due to the limited reliability of the onafterprint event detection, I chose to not implement it.
 *
 * USAGE: Nothing fancy, it's your vanilla jquery event.
 * use $(elem).on('mrmBeforePrint', handler) [or $(elem).on('mrmBeforePrint', selector, handler) for delegated events]
 * to bind the event to elem. The bound event handler will be called on (before) print.
 *
 * NOTE: The event only bubbles "under the hood" (to make delegation work), apart from beeig able to use
 * the jquery event delegation methods it won't appear to bubble at all.
 * For example: if the event is bound to an element and one of it's children, calling window.print() triggers the event
 * on both elements, but the parent won't actually catch the child elements event object but receive it's own one instead.
 *
 */
(function($){
	// Collection of elements to which the event is bound
	var $contexts = $(),
		handleObjs = [];

	// Special event definition.
	$.event.special.mrmBeforePrint = {
		setup: function()
		{
			$contexts = $contexts.add( this );
			// If it's the first context to bind this event (i.e. the event is bound the first time)
			if ( $contexts.length === 1 ) {
				setupPrintEventBindings();
			}
		},

		teardown: function()
		{
			$contexts = $contexts.not( this );
			// If it's the last element to unbind this event (i.e. the event is bound the first time)
			if ( !$contexts.length ) {
				removePrintEventBindings();
			}
		},
		remove: function( handleObj )
		{
			// Remove this context + handleObj from the array.
			var context = this;
			handleObjs = $.grep( handleObjs, function(v) {
				return v.context !== context || v.handleObj !== handleObj;
			});
		},

		add: function( handleObj )
		{
			// Save a reference to the bound event handler.
			var old_handler = handleObj.handler;

			handleObjs.push({ context: this, handleObj: handleObj });

			handleObj.handler = function( event )
			{
				var $target = $(event.target),
					$listeningElement = $(this);

				// While the event needs to bubble in general (support delegated events),
				// there is no use for it to bubble in the classic sense because the print event is
				// triggered on each element that bound it (or the elements matching a selector for delegated events)
				// but obviously does not originate there.
				// We do not want it to trigger handlers on it's way up the DOM,
				// unless it is the element the event was delegated to.
				if ( $target.is($listeningElement) )
				{
					// Call the originally-bound event handler and return its result.
					return old_handler.apply( this, arguments );
				}
			};
		}
	};

	function onBeforePrint()
	{
		var $elements = $();
		// Create a sorted, uniqued collection of elements selected by all
		// context + handleObj pairs
		$.each( handleObjs, function(i,item){
			if ( item.handleObj.selector ) {
				$elements = $elements.add( $(item.handleObj.selector, item.context) );
			}
			else
			{
				$elements = $elements.add( $(item.context) );
			}
		});

		$elements.trigger('mrmBeforePrint');
	}

	function printEventsSupported() {
		return window.onbeforeprint !== undefined;
	}

	function mediaQueryListHandlePrint(mql)
	{
		if (mql.matches)
		{
			onBeforePrint();
		}
	}

	function setupPrintEventBindings()
	{
		if ( !printEventsSupported() )
		{
			if ( window.matchMedia )
			{
				window.matchMedia('print').addListener(mediaQueryListHandlePrint);
			}
		}
		else
		{
			window.onbeforeprint = onBeforePrint;
		}
	};

	function removePrintEventBindings()
	{
		if ( !printEventsSupported() )
		{
			if ( window.matchMedia )
			{
				window.matchMedia('print').removeListener(mediaQueryListHandlePrint);
			}
		}
		else
		{
			window.onbeforeprint = null;
		}
	};
})(mrm.$);/*! Copyright (c) 2010 Brandon Aaron (http://brandonaaron.net)
 * Dual licensed under the MIT (MIT_LICENSE.txt)
 * and GPL Version 2 (GPL_LICENSE.txt) licenses.
 *
 * Version: 1.1.1
 * Requires jQuery 1.3+
 * Docs: http://docs.jquery.com/Plugins/livequery
 */

(function($) {

$.extend($.fn, {
	livequery: function(type, fn, fn2) {
		var self = this, q;

		// Handle different call patterns
		if ($.isFunction(type))
			fn2 = fn, fn = type, type = undefined;

		// See if Live Query already exists
		$.each( $.livequery.queries, function(i, query) {
			if ( self.selector == query.selector && self.context == query.context &&
				type == query.type && (!fn || fn.$lqguid == query.fn.$lqguid) && (!fn2 || fn2.$lqguid == query.fn2.$lqguid) )
					// Found the query, exit the each loop
					return (q = query) && false;
		});

		// Create new Live Query if it wasn't found
		q = q || new $.livequery(this.selector, this.context, type, fn, fn2);

		// Make sure it is running
		q.stopped = false;

		// Run it immediately for the first time
		q.run();

		// Contnue the chain
		return this;
	},

	expire: function(type, fn, fn2) {
		var self = this;

		// Handle different call patterns
		if ($.isFunction(type))
			fn2 = fn, fn = type, type = undefined;

		// Find the Live Query based on arguments and stop it
		$.each( $.livequery.queries, function(i, query) {
			if ( self.selector == query.selector && self.context == query.context &&
				(!type || type == query.type) && (!fn || fn.$lqguid == query.fn.$lqguid) && (!fn2 || fn2.$lqguid == query.fn2.$lqguid) && !this.stopped )
					$.livequery.stop(query.id);
		});

		// Continue the chain
		return this;
	}
});

$.livequery = function(selector, context, type, fn, fn2) {
	this.selector = selector;
	this.context  = context;
	this.type     = type;
	this.fn       = fn;
	this.fn2      = fn2;
	this.elements = [];
	this.stopped  = false;

	// The id is the index of the Live Query in $.livequery.queries
	this.id = $.livequery.queries.push(this)-1;

	// Mark the functions for matching later on
	fn.$lqguid = fn.$lqguid || $.livequery.guid++;
	if (fn2) fn2.$lqguid = fn2.$lqguid || $.livequery.guid++;

	// Return the Live Query
	return this;
};

$.livequery.prototype = {
	stop: function() {
		var query = this;

		if ( this.type )
			// Unbind all bound events
			this.elements.unbind(this.type, this.fn);
		else if (this.fn2)
			// Call the second function for all matched elements
			this.elements.each(function(i, el) {
				query.fn2.apply(el);
			});

		// Clear out matched elements
		this.elements = [];

		// Stop the Live Query from running until restarted
		this.stopped = true;
	},

	run: function() {
		// Short-circuit if stopped
		if ( this.stopped ) return;
		var query = this;

		var oEls = this.elements,
			els  = $(this.selector, this.context),
			nEls = els.not(oEls);

		// Set elements to the latest set of matched elements
		this.elements = els;

		if (this.type) {
			// Bind events to newly matched elements
			nEls.bind(this.type, this.fn);

			// Unbind events to elements no longer matched
			if (oEls.length > 0)
				$.each(oEls, function(i, el) {
					if ( $.inArray(el, els) < 0 )
						$.event.remove(el, query.type, query.fn);
				});
		}
		else {
			// Call the first function for newly matched elements
			nEls.each(function() {
				query.fn.apply(this);
			});

			// Call the second function for elements no longer matched
			if ( this.fn2 && oEls.length > 0 )
				$.each(oEls, function(i, el) {
					if ( $.inArray(el, els) < 0 )
						query.fn2.apply(el);
				});
		}
	}
};

$.extend($.livequery, {
	guid: 0,
	queries: [],
	queue: [],
	running: false,
	timeout: null,

	checkQueue: function() {
		if ( $.livequery.running && $.livequery.queue.length ) {
			var length = $.livequery.queue.length;
			// Run each Live Query currently in the queue
			while ( length-- )
				$.livequery.queries[ $.livequery.queue.shift() ].run();
		}
	},

	pause: function() {
		// Don't run anymore Live Queries until restarted
		$.livequery.running = false;
	},

	play: function() {
		// Restart Live Queries
		$.livequery.running = true;
		// Request a run of the Live Queries
		$.livequery.run();
	},

	registerPlugin: function() {
		$.each( arguments, function(i,n) {
			// Short-circuit if the method doesn't exist
			if (!$.fn[n]) return;

			// Save a reference to the original method
			var old = $.fn[n];

			// Create a new method
			$.fn[n] = function() {
				// Call the original method
				var r = old.apply(this, arguments);

				// Request a run of the Live Queries
				$.livequery.run();

				// Return the original methods result
				return r;
			}
		});
	},

	run: function(id) {
		if (id != undefined) {
			// Put the particular Live Query in the queue if it doesn't already exist
			if ( $.inArray(id, $.livequery.queue) < 0 )
				$.livequery.queue.push( id );
		}
		else
			// Put each Live Query in the queue if it doesn't already exist
			$.each( $.livequery.queries, function(id) {
				if ( $.inArray(id, $.livequery.queue) < 0 )
					$.livequery.queue.push( id );
			});

		// Clear timeout if it already exists
		if ($.livequery.timeout) clearTimeout($.livequery.timeout);
		// Create a timeout to check the queue and actually run the Live Queries
		$.livequery.timeout = setTimeout($.livequery.checkQueue, 20);
	},

	stop: function(id) {
		if (id != undefined)
			// Stop are particular Live Query
			$.livequery.queries[ id ].stop();
		else
			// Stop all Live Queries
			$.each( $.livequery.queries, function(id) {
				$.livequery.queries[ id ].stop();
			});
	}
});

// Register core DOM manipulation methods
$.livequery.registerPlugin('append', 'prepend', 'after', 'before', 'wrap', 'attr', 'removeAttr', 'addClass', 'removeClass', 'toggleClass', 'empty', 'remove', 'html');

// Run Live Queries when the Document is ready
$(function() { $.livequery.play(); });

})(mrm.$);/**
 * this is a customized version of the touchwipe plugin (see comment block below)
 * the difference to the original version is additional control over the default event (scrolling)
 * 1) The callbacks (wipeLeft, wipeRight, ...) receive the jQuery event object as a parameter.
 *    That way we can always use event.preventDefault() from within the callbacks 
 * 2) Added config parameters preventDefaultEventsHorizontal and preventDefaultEventsVertical.
 *    If set to true they will prevent the default event for horizontal/vertical wipes
 *    Setting either one of them true sets preventDefaultEvents to false, regardless of it's config value
 *
 * An example: For the masthead scroller (chevy) we want swipe ability (left/right), but since the masthead might use up
 * most (if not all) of the screen height, the user would not be able to scroll down the page if we prevented the default event
 * in general for all directions. Not preventing the default on the other hand leads to unforseen behaviour sometimes, as
 * parts of the scroller sometimes move due to the native scrolling.
 * To achieve horizontal wipe ability and vertical scroll ability at the same time, we can use a cfg like this
 * 
 * $(scrollerWrapper).touchwipe({
 *     wipeLeft: function(e) { scrollCarousel },
 *     wipeRight: function(e) { scrollCarousel },
 *     preventDefaultEventsHorizontal: true
 * });
 * 
 * OR
 *
 * $(scrollerWrapper).touchwipe({
 *     wipeLeft: function(e) { scrollCarousel },
 *     wipeRight: function(e) { scrollCarousel },
 *     wipeUp: function(e) { e.preventDefault(); },
 *     wipeDown: function(e) { e.preventDefault(); },
 *     preventDefaultEvents: false
 * });
 */

/**
 * jQuery Plugin to obtain touch gestures from iPhone, iPod Touch and iPad, should also work with Android mobile phones (not tested yet!)
 * Common usage: wipe images (left and right to show the previous or next image)
 *
 * @author Andreas Waltl, netCU Internetagentur (http://www.netcu.de)
 * @version 1.1.1 (9th December 2010) - fix bug (older IE's had problems)
 * @version 1.1 (1st September 2010) - support wipe up and wipe down
 * @version 1.0 (15th July 2010)
 */
(function($) {
$.fn.touchwipe = function(settings) {
	var config = {
			min_move_x: 20,
			min_move_y: 20,
			wipeLeft: function() { },
			wipeRight: function() { },
			wipeUp: function() { },
			wipeDown: function() { },
			preventDefaultEvents: true,
			preventDefaultEventsHorizontal: false,
			preventDefaultEventsVertical: false
	};

	if (settings) $.extend(config, settings);

	if (config.preventDefaultEventsHorizontal || config.preventDefaultEventsVertical) {
		config.preventDefaultEvents = false;
	}

	this.each(function() {
		var startX;
		var startY;
		var isMoving = false;

		function cancelTouch() {
			this.removeEventListener('touchmove', onTouchMove);
			startX = null;
			isMoving = false;
		}

		function onTouchMove(e) {
			if(config.preventDefaultEvents) {
				e.preventDefault();
			}
			if(isMoving) {
				var x = e.touches[0].pageX;
				var y = e.touches[0].pageY;
				var dx = startX - x;
				var dy = startY - y;
				if(Math.abs(dx) >= config.min_move_x) {
					cancelTouch();
					if(config.preventDefaultEventsHorizontal) {
						e.preventDefault();
					}
					if(dx > 0) {
						config.wipeLeft(e);
					}
					else {
						config.wipeRight(e);
					}
				}
				else if(Math.abs(dy) >= config.min_move_y) {
					cancelTouch();
					if(config.preventDefaultEventsVertical) {
						e.preventDefault();
					}
					if(dy > 0) {
						config.wipeDown(e);
					}
					else {
						config.wipeUp(e);
					}
				}
			}
		}

		function onTouchStart(e)
		{
			if (e.touches.length == 1) {
				startX = e.touches[0].pageX;
				startY = e.touches[0].pageY;
				isMoving = true;
				this.addEventListener('touchmove', onTouchMove, false);
			}
		} 
		if ('ontouchstart' in document.documentElement) {
			this.addEventListener('touchstart', onTouchStart, false);
		}
	});

	return this;
};

})(mrm.$);
/**
 * @author trixta
 */
(function($){
	$.userMode = (function(){
		var userBg, 
			timer, 
			testDiv,
			boundEvents = 0;
		
		function testBg(){
			testDiv = testDiv || $('<div></div>').css({position: 'absolute', left: '-999em', top: '-999px', width: '0px', height: '0px'}).appendTo('body');
			var black = $.curCSS( testDiv.css({backgroundColor: '#000000'})[0], 'backgroundColor', true),
				white = $.curCSS( testDiv.css({backgroundColor: '#ffffff'})[0], 'backgroundColor', true),
				newBgStatus = (black === white || white === 'transparent');
			if(newBgStatus != userBg){
				userBg = newBgStatus;
				$.event.trigger('_internalusermode');
			}
			return userBg;
		}
		
		function init(){
			testBg();
			timer = setInterval(testBg, 3000);
		}
		
		function stop(){
			clearInterval(timer);
			testDiv.remove();
			testDiv = null;
		}
		
		$.event.special.usermode = {
			setup: function(){
				(!boundEvents && init());
				boundEvents++;
				var jElem = $(this)
					.bind('_internalusermode', $.event.special.usermode.handler);
				//always trigger
				setTimeout(function(){
					jElem.triggerHandler('_internalusermode');
				}, 1);
                return true;
            },
			teardown: function(){
                boundEvents--;
				(!boundEvents && stop());
				$(this).unbind('_internalusermode', $.event.special.usermode.handler);
                return true;
            },
            handler: function(e){
                e.type = 'usermode';
				e.disabled = !userBg;
				e.enabled = userBg;
                return mrm.$.event.handle.apply(this, arguments);
            }
		};
		
		return {
			get: testBg
		};
		
	})();
	
	$.fn.userMode = function(fn){
		return this[(fn) ? 'bind' : 'trigger']('usermode', fn);
	};
	
	$(function(){
		$('html').userMode(function(e){
			$('html')[e.enabled ? 'addClass' : 'removeClass']('hcm');
		});
	});
})(mrm.$);
/**
 * @author alexander.farkas
 * @version 1.4.1
 * http://www.protofunc.com/scripts/jquery/checkbox-radiobutton/
 */
(function($){
	var baseClasses = /ui-checkbox|ui-radio/;
    $.widget('ui.checkBox', {
      options: {
        hideInput: true,
        addVisualElement: true,
        addLabel: true,
        _delegated: false
	    },
        _create: function(){
            var that = this,
				opts = this.options
			;

			if(!this.element.is(':radio,:checkbox')){
				if($.nodeName(this.element[0], 'input')){return false;}
				this._addDelegate();
				this.updateContainer();
				return false;
			}
      this.labels = $([]);

      this.checkedStatus = false;
			this.disabledStatus = false;
			this.hoverStatus = false;

      this.radio = (this.element.is(':radio'));

      this.visualElement = $([]);
      if (opts.hideInput) {
				this.element
					.addClass('ui-helper-hidden-accessible')
				;
				if(opts.addVisualElement){
					this.visualElement = $('<span />')
						.addClass(this.radio ? 'ui-radio' : 'ui-checkbox')
					;
					this.element.after(this.visualElement[0]);
				}
      }

			if(opts.addLabel){
				this.labels = $('label[for="' + this.element.attr('id') + '"]')
					.addClass(this.radio ? 'ui-radio' : 'ui-checkbox')
				;
			}
			if(!opts._delegated){
				this._addEvents();
			}
			this.initialized = true;
            this.reflectUI({type: 'initialReflect'});
			return undefined;
    },
		updateContainer: function(){
			if(!this.element.is(':radio,:checkbox') && !$.nodeName(this.element[0], 'input')){
				$('input', this.element[0])
					.filter(function(){
						return !($.data(this, 'checkBox'));
					})
					.checkBox($.extend({}, this.options, {_delegated: true}))
				;
			}
		},
		_addDelegate: function(){
			var opts 		= this.options,

				toggleHover = function(e, that){
					if(!that){return;}
					that.hover = !!(e.type == 'focus' || e.type == 'mouseenter' || e.type == 'focusin' || e.type == 'mouseover');
					that._changeStateClassChain.call(that);
					return undefined;
				}
			;


			this.element
				.bind('click', function(e){
					if(!$.nodeName(e.target, 'input')){return;}
					var inst = ($.data(e.target) || {}).checkBox;
					if(!inst){return;}
					inst.reflectUI.call(inst, e.target, e);
				})
				.bind('focusin.checkBox focusout.checkBox', function(e){
					if(!$.nodeName(e.target, 'input')){return;}
					var inst = ($.data(e.target) || {}).checkBox;
					toggleHover(e, inst);
				})
			;

			if (opts.hideInput){
				this.element
					.bind('usermode', function(e){
						if(!e.enabled){return;}
						$('input', this).each(function(){
		                    var inst = ($.data(this) || {}).checkBox;
							(inst && inst.destroy.call(inst, true));
						});
	                })
				;
            }

			if(opts.addVisualElement){
				this.element
					.bind('mouseover.checkBox mouseout.checkBox', function(e){
						if(!$.nodeName(e.target, 'span')){return;}
						var inst = ( $.data($(e.target).prev()[0]) || {} ).checkBox;
						toggleHover(e, inst);
					})
					.bind('click.checkBox', function(e){
						if(!$.nodeName(e.target, 'span') || !baseClasses.test( e.target.className || '' )){return;}
						$(e.target).prev()[0].click();
						return false;
					})
				;
			}
			if(opts.addLabel){
				this.element
					.delegate('label.ui-radio, label.ui-checkbox', 'mouseenter.checkBox mouseleave.checkBox', function(e){
						var inst = ( $.data(document.getElementById( $(this).attr('for') )) || {} ).checkBox;
						toggleHover( e, inst );
					});
			}

		},
		_addEvents: function(){
			var that 		= this,

				opts 		= this.options,

				toggleHover = function(e){
					if(that.disabledStatus){
						return undefined;
					}
					that.hover = (e.type == 'focus' || e.type == 'mouseenter');
					that._changeStateClassChain();
					return undefined;
				}
			;

			this.element
				.bind('click.checkBox', $.proxy(this, 'reflectUI'))
				.bind('focus.checkBox blur.checkBox', toggleHover)
			;
			if (opts.hideInput){
				this.element
					.bind('usermode', function(e){
	                    (e.enabled &&
	                        that.destroy.call(that, true));
	                })
				;
            }
			if(opts.addVisualElement){
					this.visualElement
						.bind('mouseenter.checkBox mouseleave.checkBox', toggleHover)
						.bind('click.checkBox', function(e){
							that.element[0].click();
							
							if( $.browser.opera || ($.browser.msie && $.browser.versionNumber < 9) ){
								// triggering the click does not lead to a change event in opera or old IEs, so we trigger change
								$(that.element[0]).trigger('change');
							}
							return undefined;
						})
					;
				}
			if(opts.addLabel){
				this.labels.bind('mouseenter.checkBox mouseleave.checkBox', toggleHover);
			}
		},
		_changeStateClassChain: function(){
			var allElements = this.labels.add(this.visualElement),
				stateClass 	= '',
				baseClass 	= 'ui-'+((this.radio) ? 'radio' : 'checkbox')
			;

			if(this.checkedStatus){
				stateClass += '-checked';
				allElements.addClass(baseClass+'-checked');
			} else {
				allElements.removeClass(baseClass+'-checked');
			}

			if(this.disabledStatus){
				stateClass += '-disabled';
				allElements.addClass(baseClass+'-disabled');
			} else {
				allElements.removeClass(baseClass+'-disabled');
			}
			if(this.hover){
				stateClass += '-hover';
				allElements.addClass(baseClass+'-hover');
			} else {
				allElements.removeClass(baseClass+'-hover');
			}

			baseClass += '-state';
			if(stateClass){
				stateClass = baseClass + stateClass;
			}

			function switchStateClass(){
				var classes = this.className.split(' '),
					found = false;
				$.each(classes, function(i, classN){
					if(classN.indexOf(baseClass) === 0){
						found = true;
						classes[i] = stateClass;
						return false;
					}
					return undefined;
				});
				if(!found){
					classes.push(stateClass);
				}
				this.className = classes.join(' ');
			}

			this.labels.each(switchStateClass);
			this.visualElement.each(switchStateClass);
		},
    destroy: function(onlyCss){
      this.element.removeClass('ui-helper-hidden-accessible');
			this.visualElement.addClass('ui-helper-hidden');
      if (!onlyCss) {
        var o = this.options;
        this.element.unbind('.checkBox');
				this.visualElement.remove();
                this.labels
					.unbind('.checkBox')
					.removeClass('ui-state-hover ui-state-checked ui-state-disabled')
				;
      }
    },

    disable: function(){
        this.element[0].disabled = true;
        this.reflectUI({type: 'manuallyDisabled'});
    },

    enable: function(){
        this.element[0].disabled = false;
        this.reflectUI({type: 'manuallyenabled'});
    },

    toggle: function(e){
        this.changeCheckStatus((this.element.is(':checked')) ? false : true, e);
    },

    changeCheckStatus: function(status, e){
        if(e && e.type == 'click' && this.element[0].disabled){
          return false;
        }
        this.element.prop('checked', status);
        this.reflectUI(e || {
            type: 'changeCheckStatus'
        });
        return undefined;
    },

    propagate: function(n, e, _noGroupReflect){
			if(!e || e.type != 'initialReflect'){
				if (this.radio && !_noGroupReflect) {
					//dynamic

	          $(document.getElementsByName(this.element.attr('name')))
						.checkBox('reflectUI', e, true);
	      }
	      return this._trigger(n, e, {
            options: this.options,
            checked: this.checkedStatus,
            labels: this.labels,
            disabled: this.disabledStatus
        });
			}
			return undefined;
    },

    reflectUI: function(e){

         var oldChecked 			= this.checkedStatus,
         oldDisabledStatus 	= this.disabledStatus
          ;

        this.disabledStatus = this.element.is(':disabled');
        this.checkedStatus = this.element.is(':checked');

        if (this.disabledStatus != oldDisabledStatus || this.checkedStatus !== oldChecked) {
          this._changeStateClassChain();

          (this.disabledStatus != oldDisabledStatus &&
            this.propagate('disabledChange', e));

          (this.checkedStatus !== oldChecked &&
            this.propagate('change', e));
        }
    },
    update: function(){
      this.reflectUI({type: 'change'});
    }

  });

  $.ui.checkBox.getter = "update";
    
})(mrm.$);

;( function( $ ) {
	$.widget( 'ui.infoBox', {

		options: {
			// gets extended per config

			trigger: false,
			target: false,

			// jqueryui position
			position: {
				my: 'center top',
				at: 'center bottom',
				offset: '0 10',
				collision: 'fit flip'
			},

			// behaviour
			openEvent: 'click',
			closeEvent: 'click',
			closeOnEsc: true,
			showCloseButton: true,
			openDelay: 0,
			closeDelay: 0,
			closeOnEsc: true,
			closeOnBoxLeave: false,
			addBoxClass: ''
		},

		_isOpen: false,
		_eventNamespace: '.infoBox',

		_create: function() {
			var self = this;

			self.$trigger = self.options.trigger ? self.element.find( self.options.trigger ) : self.element;
			self.$target = self.options.target ? self.element.find( self.options.target ) : $( self.element.data('infoboxId') );

			self._addEvents();

			// closeOnEsc
			if (self.options.closeOnEsc) {
				$(document).on('keyup', function(e) {
					if (e.keyCode == 27) {
						self.close();
					}
				});
			}
		},

		destroy: function() {
			this.$trigger
				.off( this.options.openEvent + this._eventNamespace )
				.off( this.options.closeEvent + this._eventNamespace );

			if ( this._isOpen ) {
				$.proxy( this._close, this );
			}
		},

		enable: function() {
			this._addEvents();
			this.element.disabled = false;
		},

		disable: function() {
			this.$trigger
				.off( this.options.openEvent + this._eventNamespace )
				.off( this.options.closeEvent + this._eventNamespace );

			if ( this._isOpen ) {
				this.close();
			}

			this.element.disabled = true;
		},

		_toggleMenu: function( event ) {
			if( this._isOpen ) {
				this._close(event);
			} else {
				this._open(event);
			}
		},

		_open: function( event ) {
			var self = this;

			if ( self.boxCloseTimeout ) {
				window.clearTimeout( self.boxCloseTimeout );
			}

			if ( event ) {
				event.stopPropagation();
				event.preventDefault();
			}

			if ( !self._isOpen ) {
				self.boxOpenTimeout = window.setTimeout( function() {
					self.open();
				}, self.options.openDelay );
			}
		},

		_close: function( event ) {
			var self = this;

			if ( self.boxOpenTimeout ) {
				window.clearTimeout( self.boxOpenTimeout );
			}

			if ( event ) {
				event.stopPropagation();
				event.preventDefault();
			}

			if ( self._isOpen ) {
				self.boxCloseTimeout = window.setTimeout( function() {
					self.close();
				}, self.options.closeDelay );
			}
		},

		open: function() {
			var self = this;

			self.$targetClone = self.$target.clone().removeAttr( 'id' ).appendTo( 'body' );

			if ( !self.options.showCloseButton ) {
				self.$targetClone.find( '.close' ).hide();
			} else {
				self.$targetClone.find( '.close' ).one( 'click', function() {
					self.close();
				});
			}

			if ( self.options.closeOnBoxLeave ) {
				self.$targetClone.on( 'mouseenter' + self._eventNamespace, function() {
					window.clearTimeout( self.boxCloseTimeout );
				});

				self.$targetClone.on( 'mouseleave' + self._eventNamespace, function() {
					self._close();
				});
			}

			self.$targetClone.find( '> div' ).on( 'click', function( event ) {
				event.stopPropagation();
			});

			self.$targetClone.addClass(self.options.addBoxClass).fadeIn( function() {
				/* IMPORTANT: class "open" (or at least any class) must be added to trigger reflow in IE */
				$( this ).focus().addClass( 'ui-infobox open' );
			});

			self._setPosition();
			self.$trigger.addClass( 'ui-state-opened' );
			self._isOpen = true;
			self._trigger( 'open' );
		},

		close: function() {
			if( this._isOpen ) {
				this.$trigger.removeClass( 'ui-state-opened' );
				this.$targetClone.fadeOut( 'fast', function() {
					$( this ).remove();
				} );

				this._isOpen = false;
				this._trigger( 'close' );
			}
		},

		update: function() {
			if( !this._isOpen ) {
				return;
			}

			this._setPosition();
		},

		_setPosition: function() {
			var self = this;

			self.$targetClone.position({
				my: self.options.position.my,
				at: self.options.position.at,
				of: self.$trigger,
				offset: self.options.position.offset,
				collision: self.options.position.collision,
				using: function(coords) {
					var $this = $(this);
					var triggerOffset = self.$trigger.offset();

					$this
						.css({
							left: coords.left + 'px',
							top: coords.top + 'px'
						})
						.removeClass(function(index, css) {
							return(css.match(/\btt-p-\w+/g) || []).join(' ');
						});

					// vertical position
					if (triggerOffset.top >= (coords.top + $this.outerHeight())) {
						$this.addClass('tt-p-top');
					} else if (triggerOffset.top + self.$trigger.outerHeight() <= coords.top) {
						$this.addClass('tt-p-bottom');
					}

					// horizontal position
					if (triggerOffset.left + self.$trigger.outerWidth() <= coords.left) {
						$this.addClass('tt-p-right');
					} else if (triggerOffset.left >= coords.left + $this.outerWidth()) {
						$this.addClass('tt-p-left');
					}

				}
			});
		},

		_addEvents: function() {
			if ( this.options.openEvent == this.options.closeEvent ) {
				this.$trigger.on( this.options.openEvent + this._eventNamespace, $.proxy( this._toggleMenu, this ) );
			} else {
				this.$trigger
					.on( this.options.openEvent + this._eventNamespace, $.proxy( this._open, this ) )
					.on( this.options.closeEvent + this._eventNamespace, $.proxy( this._close, this ) );
			}
		}
	});
})( mrm.$ );


/**
 * 
 * @author Oliver Bosse <oliver.bosse@mrm.de>
 * This is the wrapper for the carousel.
 * Its purpose is to capsulate general and extended functionality without modifying the plugin itself.
 * Another purpose is to provide a standard interface to make it possible to change the underlying carousel 
 * functionality in the future with any other technical solution that is available without changing the interface.
 */

;
(function($) {
	$.fn.mrmCarousel = function(config)	{	
		var $validCollection = $();
		this.each(function(i) 
		{
			var $currentElement = $(this);
			var $currentElementItems = $currentElement.children();
			
			if($currentElementItems.not(":visible").length === 0 || config.hiddenItemOverride === true) // ummm if there is no hidden items
				{
					$validCollection = $validCollection.add($currentElement);
				}
			});
			return $validCollection.carouFredSel(config);
		};
})(mrm.$);/*
	This is the wrapper for the cluetip-plugin.
	Its purpose is to capsulate general, extended functionality without modifying the plugin itself.
*/
;(function($) {

	$.fn.cluetipWrap = function(js, options) {
		// to be consitent to cluetip.js
		var opts = options || {};
		if (typeof js == 'object') {
			opts = js;
		}

			// extend options with defaults
			/*
				Fix this to use $.fn.cluetipWrap.default:
			Every property which is overridden after using $.extend will be set as it
			was set before extending the opts-object when cluetip uses the config-object.
			*/
			// opts = $.extend(true, {}, $.fn.cluetipWrap.defaults, opts);

		// extend onShow
		var customOnShow = $.isFunction(opts.onShow) ? opts.onShow : function() {};
		opts.onShow = function($cTip, $cTipInner, triggerElem) {
			customOnShow.call(this, $cTip, $cTipInner, triggerElem);

			// custom centerFunction
			var func = $.fn.cluetipWrap.functions[opts.positionByMethod];
			if ($.isFunction(func)) {
				func.call(this, $cTip, $cTipInner, triggerElem);
			}

			if (opts.liveLeftPosition){
				$.fn.cluetipWrap.functions['liveLeftPosition'].call(this, $cTip, triggerElem, opts.liveLeftOffset);
			}

			if (opts.newPosition){
				$.fn.cluetipWrap.functions['newPosition'].call(this, $cTip, triggerElem, opts.liveLeftOffset, opts.liveTopOffset);
			}

			if (opts.disableScroll) {
				$cTip.css({
					position: 'fixed',
					top: $cTip.offset().top - $(document).scrollTop()
				});
			}
		};

		// extend onHide
		var customOnHide = $.isFunction(opts.onHide) ? opts.onHide : function() {};
		opts.onHide = function($cTip) {
			customOnHide.call(this, $cTip);

			// If the tooltip is opened again while the old animation is still running, the custom positioning makes mistakes
			// solution: stop the fadeIn animation that might be still running.
			$cTip.stop(true, true);
		};

		// prepareTitleAttr
		if (opts.prepareTitleAttr === true) {
			$.fn.cluetipWrap.functions.prepareTitleAttr(this);
		}

		// call native plugin
		this.each(function(){
			var $this = $(this);

			if (!opts.cluetipClass) {
				// this will add class "header-area-tooltip" to the tooltip if the referenced link
				// stay in the "mds-area-header" container
				opts.cluetipClass = $this.closest('#mds-area-header').length > 0 ? 'header-area-tooltip' : 'default';
			}
			$this.cluetip(js, opts);
		});
		// wrap for NGDOE compatibility
		if (typeof(MRM_EXTERNAL_DOMAIN) === "string") {
			if (!$('div.gmdsWidget div#cluetip').length && ($('div#cluetip').length)) {
				$('div#cluetip').wrap('<div class="gmdsWidget" />');
			}
		}
	};

	/** Wrapper-Defaults */
	$.fn.cluetipWrap.defaults = {
		prepareTitleAttr: false,
		disableScroll: false, // If true, keeps cluetip pegged to absolute positioned element when scrolling
		positionByMethod: '' // '', 'hCenter', 'vCenter'
	};

	/**
		Wrapper-Functions
	*/
	$.fn.cluetipWrap.functions = {
		/**
			this prefixes the elements title-attribute with "splitTitle" to let cluetip set its bodys content
		*/
		prepareTitleAttr: function($elements) {
			$elements.attr('title', function(i, oldTitle) {
				return (mrm.conf.plugin.cluetip.splitTitle || '|') + oldTitle;
			});
			return $elements;
		},

		/**
			this centers the cluetip horizontally on the referenced root-element and
			flips it vertically if it does not fit in the window when positioned above.
		*/
		hCenter: function($cTip, $cTipInner, triggerElem) {
			triggerElem = triggerElem || this;
			$triggerElem = $(triggerElem);

			var sTop = $(document).scrollTop();
			var offset = 5;
			$cTip.position({
				of: $triggerElem,
				my: 'center bottom',
				at: 'center top',
				offset: '0',
				collison: 'none',
				using: function(pos) {
					$cTip.css('left', pos.left);
					$cTip.removeClass('clue-bottom-default clue-top-default');
					if (pos.top - offset < (sTop+210)) {
						// down under
						$cTip.css('top', $triggerElem.offset().top + $triggerElem.height() + offset);
						$cTip.addClass('clue-bottom-default');
					} else {
						// upper
						$cTip.css('top', pos.top - offset);
						$cTip.addClass('clue-top-default');
					}
					// fixes cluetips so they don't appear outside window on left
                    var curLeft = parseInt($cTip.css("left").replace("px",""));
                    if ( curLeft < 0 ) {
                        $cTip.css("margin-left",(0-curLeft) + "px");
                    }
				}
			});
		},

		/**
			onShow callback for cluetip that overrides the vertical positioning of the
			tooltip and it's arrow if the tooltip is displayed to the left or the right of the
			invoking element

			While cluetip is a very versatile plugin, it could not match all of our requirements.
			(i.e. it does not center the tooltip to the invoking element, it does not point the arrow
			exactly to the (vertical) center of the invoking element)

			This function implements the following vertical positioning rules:
			Since this function aims to center the tooltip next to it's trigger, any configured
			cluetip value for 'topOffset' will be ignored.
			However, horizontal positioning of any kind stays untouched and is left to cluetip!

			- Position the arrow's center as close to the vertical center of the invoking element as possible
			- Position the tooltip's center as close to the arrow's center as possible
			- Do not not place parts of the tooltip outside the viewport unless the viewport is too small
			- If the tooltip is too tall for the viewport the tooltip is placed on the upper edge of the viewport
			(e.g. bottom part gets "cut off" by the viewport)
		*/
		vCenter: function($cTip, $cTipInner, triggerElem) {
			if (!/clue-right|clue-left/.test($cTip.attr('class'))) {
				return;
			}

			triggerElem = triggerElem || this;

			var pointTo, moveTopBy, arrowOffset,
				$cTipArrow = $('#cluetip-arrows:visible'),
				$triggerElem = $(triggerElem),
				tipHeight   = $cTip.outerHeight(),
				tipOffset   = $cTip.offset(),
				arrowHeight = $cTipArrow.outerHeight() || 0,
				viewportBoundaries = {
					top: $(document).scrollTop(),
					bottom: $(document).scrollTop() + $(window).height()
				};

			// set the desired y-coordinate to point the arrow to (the vertical center of the invoking element)
			pointTo     = $triggerElem.offset();
			pointTo.top = Math.round(pointTo.top + $triggerElem.outerHeight()/2);
			/* ------------------------------------
			calculate the new tooltip position
			------------------------------------ */
			tipOffset.left = Math.round(tipOffset.left);
			tipOffset.top  = pointTo.top;

			// Check if the arrow (and thus the tooltip) will even fit into the viewport if it is centered with pointTo
			if (pointTo.top >= viewportBoundaries.top + arrowHeight/2 && pointTo.top <= viewportBoundaries.bottom - arrowHeight/2) {
				// if it does fit, position the tooltip in relation to pointTo:
				// 1) Move the tooltip up by either half it's height or the distance to the upper viewport edge
				// 2) If the tooltip still sticks out the lower edge of the viewport position it further up
				//    until it is either fully visible or the upper edge of the viewport is reached
				moveTopBy = Math.min(
					pointTo.top - viewportBoundaries.top,
					pointTo.top + tipHeight/2 <= viewportBoundaries.bottom ?
						tipHeight/2 :
						tipHeight - viewportBoundaries.bottom + pointTo.top
				);
				tipOffset.top -= Math.round(moveTopBy);
				$cTipArrow.css('top', parseInt(moveTopBy - arrowHeight/2, 10));
			}
			else {
				// if the arrow would get out of the viewport when centered at the pointTo coordinate
				// -> position the tooltip right at the edge of the viewport
				if (pointTo.top < viewportBoundaries.top + arrowHeight) {
					tipOffset.top = viewportBoundaries.top;
					arrowOffset   = 0;
				}
				else {
					tipOffset.top = viewportBoundaries.bottom - tipHeight;
					arrowOffset   = tipHeight - arrowHeight;
				}
				$cTipArrow.css('top', arrowOffset);
			}

			/* ------------------------
			position the tooltip
			------------------------ */
			$cTip.offset(tipOffset);
		},
		liveLeftPosition: function($cTip, triggerElem, leftOffset) {			
			triggerElem = triggerElem || this;
			leftOffset = leftOffset || 0;
			var $triggerElem = $(triggerElem),
			triggerOffset = $triggerElem.offset(),
			tipOffset = $cTip.offset();
			tipOffset.left = triggerOffset.left + $triggerElem.width() + leftOffset;
			$cTip.offset(tipOffset);
		},
		newPosition: function($cTip, triggerElem, leftOffset, topOffset) {
			triggerElem = triggerElem || this;
			leftOffset = (leftOffset == 0) ? -($('#cluetip-outer').width()) : 20;
			topOffset = (topOffset == 0) ? -($('#cluetip-outer').height() + 10) : 30;
			
			var $triggerElem = $(triggerElem),
			triggerOffset = $triggerElem.offset(),
			tipOffset = $cTip.offset();
		   // for options in author having cluetip position top, right, bottom, left relative to mouse cursor
			$triggerElem.mousemove( function (e){
				tipOffset.left = e.pageX + leftOffset;
				tipOffset.top = e.pageY + topOffset;
				$cTip.offset(tipOffset);
			});
		}
	};
})(mrm.$);;(function($) {
	$.fn.mrmDialog = function mrmDialog(config) {
		config = $.isPlainObject(config) ? config : {};

		var cfg, wrapperCfg, optionExtension, methodExtension;

		optionExtension = {
			// set default values for mrmDialog wrapper specific options 
			closeOnClickOfModalLayer: true,
			initDomContent: false,
			destroyOnClose: false,
			resizeEvent: 'itemChange'
		};

		cfg = $.extend(true, optionExtension, mrm.conf.plugin.ui_dialog || {}, config);

		methodExtension = {
			open: function(event, ui){
				if ( cfg.closeOnClickOfModalLayer ) {
					$('.ui-widget-overlay').one('click.mrmDialog', function() {
						$(event.target).dialog('close');
					});
				}
				if ( cfg.initDomContent ) {
					mrm.util.initDomContent($(event.target));
				}
				$(this).find('.caroufredsel_wrapper').trigger('itemChange');

				return (cfg.open || $.noop) (event, ui);
			},
			close: function(event, ui){
				var $this = $(this); // dialog-content

				// deactivate video, 
				// TODO: all underneath this could be removed?
				mrm.corcmp.mmVideo.deactivateVideo($this);

				// stop jwplayers when closing (GMDSSDS-19413)
				var $fl = $('object[type="application/x-shockwave-flash"]', this);
				$fl.each(function() {
					// jwplayer-api does not work, so we had to use the native flash-api.
					try { this.sendEvent('STOP'); } catch(e) {}
				}); 
				if ($fl.length || cfg.destroyOnClose) {
					$this.dialog('destroy').remove();
				}

				return (cfg.close || $.noop) (event, ui);
			}
		};

		wrapperCfg = $.extend(true, {}, cfg, methodExtension);

		function autoResize(e,newDimensions) {
			var $dialog = $(this),
				isMmContentDialog = $dialog.closest('.ui-dialog.mm-content').length > 0,
				$carouselWrp,
				resetVal = $dialog.css('overflow');

			if (!newDimensions || !isMmContentDialog) {
				$carouselWrp = $dialog.find('.caroufredsel_wrapper');
				if ($carouselWrp.length && isMmContentDialog) {
					newDimensions = {
						width: $carouselWrp.width(),
						height: $carouselWrp.height()
					};
				} else {
					newDimensions = {
						width: 'auto',
						height: 'auto'
					};
				}
			}

			$dialog.dialog('option', {
				width: newDimensions.width,
				height: newDimensions.height
			});
			$dialog.css('overflow', 'hidden').dialog('option', 'position', cfg.position || 'center').css('overflow', resetVal);
		}

		return this.each(function(i) {
			var $currentElement = $(this);

			$currentElement.dialog(wrapperCfg);
			if (cfg.resizeEvent) {
				$currentElement.off('.mrmDialog');
				$currentElement.on(cfg.resizeEvent + '.mrmDialog', autoResize);
			}

		});
	}
})(mrm.$);/*! pym.js - v1.2.2 - 2017-05-20 */
!function(a){"function"==typeof define&&define.amd?define(a):"undefined"!=typeof module&&module.exports?module.exports=a():window.pym=a.call(this)}(function(){var a="xPYMx",b={},c=function(a){var b=document.createEvent("Event");b.initEvent("pym:"+a,!0,!0),document.dispatchEvent(b)},d=function(a){var b=new RegExp("[\\?&]"+a.replace(/[\[]/,"\\[").replace(/[\]]/,"\\]")+"=([^&#]*)"),c=b.exec(location.search);return null===c?"":decodeURIComponent(c[1].replace(/\+/g," "))},e=function(a,b){if(("*"===b.xdomain||a.origin.match(new RegExp(b.xdomain+"$")))&&"string"==typeof a.data)return!0},f=function(b,c,d){var e=["pym",b,c,d];return e.join(a)},g=function(b){var c=["pym",b,"(\\S+)","(.*)"];return new RegExp("^"+c.join(a)+"$")},h=function(){for(var a=b.autoInitInstances.length,c=a-1;c>=0;c--){var d=b.autoInitInstances[c];d.el.getElementsByTagName("iframe").length&&d.el.getElementsByTagName("iframe")[0].contentWindow||b.autoInitInstances.splice(c,1)}};return b.autoInitInstances=[],b.autoInit=function(a){var d=document.querySelectorAll("[data-pym-src]:not([data-pym-auto-initialized])"),e=d.length;h();for(var f=0;f<e;++f){var g=d[f];g.setAttribute("data-pym-auto-initialized",""),""===g.id&&(g.id="pym-"+f+"-"+Math.random().toString(36).substr(2,5));var i=g.getAttribute("data-pym-src"),j={xdomain:"string",title:"string",name:"string",id:"string",sandbox:"string",allowfullscreen:"boolean",parenturlparam:"string",parenturlvalue:"string",optionalparams:"boolean"},k={};for(var l in j)if(null!==g.getAttribute("data-pym-"+l))switch(j[l]){case"boolean":k[l]=!("false"===g.getAttribute("data-pym-"+l));break;case"string":k[l]=g.getAttribute("data-pym-"+l);break;default:console.err("unrecognized attribute type")}var m=new b.Parent(g.id,i,k);b.autoInitInstances.push(m)}return a||c("pym-initialized"),b.autoInitInstances},b.Parent=function(a,b,c){this.id=a,this.url=b,this.el=document.getElementById(a),this.iframe=null,this.settings={xdomain:"*",optionalparams:!0,parenturlparam:"parentUrl",parenturlvalue:window.location.href},this.messageRegex=g(this.id),this.messageHandlers={},c=c||{},this._constructIframe=function(){var a=this.el.offsetWidth.toString();this.iframe=document.createElement("iframe");var b="",c=this.url.indexOf("#");for(c>-1&&(b=this.url.substring(c,this.url.length),this.url=this.url.substring(0,c)),this.url.indexOf("?")<0?this.url+="?":this.url+="&",this.iframe.src=this.url+"initialWidth="+a+"&childId="+this.id,this.settings.optionalparams&&(this.iframe.src+="&parentTitle="+encodeURIComponent(document.title),this.iframe.src+="&"+this.settings.parenturlparam+"="+encodeURIComponent(this.settings.parenturlvalue)),this.iframe.src+=b,this.iframe.setAttribute("width","100%"),this.iframe.setAttribute("scrolling","no"),this.iframe.setAttribute("marginheight","0"),this.iframe.setAttribute("frameborder","0"),this.settings.title&&this.iframe.setAttribute("title",this.settings.title),void 0!==this.settings.allowfullscreen&&this.settings.allowfullscreen!==!1&&this.iframe.setAttribute("allowfullscreen",""),void 0!==this.settings.sandbox&&"string"==typeof this.settings.sandbox&&this.iframe.setAttribute("sandbox",this.settings.sandbox),this.settings.id&&(document.getElementById(this.settings.id)||this.iframe.setAttribute("id",this.settings.id)),this.settings.name&&this.iframe.setAttribute("name",this.settings.name);this.el.firstChild;)this.el.removeChild(this.el.firstChild);this.el.appendChild(this.iframe),window.addEventListener("resize",this._onResize)},this._onResize=function(){this.sendWidth()}.bind(this),this._fire=function(a,b){if(a in this.messageHandlers)for(var c=0;c<this.messageHandlers[a].length;c++)this.messageHandlers[a][c].call(this,b)},this.remove=function(){window.removeEventListener("message",this._processMessage),window.removeEventListener("resize",this._onResize),this.el.removeChild(this.iframe),h()},this._processMessage=function(a){if(e(a,this.settings)&&"string"==typeof a.data){var b=a.data.match(this.messageRegex);if(!b||3!==b.length)return!1;var c=b[1],d=b[2];this._fire(c,d)}}.bind(this),this._onHeightMessage=function(a){var b=parseInt(a);this.iframe.setAttribute("style","height: "+b+"px")},this._onNavigateToMessage=function(a){document.location.href=a},this._onScrollToChildPosMessage=function(a){var b=document.getElementById(this.id).getBoundingClientRect().top+window.pageYOffset,c=b+parseInt(a);window.scrollTo(0,c)},this.onMessage=function(a,b){a in this.messageHandlers||(this.messageHandlers[a]=[]),this.messageHandlers[a].push(b)},this.sendMessage=function(a,b){this.el.getElementsByTagName("iframe").length&&(this.el.getElementsByTagName("iframe")[0].contentWindow?this.el.getElementsByTagName("iframe")[0].contentWindow.postMessage(f(this.id,a,b),"*"):this.remove())},this.sendWidth=function(){var a=this.el.offsetWidth.toString();this.sendMessage("width",a)};for(var d in c)this.settings[d]=c[d];return this.onMessage("height",this._onHeightMessage),this.onMessage("navigateTo",this._onNavigateToMessage),this.onMessage("scrollToChildPos",this._onScrollToChildPosMessage),window.addEventListener("message",this._processMessage,!1),this._constructIframe(),this},b.Child=function(b){this.parentWidth=null,this.id=null,this.parentTitle=null,this.parentUrl=null,this.settings={renderCallback:null,xdomain:"*",polling:0,parenturlparam:"parentUrl"},this.timerId=null,this.messageRegex=null,this.messageHandlers={},b=b||{},this.onMessage=function(a,b){a in this.messageHandlers||(this.messageHandlers[a]=[]),this.messageHandlers[a].push(b)},this._fire=function(a,b){if(a in this.messageHandlers)for(var c=0;c<this.messageHandlers[a].length;c++)this.messageHandlers[a][c].call(this,b)},this._processMessage=function(a){if(e(a,this.settings)&&"string"==typeof a.data){var b=a.data.match(this.messageRegex);if(b&&3===b.length){var c=b[1],d=b[2];this._fire(c,d)}}}.bind(this),this._onWidthMessage=function(a){var b=parseInt(a);b!==this.parentWidth&&(this.parentWidth=b,this.settings.renderCallback&&this.settings.renderCallback(b),this.sendHeight())},this.sendMessage=function(a,b){window.parent.postMessage(f(this.id,a,b),"*")},this.sendHeight=function(){var a=document.getElementsByTagName("body")[0].offsetHeight.toString();return this.sendMessage("height",a),a}.bind(this),this.scrollParentTo=function(a){this.sendMessage("navigateTo","#"+a)},this.navigateParentTo=function(a){this.sendMessage("navigateTo",a)},this.scrollParentToChildEl=function(a){var b=document.getElementById(a).getBoundingClientRect().top+window.pageYOffset;this.scrollParentToChildPos(b)},this.scrollParentToChildPos=function(a){this.sendMessage("scrollToChildPos",a.toString())};var g=function(a){var b,d=document.getElementsByTagName("html")[0],e=d.className;try{b=window.self!==window.top?"embedded":"not-embedded"}catch(a){b="embedded"}e.indexOf(b)<0&&(d.className=e?e+" "+b:b,a&&a(b),c("marked-embedded"))};this.remove=function(){window.removeEventListener("message",this._processMessage),this.timerId&&clearInterval(this.timerId)};for(var h in b)this.settings[h]=b[h];this.id=d("childId")||b.id,this.messageRegex=new RegExp("^pym"+a+this.id+a+"(\\S+)"+a+"(.*)$");var i=parseInt(d("initialWidth"));return this.parentUrl=d(this.settings.parenturlparam),this.parentTitle=d("parentTitle"),this.onMessage("width",this._onWidthMessage),window.addEventListener("message",this._processMessage,!1),this.settings.renderCallback&&this.settings.renderCallback(i),this.sendHeight(),this.settings.polling&&(this.timerId=window.setInterval(this.sendHeight,this.settings.polling)),g(b.onMarkedEmbeddedStatus),this},"undefined"!=typeof document&&b.autoInit(!0),b});(function($)
{
	mrm.util.SlotManager = function()
	{
		this.initialize.apply(this, arguments);
	};

	_.extend(mrm.util.SlotManager.prototype, {

		list : null,
		maxLength : null,

		initialize : function(length)
		{
			this.maxLength = length;
			this.list = [];
			
			this.initList();
		},
		
		initList : function()
		{
			_.times(this.maxLength, function(n){
				this.list[n] = null;
			}, this);
		},
		
		isFull : function()
		{
			return this.getNextFreeIndex() < 0;
		},
		
		add : function(content)
		{
			var index = this.getNextFreeIndex();

			if( index >= 0 )
			{
				this.list[index] = content;
			}
			
			return index;
		},
		
		remove : function(content)
		{
			var index = this.getIndexByContent(content);
			
			if( index >= 0 )
			{
				this.list[index] = null;
			}
			
			return index;
		},
		
		getNextFreeIndex : function()
		{
			return _.indexOf(this.list, null);
		},

		getIndexByContent : function(content)
		{
			return _.indexOf(this.list, content);
		},
		
		clearAll : function()
		{
			this.initList();
		},
		
		toArray : function()
		{
			return _.clone(this.list);
		},
		
		length : function()
		{
			return _.without(this.list, null).length;
		}
	});
}(mrm.$));/**
 * Helper for managing steps in step based applications
 * Set an array of steps (identified by their name). The step manager is then able to return
 * the previous/next step or all previous/next steps based on the current step.
 * The current step can be included in the result of nextAll/prevAll
 * (both methods accept a boolean flag as second param)
 *
 * The steps array may be set while creating a new instance (constructor param) or later using setSteps()
 * var sMan = new stepManager(stepsArray); OR
 * var sMan = new stepManager(); sMan.setSteps(stepsArray);
 */
(function($)
{
	mrm.util.StepManager = function(stepsArray)
	{
		var _steps = [];
		this.setSteps = function(value) {
			if ( _.isArray(value) ) {
				_steps = value;
			} else {
				throw "mrm.util.StepManager.setSteps() - parameter must be an array";
			}
		};
		this.getSteps = function() {
			return _steps;
		};
		if ( stepsArray ) {
			this.setSteps(stepsArray);
		}
	};

	_.extend(mrm.util.StepManager.prototype, {
		/**
		 * Checks if a given step is known to the StepManager
		 * @param string stepName - the name of the step to check for
		 * @return bool - true if stepName is set in the StepManager, otherwise false
		 */
		hasStep: function(stepName) {
			return _.indexOf(this.getSteps(), stepName) > -1;
		},

		/**
		 * @param string current - the current step (value)
		 * @return mixed - the previous step if it exists, else undefined
		 */
		getPrev: function(current) {
			var index = _.indexOf(this.getSteps(), current);
			return this.getSteps()[index - 1]; // undefined indexes return undefined
		},

		/**
		 * @param string current - the current step (value)
		 * @return mixed - the next step if it exists, else undefined
		 */
		getNext: function(current) {
			var index = _.indexOf(this.getSteps(), current);
			return this.getSteps()[index + 1]; // undefined indexes return undefined
		},

		/**
		 * @param string current - the current step (value)
		 * @param bool andSelf - include the current step in the result?
		 * @return array - array with all steps following the current one 
		 */
		getAllNext: function(current, andSelf) {
			var index = _.indexOf(this.getSteps(), current);
			return index > -1 && index !== this.getSteps().length - 1 ? _.rest(this.getSteps(), andSelf ? index : index + 1) : [];
		},

		getAllPrev: function(current, andSelf) {
			var index = _.indexOf(this.getSteps(), current);
			return index > 0 ? _.first(this.getSteps(), !andSelf ? index : index + 1) : [];
		}
	});
}(mrm.$));
(function($) {
	mrm.util = mrm.util || {};
	$.extend(mrm.util, {     
		
		alignTextWithinCmp : function($textArea){

			$textArea.each(function(){
				
				var $this = $(this);
				
				if( $this.hasClass('pos_middle') ){
					var top = ($this.parent().innerHeight() - $this.outerHeight(true)) / 2;
					$this.css('top', top+'px');
				}
				
				if( $this.hasClass('pos_center') ){
					var left = ($this.parent().innerWidth() - $this.outerWidth(true)) / 2;
					$this.css('left', left+'px');
				}
			});
		}       

	});
}(mrm.$));
/**
 * @author Christian Zindel, Namics Deutschland
 */

 (function($) { 
	mrm.util = mrm.util || {};
	$.extend(mrm.util, {           
		/**
		 * JS for adding boxshadow in ie
		 * 
		 * @param {String} c DOM Context
		 */
		
		addShadow : function($selection, filterPixelRadius, displayType){

	        if( !mrm.util.ie9_lt() ) return; 
	                
	        $selection.each(function(){
	
                var $this = $(this);

                var marginLeft	= parseInt( $this.css('margin-left'), 10 ) || 0;
                var marginTop	= parseInt( $this.css('margin-top'), 10 ) || 0;
                var marginRight	= parseInt( $this.css('margin-right'), 10 ) || 0;
                var marginBottom= parseInt( $this.css('margin-bottom'), 10 ) || 0;

                var radius		= filterPixelRadius;
                var cssDisplay	= $this.css('display');
                var cssFloat	= $this.css('float');

                var $shadow = $('<span></span>').addClass('shadow');
                var styles = {
                        'height'	: $this.outerHeight(),
                        'width'		: $this.outerWidth()
                };

                if( $this.css('z-index') == 'auto' || $this.css('z-index') < 2 )
                {
                    $this.css('z-index', '2');
                }

                if( $this.css('position') == 'static' )
                {
                    $this.css( 'position', 'relative');
                }


                if( displayType != undefined )
                {
                    cssDisplay = displayType;
                }

                // fix some IE8.js issues which occur by generated inline styles
                if( mrm.util.ie6() && cssDisplay == 'inline' && $this.css('float') != 'none')
                {
                    cssDisplay = 'block';
                }

                switch( cssDisplay )
                {
                    case 'inline':
                    case 'inline-block':
                        styles.marginTop  = marginTop - radius;
                        styles.marginLeft = marginLeft - radius;

                        $shadow.css( styles );
                        $this.before($shadow);
                        break;

                    case 'block':
                    case 'none':
                        var pos = $this.position();

                        styles.left = pos.left - radius + marginLeft;
                        
                        if( cssFloat != 'none' || $this.css('position') == 'absolute' || $this.css('margin-left') == 'auto' )
                        {
                            // TODO check if it works correctly
                            styles.top  = pos.top - radius + marginTop;

                            $shadow.css( styles );
                            $this.after($shadow);
                        }
                        else
                        {
                            styles.marginTop = ($this.outerHeight() + marginBottom + radius) * -1;
//							styles.marginLeft = marginLeft - radius;

                            $shadow.css( styles );
                            $this.after($shadow); // must be after, otherwise some :first-child selectors could crash
                        }
                        break;
                }
	
	        });
	    }                        
		
	});
}(mrm.$));/**
 * @author Sebastian Telschow, s.telschow@enterfra.me
 */
(function($) {
	mrm.util = mrm.util || {};
	$.extend(mrm.util, {
		deeplinking: {
			/**
			 * JS to manage deeplinking
			 *
			 * @param {String} c DOM Context
			 */
			init: function() {
				var self = this;

				// initial call
				$(document).ready(function() {
					self.navigateToHash(mrm.util.getHash());
				});

				// bind all #-links to get inpage-deeplink work without changing the url
				$('a[href^="#"]').not('a[href="#"]').on('click', function(event) {
					var modName = mrm.util.getModuleName($(event.currentTarget).closest('.mod'));
					switch(modName) {
						case "nav_tablay_1":
							// exit without doing anything
							break;
						case "ts_ln_1":
						case "ts_ln_2":
						case "ts_img_1":
							var anchorLink = $(this).attr("href");

							// suppress default behavior when teaser links to ID within mm_1
							// let navigateToHash handle the scrolling behavior
							if ($(".modMm_1 " + anchorLink).length ===1) {
								event.preventDefault();
								self.navigateToHash($(event.currentTarget).attr("href"));
							}
							break;
						default:
							self.navigateToHash($(event.currentTarget).attr('href'));
					}
				});

				// bind optional hashchange-event
				$(window).hashchange(function(event) {
					self.navigateToHash(mrm.util.getHash());
				});
			},

			navigateToHash: function(hash) {
				var modKey = 'mod';
				if (!mrm.util.isValidIdentifier(mrm.util.stripHash(hash))) {
					return;
				}
				var $content = $(hash);

				// iterate over replacements and look for dom-#id
				if ($content.length === 0) {
					$content = $(hash.replace(/^#/, '#' + mrm.util.getRenamedIdPrefix()));
				}
				if ($content.length === 0) return;

				// iterate over all embracing .mods
				$content.parents('.' + modKey).each(function(index, mod) {
					var cmpName = mrm.util.getModuleName($(this));
					if (mrm.cmp[cmpName] && typeof mrm.cmp[cmpName].switchToContent === 'function') {
						// call cmp-function to switch to content
						mrm.cmp[cmpName].switchToContent($content);
					} else if (mrm.mod[mrm.util.getTerrificModuleName(cmpName)]) {
						// its a terrific module
						var instance = mrm.util.getTerrificInstance($(mod));
						if (instance) instance.switchToContent($content);
					}
				});
			}
		}
	});
}(mrm.$));/**
 * @author Gregory Stewart, gregory.stewart@mrm.de
 */


(function($) {
	mrm.util = mrm.util || {};
	$.extend(mrm.util, {
		externalServices: {
		/**
		 * JS for loading external web services / libraries
		 *
		 * @param {String} c DOM Context
		 */
		isGoogleMapsLoaded: false,
		isGoogleMapsLoading: false,

		isReevooLoaded: false,
		isReevooLoading: false,
		isReevooAPILoaded: false,

		googleMapsCallbacks: [],
		reevooCallbacks: [],
		reevooAPICallbacks: [],

		loadGoogleMaps: function(callback) {
			var self = this;

			if(self.isGoogleMapsLoaded){
				if ($.isFunction(callback)) callback({'status': 'alreadyLoaded'});
				return;
			}

			self.googleMapsCallbacks.push(callback);
			head.test((!this.isGoogleMapsLoaded && !this.isGoogleMapsLoading),
				'//www.google.com/jsapi',
				undefined,
				function () {
					if (!window.google) return;
					var lang = mrm.util.locale.getLang();
					var other_params = 'client=gme-adamopelag&language=' + lang;

					google.load('maps', '3.23', {
						'language': lang,
						'other_params': other_params,
						'callback': function(){
							self.isGoogleMapsLoading = false;
							self.isGoogleMapsLoaded = true;
							$.each(self.googleMapsCallbacks, function(index, func) {
								if ($.isFunction(func)) func({'status': 'loaded'});
							});
							self.googleMapsCallbacks = [];
						}
					});
				}
			);
			self.isGoogleMapsLoading = true;
		},

		/**
		 * reevoo customer-ratings (GMDSPLM-13414)
		 * @param  {Function} callback [description]
		 * @return {[type]}            [description]
		 */
		loadReevoo: function(callback) {
			var self = this;
			var trkref = mrm.conf.util.externalServices.reevooTRKREF;

			if(self.isReevooLoaded){
				if ($.isFunction(callback)) callback({'status': 'alreadyLoaded'});
				return;
			}

			self.reevooCallbacks.push(callback);
			head.test((!this.isReevooLoaded && !this.isReevooLoading),
				'//mark.reevoo.com/reevoomark/' + trkref + '.js?async=true',
				undefined,
				function() {
					self.isReevooLoaded = true;
					self.isReevooLoading = false;
					$.each(self.reevooCallbacks, function(index, func) {
						if ($.isFunction(func)) func({'status': 'loaded'});
					});
					self.reevooCallbacks = [];
				}
			);
			self.isReevooLoading = true;
		},

		loadReevooAPI: function(callback) {
			var self = this;
			var trkref = mrm.conf.util.externalServices.reevooTRKREF;

			if (!self.isReevooLoaded) {
				console.log('reevoo is not loaded');
				return;
			}

			if(self.isReevooAPILoaded){
				if ($.isFunction(callback)) callback({'status': 'alreadyLoaded'});
				return;
			}

			self.reevooAPICallbacks.push(callback);
			window.afterReevooMarkLoaded = window.afterReevooMarkLoaded || [];
			window.afterReevooMarkLoaded.push(function() {
				ReevooApi.load(trkref, function(retailer) {
					self.isReevooAPILoaded = true;
					$.each(self.reevooAPICallbacks, function(index, func) {
						if ($.isFunction(func)) func({'status': 'loaded'});
					});
					self.reevooAPICallbacks = [];
				});
			});
		},

		/**
		 * hook into the reevoo-button click
		 * @param  {[type]}   $container [description]
		 * @param  {Function} callback   [description]
		 * @return {[type]}              [description]
		 */
		onReevooClick: function($container /* jQuery */, callback) {
			var self = this;
			if (!self.isReevooLoaded) {
				console.log('reevoo not loaded');
				return;
			}
			if (!self.isReevooAPILoaded) {
				console.log('reevoo API not loaded');
				return;
			}

			ReevooMark.Callbacks.observe_click(function(e) {
				if ($container.has(e.target).length > 0) {
					if ($.isFunction(callback)) callback(e.target);
				}
			});

		}

	}});
}(mrm.$));/* Package: mrm.util.geoLocation
 * Author: Tony Herford
 *
 * Example of how to call function
 * mrm.util.geoLocation.getLocationZip(function(results){
 *      if(results.status == 'success'){
 *          $(el).html(results.postal_code);
 *      }else{
 *          $(el).html(results.error_message);
 *      }
 * });
 *
 * ERROR CODE KEY
 * gl001 = User denied the request for Geolocation.
 * gl002 = Location information is unavailable.
 * gl003 = The request to get user location timed out.
 * gl004 = An unknown error occurred.
 * gl005 = Geolocation is not supported by this browser.
 * gl006 = No results found.
 *
 */

(function($) {
    mrm.util = mrm.util || {};
    $.extend(mrm.util, {
        geoLocation: {
            //init stuff
            init: function() {

            },
            available: function() {
                return (typeof navigator.geolocation != 'undefined');
            },
            getLocation: function(callback) {
				if(!$.isFunction(callback)){throw new Error("getLocation() requires a callback function as the first argument");}

                if (this.available()) {
                    navigator.geolocation.getCurrentPosition(
                        function(position) {
                            callback({
                                status: 'success',
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude
                            });
                        }, function(error) {
                            var errorCode = "";
                            switch (error.code) {
                                case error.PERMISSION_DENIED:
                                    errorCode = 'gl001'; //"User denied the request for Geolocation.";
                                    break;
                                case error.POSITION_UNAVAILABLE:
                                    errorCode = 'gl002'; //"Location information is unavailable.";
                                    break;
                                case error.TIMEOUT:
                                    errorCode = 'gl003'; //"The request to get user location timed out.";
                                    break;
                                case error.UNKNOWN_ERROR:
                                    errorCode = 'gl004';//"An unknown error occurred.";
                                    break;
                            }

                            callback({
                                status: 'error',
                                error_code: errorCode
                            });
                        }, {timeout:50000});
                } else {
                    callback({
                        status: 'error',
                        error_code: 'gl005' /*"Geolocation is not supported by this browser."*/
                    });
                }
            },
            getLocationZip: function(callback) {
				if(!$.isFunction(callback)){throw new Error("getLocationZip() requires a callback function as the first argument");}

				this.getLocation(function(results) {
                    mrm.util.externalServices.loadGoogleMaps(function() {
                        if (results.status === 'success') {
                            var geocoder = new google.maps.Geocoder();
                            var latlng = new google.maps.LatLng(results.latitude, results.longitude);

                            if (geocoder) {
                                geocoder.geocode({
                                    'latLng': latlng
                                }, function(geoResults, status) {
                                    if (status === google.maps.GeocoderStatus.OK) {
                                        $.each(geoResults, function() {
                                            if (this.types[0] === 'postal_code') {
                                                callback({
                                                    status: 'success',
                                                    postal_code: this.address_components[0].long_name
                                                });
                                                return false;
                                            }
                                        });
                                    } else {
                                        callback({
                                            status: 'error',
                                            error_code: 'gl006' /* 'No results found' */
                                        });
                                    }
                                });
                            }
                        } else {
                            callback(results);
                        }
                    });
                });
            }
        }
    });
}(mrm.$));mrm.util.location = function($) {
	var _config = {
		us: {
			en: {
				regex: /^[0-9]{5}$/,
				akamaiAvailable: true,
				ajaxValidate: true,
				ajaxLocation: "/zipdata/en-us/"
			}
		},
		ca: {
			en: {
				regex: /^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\d{1}[a-zA-Z]{1} *\d{1}[a-zA-Z]{1}\d{1}$|^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\d{1}[a-zA-Z]{1}/,
				akamaiAvailable: true
			},
			fr: {
				regex: /^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\d{1}[a-zA-Z]{1} *\d{1}[a-zA-Z]{1}\d{1}$|^[ABCEGHJKLMNPRSTVXYabceghjklmnprstvxy]{1}\d{1}[a-zA-Z]{1}/,
				akamaiAvailable: true
			}
		}
	};

	var _regex = null;
	var _akamaiAvailable = false;
	var _ajaxValidate = false;
	var _ajaxLocation = null;

	/**
	* Utility initialization. Checks country and language, and then searches _config
	* for an available configuration. If one is available, the utility is setup to
	* use that configuration. Called by public init method directly.
	*
	* @private method _init
	*/

	function _init() {
		var country = mrm.util.locale.getCountry();
		var language = mrm.util.locale.getLang();

		if (typeof _config[country] === "object" && typeof _config[country][language] === "object") {
			var marketConfig = _config[country][language];
			if (typeof marketConfig.regex === "object") {
				_regex = marketConfig.regex;
			}

			if (typeof marketConfig.akamaiAvailable === "boolean") {
				_akamaiAvailable = marketConfig.akamaiAvailable;
			}

			if (typeof marketConfig.ajaxValidate === "boolean") {
				_ajaxValidate = marketConfig.ajaxValidate;
			}

			if (typeof marketConfig.ajaxLocation === "string") {
				_ajaxLocation = marketConfig.ajaxLocation;
			}
		}

		if(mrm.util.locale.getCountry()==='ca') {
			if(mrm.util.cookie.get('cookie_customer_location') == null){
				if  (mrm.util.cookie.get('GMWP_location') == null) {
					_setLocation('L1H8P7');
				} else {
					var akamaiCookie = mrm.util.cookie.get('GMWP_location');
					var zipLocation = akamaiCookie.search("zip=") + 4;
					var akamaiZip = akamaiCookie.substring(zipLocation, (zipLocation+3));
					if(!_setLocation(akamaiZip)) {
						_setLocation('L1H8P7');
					}
				}
			}
		}
	}

	/**
	* Pulls the value from platform location cookie if available.
	*
	* @private method _getPlatformLocation
	* @param {String} The name of the property that should be pulled from the cookie's stored JSON obect
	* @return {String, Object, Boolean} Returns stored value if available, otherwise returns false
	*/

	function _getPlatformLocation(type) {
		if (mrm.util.cookie.get('cookie_customer_location') !== null) {
			var platformCookie = $.parseJSON(mrm.util.cookie.get('cookie_customer_location'));
			if (typeof platformCookie[type] === "string") {
				return platformCookie[type];

			} else if (type === "cities" && typeof platformCookie[type] === "object") {
				return platformCookie[type];
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	/**
	* Pulls postal code from Akamai provided cookie if cookie is available.
	*
	* @private method _getAkamaiLocation
	* @return {String, Boolean} Returns postal code string when available. Returns false if not available.
	*/

	function _getAkamaiLocation() {
		if (mrm.util.cookie.get('GMWP_location') !== null) {
			var akamaiCookie = mrm.util.cookie.get('GMWP_location');
			var zipLocation = akamaiCookie.search("zip=") + 4;
			var akamaiZip = akamaiCookie.substring(zipLocation, (zipLocation + 5));
			return akamaiZip;
		} else {
			return false;
		}
	}

	/**
	* Handles pulling location data from both platform cookie and Akamai cookie. Will only pull
	* from Akamai cookie if configured to be enabled for the current market. Called directly
	* by public methods getState, getPostalCode, and getCities.
	*
	* @private method _getLocation
	* @param {String} Name of property to read from cookie JSON object
	* @return {String, Object, Boolean} Returns value as string or object. Returns false if not available
	*/

	function _getLocation(type) {
		var platformLocation = _getPlatformLocation(type);
		if (platformLocation !== false) {
			return platformLocation;
		}

		if (!_akamaiAvailable) return false;

		var akamaiLocation = _getAkamaiLocation();

		if (akamaiLocation !== false) {
			var validLocation = _setLocation(akamaiLocation);
			if (validLocation !== false) {
				return _getPlatformLocation(type);
			}
		}

		return false;
	}

	/**
	* Checks the validity of the postal code against the configured regular expression for
	* the market. Second parameter will override the configured regular expression. A second
	* validation type can be enabled which compares the value against a database.
	*
	* @private method _validatePostal
	* @param {String} The postal code string to be validated
	* @param {Object} Regular expression to override configured regex.
	* @return {Object, Boolean} Returns stringified JSON object if valid, returns false in invalid
	*/

	function _validatePostal(postalcode, regex) {
		var validateRegex;

		if (typeof regex !== "undefined") {
			validateRegex = regex; // Use regex from param
		} else {
			validateRegex = _regex; // Use regex configured for market
		}

		if (typeof postalcode === "string" && postalcode.search(validateRegex) === -1) {
			return false;
		}

		if (typeof postalcode === "string" && postalcode.search(validateRegex) === 0) {

			if (!_ajaxValidate) return JSON.stringify({zipcode: postalcode});

			var validated = false;
			var url = _ajaxLocation + postalcode + ".json";
			$.ajax({
				url:url,
				dataType:"json",
				async:false,
				dataFilter: function (data, type) {
					if (type === "json") {
						validated = data;
					}
				}
			});
			return validated;
		}

		return false;
	}

	/**
	* Verify postal code and set value within stringified JSON object within platform cookie.
	* Called by public method setLocation directly.
	*
	* @private method _setLocation
	* @param {String} Value to be varified and set within platform cookie
	* @param {Object} Optional - Regular expression to verify postal code value
	* @return {Boolean} Returns true if valid, false if invalid
	*/

	function _setLocation(postalcode, regex) {
		postalcode = postalcode.toString();
		var locationObject = _validatePostal(postalcode, regex);
		if (locationObject !== false) {
			mrm.util.cookie.set("cookie_customer_location", locationObject,{expires: 30, path: "/"});
			return true;
		} else {
			return false;
		}
	}

	/**
	* Check to see if market is configured for location utility. Called by public 
	* isConfigured method directly.
	*
	* @private method _isConfigured
	* @return {Boolean} Returns true if market is configured, false if not configured
	*/

	function _isConfigured() {
		var country = mrm.util.locale.getCountry();
		var language = mrm.util.locale.getLang();

		if (typeof _config[country] === "object" && typeof _config[country][language] === "object") {
			return true;
		}

		return false;
	}

	return {
		/**
		* Utility initialization. Checks country and language, and then searches _config
		* for an available configuration. If one is available, the utility is setup to
		* use that configuration. Calls private _init method directly.
		*
		* @public method init
		*/
		init: _init,

		/**
		* Handles pulling postal code data from both platform cookie and Akamai cookie. Will only pull
		* from Akamai cookie if configured to be enabled for the current market. Calls _getLocation
		* directly.
		*
		* @public method getPostalCode
		* @return {String, Boolean} Returns value as string if available. Returns false if not available.
		*/
		getPostalCode: function() {
			return _getLocation("zipcode");
		},

		/**
		* Handles pulling city data from both platform cookie and Akamai cookie. Will only pull
		* from Akamai cookie if configured to be enabled for the current market. Calls _getLocation
		* directly.
		*
		* @public method getState
		* @return {Object} Returns array of cities if cookies are available. Returns false if not available
		*/
		getCities: function() {
			return _getLocation("cities");
		},

		/**
		* Handles pulling State data from both platform cookie and Akamai cookie. Will only pull
		* from Akamai cookie if configured to be enabled for the current market. Calls _getLocation
		* directly.
		*
		* @public method getState
		* @return {String, Boolean} Returns State as string if available. Returns false if not available.
		*/
		getState: function() {
			return _getLocation("state");
		},

		/**
		* Verify postal code and set value within stringified JSON object within platform cookie.
		* Calls private method _setLocation directly.
		*
		* @public method _setLocation
		* @param {String} Value to be varified and set within platform cookie
		* @param {Object} Optional - Regular expression to verify postal code value
		* @return {Boolean} Returns true if valid, false if invalid
		*/
		setLocation: _setLocation,

		/**
		* Check to see if market is configured for location utility. Called by private 
		* _isConfigured method directly.
		*
		* @public method _isConfigured
		* @return {Boolean} Returns true if market is configured, false if not configured
		*/
		isConfigured: _isConfigured
	};
}(mrm.$);(function ($) {
	mrm.util = mrm.util || {};
	$.extend(mrm.util, {
		isMobile: {
			Android: function () {
				return navigator.userAgent.match(/Android/i);
			},
			BlackBerry: function () {
				return navigator.userAgent.match(/BlackBerry/i);
			},
			iOS: function () {
				return navigator.userAgent.match(/iPhone|iPad|iPod/i);
			},
			Opera: function () {
				return navigator.userAgent.match(/Opera Mini/i);
			},
			Windows: function () {
				return navigator.userAgent.match(/IEMobile/i);
			},
			any: function () {
				return (mrm.util.isMobile.Android() || mrm.util.isMobile.BlackBerry() || mrm.util.isMobile.iOS() || mrm.util.isMobile.Opera() || mrm.util.isMobile.Windows());
			}
		}
	});
}(mrm.$));


(function($) {
	mrm.util = mrm.util || {};
	$.extend(mrm.util, {
		sectionname: {
			/**
			 * JS to get and name sections on the page dependent on content well or headline IDs
			 *
			 * @param {String} c DOM Context
			 */
			init: function(c) {
				var sectionId;
				$(".contentArea, .componentsArea").children().each(function(count, item) {
					if ($(item).find(".modCnt_well_1").attr("id") !== undefined) {
						sectionId = $(item).find(".modCnt_well_1").attr("id");
						$(item).data("section", sectionId);
					} else if ($(item).find(".modCnt_well_2").attr("id") !== undefined) {
						sectionId = $(item).find(".modCnt_well_2").attr("id");
						$(item).data("section", sectionId);
					} else if ($(item).find(".modCnt_hl_1").attr("id") !== undefined) {
						sectionId = $(item).find(".modCnt_hl_1").attr("id");
						$(item).data("section", sectionId);
					} else if ($(item).find(".modCnt_hl_2").attr("id") !== undefined) {
						sectionId = $(item).find(".modCnt_hl_2").attr("id");
						$(item).data("section", sectionId);
					} else if (sectionId !== undefined) {
						$(item).data("section", sectionId);
					}
				});
			},

			getSectionName: function($mod) {
				var section;
				if ($mod.parents(".contentArea, .componentsArea").length > 0) {
					var ancestors = $mod.parentsUntil(".contentArea, .componentsArea");
					var lastAncestor = ancestors.length - 1;
					if (typeof($(ancestors[lastAncestor]).data("section")) === "undefined") {
						section = "no section";
					} else {
						section = $(ancestors[lastAncestor]).data("section");
					}
				} else if ($mod.parents(".leftNavigationSticky").length > 0) {
					section = "sticky nav";
				} else if ($mod.parents(".mds-area-ptl").length > 0) {
					section = "left column";
				} else if ($mod.parents(".mds-area-ptr").length > 0) {
					section = "right column";
				} else if ($mod.parents(".teaserContainer").length > 0) {
					section = "promotiles";
				} else if (($mod.parents(".mds-area-pf4").length > 0) && ($mod.parents(".t03b_teaserarea").length > 0)) {
					section = $mod.find("h3 a").text();
				} else if ($mod.parents(".mds-area-content").length > 0) {
					section = "no section";
				} else if ($mod.parents(".mds-area-header").length > 0) {
					section = "header";
				} else if ($mod.parents(".masthead").length > 0) {
					section = "masthead";
				} else if ($mod.parents(".mds-area-footer, #mds-area-legal, .mds-area-sec_footer").length > 0) {
					section = "footer";
				} else {
					section = "no section";
				}
				return section;
			}
		}
	});
}(mrm.$));









/**
 * @author Sebastian Telschow, s.telschow@enterfra.me
 */
(function($) {
	mrm.util = mrm.util || {};
	$.extend(mrm.util, {
		sharing: {
			/**
		* JS for global sharing functionality
		*
		* @param {String} c DOM Context
		*/
			facebookLoaded: false,
			googleplusLoaded: false,
			twitterLoaded: false,
			_lazyProviderTag: 'lazy-',
			_cookieName: 'gmwp.social.services.enabled',
			_cookieOptions: {
				path: '/'
			},
			_resetServiceSwitches: false,

			loadFacebook: function(callback) {
				var self = this;
				var options = $.extend({}, mrm.conf.util.sharing);
				var locale = mrm.util.locale.getFacebook();
				head.test((options.facebookAppId && locale),
					'//connect.facebook.net/' + locale + '/all.js',
					undefined,
					function () {
						if (window.FB) self._facebookInit(options.facebookAppId);
						if (window.FB && self.facebookLoaded === false) self._trackFacebook();
						self.facebookLoaded = true;
						if (callback) callback();
					}
				);
			},

			loadGooglePlus: function(callback) {
				var self = this;
				// set g+ locale
				window.___gcfg = {
					lang: mrm.util.locale.getGoogle(),
					parsetags: 'onload'
				};
				head.test(mrm.util.locale.getGoogle(),
					'//apis.google.com/js/plusone.js',
					undefined,
					function() {
						self._trackGooglePlus();
						self.googleplusLoaded = true;
						if (callback) callback();
					}
				);
			},

			loadTwitter: function(callback) {
				var self = this;
				head.load('//platform.twitter.com/widgets.js', function() {
					if (window.twttr && self.twitterLoaded === false) self._trackTwitter();
					self.twitterLoaded = true;
					if (callback) callback();
				});
			},

			/* PUBLIC */
			enableShare2Autorender: function($container) {
				var $share2 = $container.find('.modShare_2[data-autorender="false"]');
				$share2.attr('data-autorender', 'true');
			},

			/* RERENDER FUNCTIONS */
			rerender: function(container) {
				this._rerenderGooglePlus(container);
				this._rerenderTwitter(container);
				this._rerenderFacebook(container);
			},

			/*
			 	Initialise ON/OFF switches for social media functionalities in
			 	order to prevent personal data being transferred to the social
			 	media providers without consent of the user
			 */
			initSocialSwitches: function($mod) {
				var self = this,
				    $allServiceContainers = $('.service-facebook, .service-twitter, .service-google, .service-youtube', $mod),
				    cookieLifetime;

				// set cookie lifetime if provided
				if ( cookieLifetime = mrm.conf.util.sharing.cookieLifetime ) {
					var expiryDate = new Date();
					expiryDate.setTime( expiryDate.getTime() + (cookieLifetime * 1000) );
					self._cookieOptions.expires = expiryDate;
				}

				// save original code of services, detach it and show deactivated service tags
				$allServiceContainers.addClass('socialPrivacy').each(function() {
					var $socialShareWrapper = $('.socialShareWrapper', $(this));
					self._saveServiceCode($(this));
					$socialShareWrapper.children(':not(.deactivatedService)').detach();
					$('.deactivatedService', $socialShareWrapper).show();
				});

				// bind click events to switches
				$('.socialSwitch', $allServiceContainers).addClass('off').on('click.socialSwitch', function( event ) {
					var serviceClass = $(this).parents('.socialPrivacy').attr('class').match(/service[\w\-]*\b/)[0],
					    $serviceContainers = $('.' + serviceClass),
					    $serviceSwitches = $('.socialSwitch', $serviceContainers),
					    service = serviceClass.replace('service-', '');

					event.stopPropagation();

					if ( $(this).hasClass('off') ) {
						self._switchServiceOn($serviceContainers, $serviceSwitches, service);
					} else {
						self._switchServiceOff($serviceContainers, $serviceSwitches, service);
					}
				});

				self._attachInfobox($allServiceContainers);

				// check if cookie exists and activate respective services
				if ( enabledServices = self._checkSocialServiceCookie() ) {
					for ( var i=0, j=enabledServices.length; i<j; i++ ) {
						var serviceClass = 'service-' + enabledServices[i],
						    $serviceContainers = $('.' + serviceClass, $mod),
						    $serviceSwitches = $('.socialSwitch', $serviceContainers);

						if ( $serviceContainers.length > 0 ) {
							self._switchServiceOn($serviceContainers, $serviceSwitches, enabledServices[i]);
						}
					}
				}
			},

			/* PRIVATE */
			_switchServiceOn: function($serviceContainers, $serviceSwitches, service) {

				// hide deactivated service tags and recover original service code
				$serviceContainers.each(function() {
					var $serviceCode = $(this).data('serviceCode');

					$(this).infoBox('disable');
					$('.deactivatedService', $(this)).hide();
					$('.socialShareWrapper', $(this)).append($serviceCode);
				});

				// toggle switch
				$serviceSwitches.removeClass('off').addClass('on');

				// enable service tags
				$('[class^="disabled-"]', $serviceContainers).each(function() {
					var cls = $(this).attr('class');
					$(this).attr('class', cls.replace('disabled-', ''));
				});

				// rerender services
				switch (service) {
					case 'facebook':
						if ( !this.facebookLoaded ) {
							this.loadFacebook( mrm.cmp.share_2.bindEventToFacebookIcons );
						}
						break;
					case 'twitter':
						if ( !this.twitterLoaded ) {
							this.loadTwitter( mrm.cmp.share_2.bindEventToTwitterIcons );
						}
						break;
					case 'google':
						if ( !this.googleplusLoaded ) {
							this.loadGooglePlus();
						}
						break;
					case 'youtube':
						break;
					default:
				}

				// add service to cookie
				this._addServiceToCookie(service);
			},

			_switchServiceOff: function($serviceContainers, $serviceSwitches, service) {
				// save service code
				this._saveServiceCode($serviceContainers);

				// detach original service code and show deactivated service tag
				$serviceContainers.each(function() {
					$('.socialShareWrapper', $(this)).children(':not(.deactivatedService)').detach();
					$('.deactivatedService', $(this)).show();
					$(this).infoBox('enable');
				});

				// toggle switch
				$serviceSwitches.removeClass('on').addClass('off');

				// remove service from cookie
				this._removeServiceFromCookie(service);
			},

			_saveServiceCode: function($serviceTags) {
				$serviceTags.each(function() {
					var $serviceCode = $('.socialShareWrapper', $(this)).children(':not(.deactivatedService)');
					$(this).data('serviceCode', $serviceCode);
				});
			},

			_addServiceToCookie: function(service) {
				if ( this._checkSocialServiceCookie(service) === false ) {
					enabledServices = this._checkSocialServiceCookie();
					enabledServices.push(service);
					mrm.util.cookie.set(this._cookieName, enabledServices.join(','), this._cookieOptions);
				} else if ( !this._checkSocialServiceCookie() ) {
					mrm.util.cookie.set(this._cookieName, service, this._cookieOptions);
				}
			},

			_removeServiceFromCookie: function(service) {
				if ( this._checkSocialServiceCookie(service) === true ) {
					enabledServices = this._checkSocialServiceCookie();
					enabledServices.splice(_.indexOf(enabledServices, service), 1)
					if ( enabledServices.length < 1 ) {
						mrm.util.cookie.remove(this._cookieName, this._cookieOptions);
					} else {
						mrm.util.cookie.set(this._cookieName, enabledServices.join(','), this._cookieOptions);
					}
				}
			},

			_checkSocialServiceCookie: function(service) {
				// returns true | false | array | undefined
				var enabledServices = [],
				    serviceEnabled = false;

				if ( cookieValue = mrm.util.cookie.get(this._cookieName) ) {
					// cookie exists
					enabledServices = cookieValue.split(',');
					if (service) {
						// check for a specific service
						serviceEnabled = ( _.indexOf(enabledServices, service) < 0 ) ? false : true;
						return serviceEnabled;
					} else {
						// check for all services
						return enabledServices;
					}
				} else {
					// cookie does not exist
					return;
				}
			},

			_attachInfobox: function($elements) {
				var infoboxOptions = $.extend({}, mrm.conf.plugin.infobox, {
				    trigger: '.socialSwitch',
				    addBoxClass: 'socialPrivacy'
				});

				$elements.infoBox(infoboxOptions);
			},


			_rerenderGooglePlus: function(container) {
				if (!window.gapi) return;
				if ($('div.g-plusone', container).length === 0) return;
				window.gapi.plusone.go(container);
			},

			_rerenderTwitter: function(container) {
				if (!window.twttr) return;
				if ($('a.twitter-share-button', container).length === 0) return;
				window.twttr.widgets.load();
			},

			_rerenderFacebook: function(container) {
				if ( !window.FB ) return;
				FB.XFBML.parse(container);
				mrm.cmp.share_2.bindEventToFacebookIcons();
			},

			_facebookInit: function(appId){
				FB.init({
					appId      : appId, // App ID
					//channelUrl : '//WWW.YOUR_DOMAIN.COM/channel.html', // Channel File
					status     : true, // check login status
					cookie     : true, // enable cookies to allow the server to access the session
					xfbml      : true  // parse XFBML
				});

				// execute only once
				this._facebookInit = function() {};
			},

			_trackFacebook: function() {

				// Track Facebook 'like' and 'unlike' events when using iframe
				FB.Event.subscribe('edge.create', function(href, widget) {
					if(typeof(pageTrackJSON) !== "undefined"){fireMetrics('facebook_like');}
				});

				FB.Event.subscribe('edge.remove', function(href, widget) {
					if(typeof(pageTrackJSON) !== "undefined"){fireMetrics('facebook_like');}
				});

				// Track Facebook 'send' when using iframe
				FB.Event.subscribe('message.send', function(href, widget) {
					if(typeof(pageTrackJSON) !== "undefined"){fireMetrics('facebook_send');}
				});

				// Track Facebook 'send' without iframe with normal onClick event
				if ($(".service-facebook > a").length > 0) {
					mrm.$(".service-facebook > a").on("click", function(){
						if(typeof(pageTrackJSON) !== "undefined"){fireMetrics('facebook_send');}
					});
				}
			},

			_trackTwitter: function(){
				// Track Twitter 'tweet' and 'send' in an iframe
				twttr.events.bind('click', function(event) {
					var click_type = event.region;
					if (click_type === "tweet") {
						if(typeof(pageTrackJSON) !== "undefined"){fireMetrics('twitter_tweet');}
					} else if (click_type === "follow" || click_type === "following") {
						if(typeof(pageTrackJSON) !== "undefined"){fireMetrics('twitter_follow');}
					}

				});

				// Track Twitter 'tweet' without iframe with normal onClick event
				mrm.$(".service-twitter > a").on("click", function(){
					if(typeof(pageTrackJSON) !== "undefined"){fireMetrics('twitter_tweet');}
				});
			},

			_trackGooglePlus: function() {

				// G+ needs a callback function added to the global scope without object namespacing
				googlePlusTracking = function() {
					if(typeof(pageTrackJSON) !== "undefined"){fireMetrics('google_plus_one');}
				};
			},


			/// lazy load functionality starts
			_lazySelectors:[], /* keep track of all the selectors added by addToLazyLoad */
			_lazyRendered: [], /* Which have already been loaded */
			_lazyShares: [],  /* The share elements found */
			lazyOffset: 150, /* When using the scrolling events, how far before viewable before rendering */
			addToLazyLoad: function(selector){ /* Called to add social containers to the lazy load functionality */
				if (_.indexOf(this._lazySelectors, selector) === -1) this._lazySelectors.push(selector);
				this._lazyLoadTags(selector, $(document));
				this._lazyShares = $(this._lazySelectors.join(', ')).has('.' + this._lazyProviderTag + 'twitter-share-button, .' + this._lazyProviderTag + 'g-plusone');
				if(this._lazyShares.length > 0 && !this.lazyInit){
					this._lazyLoadInit();
				}
			},
			loaded:function(event){ /* called when the page is loaded. On load event or timer event */
				clearTimeout(mrm.util.sharing.lazyTimeout);
				$(window).unbind('load.lazy');
				mrm.util.sharing._lazyLoad(mrm.util.sharing._lazyShares);
			},
			_lazyLoadInit: function(){ /* Start timers and bind events */
				/** functionality for onload lazyLoad */
				this.lazyInit = true;
				this._lazyUpdate(); /* Run to make sure any social Icons in view are loaded */
				mrm.util.sharing.lazyTimeout = setTimeout(mrm.util.sharing.loaded, 5000);
				$(window).bind('load.lazy', mrm.util.sharing.loaded);

				/** funtionality for lazyLoad on scrolling.
				 * $(window).on('resize.lazyLoad', this._lazyUpdate).on('scroll.lazyLoad', this._lazyUpdate);
				 * mrm.util.sharing.lazyInterval = setInterval(this._lazyUpdate, 500);
				 */

			},
			/* Lazy load functions */
			_lazyLoadTags: function(selector, $container){ /* Hide provider-tags so they are not rendered on load provider-scripts */
				return $(selector + ' .twitter-share-button, ' + selector + ' .g-plusone', $container).each(function(){
					var $tag = $(this);
					var cls = $tag.attr('class');
					$tag.attr('class', cls.replace(/(g-plusone|twitter-share-button)/, mrm.util.sharing._lazyProviderTag + "$1"));
				});
			} ,
			_lazyUpdate: function(){ /* Check to see what shares are in the view port to load */

				/* to keep it form running on ever scroll event */
				if (mrm.util.sharing.lazyWait) {
					clearTimeout(mrm.util.sharing.lazyWait);
				}
				mrm.util.sharing.lazyWait = setTimeout(function(){
					return;
				}, 100);

				var shares = mrm.util.sharing._lazyShares;
				/* if there are no shares then exit */
				if(shares.length < 1) return;
				// viewport bounds
				var win = $(window),
				found = [],
				os = mrm.util.sharing.lazyOffset,
				wT = win.scrollTop()-os,
				wL = win.scrollLeft(),
				wR = wL + win.width(),
				wB = wT + win.height()+(os*2)/*x2 because the to is already moved up*/;
				// check which articles are visible and socialise!
				for (var i = 0; i < shares.length; i++) {
					var el = $(shares[i]);
					if (mrm.util.sharing._lazyRendered[i] || !el.is(':visible')) {
						continue;
					}

					// share bounds
					var eT = el.offset().top,
					eL = el.offset().left,
					eR = eL + el.width(),
					eB = eT + el.height();
					// vertial point inside viewport
					if ((eT >= wT && eT <= wB) || (eB >= wT && eB <= wB)) {
						// horizontal point inside viewport
						if ((eL >= wL && eL <= wR) || (eR >= wL && eR <= wR)) {
							mrm.util.sharing._lazyRendered[i] = true;
							found.push(shares[i]);
						}
					}
				}
				// kill the timer if all shares have been rendered
				for(var z = 0;z<mrm.util.sharing._lazyRendered.length;z++){
					if(mrm.util.sharing._lazyRendered[z] === undefined) break;
				}
				if(z == shares.length) {
					clearInterval(mrm.util.sharing.lazyInterval);
					$(window).off('.lazyLoad');
				}
				mrm.util.sharing._lazyLoad(found);
			},
			_lazyLoad:function(shares){ /* Make provider tags visible and calls the rerender method */
				if (shares.length === 0) return;
//				mrm.util.log(shares.length+" shares found", shares);
				$.each(shares, function(){
					$(this).find('.' + mrm.util.sharing._lazyProviderTag + 'twitter-share-button, .' + mrm.util.sharing._lazyProviderTag + 'g-plusone').each(function() {
						var $tag = $(this);
						var cls = $tag.attr('class');
						$tag.attr('class', cls.replace(mrm.util.sharing._lazyProviderTag, ''));
					});
					mrm.util.sharing.rerender(this);
				});
			}
		}
	});
}(mrm.$));/*
 * 2013 by MRM Worldwide
 */
/* This class is used to track user perferences so byo can choose the closest match.
 * Also, keeps track of vehicles configured by byo.
 *
 * @author tony.herford
 * @name vehicleConfig.js
 */
(function($){
mrm.util = mrm.util || {};
	$.extend(mrm.util, {
		vehicleConfig: (function(){
			var _maxVehicles = 5,
				_config = {
					currentView:'ext',
					extAngle: 0,
					intAngle: 0,
					vehicles: []
				},
				_generalDefaults = {
					timestamp: 0,
					configState: false,
					year: new Date().getFullYear(),
					carline: '',
					bodystyle: '',
					intColor: '',
					extColor: '',
					wheels: '',
					defaultCGI: '',
					options: {}

				},
				_preferredDefaults = {
					mmc:'',
					configuration:'',
					driveType: '',
					peg:'', // trim
					color: '',
					intColor:'',
					wheels:''
				},
				_configuredDefaults = {
					mmc:'',
					configuration:'',
					driveType: '',
					peg:'', // trim
					color: '',
					intColor:'',
					wheels:'',
					price: '',
					date:'',
					extColorList: [],
					interiorList: [],
					wheelsList: [],
					selectedOptions: [],
					selectedRpo: []
				},
				_vehicleObj = {generalParams:{}, preferredParams:{}, configuredParams:{}},
				_curPageData = {};

			/**
			 * Save the config and current vehicle to the localStorage.  if object is passed
			 * in then that replace the current one and is saved.
			 * @param [object] vehicleObj
			 * @returns void
			 */
			function _save(vehicleObj) {
				if(_config.vehicles.length === 0 && vehicleObj){
					_vehicleObj = _findVehicle(
						vehicleObj.generalParams.year,
						vehicleObj.generalParams.carline,
						vehicleObj.generalParams.bodystyle
					);
					if(typeof _vehicleObj === 'undefined') throw "Vehicle object not found in vehicleConfig";
				}
				_vehicleObj = vehicleObj || _vehicleObj;

				if(_config.vehicles.length > 0){
					_config.vehicles[0].timestamp = new Date().getTime();
					var vehicle = _config.vehicles[0];

					// save config data
					localStorage.setItem('vehicle-config', JSON.stringify(_config));

					// save the vehicles
					_vehicleObj.generalParams.timestamp = new Date().getTime();
					localStorage.setItem(vehicle.key, JSON.stringify(_vehicleObj));

					$.eventDispatcher.trigger('vehicle_config_change', _vehicleObj);

					// add the trimVcCode is set for each. AV's request.
					if(_vehicleObj.generalParams.mmc && _vehicleObj.generalParams.peg){
						_vehicleObj.generalParams.trimVcCode = _vehicleObj.generalParams.mmc + '_' + _vehicleObj.generalParams.peg
					}
					if(_vehicleObj.preferredParams.mmc && _vehicleObj.preferredParams.peg){
						_vehicleObj.preferredParams.trimVcCode = _vehicleObj.preferredParams.mmc + '_' + _vehicleObj.preferredParams.peg
					}
					if(_vehicleObj.configuredParams.mmc && _vehicleObj.configuredParams.peg){
						_vehicleObj.configuredParams.trimVcCode = _vehicleObj.configuredParams.mmc + '_' + _vehicleObj.generalParams.peg
					}

					_setCookie();
				}
			}

			function _setCookie(){
				var car = {};
				car.carline = _vehicleObj.generalParams.carline;
				car.bodystyle = _vehicleObj.generalParams.bodystyle;
				car.year = _vehicleObj.generalParams.year.toString();
				car.configured =_vehicleObj.generalParams.configState
				if(car.configured){
					car.peg = _vehicleObj.configuredParams.peg;
					car.mmc = _vehicleObj.configuredParams.mmc;
					car.trimVcCode = _vehicleObj.configuredParams.trimVcCode
					car.color = _vehicleObj.configuredParams.color;
					car.intColor =_vehicleObj.preferredParams.intColor;
					car.options = _.map(_vehicleObj.generalParams.options, function(v, k){
						return k;
					}).join('|')
				}

				//set cookie
				mrm.util.cookie.set('vehicleConfig', JSON.stringify(car), {path:'/', expires: 365});

			}

			function _getCookie(){
				return JSON.parse(mrm.util.cookie.get('vehicleConfig'));

			}

			/**
			 * Sorts the vehicle list by timestamp in decending order
			 * @returns void
			 */
			function _sortVehicles() {
				_config.vehicles = _.sortBy(_config.vehicles, function(d) {
					return -d.timestamp;
				});
			}

			/**
			 * Loads the vehicle config
			 * @returns void
			 */
			function _load() {
				_config = JSON.parse(localStorage.getItem('vehicle-config')) || {};
				_sortVehicles();
			}

			/**
			 * Loaded the extended data from the DDP json service.
			 * NOTE: Not sure why but Dave said this was causing a reloading issue on BTL
			 * May not be used here.
			 * @param string brand
			 * @param string year
			 * @param string carline
			 * @param string bodystyle
			 * @returns void
			 */
			function _getExtendedInfo(brand, year, carline, bodystyle){
				if($.find(".masthead .modMm_visualizer_1").length !== 0){
					var url = '/configurator/DDP/'+brand.toLowerCase()+'/'+mrm.util.locale.getCountry().toUpperCase()+'/b2c/'+mrm.util.locale.getLang().toLowerCase()+'/'+year+'/'+carline.toLowerCase()+'/'+bodystyle.toLowerCase()+'/colorwheelstrim.json';
					//url = 'http://buick.com.dev01-www-seg1.gmds.plusline.net/configurator/DDP/buick/US/b2c/en/2013/regal/regal/colorwheelstrim.json';
					$.getJSON(url).done(function(data){
	//					_.each(data.colorsWheelsTrimsData.intColors, function(value, key, list){
	//						_vehicleObj.availableIntColors.push({rpo:key, name:value.displayName});
	//					});
	//
	//					_.each(data.colorsWheelsTrimsData.extColors, function(value, key, list){
	//						_vehicleObj.availableExtColors.push({rpo:key, name:value.displayName});
	//					});
	
						var trim = _.find(data.colorsWheelsTrimsData.trim, function(value){return value.mmc !== ''});
						var group = _.find(trim, function(value){return value.mmc !== ''});
	
						_vehicleObj.generalParams.mmc = group.mmc;
						_vehicleObj.generalParams.peg = group.peg;
	
						_vehicleObj.generalParams.extColor = group.extColors ? group.extColors[0] : null;
						_vehicleObj.generalParams.intColor = group.intColors ? group.intColors[0] : null;
						_vehicleObj.generalParams.wheels = group.wheels ? group.wheels[0] : null;
	
	//					_config.cgiExteriorImageBaseUrl = data.colorsWheelsTrimsData.global.cgiExteriorImageBaseUrl;
	//					_config.cgiInteriorImageBaseUrl = data.colorsWheelsTrimsData.global.cgiInteriorImageBaseUrl;
	
						$.eventDispatcher.trigger('vehicle_config_load');
	
					}).fail(function(jqxhr, textStatus, error){
	//					console.log('fail', error);
					});
				}
			}

			/**
			 * Look for a previous vehicle in the vehile array and if it exists
			 * load it from localStorage.
			 * @param string year
			 * @param string carline
			 * @param string bodystyle
			 * @returns {DOMString} vehicle object
			 */
			function _findVehicle(year, carline, bodystyle) {
				var index = -1;
				if(carline && bodystyle && year){
					for (var i = 0,count = _config.vehicles.length; i < count; i++) {
						if(_config.vehicles[i].key === carline+'_'+bodystyle+'_'+year){
							index = i;
							break;
						}
					}
				}
				if(index > -1){
					_config.vehicles[index].timestamp = new Date().getTime();
					_sortVehicles();
					return JSON.parse(localStorage.getItem(_config.vehicles[0].key));
				}
				return undefined;
			}

			/**
			 * Get the vehicle from the first item on the list
			 * @returns Object
			 */
			function _getCurrentVehicle(){
				if(_config.vehicles.length > 0){
					_config.vehicles[0].timestamp = new Date().getTime();
					return JSON.parse(localStorage.getItem(_config.vehicles[0].key));
				}
				return undefined;
			}

			/**
			 * Create a new vehicle object and added it to the vehicle array.
			 * Removes the oldest vehicle if there are more then max allowed.
			 * @param string year
			 * @param string carline
			 * @param string bodystyle
			 * @returns {undefined}
			 */
			function _newVehicle(brand, year, carline, bodystyle, price) {
				_vehicleObj.generalParams = _.extend(_generalDefaults, {brand:brand, year: +year, carline: carline, bodystyle: bodystyle, price: price, timestamp: new Date().getTime()});
				_vehicleObj.preferredParams = _preferredDefaults;
				_vehicleObj.configuredParams = _configuredDefaults;

				// add to array
				_config.vehicles.unshift({key:carline+'_'+bodystyle+'_'+year, timestamp:new Date().getTime()});
				if (_config.vehicles.length > _maxVehicles) {
					var vehicle = _config.vehicles.pop();
					localStorage.removeItem(vehicle.key);
				}

//				_save();
			}

			/**
			 * Adds options to the generalParams object of the vehicle object
			 * @param string rpo
			 * @param string label
			 * @param string img_path
			 * @returns void
			 */
			function _setOption(rpo, label, img_path){
				_vehicleObj.generalParams.options[rpo] = {rpo: rpo, label: label, img_path: img_path};
				$.eventDispatcher.trigger('vehicle_option_change', {action:'add', option:{rpo: rpo, label: label, img_path: img_path}});
				_save();
			}

			/**
			 * Creates the feature image path.
			 * @param string rpo
			 * @returns string
			 */
//			function _imagePath(rpo){
//				return '/ddp/gmna/assets/US/'+_curPageData.brand+'/'+_curPageData.year+'/'+_curPageData.carline+'/'+_curPageData.bodystyle+'/small/'+rpo+'.jpg';
//			}

			/**
			 * Removes options from the generalParams object of the vehicle object
			 * @param string rpo
			 * @returns void
			 */
			function _removeOption(rpo){
				delete _vehicleObj.generalParams.options[rpo];
				$.eventDispatcher.trigger('vehicle_option_change', {action:'remove', option:{rpo: rpo}});
				_save();
			}

			/**
			 * Adds key to the preferredParams object of the vehicle object
			 * @param string key
			 * @param string value
			 * @returns void
			 */
			function _setPreferred(key, value){
				_vehicleObj.preferredParams[key] = value;
				_save();
			}

			/**
			 * Sets key to the default '' value
			 * @param string key
			 * @returns void
			 */
			function _removePreferred(key){
				_vehicleObj.preferredParams[key] = '';
				_save();
			}

			/**
			 * Sets config of current vehicle (assumes valid object passed)
			 * @param object configObj
			 * @returns void
			 */
			function _setPreferrences(preferredObj) {
				$.each(preferredObj, function(key, val){
					_vehicleObj.preferredParams[key] = val;
				});
				_save();
			}

			/**
			 * Sets config of current vehicle (assumes valid object passed)
			 * @param object configObj
			 * @returns void
			 */
			function _setConfig(configObj) {
				$.each(configObj, function(key, val){
					_vehicleObj.configuredParams[key] = val;
				});
				_save();
			}

			function _validateConfigValues() {
				var valid = true, configValuesToCheck = ['color', 'driveType', 'intColor', 'mmc', 'peg', 'wheels']
				$.each(configValuesToCheck, function(i, val){
					if(_vehicleObj.configuredParams[val] == '' || _vehicleObj.configuredParams[val] == null || _vehicleObj.configuredParams[val] == 'undefined') valid = false;
				});
				return valid;
			}

			/**
			* Save and Return Visualizer View and Angle
			*/

			function _setView(view, angle){

				view = view.toLowerCase();

				if (angle[0] == 0){
					angle = angle[1];
				}

				var newView = '';
				var newAngle = '';

				if (view == 'int' || view == 'interior'){
					newView = 'int';
					newAngle = angle;
				} else if (view == 'ext' || view == 'exterior'){
					newView = 'ext';
					newAngle = angle;
				}

				if (newView == '' || newAngle == ''){ return; }

//				NOTE: No need to open and parse localStorage when it is already done.
//				var localData = localStorage.getItem('vehicle-config');
//				localData = JSON.parse(localData);
//
//				localData.currentView = newView;
//				localData[newView + 'Angle'] = newAngle;
//
//				localData = JSON.stringify(localData);
//				localStorage.setItem('vehicle-config', localData);

				// This will be global, if you want it attached to vehicle then save it to _vehicleObj
				_config.currentView = newView;
				_config[newView + 'Angle'] = newAngle;
				_save();

			}

			function _getView(){
//              NOTE: No need to open and parse localStorage when it is already done.
//				var localData = localStorage.getItem('vehicle-config');
//				localData = JSON.parse(localData);

				var view = {
					"view": _config.currentView,
					"angle": _config[_config.currentView + 'Angle'],
				}

				return view;
			}

			/**
			 * Create path for exterior images
			 * @param num size
			 * @param num angle
			 * @returns String
			 */
			function _getExteriorImage(size, angle){
//				'/mmgprod-us/dynres/prove/image.gen?i=2015/CC15906/CC15906__1LZ/GWT_H0U_RD4gmds6.jpg&v=deg03&std=true&country=US'
				var baseURL = '//cgi.pprod.'+_vehicleObj.generalParams.brand+'.com';
				var options = _.map(_vehicleObj.generalParams.options, function(value, key){return key;});
				if(+angle<10) angle = '0'+angle;
				var url = [];
				url.push(_vehicleObj.generalParams.year);
				url.push(_vehicleObj.generalParams.mmc);
				url.push(_vehicleObj.generalParams.mmc+'__'+_vehicleObj.generalParams.peg);
				url.push(_.compact([_vehicleObj.generalParams.extColor, _vehicleObj.generalParams.intColor, _vehicleObj.generalParams.wheels]).join('_')+'gmds'+size);
//				url.push(_.compact([_vehicleObj.generalParams.extColor, _vehicleObj.generalParams.intColor, _vehicleObj.generalParams.wheels]).join('_')+'_'+options.join('_')+'gmds'+size);
//				return _config.cgiExteriorImageBaseUrl+'?i='+_.compact(url).join('/') + _.compact(['.jpg','v=Deg'+angle, 'std=true', 'country=US' ]).join('&');
				return baseURL+'/mmgpprod-us/dynres/prove/image.gen?i='+_.compact(url).join('/') + _.compact(['.jpg','v=Deg'+angle, 'std=true', 'country=US' ]).join('&');
			}

			/**
			 * Create path for interior images
			 * @param num size
			 * @param num angle
			 * @returns String
			 */
			function _getInteriorImage(size, angle){
//				'/mmgprod-us/dynres/prove/imageinterior.gen?i=2015/CC15906/CC15906__1LZ/GWT_H0U_RD4gmds6.jpg&v=deg03&std=true&country=US'
				var baseURL = '//cgi.pprod.' + _vehicleObj.generalParams.brand + '.com';
				var options = _.map(_vehicleObj.generalParams.options, function(value, key){return key;});
				if(+angle<10) angle = '0'+angle;
				var url = [];
				url.push(_vehicleObj.generalParams.year);
				url.push(_vehicleObj.generalParams.mmc);
				url.push(_vehicleObj.generalParams.mmc+'__'+_vehicleObj.generalParams.peg);
				url.push(_.compact([_vehicleObj.generalParams.intColor, _vehicleObj.generalParams.extColor, _vehicleObj.generalParams.wheels]).join('_')+'gmds'+size);
//				url.push(_.compact([_vehicleObj.generalParams.intColor, _vehicleObj.generalParams.extColor, _vehicleObj.generalParams.wheels]).join('_')+'_'+options.join('_')+'gmds'+size);
//				return _config.cgiExteriorImageBaseUrl+'?i='+_.compact(url).join('/') + _.compact(['.jpg','v=Deg'+angle, 'std=true', 'country=US' ]).join('&');
				return baseURL+'/mmgpprod-us/dynres/prove/imageinterior.gen?i='+_.compact(url).join('/') + _.compact(['.jpg','v=Deg'+angle, 'std=true', 'country=US' ]).join('&');
			}
			/**
			 * merges based on order of arguments
			 * merges based on each value being defined and having length
			 * returns a merged of all objects passed as arguments
			 */
			function _mergeInOrder() //_mergeInOrder(arguments)
			{
			    var mergedObject = {};
			    var iteredValue;
				for(var i = 0; i < arguments.length; i++)
				{
					var iteredObject = arguments[i];
					for (var attrname in iteredObject)
					{
						iteredValue = iteredObject[attrname];
						if(iteredValue && iteredValue.toString().length) mergedObject[attrname] = iteredValue;
					}
				}
				return mergedObject;
			}
			/**
			 * returns all objects from "_vehicleObj" in a consolidated format
			 */
			function _getUserVehicle(argumentObject)
			{
				if(!_vehicleObj || !_vehicleObj.hasOwnProperty('generalParams') || !_vehicleObj.hasOwnProperty('configuredParams')) return undefined;
				var configuredObject = _vehicleObj.generalParams.configState ? _vehicleObj.configuredParams : {};
				return _mergeInOrder(argumentObject, _vehicleObj.generalParams, configuredObject);
			}
			/**
			 * resets the curent vehicle configuration to the default state and toggles the configured boolean
			 */
			function _resetConfiguredVehicle()
			{
				// also clear the BYO localStorage object
				var byoObj = JSON.parse(localStorage.getItem('byo'));

				try{
					byoObj[_vehicleObj.generalParams.year][_vehicleObj.generalParams.carline][_vehicleObj.generalParams.bodystyle] = {};
					localStorage.setItem('byo', JSON.stringify(byoObj))
				}catch(e){
				}
				_vehicleObj.generalParams.configState = false;
				_vehicleObj.configuredParams = _configuredDefaults;
				_save();
			}
			/**
			 * Initalize the the object
			 * @returns void
			 */
                //Variable declaration required for function _init()
            var pageData = {
                    "vehicle-info": {

                    }
                };
			function _init() {
				var config = $.extend({enabled:true/*turn it on by default*/}, mrm.conf.util.vehicleConfig ||{});

				if(config.enabled===true){
					_load();
					// use META tags to determine vehicle.  Set pageData object with that info
					// if pageData exist then find the vehicle in list or create a new one.
					// otherwise get the most recent one.
					var carline = $('meta[name="carline"]').attr('content');
					var bodystyle = $('meta[name="bodystyle"]').attr('content');
					var year = $('meta[name="year"]').attr('content');
					var brand = $('meta[name="brand"]').attr('content');
					var price = $('.modNav_anchor_1').find('.price').text();

					if(carline && bodystyle && year){
						var vehicle = _findVehicle(year, carline, bodystyle);


						if (typeof vehicle === 'undefined'){
							if(price) price = price.replace(/\D/ig, '');
							_newVehicle(brand, year, carline, bodystyle, price);
						}
						else _vehicleObj = vehicle;

						_save();

						// check if pageData is set.  If not, let's add attributes to that for future use
						if(!pageData["vehicle-info"].carline) pageData["vehicle-info"].carline = carline;
						if(!pageData["vehicle-info"].bodystyle) pageData["vehicle-info"].bodystyle = bodystyle;
						if(!pageData["vehicle-info"].year) pageData["vehicle-info"].year = year;
						if(!pageData["vehicle-info"].brand) pageData["vehicle-info"].brand = brand;

						// check to see if the extended info is loaded and if not
						// then load it otherwise trigger loaded.
						if(typeof _vehicleObj.generalParams.mmc === 'undefined' || _vehicleObj.generalParams.mmc === ''){
							_getExtendedInfo(brand, year, carline, bodystyle);
						}else{
							$.eventDispatcher.trigger('vehicle_config_load');
						}
					}else{
						_vehicleObj = _getCurrentVehicle();
						_save();
						$.eventDispatcher.trigger('vehicle_config_load');
					}
				}else{
					// create object with defaults
					_vehicleObj = _vehicleObj = {generalParams:{}, preferredParams:{}, configuredParams:{}};

					// trigger complete to prevent errors.
					$.eventDispatcher.trigger('vehicle_config_load_empty');
				}
			}

			/**
			 * public functions for the object.
			 */
			return {
				init: _init,
				getCurrentVehicle: function() {
					return _vehicleObj;
				},
				getUserVehicle: _getUserVehicle,
				getVehicle: function(year, carline, bodystyle){
					return _findVehicle(year, carline, bodystyle);
				},
				addOption: function(rpo, label, img_path) {
					_setOption(rpo, label, img_path);
				},
				removeOption: function(rpo){
					_removeOption(rpo);
				},
				getCurrentOptions: function(){
					return _vehicleObj.generalParams.options;
				},
				getCurrentOptionCount: function(){
					return _.size(_vehicleObj.generalParams.options);
				},
				optionAdded: function(rpo){
					return _vehicleObj.generalParams.options && typeof(_vehicleObj.generalParams.options[rpo]) !== 'undefined';
				},
				getAvailableOptions: function(){
					return _vehicleObj.generalParams.availableOptions || [];
				},
				setAvailableOptions: function(options){
					_vehicleObj.generalParams.availableOptions = options;
					_save();
				},
				isConfigured: function() {
					return _vehicleObj.generalParams.configState;
				},
				setConfigured: function() {
					_vehicleObj.generalParams.configState = true;
					_save();
				},
				hasAllConfigurationValues: function() {
					return _validateConfigValues();
				},
				setPreferredColor: function(rpo) {
					_vehicleObj.generalParams['extColor'] = rpo;
					_setPreferred('color', rpo);
				},
				getPreferredColor: function() {
					return _vehicleObj.preferredParams.color;
				},
				removePreferredColor: function(){
					_removePreferred('color');
				},
				getConfiguredColor: function() {
					return _vehicleObj.configuredParams.color;
				},
				setPreferredIntColor: function(rpo) {
					_setPreferred('intColor', rpo);
				},
				getPreferredIntColor: function(rpo) {
					return _vehicleObj.preferredParams.intColor;
				},
				removePreferredIntColor: function(){
					_removePreferred('intColor');
				},
				getConfiguredIntColor: function() {
					return _vehicleObj.configuredParams.intColor;
				},
				setPreferredMmc: function(key) {
					_setPreferred('mmc', key);
				},
				getPreferredMmc: function() {
					return _vehicleObj.preferredParams.mmc;
				},
				getConfiguredMmc: function() {
					return _vehicleObj.configuredParams.mmc;
				},
				setPreferredPeg: function(key) {
					_setPreferred('peg', key);
				},
				getPreferredPeg: function() {
					return _vehicleObj.preferredParams.peg;
				},
				getConfiguredPeg: function() {
					return _vehicleObj.configuredParams.peg;
				},
				setPreferredWheel: function(key) {
					_setPreferred('wheels', key);
				},
				getPreferredWheel: function() {
					return _vehicleObj.preferredParams.wheels;
				},
				getConfiguredWheel: function() {
					return _vehicleObj.configuredParams.wheels;
				},
				getConfiguredColorList: function() {
					return _vehicleObj.configuredParams.extColorList;
				},
				getConfiguredIntColorList: function() {
					return _vehicleObj.configuredParams.interiorList;
				},
				getConfiguredOptions: function() {
					return _vehicleObj.configuredParams.selectedOptions;
				},
				getSelectedRpo: function() {
					return _vehicleObj.configuredParams.selectedRpo;
				},
				setPreferrences: function(preferredObj){
					_setPreferrences(preferredObj);
				},
				getPreferences: function(){
					return _vehicleObj.preferredParams;
				},
				setConfiguration: function(configObj){
					_setConfig(configObj);
				},
				getConfiguration: function() {
					return _vehicleObj.configuredParams;
				},
				getExteriorImage:function(size, angle){
					return _getExteriorImage(size, angle);
				},
				getInteriorImage: function(size, angle){
					return _getInteriorImage(size, angle);
				},
				getCookie: function(){
					return _getCookie();
				},
				save: function(vehicleObj){
					_save(vehicleObj);
				},
				resetConfiguredVehicle: function(){
					_resetConfiguredVehicle();
				},
				setView: function(view, angle){
					_setView(view, angle);
				},
				getView: function(){
					return _getView();
				}
			}

		})()
	});
})(mrm.$);
mrm.conf.plugin.caroufredsel = {
	auto			: false,
	circular		: true,
	height			: 'auto',
	infinite		: false,
	items			: { visible	: 1 },
	pagination		: {
		anchorBuilder	: function( nr ) {
		    return '<li><a href="#">' + nr + '</a></li>';
		}
	},
	scroll: {
		pauseOnHover: true,
		wipe	: true
	}
};(function($) {
    /*
        For the full list of available options go see
        http://plugins.learningjquery.com/cluetip/#options
        or /all/js/plugins/jquery.cluetip.js
    */
    mrm.conf.plugin.cluetip = {
        // cluetipOptions
        cluezIndex  : 15,
        cursor		: 'pointer',
        arrows		: false,
        clickThrough: true,
        leftOffset	: 25,
        showTitle	: false,
        /*
            The most common usecase on the pages is using the tooltip to display title attributes,
            therefore default config should match that usecase.
            If you do not want to use the title attribute as content source
            set splitTitle: '' and configure the appropriate attribute (e.g attribute: 'href')
        */
        splitTitle	: '|',
        waitImage	: false,
        dropShadow	: false,

        // cluetipWrap options
        //prepareTitleAttr: false,     /* @see cluetipWrap.js */
        positionByMethod: 'hCenter', /* @see cluetipWrap.js */

		onHide: function($cTip) {}, 
        onShow: function($cTip, $cTipInner, triggerElem) {}
    };
})(mrm.$);mrm.conf.plugin.fancybox = {
	padding			: 0,
	margin			: 0,
	cyclic			: true,
	overlayOpacity	: 0.5,
	overlayColor	: '#000',
	titlePosition	: 'inside'
};(function($) {
    mrm.conf.plugin.jscrollpane = {
        scrollbarWidth: 17,
        showArrows: true,
        select: false,
        scrollbarMargin: 0,
        isSelect: false,
        verticalGutter: 0
        // autoReinitialise: true
    };
})(mrm.$);mrm.conf.plugin.ui_dialog = {
	callbacks: {
		onVideoContent: function($dialog) {},
		onVideoLoaded: function($dialog) {
			// special styling
			$dialog.parent().addClass('mm-content');
			// center Dialog
			$dialog.dialog('option', 'position', 'center');
		}
	},
	modal			: true,
	width			: 'auto',
	height			: 'auto'
};;(function($) {
	mrm.conf.plugin.infobox = {
		// default widget options can be overridden here
	};
})(mrm.$);mrm.conf.corcmp.mmVideo = {
	playerSwf: '/static/cms/all/swf/player.swf',
	videoDefaults: {
		'ignore'		: false,	// if set to true, mmVideo.activateVideo() must be called with an extra-parameter
		'autostart'     : false,	// start video on init [true || false]
		'startmuted'    : false,   	// start video muted [true || false]
		'posterclick'	: true   	// load video on posterimage-click [true || false]
	},
	jwpDefaults: {
		//skin: 'skin.zip', // set per brandconfig
		controlbar	: 'over'
	}
};mrm.conf.corcmp.mm_scroller = {
	scroll: {
		fx: 'slide'
	},
	animateControls: { // set animateCiontrols to false completely disable inactivity mangemet (no show/hideControls events are triggered) 
		fx: 'fade', // slide | fade | hide | none | function(jQuery $mmScrollBtns, bool isShowAnimation)
		loadTimeout: 5000, // initial inactivity timeout after pageload
		inactivityTimeout: 5000, // inactivity timeout in general
		speed: 300 // animation speed
	}
}
mrm.conf.cmp.cnt_dealer_intro_1 = mrm.$.extend(true, mrm.conf.cmp.cnt_dealer_intro_1 || {}, {
	shoppingLinks: {
		//"requestQuote": false,
		//"requestTestdrive": false,
		//"requestService": false 
	}
});mrm.conf.cmp.cnt_handraiser_1 = mrm.conf.cmp.cnt_handraiser_1 || {};
mrm.$.extend(true, mrm.conf.cmp.cnt_handraiser_1, {
	runWidth: true //add property runWidth, defaults to true
});mrm.conf.cmp.cnt_mmpar_1 = {
	fancybox	: mrm.$.extend({}, mrm.conf.plugin.fancybox),
	caroufredsel: mrm.$.extend({}, mrm.conf.plugin.caroufredsel)
}
mrm.conf.cmp.cnt_opt_1 = {
	positionBy	: 'auto',
	clickThrough: false,
	width		: 470,
	local		: false,
	hideLocal	: false,
	attribute	: 'href',
	splitTitle	: '',
	waitImage	: false,

	// cluetipWrap-Options
	positionByMethod : 'vCenter' // @see cluetipWrap.js
};//Add a close button for touch devices.
mrm.conf.cmp.cnt_opt_1_td = {
    sticky: true,
    closePosition:    'bottom',
    closeText:        'Close'
};
mrm.conf.cmp = mrm.conf.cmp || {};
mrm.conf.cmp.cnt_story_1 = {
	anim_speed: 300
};mrm.conf.cmp.colorizer = mrm.$.extend(true, mrm.conf.cmp.colorizer || {}, {
	
	animateColorizerItems: true,				// set to false if colorizer items should not be animated
	clueTipSettings: {
		prepareTitleAttr: true
	},
	enableScrollerForColorChips: true,			// scroller for the colorizer-colorchips (if too many)
	maxVisibleColours: 20,
	scrollerSettings: {
		circular: false,
		infinite: false,
		scroll: {
			wipe: false
		},
		items: {
			visible: 20
		},
		prev: {
			key: null
		},
		next: {
			key: null
		},
		pagination: {
			container: null,
			anchorBuilder: null
		}
	}

});mrm.conf.cmp.connect_1 = mrm.$.extend(true, mrm.conf.cmp.connect_1 || {}, {
	lazyLoad: true
});mrm.conf.cmp.disclaimer_1 = {
	cluetip: {
		sticky: 			true,     // keep visible until manually closed
		titleAttribute: 	'rel',    // the attribute to be used for fetching the clueTip's title
		activation: 		'click'	  // set to 'click' to force user to click to show clueTip,
	}
};mrm.conf.cmp = mrm.conf.cmp || {};
mrm.conf.cmp.lyr_email_1 = {
	errormsg: "service currently not available",
	validationmsg: "please fill all required input fields"
};mrm.conf.cmp.mh_1 = mrm.conf.cmp.mh_1 || {};
mrm.$.extend(true, mrm.conf.cmp.mh_1, {
	prev: {
		key: 'left'
	},
	next: {
		key: 'right'
	},
	scroll: {
		wipe: true,
		noWipeDirection: 'vertical'
	},
	smallContentMaxHeight: false,
	smallContentComponents: false,
	animatePagination: true // set to false if colorizer items should not be animated
});
mrm.conf.cmp.mh_expander_1 = mrm.$.extend(true, mrm.conf.cmp.mh_expander_1 || {}, {
	
	enableScrollerForColorChips: true,			// scroller for the colorizer-colorchips (if too many)
	maxVisibleColours: 10,
	scrollerSettings: {
		circular: false,
		infinite: false,
		scroll: {
			wipe: false
		},
		items: {
			visible: 10
		},
		prev: {
			key: 'left'
		},
		next: {
			key: 'right'
		},
		pagination: {
			container: null,
			anchorBuilder: null
		}
	}
	
});mrm.conf.cmp.mh_scroller_1 = mrm.conf.cmp.mh_scroller_1 || {};
mrm.$.extend(true, mrm.conf.cmp.mh_scroller_1, {
	prev: {
		key: 'left'
	},
	next: {
		key: 'right'
	},
	scroll: {
		wipe: true,
		noWipeDirection: 'vertical'
	},
	smallContentMaxHeight: false,
	smallContentComponents: false,
	animatePagination: true // set to false if colorizer items should not be animated
});mrm.conf.cmp.mm_1 = {
	jwpOptions: {},
	thumbnails_scroller_multiplier: 1
};mrm.conf.cmp = mrm.conf.cmp || {};
mrm.conf.cmp.mm_anim_1 = mrm.conf.cmp.mm_anim_1 || {};
mrm.$.extend(mrm.conf.cmp.mm_anim_1, {
	maxWidth: 1920
});mrm.conf.cmp = mrm.conf.cmp || {};
mrm.conf.cmp.mm_gal_1 = mrm.conf.cmp.mm_gal_1 || {};
mrm.$.extend(mrm.conf.cmp.mm_gal_1, {
	jumpToAnchors: false
});
mrm.conf.cmp = mrm.conf.cmp || {};

mrm.conf.cmp.mm_mos_1 = {
	autoscroll_slow		: 8000,
	autoscroll_medium	: 5000,
	autoscroll_fast		: 3000
};
mrm.conf.cmp.mm_visualizer_1 = mrm.conf.cmp.mm_visualizer_1 || {};
mrm.$.extend(true, mrm.conf.cmp.mm_visualizer_1, {
	scrollerSettings: {
		doInlineMargins: false,
		itemScrollerAlign: 'left',
		scroll: {
			fx: 'none'
		}
	},
	colorClueTipSettings: {
		prepareTitleAttr: true
	}
});
mrm.conf.cmp.nav_carlinefamily_selection_1 = {
	height	: 'auto' // integer value, or 'auto' or remove this line for auto height
};(function ($) {
	mrm.conf.cmp.nav_meta = {
	    positionDropdown: true,
	    menuItemTriggerSelector: "#mds-cmp-metanavigation li > .mod > dl > dt > a",
		menuItemParentSelector: "li",
		/*
		jQuery UI position() config
		http://jqueryui.com/demos/position/#options
		Unless configured otherwise, the 'of' property (element to position against) is set to the current list item 
		*/
		positionCfg: {
			my: "center top",
			at: "center bottom",
			collision: 'fit none',
			offset: "0 0",

			/* positioning callback to ensure the dropdowns are not positioned outside the header */
			using: function (coords) {
				var headerWidth = $('#mds-area-header').innerWidth(),
					layerWidth = $(this).innerWidth(),
					layerBorderWidth = ($(this).outerWidth() - layerWidth) / 2;

				if ( headerWidth < coords.left + layerWidth ) {
					coords.left = headerWidth - layerWidth;
					coords.left -= layerBorderWidth;
				}
				
				if ( !(coords.left > 0) ) {
					coords.left = -1 * layerBorderWidth;
				}

				$(this).css(coords);
			}
		}
	};
}(mrm.$));
mrm.conf.cmp.nav_viewallvehicles_selection_1 = {
	height	: 'auto' // integer value, or 'auto' or remove this line for auto height
};mrm.conf.cmp = mrm.conf.cmp || {};
mrm.conf.cmp.ut_cookie_privacy_1 = mrm.$.extend({
		adviceDisplayTime: 12
	},
	mrm.conf.cmp.ut_cookie_privacy_1 || {}
);mrm.conf.cmp.vi_3 = {
	fancybox	: mrm.$.extend({}, mrm.conf.plugin.fancybox),
	caroufredsel: mrm.$.extend({}, mrm.conf.plugin.caroufredsel)
};mrm.conf.ui.rows = {
	except: {
		// 'tpl': 'container' (jquery-selector)
		'06': '.mds-area-content'
	}
};mrm.conf.ui.scrollcontrol = {
	useScrollControl: false, // set to false if scrollcontrol should not be used
	offsetTop: 0
}
// Test-Data
mrm.conf.util.externalServices = mrm.$.extend(mrm.conf.util.externalServices || {}, {
	//reevooTRKREF: 'KIA' // for testing
});// Test-Data
mrm.conf.util.sharing = mrm.$.extend(mrm.conf.util.sharing || {}, {
	disabledProviderTag: 'disabled-'
	//facebookAppId: '164901976880508' // set by inline-js
});mrm.conf.plugin.cluetip = mrm.$.extend(true, mrm.conf.plugin.cluetip || {}, {
	// sticky:			false,	 // keep visible until manually closed
	// titleAttribute:	'rel',		// the attribute to be used for fetching the clueTip's title
	// activation:		'click',  	// set to 'click' to force user to click to show clueTip
	// closeText:		'X',	  	// text (or HTML) to to be clicked to close sticky clueTips
	// closePosition:	'top',		// location of close text for sticky cluetips; can be 'top' or 'bottom' or 'title'
	// attribute:		'rev',		// the attribute to be used for fetching the clueTip's body content
	// mouseOutClose:	false,		// close when clueTip is moused out
	arrows:			true, 			// Sets the z-index style property of the clueTip
	positionBy:		'bottomTop',	// Sets the type of positioning. more info below [2]
	topOffset:		15,			 	// Number of px to offset clueTip from top of invoking element. more info below [3]
	leftOffset:		15,				// Number of px to offset clueTip from left of invoking element. more info below [4]
	width:			'auto',			// The width of the clueTip
	height:			'auto',			// The height of the clueTip. more info below [1]
	maxWidth:		233,			// The max-width of the clueTip for cases where width is set to auto
	fx: {
	 	open:		'fadeIn',
		openSpeed:  300
	}
});mrm.conf.plugin.fancybox = mrm.$.extend(true, mrm.conf.plugin.fancybox, {
	overlayOpacity	: 0.55,
	centerOnScroll	: true,
	speedIn			: 200, 
	speedOut		: 200,
	changeSpeed		: 0,
	titlePosition	: 'over'	
});(function($) {
	mrm.conf.plugin.jscrollpane = mrm.$.extend(true, mrm.conf.plugin.jscrollpane || {}, {
		showArrows: false
	});
})(mrm.$);mrm.conf.plugin.ui_dialog = mrm.$.extend(true, mrm.conf.plugin.ui_dialog, {
	show: {
		effect: 'fade', 
		duration: 200 
	},
	hide: {
		effect: 'fade', 
		duration: 200 
	}
});;(function($) {
	mrm.conf.plugin.infobox = {
		// jqueryui position
		position: {
			my: 'center top',
			at: 'center bottom',
			collision: 'fit flip',
			offset: '0 10'
		},

		// behaviour
		openEvent: 'mouseenter',
		closeEvent: 'mouseleave',
		openDelay: 300,
		closeDelay: 300,
		showCloseButton: false,
		closeOnBoxLeave: true
	};
})(mrm.$);if (mrm.util.flash()) {
    mrm.conf.corcmp.mmVideo = mrm.$.extend(true, {}, mrm.conf.corcmp.mmVideo || {}, {
        jwpDefaults: {
            skin: '/static/cms/chevrolet2013/skins/jwplayer/skin.zip'
        }
    });
} else {
    /* add auto fullscreen on touch devices */
    if ((typeof(mrm.conf.corcmp.mmVideo) === "object") && (typeof(mrm.conf.corcmp.mmVideo.jwpSetup) === "object") && (mrm.util.touchDevice()))  {
        mrm.conf.corcmp.mmVideo.jwpSetup.events.onPlay = function() {
            var $video = mrm.$('#'+this.id + '_video:first');
            if ($video.length) {
                var vidElem = $video.get(0);
                if (vidElem.webkitSupportsFullscreen) {
                    vidElem.webkitEnterFullscreen();
                }                   
            }                
        }
    }  
    /*  removing the skin if it's HTML5 */
    if (typeof(mrm.conf.corcmp.mmVideo) === "object") {
        delete mrm.conf.corcmp.mmVideo.config;
    }
    mrm.$(document).ready(function() {
        mrm.corcmp.mmVideo.disableHtml5Skin(true);
    });	
}
(function($) {
	mrm.$.extend(true, mrm.conf.corcmp, {
		mm_scroller: {
			auto: {
				pauseDuration:6000
			},
			scroll: {
				fx: !mrm.util.touchDevice() ? 'crossfade' : 'slide',
				easing:'easeInOutExpo', // provided by jquery ui (public/js/libraries/static/jquery-ui.custom.js)
				duration:1000,
				noWipeDirection: 'vertical'
			},
			animateControls: {
				fx: mrm.util.touchDevice() ? 'none' : 'slide', /* slide | fade | hide | none | function */
				loadTimeout: 5000,
				inactivityTimeout: 5000,
				speed: 300
			}
		}
	});
})(mrm.$);/* The script is set up to not overwrite the error message if there is text inside #error-tx coming from the back end */

(function ($) {
	var countryCode = mrm.util.locale.getCountry();

	switch( countryCode.toUpperCase() ) {
	case 'US':
		mrm.conf.cmp.cnt_handraiser_opt_1 = $.extend( {},
		mrm.conf.cmp.cnt_handraiser_opt_1 || {}, {
			error_form: 	'Service currently not available.',
			error_ft0: 		'Required field.',
			error_gen:		'Please review the red highlighted fields for errors.', // generic error

			test_ft1: 		/^[A-Za-z0-9() -]+$/, // check for alphanumeric - both numbers and or letters (allow parenthesis, spaces, hyphens)
			// test_ft2: 		/^\d+$/, // check for numeric (numbers only)
			test_ft2: 		/^[0-9() -]+$/, // check for numeric - no alpha (numbers and parenthesis, spaces, hyphens)
			test_ft3: 		/^[A-Za-z -]+$/, // check for alphabetic (allow spaces and hyphens)
			test_ft4: 		/[a-zA-Z]/, // check for alphabetic (strictly letters)

			test_sosub: 	/[^0-9.]/g, // check for numeric (numbers only)
			test_numb:		/^\d+$/, // check for numeric (numbers only)
			test_email: 	/^[a-zA-Z0-9._%\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,4}$/, // email validation
			test_zip:		/(^\d{5}$)|(^\d{5}-\d{4}$)/, // us zip code validation
			dash_dot: 		/[^a-zA-Z0-9]/g,

			error_ft1: 		'Entered value must be alphanumeric (no special characters).',
			error_ft2: 		'Entered value must be numbers only.',
			error_ft3: 		'Entered value must be alphabetic only (letters only).',
			error_msk1:		'Entered value does not meet required criteria. Please check number of entered characters.',
			error_msk2:		'Entered value does not meet required criteria. Please check format.',
			error_email: 	'Please verify that the email entered is correct.',
			error_email2: 	'Confirmation email does not match.',
			error_city:		'Please enter a City.',
			error_zip:		'Please verify that the zip code entered is correct.',
			error_zipCity:	'Zipcode and City do not match.'
		});
	break;

	case 'MX': // example content
		mrm.conf.cmp.cnt_handraiser_opt_1 = $.extend( {},
		mrm.conf.cmp.cnt_handraiser_opt_1 || {}, {

		});
	break;

	default:
		mrm.conf.cmp.cnt_handraiser_opt_1 = $.extend( {},
		mrm.conf.cmp.cnt_handraiser_opt_1 || {}, {

		});

	}
})(mrm.$);mrm.conf.cmp.cnt_opt_1 = mrm.conf.cmp.cnt_opt_1 || {};

mrm.$.extend(mrm.conf.cmp.cnt_opt_1, {
	leftOffset: 61,
	arrows: 	true, 
        liveLeftPosition:true,
        liveLeftOffset:10
});(function($){
	$.extend(true, mrm.conf.cmp, {colorizer: {
		useColorTip: true,
		animateControlsForTouch:false
	}});
})(mrm.$);(function($){
	$.extend(true, mrm.conf.cmp, {mh_1: {
		scrollerType2: {
			enabled:true,
			imageWidth:1280,			
			width:1280,
			minWidth:980,
			height:551,			
			polygon_str:null,
			zIndexBase:40,
			offset:5,
			strokeWidth:10,
			angleLength:278,
			loadingImgSrc:"/static/cms/chevrolet2013/images/ajax-loader.gif",
			animateTime:{
				minTime:750,
				maxTime:1000				
			},
			onItemLoad:function(_ctx) { // _ctx: canvas element context
				/* this will draw the white borders into the canvas elements */
				_ctx.strokeStyle = 'white';		
		        _ctx.beginPath();
		        _ctx.lineWidth = this.strokeWidth;
		        /* left border */

		        _ctx.moveTo(0,this.height+this.strokeWidth);
		        _ctx.lineTo(this.angleLength,-this.strokeWidth);

				_ctx.shadowColor="rgba(0, 0, 0, 0.1)";
				_ctx.shadowBlur = 10;
				_ctx.shadowOffsetX = 5;
				_ctx.shadowOffsetY = 5;
		        
		        _ctx.stroke();
		        /* right border */		       
		        _ctx.moveTo(this.imageWidth-this.angleLength,this.height+this.strokeWidth);
		        _ctx.lineTo(this.imageWidth,-this.strokeWidth);

				_ctx.shadowColor="rgba(0, 0, 0, 0.1)";
				_ctx.shadowBlur = 10;
				_ctx.shadowOffsetX = 5;
				_ctx.shadowOffsetY = 5;

		        _ctx.stroke();
			}
		},

		animateControls:{fx:'slide'},
		hiddenVideoJWOptions:{
			"controlbar.idlehide":true,
			"controlbar.position":'over',
			"controlbar":'over',
			showControls:true,
			stretching:'fill',
			skin:'/static/cms/chevrolet2013/skins/jwplayer/skin.zip'
		}
	}});
	// set default masthead width for homepage
	if (mrm.util.curTemplate() === "02") {
		mrm.conf.cmp.mh_1.scrollerType2.imageWidth = 1440;
	}
	/* homepage full size masthead video */
	if ((mrm.util.curTemplate() === "02") && (typeof(mrm.conf.corcmp.mmVideo) === "object") && (typeof(mrm.conf.corcmp.mmVideo.jwpSetup) === "object")) {
		$.extend(true, mrm.conf.corcmp.mmVideo.jwpSetup, {
			"controlbar.idlehide":true,
			stretching:'fill'
		});
	}	

})(mrm.$);
(function($) {
	$.extend(true, mrm.conf.cmp, {
		mh_scroller_1: {
			scrollerType2: {
				enabled: true,
				imageWidth: 1280,
				width: 1280,
				minWidth: 980,
				height: 551,
				polygon_str: null,
				zIndexBase: 40,
				offset: 5,
				strokeWidth: 10,
				angleLength: 278,
				loadingImgSrc: "/static/cms/chevrolet2013/images/ajax-loader.gif",
				animateTime: {
					minTime: 750,
					maxTime: 1000
				},
				onItemLoad: function(_ctx) { // _ctx: canvas element context
					/* this will draw the white borders into the canvas elements */
					_ctx.strokeStyle = 'white';
					_ctx.beginPath();
					_ctx.lineWidth = this.strokeWidth;
					/* left border */

					_ctx.moveTo(0, this.height + this.strokeWidth);
					_ctx.lineTo(this.angleLength, -this.strokeWidth);

					_ctx.shadowColor = "rgba(0, 0, 0, 0.1)";
					_ctx.shadowBlur = 10;
					_ctx.shadowOffsetX = 5;
					_ctx.shadowOffsetY = 5;

					_ctx.stroke();
					/* right border */
					_ctx.moveTo(this.imageWidth - this.angleLength, this.height + this.strokeWidth);
					_ctx.lineTo(this.imageWidth, -this.strokeWidth);

					_ctx.shadowColor = "rgba(0, 0, 0, 0.1)";
					_ctx.shadowBlur = 10;
					_ctx.shadowOffsetX = 5;
					_ctx.shadowOffsetY = 5;

					_ctx.stroke();
				}
			},
			animateControls: {
				fx: 'slide'
			},
			hiddenVideoJWOptions: {
				"controlbar.idlehide": true,
				"controlbar.position": 'over',
				"controlbar": 'over',
				showControls: true,
				stretching: 'fill',
				skin: '/static/cms/chevrolet2013/skins/jwplayer/skin/skin.zip'
			}
		}
	});
	// set default masthead width for homepage
	if (mrm.util.curTemplate() === "02") {
		mrm.conf.cmp.mh_scroller_1.scrollerType2.imageWidth = 1440;
	}
	/* homepage full size masthead video */
	if ((mrm.util.curTemplate() === "02") && (typeof(mrm.conf.corcmp.mmVideo) === "object") && (typeof(mrm.conf.corcmp.mmVideo.jwpSetup) === "object")) {
		$.extend(true, mrm.conf.corcmp.mmVideo.jwpSetup, {
			"controlbar.idlehide": true,
			stretching: 'fill'
		});
	}
})(mrm.$);(function($) {
	mrm.conf.cmp.mm_1 = $.extend(true, {}, mrm.conf.cmp.mm_1 || {}, {
		jwpOptions: {skin: '/static/cms/chevrolet2013/skins/jwplayer/mm1-skin.zip'},
		thumbnail_scroller_config: {
			scroll: {
				fx: 'slide' // fix transition on thumbs in video scroller
			}
		}

	});

	mrm.conf.cmp.mm_1 = $.extend(true, {}, mrm.conf.cmp.mm_1 || {}, {
			/*for ie 8 to keep the next image from flashing*/
			fx: 'none'
		}
	);

})(mrm.$);mrm.conf.cmp.mm_visualizer_1 = mrm.conf.cmp.mm_visualizer_1 || {};
mrm.$.extend(true, mrm.conf.cmp.mm_visualizer_1, {
	scrollerSettings: mrm.$.extend(mrm.conf.cmp.mm_visualizer_1.scrollerSettings, {
		doInlineMargins: true,
		scroll: {
			onBefore: function($oldItem, $newItem, newSize, duration) {
				/* create canvas transition with some visually trickery. */
				if (typeof(mrm.cmp.mm_visualizer_1.canvasTransition) === 'object') {
					mrm.cmp.mm_visualizer_1.canvasTransition.slide($oldItem, $newItem);
				}
			},
			noWipeDirection: 'vertical'
		},
		animateControls: {
			fx: mrm.util.touchDevice() ? 'none' : 'slide',
			/* slide | fade | hide | none | function */
			loadTimeout: 5000,
			inactivityTimeout: 5000,
			speed: 300
		}
	})
});
(function ($) {
    mrm.conf.cmp.nav_meta = $.extend({}, mrm.conf.cmp.nav_meta || {}, {
        
        /**
            jQuery UI position() config
            http://jqueryui.com/demos/position/#options
            Unless configured otherwise, the 'of' property (element to position against) is set to the current list item 
        */
        
        positionCfg: {
            my: "center top",
            at: "center bottom",
            collision: 'fit none',
            offset: "0 0",

            /* positioning callback to ensure the dropdowns are not positioned outside the header */
            using: function (coords) {
                var headerWidth = $('#mds-area-header').innerWidth(),
                    layerWidth = $(this).innerWidth(),
                    layerBorderWidth = ($(this).outerWidth() - layerWidth) / 2,
                    metaWidth = $('#mds-cmp-metanavigation').outerWidth();

                // set base centering
                coords.left = $(this).parent().position().left + ($(this).parent().outerWidth()/2)-(layerWidth/2);
                coords.top = 45;

                if ($("html").attr("dir") == "rtl" && coords.left < 0) {
                    coords.left = 0;
                    $(this).css(coords);

                } else if ( (coords.left + layerWidth) > metaWidth ) { 
                    $(this).css({right:0,left:'inherit',top:45});

                } else {
                	$(this).css(coords);

                }

            }
        }
    });
}(mrm.$));(function ($) {
	mrm.conf.cmp.nav_prim = $.extend({}, mrm.conf.cmp.nav_prim || {}, {
		openOnClick: true,
		followRootLevelLink: false,
		showMask: true,
		maskSpeed: 200
	});
})(mrm.$);mrm.conf.ui.rows = mrm.conf.ui.rows || {};
mrm.$.extend(true, mrm.conf.ui.rows, {
	except: {
		// 'tpl': 'container' (jquery-selector)
		'05': '.grid_col2plus1_c2',
		'05': '.grid_col2_c1'
	}
});mrm.conf.ui.scrollcontrol = mrm.conf.ui.scrollcontrol || {};
mrm.$.extend(mrm.conf.ui.scrollcontrol, {
	useScrollControl: true,
	offsetTop: 82
});
if(typeof(Omniture_s) !== "undefined" && typeof(swfobject) !== "undefined") {
	Omniture_s.prop42 = swfobject.getFlashPlayerVersion().major + '.' + swfobject.getFlashPlayerVersion().minor + '.' + swfobject.getFlashPlayerVersion().release;
}if(typeof(Omniture_s) != "undefined"){
/* Omniture Module: Media; regarding https://jira.mrmworldwide.de/browse/GMDSPLM-2965 */
Omniture_s.m_Media_c="var m=s.m_i('Media');if(m.completeByCloseOffset==undefined)m.completeByCloseOffset=1;if(m.completeCloseOffsetThreshold==undefined)m.completeCloseOffsetThreshold=1;m.cn=function(n){var m="
+"this;return m.s.rep(m.s.rep(m.s.rep(n,\"\\n\",''),\"\\r\",''),'--**--','')};m.open=function(n,l,p,b){var m=this,i=new Object,tm=new Date,a='',x;n=m.cn(n);if(!l)l=-1;if(n&&p){if(!m.l)m.l=new Object;"
+"if(m.l[n])m.close(n);if(b&&b.id)a=b.id;if(a)for (x in m.l)if(m.l[x]&&m.l[x].a==a)m.close(m.l[x].n);i.n=n;i.l=l;i.o=0;i.x=0;i.p=m.cn(m.playerName?m.playerName:p);i.a=a;i.t=0;i.ts=0;i.s=Math.floor(tm"
+".getTime()/1000);i.lx=0;i.lt=i.s;i.lo=0;i.e='';i.to=-1;i.tc=0;i.fel=new Object;i.vt=0;i.sn=0;i.sx=\"\";i.sl=0;i.sg=0;i.sc=0;i.us=0;i.co=0;i.cot=0;i.lm=0;i.lom=0;m.l[n]=i}};m._delete=function(n){var"
+" m=this,i;n=m.cn(n);i=m.l[n];m.l[n]=0;if(i&&i.m)clearTimeout(i.m.i)};m.close=function(n){this.e(n,0,-1)};m.play=function(n,o,sn,sx,sl){var m=this,i;i=m.e(n,1,o,sn,sx,sl);if(i&&!i.m){i.m=new Object;"
+"i.m.m=new Function('var m=s_c_il['+m._in+'],i;if(m.l){i=m.l[\"'+m.s.rep(i.n,'\"','\\\\\"')+'\"];if(i){if(i.lx==1)m.e(i.n,3,-1);i.m.i=setTimeout(i.m.m,1000)}}');i.m.m()}};m.complete=function(n,o){th"
+"is.e(n,5,o)};m.stop=function(n,o){this.e(n,2,o)};m.track=function(n){this.e(n,4,-1)};m.bcd=function(vo,i){var m=this,ns='a.media.',v=vo.linkTrackVars,e=vo.linkTrackEvents,pe='m_i',pev3,c=vo.context"
+"Data,x;c['a.contentType']='video';c[ns+'name']=i.n;c[ns+'playerName']=i.p;if(i.l>0){c[ns+'length']=i.l;}c[ns+'timePlayed']=Math.floor(i.ts);if(!i.vt){c[ns+'view']=true;pe='m_s';i.vt=1}if(i.sx){c[ns"
+"+'segmentNum']=i.sn;c[ns+'segment']=i.sx;if(i.sl>0)c[ns+'segmentLength']=i.sl;if(i.sc&&i.ts>0)c[ns+'segmentView']=true}if(!i.cot&&i.co){c[ns+\"complete\"]=true;i.cot=1}if(i.lm>0)c[ns+'milestone']=i"
+".lm;if(i.lom>0)c[ns+'offsetMilestone']=i.lom;if(v)for(x in c)v+=',contextData.'+x;pev3='video';vo.pe=pe;vo.pev3=pev3;var d=m.contextDataMapping,y,a,l,n;if(d){vo.events2='';if(v)v+=',events';for(x i"
+"n d){if(x.substring(0,ns.length)==ns)y=x.substring(ns.length);else y=\"\";a=d[x];if(typeof(a)=='string'){l=m.s.sp(a,',');for(n=0;n<l.length;n++){a=l[n];if(x==\"a.contentType\"){if(v)v+=','+a;vo[a]="
+"c[x]}else if(y){if(y=='view'||y=='segmentView'||y=='complete'||y=='timePlayed'){if(e)e+=','+a;if(c[x]){if(y=='timePlayed'){if(c[x])vo.events2+=(vo.events2?',':'')+a+'='+c[x];}else if(c[x])vo.events"
+"2+=(vo.events2?',':'')+a}}else if(y=='segment'&&c[x+'Num']){if(v)v+=','+a;vo[a]=c[x+'Num']+':'+c[x]}else{if(v)v+=','+a;vo[a]=c[x]}}}}else if(y=='milestones'||y=='offsetMilestones'){x=x.substring(0,"
+"x.length-1);if(c[x]&&d[x+'s'][c[x]]){if(e)e+=','+d[x+'s'][c[x]];vo.events2+=(vo.events2?',':'')+d[x+'s'][c[x]]}}}vo.contextData=0}vo.linkTrackVars=v;vo.linkTrackEvents=e};m.bpe=function(vo,i,x,o){v"
+"ar m=this,pe='m_o',pev3,d='--**--';pe='m_o';if(!i.vt){pe='m_s';i.vt=1}else if(x==4)pe='m_i';pev3=m.s.ape(i.n)+d+Math.floor(i.l>0?i.l:1)+d+m.s.ape(i.p)+d+Math.floor(i.t)+d+i.s+d+(i.to>=0?'L'+Math.fl"
+"oor(i.to):'')+i.e+(x!=0&&x!=2?'L'+Math.floor(o):'');vo.pe=pe;vo.pev3=pev3};m.e=function(n,x,o,sn,sx,sl,pd){var m=this,i,tm=new Date,ts=Math.floor(tm.getTime()/1000),c,l,v=m.trackVars,e=m.trackEvent"
+"s,ti=m.trackSeconds,tp=m.trackMilestones,to=m.trackOffsetMilestones,sm=m.segmentByMilestones,so=m.segmentByOffsetMilestones,z=new Array,j,t=1,w=new Object,x,ek,tc,vo=new Object;n=m.cn(n);i=n&&m.l&&"
+"m.l[n]?m.l[n]:0;if(i){if(o<0){if(i.lx==1&&i.lt>0)o=(ts-i.lt)+i.lo;else o=i.lo}if(i.l>0)o=o<i.l?o:i.l;if(o<0)o=0;i.o=o;if(i.l>0){i.x=(i.o/i.l)*100;i.x=i.x>100?100:i.x}if(i.lo<0)i.lo=o;tc=i.tc;w.name"
+"=n;w.length=i.l;w.openTime=new Date;w.openTime.setTime(i.s*1000);w.offset=i.o;w.percent=i.x;w.playerName=i.p;if(i.to<0)w.mediaEvent=w.event='OPEN';else w.mediaEvent=w.event=(x==1?'PLAY':(x==2?'STOP"
+"':(x==3?'MONITOR':(x==4?'TRACK':(x==5?'COMPLETE':('CLOSE'))))));if(!pd){if(i.pd)pd=i.pd}else i.pd=pd;w.player=pd;if(x>2||(x!=i.lx&&(x!=2||i.lx==1))) {if(!sx){sn=i.sn;sx=i.sx;sl=i.sl}if(x){if(x==1)i"
+".lo=o;if((x<=3||x==5)&&i.to>=0){t=0;v=e=\"None\";if(i.to!=o){l=i.to;if(l>o){l=i.lo;if(l>o)l=o}z=tp?m.s.sp(tp,','):0;if(i.l>0&&z&&o>=l)for(j=0;j<z.length;j++){c=z[j]?parseFloat(''+z[j]):0;if(c&&(l/i"
+".l)*100<c&&i.x>=c){t=1;j=z.length;w.mediaEvent=w.event='MILESTONE';i.lm=w.milestone=c}}z=to?m.s.sp(to,','):0;if(z&&o>=l)for(j=0;j<z.length;j++){c=z[j]?parseFloat(''+z[j]):0;if(c&&l<c&&o>=c){t=1;j=z"
+".length;w.mediaEvent=w.event='OFFSET_MILESTONE';i.lom=w.offsetMilestone=c}}}}if(i.sg||!sx){if(sm&&tp&&i.l>0){z=m.s.sp(tp,',');if(z){z[z.length]='100';l=0;for(j=0;j<z.length;j++){c=z[j]?parseFloat('"
+"'+z[j]):0;if(c){if(i.x<c){sn=j+1;sx='M:'+l+'-'+c;j=z.length}l=c}}}}else if(so&&to){z=m.s.sp(to,',');if(z){z[z.length]=''+(i.l>0?i.l:'E');l=0;for(j=0;j<z.length;j++){c=z[j]?parseFloat(''+z[j]):0;if("
+"c||z[j]=='E'){if(o<c||z[j]=='E'){sn=j+1;sx='O:'+l+'-'+c;j=z.length}l=c}}}}if(sx)i.sg=1}if((sx||i.sx)&&sx!=i.sx){i.us=1;if(!i.sx){i.sn=sn;i.sx=sx}if(i.to>=0)t=1}if(x>=2&&i.lo<o){i.t+=o-i.lo;i.ts+=o-"
+"i.lo}if(x<=2||(x==3&&!i.lx)){i.e+=(x==1||x==3?'S':'E')+Math.floor(o);i.lx=(x==3?1:x)}if(!t&&i.to>=0&&x<=3){ti=ti?ti:0;if(ti&&i.ts>=ti){t=1;w.mediaEvent=w.event='SECONDS'}}i.lt=ts;i.lo=o}if(!x||i.x>"
+"=100){x=0;m.e(n,2,-1,0,0,-1,pd);v=e=\"None\";w.mediaEvent=w.event=\"CLOSE\"}if(x==5||(m.completeByCloseOffset&&(!x||i.x>=100)&&i.l>0&&o>=i.l-m.completeCloseOffsetThreshold)){w.complete=i.co=1;t=1}e"
+"k=w.mediaEvent;if(ek=='MILESTONE')ek+='_'+w.milestone;else if(ek=='OFFSET_MILESTONE')ek+='_'+w.offsetMilestone;if(!i.fel[ek]) {w.eventFirstTime=true;i.fel[ek]=1}else w.eventFirstTime=false;w.timePl"
+"ayed=i.t;w.segmentNum=i.sn;w.segment=i.sx;w.segmentLength=i.sl;if(m.monitor&&x!=4)m.monitor(m.s,w);if(x==0)m._delete(n);if(t&&i.tc==tc){vo=new Object;vo.contextData=new Object;vo.linkTrackVars=v;vo"
+".linkTrackEvents=e;if(!vo.linkTrackVars)vo.linkTrackVars='';if(!vo.linkTrackEvents)vo.linkTrackEvents='';if(m.trackUsingContextData)m.bcd(vo,i);else m.bpe(vo,i,x,o);m.s.t(vo);if(i.us){i.sn=sn;i.sx="
+"sx;i.sc=1;i.us=0}else if(i.ts>0)i.sc=0;i.e=\"\";i.lm=i.lom=0;i.ts-=Math.floor(i.ts);i.to=o;i.tc++}}}return i};m.ae=function(n,l,p,x,o,sn,sx,sl,pd,b){var m=this,r=0;if(n&&(!m.autoTrackMediaLengthReq"
+"uired||(length&&length>0)) &&p){if(!m.l||!m.l[n]){if(x==1||x==3){m.open(n,l,p,b);r=1}}else r=1;if(r)m.e(n,x,o,sn,sx,sl,pd)}};m.a=function(o,t){var m=this,i=o.id?o.id:o.name,n=o.name,p=0,v,c,c1,c2,x"
+"c=m.s.h,x,e,f1,f2='s_media_'+m._in+'_oc',f3='s_media_'+m._in+'_t',f4='s_media_'+m._in+'_s',f5='s_media_'+m._in+'_l',f6='s_media_'+m._in+'_m',f7='s_media_'+m._in+'_c',tcf,w;if(!i){if(!m.c)m.c=0;i='s"
+"_media_'+m._in+'_'+m.c;m.c++}if(!o.id)o.id=i;if(!o.name)o.name=n=i;if(!m.ol)m.ol=new Object;if(m.ol[i])return;m.ol[i]=o;if(!xc)xc=m.s.b;tcf=new Function('o','var e,p=0;try{if(o.versionInfo&&o.curre"
+"ntMedia&&o.controls)p=1}catch(e){p=0}return p');p=tcf(o);if(!p){tcf=new Function('o','var e,p=0,t;try{t=o.GetQuickTimeVersion();if(t)p=2}catch(e){p=0}return p');p=tcf(o);if(!p){tcf=new Function('o'"
+",'var e,p=0,t;try{t=o.GetVersionInfo();if(t)p=3}catch(e){p=0}return p');p=tcf(o)}}v=\"var m=s_c_il[\"+m._in+\"],o=m.ol['\"+i+\"']\";if(p==1){p='Windows Media Player '+o.versionInfo;c1=v+',n,p,l,x=-"
+"1,cm,c,mn;if(o){cm=o.currentMedia;c=o.controls;if(cm&&c){mn=cm.name?cm.name:c.URL;l=cm.duration;p=c.currentPosition;n=o.playState;if(n){if(n==8)x=0;if(n==3)x=1;if(n==1||n==2||n==4||n==5||n==6)x=2;}"
+"';c2='if(x>=0)m.ae(mn,l,\"'+p+'\",x,x!=2?p:-1,0,\"\",0,0,o)}}';c=c1+c2;if(m.s.isie&&xc){x=m.s.d.createElement('script');x.language='jscript';x.type='text/javascript';x.htmlFor=i;x.event='PlayStateC"
+"hange(NewState)';x.defer=true;x.text=c;xc.appendChild(x);o[f6]=new Function(c1+'if(n==3){x=3;'+c2+'}setTimeout(o.'+f6+',5000)');o[f6]()}}if(p==2){p='QuickTime Player '+(o.GetIsQuickTimeRegistered()"
+"?'Pro ':'')+o.GetQuickTimeVersion();f1=f2;c=v+',n,x,t,l,p,p2,mn;if(o){mn=o.GetMovieName()?o.GetMovieName():o.GetURL();n=o.GetRate();t=o.GetTimeScale();l=o.GetDuration()/t;p=o.GetTime()/t;p2=o.'+f5+"
+"';if(n!=o.'+f4+'||p<p2||p-p2>5){x=2;if(n!=0)x=1;else if(p>=l)x=0;if(p<p2||p-p2>5)m.ae(mn,l,\"'+p+'\",2,p2,0,\"\",0,0,o);m.ae(mn,l,\"'+p+'\",x,x!=2?p:-1,0,\"\",0,0,o)}if(n>0&&o.'+f7+'>=10){m.ae(mn,l"
+",\"'+p+'\",3,p,0,\"\",0,0,o);o.'+f7+'=0}o.'+f7+'++;o.'+f4+'=n;o.'+f5+'=p;setTimeout(\"'+v+';o.'+f2+'(0,0)\",500)}';o[f1]=new Function('a','b',c);o[f4]=-1;o[f7]=0;o[f1](0,0)}if(p==3){p='RealPlayer '"
+"+o.GetVersionInfo();f1=n+'_OnPlayStateChange';c1=v+',n,x=-1,l,p,mn;if(o){mn=o.GetTitle()?o.GetTitle():o.GetSource();n=o.GetPlayState();l=o.GetLength()/1000;p=o.GetPosition()/1000;if(n!=o.'+f4+'){if"
+"(n==3)x=1;if(n==0||n==2||n==4||n==5)x=2;if(n==0&&(p>=l||p==0))x=0;if(x>=0)m.ae(mn,l,\"'+p+'\",x,x!=2?p:-1,0,\"\",0,0,o)}if(n==3&&(o.'+f7+'>=10||!o.'+f3+')){m.ae(mn,l,\"'+p+'\",3,p,0,\"\",0,0,o);o.'"
+"+f7+'=0}o.'+f7+'++;o.'+f4+'=n;';c2='if(o.'+f2+')o.'+f2+'(o,n)}';if(m.s.wd[f1])o[f2]=m.s.wd[f1];m.s.wd[f1]=new Function('a','b',c1+c2);o[f1]=new Function('a','b',c1+'setTimeout(\"'+v+';o.'+f1+'(0,0)"
+"\",o.'+f3+'?500:5000);'+c2);o[f4]=-1;if(m.s.isie)o[f3]=1;o[f7]=0;o[f1](0,0)}};m.as=new Function('e','var m=s_c_il['+m._in+'],l,n;if(m.autoTrack&&m.s.d.getElementsByTagName){l=m.s.d.getElementsByTag"
+"Name(m.s.isie?\"OBJECT\":\"EMBED\");if(l)for(n=0;n<l.length;n++)m.a(l[n]);}');if(s.wd.attachEvent)s.wd.attachEvent('onload',m.as);else if(s.wd.addEventListener)s.wd.addEventListener('load',m.as,fal"
+"se);if(m.onLoad)m.onLoad(s,m)";
Omniture_s.m_i("Media");
}/*
	 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) {
	mrm.app = mrm.app || {};
	$.extend(mrm.app, {
		byo: {
			/**
			 * JS for component byo
			 *
			 * @param {String} c DOM Context
			 */
			tpl: ['16'],
			init: function(c)
			{
				mrm.util.log('[mrm.cmp.byo] Context: ' + c);

				/* Replace the title attributes with a tooltip */
				$('#mds-app-byo .ui-title-replace[title]').livequery(function()
				{
					/* Add a custom class to the tooltip source element
					 * so we can identify if the tooltip replacement
					 * takes place currently or has taken place */
					if(!$(this).hasClass("ui-title-replaced"))
						$(this).addClass("ui-title-replaced");

					/* Add tooltip with title content and remove extra class */
					$(this).tooltip({ showURL: false, extraClass: "" });
				});

				/* Remove the tooltip if there is no title attribute anymore and
				 * if there is no title replaced class flag also; The class flag
				 * may be removed by applications on runtime */
				$('#mds-app-byo .ui-title-replace:not([title], .ui-title-replaced)').livequery(function()
				{
					/* Hide the tooltip because there is no method to delete it */
					$(this).tooltip({ extraClass: "ui-helper-hidden" });
				});

			}
		}
	});
}(mrm.$));/*
	Sabina D'Addea, MRM
*/
 (function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		social01: {          
			/**
			 * JS for component social01-twitter
			 * 
			 * @param {String} c DOM Context
			 */
			tpl: ['05', '06', '08'],
			socialcontent: function(url) {
				$.getJSON(url, function(data){
					$.each(data, function(index, item){
						$('#twitter').append('<li><strong>' + item.text + '</strong> - ' + item.created_at + '</li>');
					});					
				});				
			},
			init: function(c) {  
			
				$('div.mds-cmp-social01 div.nav_extended_1 li:first').addClass('active');
				
				$('div.mds-cmp-social01 div.nav_extended_1').click(function(event){
					mrm.util.log($(event.target).closest('li').siblings());
					$(event.target).closest('li').addClass('active').siblings().removeClass('active');
				});							  
			}   
		}
	});
}(mrm.$));/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) { 
	mrm.cms = mrm.cms || {};
	$.extend(mrm.cms, {           
		has_mdsAreaPT: {          
			/**
			 * JS for component has_mds-area-pt
			 * 
			 * @param {String} c DOM Context
			 */
			tpl: ['04', '05', '08', '09', '12', '13', '14'],
			init: function(c) {    
				mrm.util.log('[mrm.cmp.has_mdsAreaPT] Context: ' + c);
				
				$('div.mds-area-ptl').parent(":not('.teaser_scroller_area')").closest('div[id^="mds-tpl"]').addClass('has_ptl');
				$('div.mds-area-ptr').parent(":not('.teaser_scroller_area')").closest('div[id^="mds-tpl"]').addClass('has_ptr');
			}   
		}
	});
}(mrm.$));/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) { 
	mrm.cms = mrm.cms || {};
	$.extend(mrm.cms, {           
		nested_objects: {          
			/**
			 * adding a class on the oject which is interpreted according to the browser
			 * 
			 * @param {String} c DOM Context
			 */
			
			init: function(c) {    
				mrm.util.log('[mrm.cms.nested_objects] Context: ' + c);
				
				var $objects = $('object');
				
				$objects.each(function(index, item){
					var id = $(item).attr('id');
					
					// swfobject.getObjectById corrects crossbrowser issues for nested objects
					$( swfobject.getObjectById(id) ).addClass('active');
				});
			}   
		}
	});
}(mrm.$));/*
 *  2013 by MRM Worldwide
 */
/*
 * @author david.walker
 * @name validate_cookie
 */
(function($) {
    mrm.cms = mrm.cms || {};
    $.extend(mrm.cms, {
        validate_cookie: {
            init:function(context) {
                var uiDown = mrm.util.touchDevice() ? 'touchstart' : 'click';
                $(".validate-cookie").on(uiDown, function(event) {
                    var currentButton   = $(event.currentTarget);
                    var currentHREF = currentButton.attr('href');
                    mrm.cmp.zc.open(currentHREF, true, 'byo16');
                    return false;
                });
            }
		}
    });
}(mrm.$));/*
    global Callback for jwPlayer
*/
function playerReady(obj) {
    mrm.corcmp.mmVideo.playerReady(obj);
}

(function ($) {
    mrm.corcmp = mrm.corcmp || {};
    $.extend(mrm.corcmp, {
        mmVideo: function () {
            var targetVideoPlayer = null;
            var targetVideoItem = null;
            var disableHtml5Skin = false;
            var mmVideoInterface = {};

            /**
             * private, _initVideo() initilizes the JW Player per div.video
             * @param $video    $(div.video)
             * @param data      individual $video.data()
             * @param options   additional jwPlayer settings
             * @param $target   element which contains a reusable JW Player object that only gets setup once
             */
            mmVideoInterface._initVideo = function ($video, data, options, $target) {
                var self = this;
                var config = $.extend(true, {}, mrm.conf.corcmp.mmVideo);
                data = $.extend(true, {}, config.videoDefaults, data);

                var id = $video.attr('id');
                var jwPlayerTargetId = 'jwPlayerTarget_' + id;
                var poster = $('> img', $video).eq(0).attr('src');

                // if already initialized, quit
                if ($video.data('initialized') === true) return true;
                $video.data('initialized', true);

                // JW-Player config
                var jwpSetup = $.extend(true, {}, config.jwpDefaults, {
                    image: poster,
                    file: data.url,
                    autostart: false,
                    mute: data.startmuted,
                    height: data.height || '100%',
                    width: data.width || '100%',
                    modes: [{
                        type: 'flash',
                        src: config.playerSwf || null
                    }, {
                        type: 'html5'
                    }]
                });
                var jwpSetup = $.extend(true, {}, jwpSetup, options);

				/// force to the right size for Firefox
				if (($('html').hasClass('firefox') || mrm.util.ie() || $('html').hasClass('unknownX')) && jwpSetup.endFrameCall) {
					$video.width(jwpSetup.width).height(jwpSetup.height);
					$video.find('object').width(jwpSetup.width).height(jwpSetup.height);
				}

                // determin whether jwplayer object will be created inside div.video or within specified container
                var $setupTarget = (typeof $target === "undefined" || $target.length < 1) ? $video : $target;



                if ($setupTarget.data("setup") !== true || $("#" + $setupTarget.data("jwpTargetId")).length < 1 ) {

                    // create target for jwPlayer
                    $setupTarget.html('<div id="' + jwPlayerTargetId + '" />');

                    // init jwPlayer
					try {
						var player = jwplayer(jwPlayerTargetId).setup(jwpSetup);
					} catch (e) {
						mrm.util.log(e);
					}

					if(!player) return;


                    // When playing a video, pause all other videos as well as disabling tracking metrics
                    player.onPlay(function(){
//						/// force to the right size for Firefox moved up
//						if(($('html').hasClass('firefox') || mrm.util.ie() || $('html').hasClass('unknownX')) && jwpSetup.endFrameCall){
//							$video.width(jwpSetup.width).height(jwpSetup.height);
//							$video.find('object').width(jwpSetup.width).height(jwpSetup.height);
//						}

                    	$video.closest('.mod').trigger('mmVideoPlay');
                        self._pauseAllVideo(jwPlayerTargetId);
                    });

					// when paused show end frame if exist
					player.onPause(function(){
						var $container = $(this.container)
						var $thisVid = $container.hasClass('video') ? $container : $container.closest('.video');
						var $end_frame = $thisVid.siblings('.end_frame_wrap');
						if($end_frame.length && this.getPosition() > 1){
							mrm.ui.video_end_frame.initialize($end_frame, options, 'replay');
						}
					});

                    // When complete, dispatch a custom complete event to the containng module
                    player.onComplete(function() {
                    	$video.closest('.mod').trigger('mmVideoComplete');
						// if a poster frame was used to initiate the video, restore the poster frame
						if($video.data('posterclick') === true){
							if(typeof $target !== "undefined"){
								var $currentVideo = $("#"+$setupTarget.data("jwpCurrentVideo"));
								self.deactivateVideo($currentVideo, $target);
								self.activateVideo($currentVideo, $target);
							}else{
								if(mrm.util.ie()){
									// IE attemptes to run other ExternalInterface calls on video complete
									// If there is no delay in removing the player, IE throws a JS error since the EI call is referring to a null object
									setTimeout(function(){self.deactivateVideo($video)}, 10);
									setTimeout(function(){self.activateVideo($video)}, 20);
								}else{
									self.deactivateVideo($video);
									self.activateVideo($video)
								}
							}
						}

						if($video.siblings('.end_frame_wrap').length){
							mrm.ui.video_end_frame.initialize($video.siblings('.end_frame_wrap'), options, "end");
						}
                    });

                    // mark current jwplayer object container as being setup and keep track of the ID inside

                    $setupTarget.data("setup", true);
                    $setupTarget.data("jwpTargetId", jwPlayerTargetId);
                    $setupTarget.data("jwpCurrentVideo", $video.attr('id'));

                    // tracking
                    self._initTracking(player);
                } else {
                    // load new video config and reuse previously created jwplayer object container
                    var targetId = $setupTarget.data("jwpTargetId");
                    var player = jwplayer(targetId).load(jwpSetup);

                    // save the new video ID into the setupTarget so that oncomplete, the correct video is deactivated
                    $setupTarget.data("jwpCurrentVideo", $video.attr('id'));
                }




                // share2
                var $share2 = $('.modShare_2', $video);
                if ($share2.length > 0) $(player.container).after($share2); // TODO: does this work?



                return player;
            };


            /**
             * Returns all div.video-tags which are children of the $collection-elements.
             * $collection-items can also contain toplevel div.video-tags.
             *
             * @param $collection jQuery    parent(s) of/or direct video-tag(s)
             * @return $jQuery              collection of div.video-tags
             */
            mmVideoInterface.getVideoTags = function($collection) {
                var self = this;
                var selector = 'div.video';
                if (!$collection || $collection.length == 0) return $();

                if ($collection.length == 1) {
                    // single element
                    if ($collection.is(selector)) return $collection;
                    return $collection.find(selector);
                } else {
                    // collection
                    var $videos = $();
                    $collection.each(function() {
                        var $this = $(this);
                        if ($this.is(selector)) {
                            $videos.add($this);
                        } else {
                            $videos.add($this.find(selector));
                        }
                    });
                    return $videos;
                }
                // exception
                return false;
            },

            /**
             * returns all enabled JW PLayers
             * @param $collection   container or collection with videos
             * @return array of JW Player-objects
             */
            mmVideoInterface.getJWPlayers = function($collection) {
                var self = this;
                var players = [];
                $(jwplayer.getPlayers()).each(function(counter) {
                    if ($collection.find('#' + this.id).length > 0) players.push(this);
                });
                return players;
            },

            /**
             * public, activateVideo()
             * @param $container jQuery         containing one or more div.video to activate (can also be a collection)
             * @param argOng, argTwo, argThree  optional: auto assigned to the following variables based on type
             *      if boolean:         assigned to autoInit:       initialize also the ignore-marked div.video-tags?
             *      if jQuery object:   assigned to $videoTarget:   element in which the initialized video will reside
             *      if object:          assigned to options:        additional jwPlayer options, overrides any default
             *                                                      options provided by mmVideo
             * @return jQuery               activated div.video-tags
             */
            mmVideoInterface.activateVideo = function ($container, argOne, argTwo, argThree) {
                var initIgnored;
                var $target;
                var options;
                var optionalArgs = [];

                if (typeof argOne !== "undefined" && argOne !== null) optionalArgs.push(argOne);
                if (typeof argTwo !== "undefined" && argTwo !== null) optionalArgs.push(argTwo);
                if (typeof argThree !== "undefined" && argThree !== null) optionalArgs.push(argThree);

                for (var arg in optionalArgs) {
                    if (typeof optionalArgs[arg] === "boolean") {
                        initIgnored = optionalArgs[arg];
                    } else if (typeof optionalArgs[arg].jquery === "string") {
                        $target = optionalArgs[arg];
                    } else if (typeof optionalArgs[arg] === "object") {
                        options = optionalArgs[arg];
                    }
                }

                initIgnored = initIgnored === true;

                var self = this;
                var $videos = self.getVideoTags($container);
                if (!initIgnored) $videos = $videos.not('[data-ignore="true"]');


                if ($videos.length === 0) return;

                $videos.each(function() {
                    var $video = $(this);
                    var data = $video.data();

                    // if already activated, quit
                    if ($video.data('activated') === true) return true;
                    $video.data('activated', true);

                    // save the (fallback) content
                    var content = $video.html();
                    $video.data('content', content);

                    // bind click-event to poster-image?
                    if (data.posterclick === true) {
                        var $poster = $video.find('> img');
                        $poster.css('cursor', 'pointer');
                        $poster.on('click', function() {
                            self._initVideo($video, data, options, $target);
                        });
                    } else {
                        self._initVideo($video, data, options, $target);
                    }
                });

                return $videos;
            };

            /**
             * public, deactivateVideo() removed the JW Player from the div.video, or pause and stop video
             * if video resides in a JW Player object which is setup to load multiple video configurations
             * @param $container containing one or more div.video to deactivate (can also be a collection)
             * @param $target optional: element which contains a resuable JW Player object which needs video to be unloaded
             */
            mmVideoInterface.deactivateVideo = function ($container, $target, forceReset) {
				forceReset = forceReset || false;
				// first reset the endframe videos
				mrm.ui.video_end_frame.reset($container);

				// now disable the videos
                var self = this;
                var $video = self.getVideoTags($container);
                if ($video.length === 0) return;

                $video.each(function() {
                    var $video = $(this);

                    if ($video.data('activated') !== true) return true;
                    $video.data('initialized', false);
                    $video.data('activated', false);

                    var id = $video.attr('id');
                    var content = $video.data('content');

                    // remove player and replace with poster-img (TODO: remove player-listeneres also)
					if(!$video.siblings('.end_frame_wrap').length || forceReset){ /// don't show poster frame again if there is an end frame
						$video.html(content);
					}

                    // stop video if it was placed inside a reusable jwplayer object container
                    if (typeof $target !== "undefined" && typeof $target.data("jwpTargetId") !== "undefined") {
                        var videoTargetId = $target.data("jwpTargetId");
						var api = jwplayer(videoTargetId)
                        if(api) api.pause().stop();
                    }

                });
            };

            /**
             * Stops all Videos
             * @param except String     keep plaxing the player with this id
             */
            mmVideoInterface._pauseAllVideo = function(except) {
                $(jwplayer.getPlayers()).each(function(counter) {
                    var current = jwplayer.getPlayers()[counter];
                    if (jwplayer.getPlayers()[counter].id !== except && current.getState() === "PLAYING"){
                        current.pause();
                    }
                });
            };

            /**
             * global event-handler for player-initialization
             */
            mmVideoInterface.playerReady = function (player) {
                mrm.util.log('[mrm.corcmp.mmVideo.playerReady] - player_object ' + player);

                // trigger custom event that a video get's embedded
                $('#' + player.id).trigger('embed.video');
            };

            // SEE http://www.longtailvideo.com/support/jw-player/jw-player-for-html5/11894/player-javascript-api
            mmVideoInterface._initTracking = function(player) {
                var self = this;

                player.onPlay(function (event) {
                    self._onVideoPlay(this, event);
                });
                player.onPause(function (event) {
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.stop(this.getPlaylistItem().file.split('/').pop(), this.getPosition());
                });
                player.onComplete(function (event) {
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.stop(this.getPlaylistItem().file.split("/").pop(), this.getPosition());
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.close(this.getPlaylistItem().file.split('/').pop());
                });
            };

            mmVideoInterface._onVideoPlay = function(currentVideo, event) {
                var playerPosition = null;

                if (currentVideo.getDuration() < currentVideo.getPosition() + 1) {
                    playerPosition = 0;
                } else {
                    playerPosition = currentVideo.getPosition();
                }

                if (currentVideo === targetVideoPlayer && currentVideo.getPlaylistItem().file.split("/").pop() !== targetVideoItem) {
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.close(targetVideoItem);
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.open(currentVideo.getPlaylistItem().file.split("/").pop(), currentVideo.getDuration(), currentVideo.id);
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.play(currentVideo.getPlaylistItem().file.split("/").pop(), playerPosition);
                } else if (event.oldstate === "PAUSED") {
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.play(currentVideo.getPlaylistItem().file.split("/").pop(), playerPosition);
                } else {
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.open(currentVideo.getPlaylistItem().file.split("/").pop(), currentVideo.getDuration(), currentVideo.id);
                    if (typeof Omniture_s != 'undefined') Omniture_s.Media.play(currentVideo.getPlaylistItem().file.split("/").pop(), playerPosition);
                }

                targetVideoPlayer = currentVideo;
                targetVideoItem = currentVideo.getPlaylistItem().file.split("/").pop();
            };
            /* this function was created as opposed to setting in a conf object because the
                HTML that is written to a page destroys any conf objects that might have previously existed rather than simply extending */
            mmVideoInterface.disableHtml5Skin = function(disabledStatus) {
                disableHtml5Skin = disabledStatus;
            }

            return mmVideoInterface;
        }()
    });
}(mrm.$));;(function($) {
	$.fn.mmScroll = function(config) {
		var defaultConfig = {
				debug: false,
				auto: {
					play: false,
					pauseDuration: 5000
				},
				hiddenItemOverride: false, // if there are needed 'display:none' elements inside scroller set to true.
				scroll: {
					pauseOnHover: true,
					wipe: true,
					noWipeDirection: false, // (vertical|horizontal) if set to "vertical" the vertical wipes will keep their native behaviour (e.g. scroll) and the other way around
					fx: 'slide'
				},
				circular: true,
				infinite: true,
				height: 'auto',
				items: {
					start: true,
					visible: 1
				},
				prev: {
					button: function() {
						return $(this).parent().prev('.prev');
					}
				},
				next: {
					button: function() {
						return $(this).parent().next('.next');
					}
				},
				pagination: {
					container : function () {
						// in certain configs the scroller will call this on window resize
						// only create a container if it does not exist. if it does, just return it
						var $existingContainer = $(this).parent().parent().find('ol.mmScrollPagination');
						if ($existingContainer.length) {
							return $existingContainer;
						}
						return $('<div class="mmScrollPaginationWrp"><ol class="mmScrollPagination" /></div>')
									.appendTo($(this).parent().parent()).children('ol');
					},
					anchorBuilder : function( nr, item ) {
						return '<li><a href="#">' + nr + '</a></li>';
					}
				},
				// if animateControls is set to false, no showControls/hideControls scroller events will be fired
				animateControls: {
					fx: 'slide', // slide | fade | hide | none | function
					loadTimeout: 5000,
					inactivityTimeout: 5000,
					speed: 250
				}
			},

			cfg = $.extend(true, {}, defaultConfig, mrm.conf.corcmp.mm_scroller || {}, config || {});

		return this.each(function() {
			var $container = $(this).hasClass('mmScroll') ? $(this) : $(this).find('.mmScroll:eq(0)'),
				$list = $container.children('ul'),
				$items = $list.children('li'),
				$mmScrollBtns = $container.children('span.mmScrollBtn'),
				mandatoryConfig = {}, // used to add settings that are mandatory for all scrollers and therefore either overrule or extend the set config ( for example the mandatory eventHandlers extend any configured handlers instead of overwriting them)
				wipeConfig = {
					min_move_x: 30,
					min_move_y: 30,
					preventDefaultEventsHorizontal: (!cfg.scroll.noWipeDirection || cfg.scroll.noWipeDirection !== 'horizontal'),
					preventDefaultEventsVertical: (!cfg.scroll.noWipeDirection || cfg.scroll.noWipeDirection !== 'vertical'),
					wipeLeft:  function (e) { $list.trigger('next'); },
					wipeRight: function (e) { $list.trigger('prev'); }
				},
				controlsVisible = true,
				$caroufredselWrp, inactivityTimer, controlsAnimation;

			/**
			 * Ads class 'ui-helper-visible' to the active slide for easier selection from outside
			 * @param $slide	active/visible slide
			 */
			function markVisible($slide) {
				$slide.addClass('ui-helper-visible').siblings().removeClass('ui-helper-visible');
			}

			function controlsHandler(delay) {
				 delay = delay || 5000;

				if (!controlsVisible) {
					$list.trigger('showControls');
					controlsVisible = true;
				}
				window.clearTimeout(inactivityTimer);
				inactivityTimer = window.setTimeout(function () {
					controlsVisible = false;
					$list.trigger('hideControls');
				}, delay);
			}

			var btnPrevLeft = '-' + $mmScrollBtns.filter('.prev').outerWidth() + 'px',
				btnNextRight = '-' + $mmScrollBtns.filter('.next').outerWidth() + 'px';

			if ( cfg.animateControls ) {
				$mmScrollBtns.on('mouseenter', function(e) {
					window.clearTimeout(inactivityTimer);
				}).on('mouseleave', function(e) {
					controlsHandler(cfg.animateControls.inactivityTimeout);
				});
			}

			if ( cfg.animateControls && $.inArray(cfg.animateControls.fx, ['fade', 'slide', 'hide']) > -1) {

				controlsAnimation = function ($mmScrollBtns, show) {
					$mmScrollBtns.stop(true, true);

					if (cfg.animateControls.fx === 'slide') {
						$mmScrollBtns.filter('.prev').animate({
							left: !show ? btnPrevLeft : '0'
						}, cfg.animateControls.speed);

						$mmScrollBtns.filter('.next').animate({
							right: !show ? btnNextRight : '0'
						}, cfg.animateControls.speed);
					} else if (cfg.animateControls.fx === 'fade') {
						// fade animation
						$mmScrollBtns[show ? 'fadeIn' : 'fadeOut'](cfg.animateControls.speed);
					} else {
						$mmScrollBtns[show ? 'show' : 'hide'](cfg.animateControls.speed);
					}
				};
			} else if ( cfg.animateControls && $.isFunction(cfg.animateControls.fx) ) {
				controlsAnimation = cfg.animateControls.fx;
			} else {
				controlsAnimation = $.noop;
			}

			if ($.fn.touchwipe && cfg.scroll.wipe) {
				$container.touchwipe(wipeConfig);
				cfg.scroll.wipe = false; // keep caroufredsel from using it's built-in touchwipe support
			}

			if ( !$items.length ) { return; }

			// define some event handler extensions
			mandatoryConfig = {
				onCreate: function ($newItems, newSizes) {
						//-- code in here will be executed before any configured handler --
					$caroufredselWrp = $newItems.closest('.caroufredsel_wrapper');

					// bind standard mmScroll eventHandlers
					$list.on('mouseenter.mmScroll', function (e) {
						$list.addClass('mmScrollHovered');
					}).on('mouseleave.mmScroll', function (e) {
						$list.removeClass('mmScrollHovered');
					});

					if (cfg.animateControls) {
						// Bug 72333: change binding to parent of list so that video itself included (mouseover will work on video now)
						$container.on('mousemove.mmScroll mouseenter.mmScroll', function (e) {
							controlsHandler(cfg.animateControls.inactivityTimeout);
						}).on('hideControls.mmScroll', function (e) {
							$list.addClass('mmScrollControlsHidden');
							controlsAnimation($mmScrollBtns, false);
						})

						// Bug 72333: keep bound to $list
						$list.on('showControls.mmScroll', function (e) {
							$list.removeClass('mmScrollControlsHidden');
							controlsAnimation($mmScrollBtns, true);
						});
						controlsHandler(cfg.animateControls.loadTimeout);
					}
					markVisible($newItems);
					//TODO $newItems.eq(0).find('.hidden-video').trigger('videoPrepare');
					mrm.util.sharing.enableShare2Autorender($items);
					// event for image change
					$.eventDispatcher.trigger('mh_scroller_image_change', {duration:0,dispatcher:$container});
					// also use the configured handler if there is one
					return (cfg.onCreate || $.noop)($newItems, newSizes);
				},
				scroll: {
					onBefore: function ($oldItems, $newItems, newSizes, duration) {
						//-- code in here will be executed before any configured handler --
						// reset caroufredsel wrapper scroll position to avoid browser scroll to item when deeplinking
						$caroufredselWrp.scrollLeft(0);
						$newItems.trigger('itemChange', newSizes);
						if (cfg.animateControls) {
							controlsHandler(cfg.animateControls.inactivityTimeout);
						}
						// event for image change
						$.eventDispatcher.trigger('mh_scroller_image_change', {duration:duration,dispatcher:$container});
						//TODO $newItems.eq(0).find('.hidden-video').trigger('videoPrepare');
						// also use the configured handler if there is one
						return (cfg.scroll.onBefore || $.noop)($oldItems, $newItems, newSizes, duration);
					},
					onAfter: function ($oldItems, $newItems, newSizes, duration) {
						//-- code in here will be executed before any configured handler --
						// reset caroufredsel wrapper scroll position to avoid browser scroll to item when deeplinking
						$caroufredselWrp.scrollLeft(0);
						$newItems.trigger('renderShare2');
						//TODO $oldItems.eq(0).find('.hidden-video').trigger('videoClear');

						markVisible($newItems);

						// also use the configured handler if there is one
						return (cfg.scroll.onAfter || $.noop)($oldItems, $newItems, newSizes, duration);
					}
				}
			};

			if ( $container.data('cfgDisableLoop') ) {
				mandatoryConfig.circular = false;
				mandatoryConfig.infinite = false;
			}

			if ( $container.data('cfgAutoscroll') ) {
				$.extend( true, mandatoryConfig, {
					auto: {
						play: true,
						pauseDuration: Number($container.data('cfgAutoscrollDuration')) || cfg.auto.pauseDuration
					},
					animateControls: {
						fx: 'none'
					}
				});
			}

			$list.mrmCarousel( $.extend(true, {}, cfg, mandatoryConfig) );
			$container.addClass('jsReady');

		});
	};
})(mrm.$);(function($) {
/*
 * Usage:
 * $.eventDispatcher.on('eventName', handler(eventObject))
 * $.eventDispatcher.off(token)
 * $.eventDispatcher.trigger('eventName', [, extraParameters] )
 */
//	var o = $({});
	var oExt = {};

	pubsubz = pubsubz || {
		subscribe: $.noop,
		unsubscribe: $.noop,
		publish: $.noop
	};

	oExt.eventDispatcher = {
		on: function(topic, func) {
			return pubsubz.subscribe(topic, func);
		},

		off: function(token) {
			pubsubz.unsubscribe(token);
		},

		trigger: function(topic, args) {
			pubsubz.publish(topic, args);
		}
	};

	$.extend(true, oExt);
}(mrm.$));/***
  source: http://stackoverflow.com/questions/3777443/css-text-transform-not-working-properly-for-turkish-characters

  slightly modified for
    * language-COUNTRY combinations on the lang-attribute
    * and check for being included on a turkish language website, as the authors isn't able to define specific text pieces to be included in another language on out platform at all
***/

(function($) {
  function getStyle(element, style) {
    var result;

    if (document.defaultView && document.defaultView.getComputedStyle) {
      result = document.defaultView.getComputedStyle(element, '').getPropertyValue(style);
    } else if(element.currentStyle) {
      style = style.replace(/\-(\w)/g, function (strMatch, p1) {
        return p1.toUpperCase();
      });
      result = element.currentStyle[style];
    }
    return result;
  }

  function replaceRecursive(element, lang) {
    if(element.lang) {
      lang = element.lang.substr(0, 2); // Maintain language context, slightly modified for language-COUNTRY combinations
    }

    if (element && element.style && getStyle(element, 'text-transform') == 'uppercase') {
      if (lang == 'tr' && element.value) {
        element.value = element.value.replace(//g, 'I');
        element.value = element.value.replace(/i/g, '');
      }

      for (var i = 0; i < element.childNodes.length; ++i) {
        if (lang == 'tr' && element.childNodes[i].nodeType == Node.TEXT_NODE) {
          element.childNodes[i].textContent = element.childNodes[i].textContent.replace(//g, 'I');
          element.childNodes[i].textContent = element.childNodes[i].textContent.replace(/i/g, '');
        } else {
          replaceRecursive(element.childNodes[i], lang);
        }
      }
    } else {
      if (!element.childNodes || element.childNodes.length == 0) return;

      for (var i = 0; i < element.childNodes.length; ++i) {
        replaceRecursive(element.childNodes[i], lang);
      }
    }
  }

  if (mrm.util.locale._lang === "tr") {
    $(document).ready(function(){
      replaceRecursive(document.getElementsByTagName('html')[0], '');
    });
  }
})(jQuery);/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) { 
	mrm.ie = mrm.ie || {};
	$.extend(mrm.ie, {           
		asteriskAfter: {          
			/**
			 * adding an IE6/IE7 workaround for the after-selector on the mandatory elements
			 * 
			 * @param {String} c DOM Context
			 */
			tpl: ['16'],
			init: function(c) {    
				mrm.util.log('[mrm.ie.asteriskAfter] Context: ' + c);
				
				if (mrm.util.ie7() || mrm.util.ie6()) {
					$('form ul.formlist label, form ul.formlist p, form ul.formlist legend span').append('<span class="asterisk">*</span>');
					$('span.asterisk span.asterisk, span.asterisk + span.asterisk', 'form ul.formlist').remove();
				}
			}   
		}
	});

}(mrm.$));/*
	 2008 by Nol Bossart, namics ag
*/
 (function($) {
	mrm.ie = mrm.ie || {};
	$.extend(mrm.ie, {   
		bgiframe: {  
			/**
			 * Fixes z-index for IE 6 where select-boxes are above floating divs...
			 * @name mrm.ie.bgiframe.init(c)
			 * 
			 * @param {String} c DOM Context
			 */
			init: function(c) {    
				if(c === 'body' && mrm.util.ie6()){
					mrm.util.log("[ie.bgiframe] context: " + c);
					$('#mds-cmp-1stlevelnavigation ul li ul').bgiframe();
					$('#mds-cmp-1stlevelnavigation li.baseballcard', c).livequery(function() {
						$(this).bgiframe();
					});
				}
			}   
		}
	});
}(mrm.$));/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) { 
	mrm.ie = mrm.ie || {};
	$.extend(mrm.ie, {           
		empty: {          
			/**
			 * JS for classifying empty elements for non :empty supporting browsers / ie
			 * 
			 * @param {String} c DOM Context
			 */
			tpl: ['02','03','05', '08', '10', '11', '13', '14', '16', '17'],
			init: function(c) {    
				mrm.util.log('[mrm.ie.empty] Context: ' + c);
				
				$('div[class*="mds-cmp"]:empty').addClass('CSSempty');
        $('ul.radiobutton-group label:empty').addClass('CSSempty');
        $('div[class*="mds-area-p"]:empty').addClass('CSSempty');

			}   
		}
	});
}(mrm.$));/*
	 2008 by Nol Bossart, namics ag
*/
 (function($) {
	mrm.ie = mrm.ie || {};
	$.extend(mrm.ie, {   
		flicker: {          
			/**
			 * Corrects an IE error where bg-images on rollover "flicker"
			 * @name mrm.ie.flicker.init(c)
			 * 
			 * @param {String} c DOM Context
			 */
			init: function(c) { 
				if($.browser.msie && (parseFloat($.browser.version) < 8))
				{
					if(c === 'body')
					{
						mrm.util.log("[ie.flicker] context: " + c);
						var fix = true;
						try {
							document.execCommand("BackgroundImageCache", false, fix);
						} catch(err) {}
					}
				}   
			}   
		}
	});
}(mrm.$));/*
	 2008 by Nol Bossart, namics ag
*/
 (function($) {
	mrm.ie = mrm.ie || {};
	$.extend(mrm.ie, {   
		linked_images_wrapped_by_span: {  
			/**
			 * Fixes the problem that a click on an linked image that is wrapped by a span doesn't trigger a click on the wrapping a tag
			 * compare to e.g. http://stackoverflow.com/questions/805865/link-problem-on-ie6-and-ie7
			 * @name mrm.ie.linked_images_wrapped_by_span.init(c)
			 * 
			 * @param {String} c DOM Context
			 */
			init: function(c) {    
				if(c === 'body' && mrm.util.ie7()){
					mrm.util.log("[ie.linked_images_wrapped_by_span] context: " + c);
					$('a span img').live('click', function() {
						$(this).closest('span').trigger('click');
					});
				}
			}   
		}
	});
}(mrm.$));;( function ( $ ) {
	mrm.mod.Abstract = Tc.Module.extend( {

		on: function ( callback ) {
			this.delegateEvents();
			this.prepare();
			this.prepareAsync( callback );
		},

		/**
		 * copied from backbone events:
		 * http://backbonejs.org/#Events
		 * 
		 */
		delegateEvents: function () {

			if( !this.events ) {
				return;
			}

			for( var key in this.events ) {
				var method = this.events[ key ];

				if( typeof method !== 'function' ) {
					method = this[ this.events[ key ] ];
				}

				if( !method ) {
					continue;
				}

				var match = key.match( /^(\S+)\s*(.*)$/ );
				var eventName = match[ 1 ] + '.delegateEvents' + this.id;
				var selector = match[ 2 ];

				if( selector === '' ) {
					this.$ctx.on( eventName, $.proxy( method, this ) );
				} else {
					this.$ctx.on( eventName, selector, $.proxy( method, this ) );
				}
			}
		},

		prepare: function () {
		},

		prepareAsync: function ( callback ) {
			callback();
		}
		
	} );
} )( mrm.$ );


;(function($) {
	mrm.mod.AbstractMod = mrm.mod.Abstract.extend({

		events: {
			// 'click .btn-dialog': 'triggerDialog'
		},

		init: function($ctx, sandbox, modId) {
			// call base constructor
			this._super($ctx, sandbox, modId);

			// load config + lbl-config
			var moduleName = mrm.util.getModuleName(this.$ctx);
			this.cfg = $.extend(true, this.cfg || {}, mrm.conf.cmp[moduleName] || {});
			this.lbl = $.extend(true, this.lbl || {}, mrm.lbl.cmp[moduleName] || {});

			// This is unused
			// this.sandbox.subscribe( 'broadcast', this );

			this.events = $.extend({}, this.events, mrm.mod.AbstractMod.prototype.events);
		},

		on: function(callback) {
			this.delegateEvents();
			this.initElements();
			this.prepare();
			this.prepareAsync(callback);
		},

		initElements: function() {
		},

		/**
		 * used by deeplinking.js
		 */
		switchToContent: function($content) {
		}

	} );
})(mrm.$);


;( function( $ ) {
	mrm.mod.Global = mrm.mod.Abstract.extend( {

		events: {
			'click': 'onBodyClick',
			'touchend': 'onBodyClick'
		},

		init: function( $ctx, sandbox, modId ) {
			// call base constructor
			this._super( $ctx, sandbox, modId );

			this.sandbox.subscribe( 'broadcast', this );

			// $( 'html' ).addClass( $.fn.details.support ? 'details' : 'no-details' );
		},

		prepare: function() {
			var throttledWindowResize;
			if ($.browser.msie && parseInt($.browser.version, 10) <= 8) {
				throttledWindowResize = _.throttle( $.proxy( this.onWindowResizeIe8, this ), 50 );
			} else {
				throttledWindowResize = _.throttle( $.proxy( this.onWindowResize, this ), 50 );
			}

			$( window )
				.on( 'resize', throttledWindowResize )
				.on( 'scroll', $.proxy(this.onWindowScroll, this ))
				.on( 'orientationchange', $.proxy(this.onOrientationChange, this ));
		},

		after: function() {
			$( window ).trigger( 'resize' );
		},

		onWindowResize: function() {
			this.fire( 'broadcastBeforeWindowResize', [ 'broadcast' ] );
			this.fire( 'broadcastWindowResize', [ 'broadcast' ] );
			this.fire( 'broadcastAfterWindowResize', [ 'broadcast' ] );
		},

		onWindowResizeIe8: function() {
			var winNewWidth = $(window).width();
			var winNewHeight = $(window).height();

			// compare the new height and width with old one
			if(this.winWidth != winNewWidth || this.winHeight != winNewHeight) {
				this.fire( 'broadcastBeforeWindowResize', [ 'broadcast' ] );
				this.fire( 'broadcastWindowResize', [ 'broadcast' ] );
				this.fire( 'broadcastAfterWindowResize', [ 'broadcast' ] );
			}

			// update width and height
			this.winWidth = winNewWidth;
			this.winHeight = winNewHeight;
		},

		onBodyClick: function() {
			this.fire( 'broadcastBodyClick', [ 'broadcast' ] );
		},

		onWindowScroll: function() {
			this.fire( 'broadcastWindowScroll', [ 'broadcast' ] );
		},

		onOrientationChange: function() {
			this.fire( 'broadcastOrientationChange', [ 'broadcast' ] );
		},

	} );
} )( mrm.$ );/*
	 2009 by Heiko Frosch, namics ag
*/
(function($) {
	mrm.ui.forms = mrm.ui.forms || {};
	$.extend(mrm.ui.forms, {
		init: function(c)
		{
			/* Keep scope of this */
			var self = this;

			this._addCheckboxReplacements();

			/* Trigger a possible change event if MSIE, because for this
			* browser a state change does not trigger a change event
			* automatically */

			if ( mrm.util.ie9_lt() ) {
				$(document).on('click.formsJS', 'input.ui-helper-hidden-accessible:enabled', function(e) {
					/* But do not trigger that change event for the checkboxes in a few HMC components */
					if ( !$(e.target).closest('.modVi_hmc_1, .modCnt_tbl_comp_1') ) {
						$(this).change();
					}
				});
			}

			/* Trigger the click event on a label if MSIE, because for this
			* browser a click on a nested image within a label does not
			* trigger a click event on the label automatically */
			if ( mrm.util.ie9_lt() ) {
				$(document).on('click.formsJS', 'label img', function() {
					var inputId = $(this).parents("label").attr("for") || '';
					$( '#' + inputId ).change();
				});
			}

			/* Bind class changes on events */
			$('input:radio').on('click.checkBox', function(e)
			{
				$(e.target).closest("li.ui-state-error").removeClass("ui-state-error");
			});
			
			if ( mrm.util.ie9_lt() ) {
				this.ieSelectFix();
			}
			
		},

		_addCheckboxReplacements : function(){

			var self = this;

			/* Replace checkboxes and radio selects for all templates but not T16 */
			if (mrm.util.curTemplate() != "16" && mrm.util.curTemplate() != "03")
			{
				try {
					$('input:not(".ui-helper-hidden-accessible")').checkBox();
				}
				catch(e){
					console.log("mrm.ui.checkbox.js missing from main.js");
				}
			}
			else
			{
				/* Use Livequery to replace all radios and checkboxes in T16
				* Selectors needs to be splitted up in four different to get all possible state changes
				* this is related to external changes that are not noticed by the checkbox-plugin */
				$('input:checked:not(:disabled)').livequery(function()
				{
					self._checkReplaceState(this);
				});
				$('input:checked:disabled').livequery(function()
				{
					self._checkReplaceState(this);
				});
				$('input:disabled:not(:checked)').livequery(function()
				{
					self._checkReplaceState(this);
				});
				$('input:not(:checked, :disabled)').livequery(function()
				{
					self._checkReplaceState(this);
				});

				/* Use Livequery to update tooltips on replacements by title attribute in T16 in case of
				* use cases where livequeries above will not catch the change of an title attribute */
                var vehExpr = 'input[title]:not(".mds-vc-prototype", ".ui-no-input-replace")';
                $("#" + vehExpr).livequery(function()
				{
					/* Add tooltips to replacement if title attribute is available on replaced element */
					var replacement = mrm.$(this).next("span.ui-checkbox, span.ui-radio");
					if( replacement.length > 0)
					{
						/* Get title value of input element */
						var title = mrm.$(this).attr("title");

						/* Update tooltip */
						self._updateTooltip(replacement, title);
					}
				});
			}
		},

		/* Create new beautified checkBox or update existing one with
		* corresponding input element and his current state */
		_checkReplaceState: function(el)
		{
			var element = $(el);

			if( !element.is(':radio, :checkbox') || element.hasClass('mds-vc-prototype') || element.hasClass('ui-no-input-replace') )
			{
				return; //stop if no replacement should be used
			}

			var replSelector = "span.ui-checkbox, span.ui-radio";

			/* Initial replacement of checkboxes or radios if no replacement exist */
			var replacement = element.next(replSelector);
			if(replacement.length === 0)
			{
			/* Create replacement */
			element.checkBox();

			/* Get newly created replacement */
			replacement = element.next(replSelector);
			}
			/* Otherwise perform an update and work with already created replacement */
			else
			{
				try{
					element.checkBox('update');
				}
				catch(error)  {
					/* if replacement is prerendered, delete it before intial checkbox */
					if(replacement.length > 0){
						replacement.remove();
					}

					element.checkBox();
					replacement = element.next(replSelector);
				}
			}

			/* Add tooltips, title & tabindex to replacement if title attribute is available on replaced element */
			if(replacement.length > 0)
			{
				/* Get title value of input element */
				var title = element.attr("title");
				var tabindex = element.attr("tabindex");

				/* Add title to replacement if title attribute is available */
				if(typeof(title)!= "undefined" && title != ""){
				replacement.attr('title', title);
				}
				/* Add tabindex to replacement if title attribute is available */
				if(typeof(tabindex) != "undefined" && tabindex != ""){
				replacement.attr('tabindex', tabindex);
				element.removeAttr('tabindex');
				}

				/* Update the tooltip on the replacement */
				this._updateTooltip(replacement, title);
			}
		},

		/* Creates or hides a tooltip on the given element
		* with the given text
		*/
		_updateTooltip: function(element, text)
		{
			if(element!=undefined && element!=null)
			{
				/* Activate tooltip if title not empty */
				if(text!="" && text!=undefined && text!=null)
				{
				/* Prepare title for style */
				text = text.split("##");
				var cnt = "";
				$.each(text, function(i) {
					cnt += "<li>"+this+"</li>";
				});

				var openEventName = '';

				if( window.navigator.pointerEnabled || window.navigator.msPointerEnabled )
				{
					element
						.on('mouseover', function(event){ if( !event.noBlock ) event.stopImmediatePropagation(); })
						.on('mouseout', function(event){ if( !event.noBlock ) event.stopImmediatePropagation(); })
						.on('click', function(event){ event.stopImmediatePropagation(); });
						openEventName = 'MSPointerDown';
				}
				else
				{
					element.on('touchstart', function(event){ event.preventDefault(); }); // prevent mouse-event emulation
					openEventName = 'touchend';
				}

				element
					.on(openEventName, function(){

						var pos = element.offset();

						element.trigger({
							type: 'mouseover',
							pageX: pos.left,
							pageY: pos.top,
							noBlock: true
						});
					})
					.on('clickoutside', function(event) {
						element.trigger({
							type: 'mouseout',
							noBlock: true
						});
					});

					// order of mouseover and touchstart is wrong in Android < 4.4
					if( !(/Android 4\.[0123]{1}/).test(window.navigator.userAgent) )
					{
						element
							.on('mouseover', function(event){ event.stopImmediatePropagation(); })
							.on('mouseout', function(event) { event.stopImmediatePropagation(); })
					}


				/* Add tooltip with title content and remove extra class */
				if(cnt!="")
					element.tooltip({ showURL: false, fixPNG: true, extraClass: "", bodyHandler: function() { return $("<ul>"+cnt+"</ul>"); } });
				}
				/* Force tooltip to be hidden by extra class */
				else
				{
					/* Apply tooltip options */
					element.tooltip({ extraClass: "ui-helper-hidden" });
				}
			}
		},

		//This fixes cut select dropdowns in IE8

		ieSelectFix: function() {
			$('select').each(function() {
				var sel = $(this)
				selWidth = sel.width();
				sel.css('min-width', selWidth);
			});
			var el;
			$(document).on("mousedown", "select", function(){
				$("select.selectIEfix").removeClass("selectIEfix");
				el = $(this);
				el.addClass("selectIEfix");
			})
			.on("blur change", "select", function(){
				if (el !== undefined) {
					el.removeClass("selectIEfix");
				}
			});
		}
	});


}(mrm.$));/*
 *   2014 by MRM Worldwide
 */
/*
 * @author Tony.Herford
 * @name image_loader.js
 */
mrm.ui = mrm.ui || {};
mrm.ui.image_loader = function($) {
	///// private variables
	var config = {},
		delay_timer,
		$win = $(window),
		onload_images = [],
		loaded_count = 0,
		image_count = 0,
		images_loaded = false;


	// private function
	/**
	 * Kicks things off.
	 * @returns {void}
	 */
	function _initialize() {
		// get default settings for this utility
		config = $.extend(true, {
			/* default settings */
			enabled: true,
			threshold: 500,
			fallbackHeight: 2000,
			onscroll_class: 'load_in_view',
			onload_class: 'onload',
			loaded_class: 'image_loaded',
			onload_delay: 5000,
			src_attr: 'orig-src'
		}, mrm.conf.ui.image_loader);


		if(config.enabled){
			// if images are found then bind load event
			$win.on('load.image_loader', _page_load_handler);
			delay_timer = setTimeout(_page_load_handler, config.onload_delay);

			/// setup scrolling load more to come later
			if($('img.'+config.onscroll_class).length){
				// bind scroll
			}

			// listen for the image load event to keep track of how many images loaded
			$.eventDispatcher.on('image_loaded', _image_loaded);
		}
	}

	/**
	 * call _load_images when page load event or timer has triggered.
	 * @param {type} event
	 * @returns {void}
	 */
	function _page_load_handler(event) {
		clearTimeout(delay_timer);
		$win.off('load.image_loader');
		// find the onload images
		onload_images = $('body').find('img[data-'+config.src_attr+'].'+config.onload_class);
		if(onload_images.length){
			_load_images(onload_images);
		}
		else {
			$.eventDispatcher.trigger('image_loaded',{src: this.src});
		}
	}

	/**
	 * Start loading the files
	 * @param {array} image_list
	 * @returns {void}
	 */
	function _load_images(image_list){
		// load all the images with the correct class name
		image_list.each(function(){
			var $img = $(this);
			$img.one('load.image_loader', _image_load_handler);
			$img.one('error.image_loader', function(){
				mrm.util.log('error >> '+this.src);
			});

			this.src = $img.data(config.src_attr);
			// for ie
			if(mrm.util.ie_lt(10) && this.complete){
				//console.log('load from cache')
				$img.trigger('load.image_loader');
			}

			image_count++;
		});
	}


	function _image_load_handler(e){
		//if(e.type === 'error')
		//console.log('image_load_handler')
		$.eventDispatcher.trigger('image_loaded', {src: this.src});
		var $img = $(this);
		$img.removeClass(config.onload_class+' '+config.onscroll_class);
		$img.addClass(config.loaded_class);
	}

	/**
	 * Event handler for when an image loads
	 * @returns {void}
	 */
	function _image_loaded(){
		loaded_count++;
		if(loaded_count === onload_images.length){
			$.eventDispatcher.trigger('all_images_loaded');
			// triggering resize fixes some issues
			$(window).trigger("resize");
			mrm.util.log('All Images loaded');
			images_loaded = true;
		}
	}

	/**
	 * _is_in_loadable_area(element)
	 *
	 * check if the given element is inside the current viewport or threshold
	 *
	 * @param element jQuery
	 * @returns boolean
	 */
	function _is_in_viewport(element) {
		var top = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
		return (top + _get_viewport_height() + config.threshold) > (element.offset().top + element.height());
	}

	/**
	 * _get_viewport_height()
	 *
	 * try to allocate current viewport height of the browser
	 * uses fallback option when no height is found
	 *
	 * @returns number
	 */
	function _get_viewport_height() {
		if (window.innerHeight)	return window.innerHeight;
		if (document.documentElement && document.documentElement.clientHeight) return document.documentElement.clientHeight;
		if (document.body && document.body.clientHeight) return document.body.clientHeight;
		if (document.body && document.body.offsetHeight) return document.body.offsetHeight;

		return config.fallbackHeight;
	}

	_initialize();

	// expose private function as public
	return {
		loaded_class: config.loaded_class,
		onload_class: config.onload_class,
                onscroll_class: config.onscroll_class,
		enabled : config.enabled,
		src_attribute: config.src_attr,
		images_loaded: images_loaded,
		load_images: _load_images
	};
}(mrm.$);(function($) {

	 mrm.ui.layer = {
		/**
		 * Init layer events
		 * @name mrm.ui.layer.init(c)
		 *
		 * @param {String} c DOM Context
		 */

		init: function(c) {
			mrm.util.log('[layer.init] Context: ' + c);
			this.setBindings();
		},

		/**
			toggle: 'show', 'hide'
		*/
		mask: function($container, toggle, speed) {
			var $mask = ($('.mask', $container).length > 0) ? $('.mask', $container) : $container.prepend('<div class="mask" />').children('.mask');
			var toggleFunction = (toggle == 'hide') ? 'fadeOut' : 'fadeIn',
				animationSpeed = (speed != undefined) ? speed : 0;
			/*NGDOE compatibility */
			if (typeof(MRM_EXTERNAL_DOMAIN) === 'string') {
				$mask.wrap('<div class="gmdsWidget" />');
			}
			$mask[toggleFunction](animationSpeed, function() {
				if (toggleFunction == 'fadeOut') $mask.css('display', 'none');
			});
		},

		setBindings : function(){
			$(document).on( 'click', 'a.ln_modal_ext', $.proxy(this.ln_modal_ext, this) );
			$(document).on( 'click', '.btn_lyr', $.proxy(this.btn_lyr, this) );
		},

		get_url: function(url){
			//Replace URLs starting with http:, https: with the current protocol
			var pattern = /(\b(https?):)/gim;
			return url.replace(pattern, window.location.protocol);
	    },

	    /**
	     *
	     */
		ln_modal_ext : function( event ){
			event.preventDefault();

			var $this	= $(event.currentTarget);
			var href	= this.get_url($this.attr('href'));
			var id		= $this.attr('id');
			var config	= window.mrm.modals_ext[id] || {};

			mrm.util.log('[mrm.cmp.ext_modals.ln_modal_ext] width: ' + config["width"] + ' - height: ' + config["height"] + ' - URL: ' + href);

			var $layer = $('#ln_modal_ext-'+id);
			if( $layer.length )
			{
				var $iframe = $layer.find('iframe');
				if( $iframe.attr('src') != href )
				{
					$iframe.attr('src', href);
				}

				$layer.dialog('open');
			}
			else
			{
				$('<div id="ln_modal_ext-'+id+'"><iframe src="' + href + '" width="' + mrm.util.parseDimension(config["width"] || 400) + '" height="' + mrm.util.parseDimension(config["height"] || 400) + '" frameborder="0" /></div>')
					.dialog({
						autoOpen	: true,
						modal		: true,
						width		: 'auto',
						resizable	: false
					});
			}
		},

		/**
		 * used to open "in page content"(hidden container in html document) inside of a layer
		 */
		btn_lyr : function( event ){
			event.preventDefault();

			var $this	= $(event.currentTarget);
			var href	= $this.attr('href');
			var data 	= $this.data();

			if( href.indexOf('#') < 0 )
			{
				this._multiMediaEnlarge( href, data, $this );
			}
			else
			{
				var id		= mrm.util.stripHash( href );
				var config	= window.mrm.modals_ext[id] || {};

				mrm.util.log('[mrm.cmp.ext_modals.btn_lyr] width: ' + config["width"] + ' - height: ' + config["height"] + ' - modal_content: ' + id + ' - modal: ' + config["modal"] + ' - resizable: ' + config["resizable"] + ' - position: ' + config["position"] );

				var options = {
					autoOpen	: true,
					modal		: config["modal"],
					width		: mrm.util.parseDimension(config["width"] || 400),
					height		: mrm.util.parseDimension(config["height"]),
					resizable	: config["resizable"]
				};


				if ( config["position"] == 'link' )
				{
					// place dialog underneath the link
					var linkTopPos = ($this.offset().top - $(window).scrollTop() + $this.height());
					options.position = ['center', linkTopPos];
				}
				else
				{
					options.position = ['center', 'center'];
				}

				$('#'+id).dialog(options);
			}
		},

		_multiMediaEnlarge : function( href, data, $clickTarget )
		{
			if( href.match(/.html$/) )
			{
				// ui dialog -> load html snippet (e.g. T17d)
				var method = data['method'] || 'get';
				if (method == 'post') {
					$.post(href, data, $.proxy(this.enlargeLoaded, this, $clickTarget));
				} else {
					$.get(href, $.proxy(this.enlargeLoaded, this, $clickTarget));
				}
			}
			else
			{
				// simple image resource -> fancybox
				$.fancybox( $.extend(mrm.conf.plugin.fancybox, {autoDimensions: true, href: href}) );
			}
		},

		enlargeLoaded : function( $clickTarget, data, textStatus, XMLHttpRequest ){
			var dialogId = 'btn_lyr-' + new Date().getTime();
			var parentModName = mrm.util.getModuleName($clickTarget.closest(".mod").closest(".mod"));

			$('body').append('<div id="' + dialogId + '" class="dialog-container"></div>');
			var $dialog = $('#' + dialogId);
			var options = $.extend({
				'autoOpen':false,
				open: function(event, ui) {
					// these needs to go into the mrmDialog wrapper
					$('html').addClass('dialog');
				},
				close: function(event, ui) {
					// these needs to go into the mrmDialog wrapper
					$('html').removeClass('dialog');
					// Pause any playing videos if the dialog modal is closed
					if ($(this).parents(".mm-content").length === 0 || $(this).find(".youtube-player").length > 0) {
						$(this).dialog("destroy").remove();
					} else {
						if (jwplayer.getPlayers().length > 0){
							$(jwplayer.getPlayers()).each(function(counter) {
								var thisPlayer = jwplayer.getPlayers()[counter];
								if (thisPlayer.id !== "hiddenvideo-preload_inner"){
									if (thisPlayer.getState() === "PLAYING") {
										thisPlayer.pause();
									}
								}
							});
						}
					}
				},
				dialogClass: parentModName + '-dialog'

			}, mrm.conf.plugin.ui_dialog);
			$dialog.dialog(options);

			if( $(data).find('object, video').length )
			{
				options.callbacks.onVideoContent($dialog);
				$dialog.on('embed.swf, embed.video', $.proxy(function(event){
					var $target = $(event.target);
					// ff calculates the object & video height too late, so we have to set it to force the right height
					$target.parent().css('height', $target.attr('height')+'px');
					// GMDSST-32921
					options.callbacks.onVideoLoaded($dialog);
					
				}, this));
			}
			
			var currentVideo = $(data).find('div.video');
			var videoId = $(currentVideo).attr("id");
			// Check whether video has already been appended to the page, and reopen the previous dialog
			if ($("#" + videoId).length > 0 && mrm.util.flash()) {
				mrm.$("body").find("#" + videoId).parents(".dialog-container").dialog("open");
			} else if ($("#" + videoId).length > 0 && !mrm.util.flash()) {
				// GMDSSDS-32924 HTML5 video fails when reopened in a modal layer. Let's not cache the modal if that's the case.
				$("#" + videoId).parents(".ui-dialog").remove();
				$dialog.append(data);
				$dialog.dialog('open');
				mrm.util.initDomContent($dialog);
			} else {
				$dialog.append(data);
				$dialog.dialog('open');
				mrm.util.initDomContent($dialog);
			}

			// Fire custom 'ui-dialog-loaded' event.
			$.event.trigger({
				type: 'ui-dialog-loaded',
				dialogId: dialogId
			});

			return $dialog;
		},

		closeDialogs: function() {
			$('.ui-dialog > [id^="btn_lyr"]').dialog('close');
		}
	};
}(mrm.$));/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) {
	mrm.ui = mrm.ui || {};
	$.extend(mrm.ui, {
		rows: {
			/**
			 * JS for making related boxes (e.g. in a grid row) having the same height
			 * 
			 * @param {String} c DOM Context
			 */
			tpl: ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15'],

			// do not equalheights() any grids in the following containers
			pf: ['pf2', 'pf3', 'pf4', 'pf6', 'pn2', 'pn3'],
			
			init: function(ctx) {
				var $ctx = $(ctx);
				this.setHeightByCmpsInRow($ctx);
			},
			
			setHeightByCmpsInRow : function($ctx) {
				var tpl = mrm.util.curTemplate();
				var self = this;
				var except = $.extend({}, mrm.conf.ui.rows.except);
				
				$.each(this.pf, function(index, pf){

					$ctx.find('div.mds-area-' + pf)
						.filter(function(){
							var selector = except[tpl];
							return selector ? !$(this).parents(selector).length : 1;
						})
						.each(function(index, row) {
							var minHeight = 0;
							var collection = [],
								collectionHasHeight = false;

							$('> div', row).each(function(index, cell){
								var cmpSelector = 'div[class*="mds-cmp"]';
								var $cell = $(cell);

								// ignore nested cmps
								var $allCmps = $cell.find(cmpSelector);
								var $firstCmp = $allCmps.first();
								var $otherCmps = $allCmps.not($firstCmp).not($cell.find(cmpSelector + ' ' + cmpSelector));

								// ignore cell that include more than one cmp
								if( $firstCmp.length && $otherCmps.length == 0 ) {
									var cmp = $firstCmp.get(0);
									var $cmp = $(cmp);
									var modName = mrm.util.getModuleName($cmp);
									switch (modName) {
										case 'mm_3':
											if ($cmp.hasClass('ui_position_float_rel')) {
												var tmpHeight = $cmp.height() + parseInt($cmp.find('.inner').css('margin-top'), 10);
												minHeight = Math.max(minHeight, tmpHeight);
											} else if (!$cmp.hasClass('ui_position_float_abs')) {
												collection.push(cmp);
											}
											break;
										case 'ts_img_1':
										case 'ts_img_2':
											break;
										default:
											collection.push(cmp);
											break;
									}

									if ($firstCmp.eq(0).height() > 0) {
										collectionHasHeight = true;
									}
								}
							});

							if( collection.length > 1 && collectionHasHeight ) {
								var $collection = $(collection);
								$collection.data('gotEqualHeight', true);
								$collection.equalHeights(minHeight);
							}
					});
				});
			}
		}
	});
}(mrm.$));/*
	By Michael Sindlinger - Nolte & Lauth
*/

(function($) {
	mrm.ui.scrollbars = {

		init: function(c) {
			mrm.util.log('[mrm.ui.scrollbars] Context: ' + c);
			
			var selectors = [
				'#mds-app-dl #dl2a .pf2b',
				'#mds-app-dl #dl2b .pf2b', //works only on localhost
				'#mds-app-dl #dr2 .pf2b', //works only on localhost
				'#citySelection',
				'.mds-dlw-result-list'
			];

			$(selectors.join(',')).each(function(key, value){
				var $item = $(value);
				
				if( $item.is('ul, ol') )
				{
					var wrap = '<div class="scroll-pane"';
					if( $item.attr('id') !== undefined ) wrap+= ' id="'+$item.attr('id')+'ScrollbarWrapper"';
					wrap+='></div>';
					
					$item.removeClass('scroll-pane');
					
					$item.wrap(wrap);
				}
				else
				{
					$item.addClass('scroll-pane');
				}

			});
			
			var config = mrm.$.extend(true, {}, mrm.conf.plugin.jscrollpane);
			$('.scroll-pane').jScrollPane(config);
			
			//if child li is error give selectedText the same class			
			$('li.ui-state-error').each(function(){
				$(this).children('.jScrollPaneContainer').addClass('ui-state-error');
			});
			
			$('#mds-tpl-16 #mds-app-dl #paging').click(function() {
				mrm.ui.scrollbars.reinitialiseScrollPane();
			});
			$('#mds-vc-cmp-advantage_pack').on('VC_CMP_Show', function(event) {
				mrm.ui.scrollbars.reinitialiseScrollPane($(event.target).find('.scroll-pane'));
			});
			// bindings in dynamic applications
			$('.mds-cmp-dealer_search_widget, .modApp_dealer_1, .modApp_dealer_2').find('ul.mds-dlw-result-list, #citySelection').on('updatedDOM', function(event) { // not necessary any more, as the server side wouldn't provide an initial list -> .jScrollPane({scrollbarWidth:17,showArrows:true,select:false,scrollbarMargin:0,isSelect:false})
				mrm.ui.scrollbars.reinitialiseScrollPane($(this).closest('.scroll-pane'));
			});
		},

		applyScrollbarsTo: function($item, customHeight) {
			var height = 'auto';
			if(customHeight != undefined){
				height = customHeight+'px';
			}
			
			if ( $item.is('ul, ol') ) {
				if ( !$item.parent().is('div.scroll-pane') ) {
					$item.wrap('<div class="scroll-pane" style="max-height:'+height+'" />');
				}
			} else {
				$item
				.addClass('scroll-pane')
				.css('max-height', height);
			}
			return $item.closest('.scroll-pane').jScrollPane( mrm.conf.plugin.jscrollpane || {} );
		},

		/**
		 * reinitialising the scrollbars 
		 **/
		reinit: function(c) {
			if (typeof(c) == "undefined") c = '.scroll-pane:visible';
			mrm.util.log('[mrm.ui.scrollbars.reinit] Context: ' + c);
			
			var config = mrm.$.extend(true, {}, mrm.conf.plugin.jscrollpane);
			//console.log(config);
			$(c).jScrollPane(config);
		},

		/**
		 * reinitialising the scrollbars 
		 * (dont know if this is called from the outside anywhere)
		 **/
		reinitialiseScrollPane:function(c) {
			this.reinit(c);
		},
		
		/**
		 * remove the Scrollbars 
		 **/
		remove: function($container) {
			var $jsp = $container.jScrollPane(); 
			var api = $jsp.data('jsp');
			if (api) api.destroy();
		}
	};
}(mrm.$));(function($) {
	mrm.ui = mrm.ui || {};
	$.extend(mrm.ui, {
		scrollcontrol: {
			/**
			 * JS for adding a top margin to page scrolls caused by
			 * clicking anchor links or triggering hashchange
			 */
			eventNamespace: '.scrollCtrl',
			cfg: {},
			init: function() {
				var self = this;

				self.cfg = mrm.conf.ui.scrollcontrol || {};

				if (!self.cfg.useScrollControl) {
					return false;
				}

				// do not make this a delegated event using the $.on "selector" param as jquery runs them first
				$(document).on('click' + self.eventNamespace, function(e) {
					if ( e.isDefaultPrevented() ) {
						return;
					}

					var linkTarget = $(e.target).closest('a').attr('href') || '';
					if (linkTarget.charAt(0) === '#' && linkTarget.length > 1) {
						self.unbindHashChange();
						location.hash = linkTarget;
						self.scrollAction(linkTarget);
						self.bindHashChange();
						return false;
					}
				});

				$(window).on('load' + self.eventNamespace, function() {
					var docEvents = $._data(document, "events");
 
					self.onHashChange();

					if ( !docEvents || !docEvents.click ) {
						return true;
					}

					// make sure the scrollCtrl click handler is the last one to run
					// (in order to allow other scripts which might have bound document clicks to deal with them first)
					var scrollCtrlClick, lastIndex;

					$.each( docEvents.click, function(key, value) {
						if ( value && value.namespace && value.namespace ===  self.eventNamespace.substr(1) ) {
							scrollCtrlClick = value;
							lastIndex = key;
							return true;
						}
						if ( scrollCtrlClick && !isNaN(key) ) {
							docEvents.click[key - 1] = value;
							lastIndex = key;
						}
					});
					if ( scrollCtrlClick ) {
						docEvents.click[lastIndex] = scrollCtrlClick;
					}
				});
				self.bindHashChange();
			},

			onHashChange: function() {
				var hash = window.location.hash;
				if ( hash.length ) {
					this.scrollAction(hash);
				}
			},

			unbindHashChange: function() {
				var self = this;
				$(window).off('hashchange' + self.eventNamespace);
			},

			bindHashChange: function() {
				var self = this;
				$(window).on('hashchange' + self.eventNamespace, function() {
					self.onHashChange();
				});
			},

			scrollAction: function(hash) {
				var scrollPos = this.getScrollPos(hash);
				if ( !isNaN(scrollPos) ) {
					$(window).scrollTop(scrollPos);
				}
			},

			getScrollPos: function(hash) {
				var $anchor, offsetTop;
				hash = hash || '';

				// sanity check the hash first. it might be a 'strange' application hash and crash sizzle
				if (!mrm.util.isValidIdentifier(mrm.util.stripHash(hash))) {
					return;
				}

				$anchor = $(hash);
				if (!$anchor.length) {
					$anchor = $('a[name="' + hash.substr(1) + '"]');
					if (!$anchor.length) {
						return;
					}
				}

				offsetTop = this.cfg.offsetTop || 0;
				return Math.floor(Math.max($anchor.offset().top - offsetTop, 0));
			}
	}});
}(mrm.$));
/*
	2012 by Mathias Seckert
*/
 (function($) {
	mrm.ui = mrm.ui || {};
	$.extend(mrm.ui, {
		stickybox: {
			/**
			 * JS for adding image-transition-functionality
			 *
			 * @param {String} c DOM Context
			 */
			cfg: {
				container: 'div.mds-area-content'
			},
			scrollOffsetTop: 0,
			$container: $(),
			init: function(c) {
				var self = this,
					$stickyBox = $('.stickyBox');

				self.$container = $($stickyBox.data('stickycontainer') || self.cfg.container);

				if ( !$stickyBox.length ) {
					return false;
				}

				self.scrollOffsetTop = parseInt($stickyBox.addClass('stickyModeFloat').css('top'), 10) || 0;
				$stickyBox.removeClass('stickyModeFloat');

				$stickyBox.data('origOffset', $stickyBox.offset().top);

				$([window, document]).on('resize', function() {
					self.stickify($stickyBox);
				});

				$(window).on('scroll', function(e) {
					self.stickify($stickyBox);
				});
			},

			stickify : function ($stickyBox) {
				var self = this,
					stickToBottom = false;

				$stickyBox.removeClass('stickyModeFloat stickyModeBottom');
				self.$container.css('min-height', 0);
				if ( !self.stickyCheck($stickyBox) ) {
					return;
				}

				self.$container.css('min-height', self.$container.height());
				stickToBottom = self.bottomCheck($stickyBox);
				$stickyBox.toggleClass('stickyModeFloat', !stickToBottom).toggleClass('stickyModeBottom', stickToBottom);
			},

			stickyCheck : function ($stickyBox) {
				var self = this,
					scrollPos = $(window).scrollTop(),
					offsetTop = self.scrollOffsetTop,
					boxPos = $stickyBox.data('origOffset');

				return scrollPos >= boxPos - offsetTop; /* scroll pos reached? */
			},

			bottomCheck : function ($stickyBox) {
				var self = this,
					scrollPos = $(window).scrollTop(),
					offsetTop = self.scrollOffsetTop;

				/* box reached bottom of content container? */
				return Math.ceil(offsetTop + $stickyBox.height()) > Math.floor(self.$container.offset().top + self.$container.height() - scrollPos);

			},

			resizeHandler : function ($stickyBox) {
				var self = this;
			}
		}
	});
}(mrm.$));
/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) { 
	mrm.ui = mrm.ui || {};
	$.extend(mrm.ui, {           
		transition: {          
			/**
			 * JS for adding image-transition-functionality
			 * 
			 * @param {String} c DOM Context
			 */
			
			init: function(c) {   
				
				mrm.util.log('[mrm.ui.rows] Context: ' + c);
				this.attachEvents();
				
			},
			
			attachEvents : function() {

			}
		}
	});
}(mrm.$));/*
 *   2014 by MRM Worldwide
 */
/*
 * @author Tony.Herford
 * @name end_frame
 */
mrm.ui = mrm.ui || {};
mrm.ui.video_end_frame = function($) {
	///// private variables
	var efOptions = {}

	///// private fucntions
	/**
	 * Initialize the end frame setting up the button and events
	 * @param {jQuery} $wrapper The end frame wrapper jQuery object
	 * @param {object} options  Configuration object
	 * @param {string} action	What action is required 'end' or 'replay'
	 * @returns {void}
	 */
	function _initialize($wrapper, options, action) {
		if ($wrapper.length < 1)
			return;

		// kill any other end frames that may be open
		$('.end_frame_wrap:visible').each(function() {
			if ($(this).not($wrapper)) {
				_kill($(this));
			}
		})


		// get default settings for the player
		efOptions = $.extend(true, {}, mrm.conf.cmp.mm_1.jwpOptions);
		efOptions = $.extend(true, options, efOptions);

		// make sure the video divs in the end frame do not have a video object
		$wrapper.find('.video').empty();

		// find the video container and the primary video
		var $vid_container = $wrapper.parent(),
			$vid = _get_video_container($wrapper);

		if ($vid_container.find('.playing').length < 1) {
			// add the playing class to the first endframe item
			var $list = $vid_container.find('ul');
			$list.find('li:eq(0)').addClass('playing');

			// remember primary video for reset
			_duplicate_video_object($vid_container, $vid);

			// if no thumbnail then hide
			$wrapper.find('.cta .video').each(function() {
				var $this = $(this);
				/// undo video activation
				$this.html($this.data('content'));
				$this.data('posterimage', '');
				$this.removeAttr('data-posterimage');
//				if ($this.data('posterimage') === '') {
//					$this.closest('li').addClass('ui-helper-hidden');
//				}
			})

		}

		// add the vid_container class and set size
		$vid_container.addClass('vid_container');
		$vid_container.height($vid.data('height'));
		$vid_container.width($vid.data('width'));

		// default action is end
		action = action || 'end';

		// get the video api
		var vp = _get_jwp_API($wrapper)
		if (vp && !vp.getFullscreen()) {
			vp.getPlugin('display').hide();
			vp.getPlugin('controlbar').hide();
		}

		// bind the events
		if (action === 'end') {

			// make sure it exit fullscreen for ie8
			vp.setFullscreen(false);
			_bindReplay($wrapper);

		} else {
			_bindContinue($wrapper);
		}
		_bindCTAs($wrapper);

		// show the end frame
		$wrapper.show();


	}

	/**
	 * Bind the continue button
	 * @param {jQuery} $wrapper The end frame wrapper jQuery object
	 * @returns {void}
	 */
	function _bindContinue($wrapper) {
		// show the proper button
		$wrapper.find('a.replay.end_frame_btn').hide();
		$wrapper.find('a.continue.end_frame_btn').css('display', 'inline-block')
		$wrapper.find('a.continue.end_frame_btn, .end_frame, .end_frame_overlay').on('click.end_frme', function(e) {
			e.preventDefault();
			e.stopPropagation();
			// get the video api
			var vp = _get_jwp_API($wrapper);
			
			// click tracking - has to go first since this function gets called multiple times on subsequent "continue" clicks for some reason
			if (vp.getState() != 'PLAYING') {
				var section = mrm.util.sectionname.getSectionName($(this));
				var videoimage = vp.getPlaylistItem().file;
				videoimage = videoimage.substr(videoimage.lastIndexOf("/") + 1);
				mrm.util.trackEvent("click_cta", {section: section, linkname: 'video:continue:' + videoimage});
			}
			
			// force the player to play
			if (vp) {
				vp.play(true);
			}

			// remove the end frame
			_kill($wrapper);
		});
	}

	/**
	 * bind the Replay button
	 * @param {jQuery} $wrapper The end frame wrapper jQuery object
	 * @returns {void}
	 */
	function _bindReplay($wrapper) {
		// show the proper button
		$wrapper.find('a.continue.end_frame_btn').hide();
		$wrapper.find('a.replay.end_frame_btn').css('display', 'inline-block');
		$wrapper.find('a.replay.end_frame_btn, .end_frame, .end_frame_overlay').on('click.end_frame', function(e) {
			e.preventDefault();
			e.stopPropagation();
			var $this = $(this);
			var vp = _get_jwp_API($wrapper);
			if (vp) { /// if there is an api stop the and play the video from the begining
				vp.stop().play();
			} else { /// if there is no video api then find the poster image and trigger event
				var postframe = _get_video_container($wrapper).find('img')
				postframe.click();
			}
			
			// tracking
			var section = mrm.util.sectionname.getSectionName($this);
			var videoimage = vp.getPlaylistItem().file;
			videoimage = videoimage.substr(videoimage.lastIndexOf("/") + 1);
			mrm.util.trackEvent("click_cta", {section: section, linkname: 'video:replay:' + videoimage});

			// remove the end frame
			_kill($wrapper);
		});
	}

	/**
	 * Bind the click event to the CTA's
	 * @param {jQuery} $wrapper The end frame wrapper jQuery object
	 * @returns {void}
	 */
	function _bindCTAs($wrapper) {
		$wrapper.find('.end_frame_cta').on('click.end_frame', function(e) {
			e.stopPropagation();
			var $this = $(this);
			var $vid_container = $this.closest('.vid_container');
			var killAfter = true;

			if ($this.find('.video').length) {
				e.preventDefault();
				// find the video
				var $old_vid = _get_video_container($wrapper),
					$new_vid = $this.find('div.video');
				// play new video
				$new_vid = $new_vid.clone();
				// force auto play
				$new_vid.attr({'data-posterclick': false, 'data-autostart': true, 'data-width': $old_vid.data('width'), 'data-height': $old_vid.data('height')});
				efOptions.autostart = true;
				efOptions.endFrameCall = true;

				$old_vid.replaceWith($new_vid);
				// kick it off
				mrm.corcmp.mmVideo.activateVideo(_get_video_container($wrapper), efOptions);

				efOptions.endFrameCall = false;
				efOptions.autostart = false;
				// update the caption
				_update_caption($this.find('.video_caption').html(), $wrapper);
			} else if ($this.data('action') === 'new_slide') {
				e.preventDefault();
				_navigate_to_hash($this.attr('herf'));
			} else {
				/// just go to the link
				killAfter = false;
			}

			var photoname = $this.find("img").attr("src");
			if (typeof (photoname) !== "undefined") {
				photoname = photoname.substr(photoname.lastIndexOf('/') + 1);
			}
			var section = mrm.util.sectionname.getSectionName($this);
			mrm.util.trackEvent("click_cta", {section: section, linkname: 'video:' + photoname});

			if(killAfter){
				$vid_container.find('.playing').removeClass('playing');
				$this.closest('li').addClass('playing');


				_kill($wrapper);
			}
		})
	}

	/**
	 * Kill the end frame by removing all event listeners and hiding it.
	 * @param {jQuery} $wrapper The end frame wrapper jQuery object
	 * @returns {void}
	 */
	function _kill($wrapper) {
		// find the video
		// get the video api
		var vp = _get_jwp_API($wrapper)
		if (vp) {
			vp.getPlugin('controlbar').show();
		}

		$wrapper.find('*').off('.end_frame');
		$wrapper.hide();
	}

	/**
	 *
	 * @param {jQuery} $container in the scroller where the end frame wrapper jQuery object is
	 * @returns {void}
	 */
	function _reset($container) {
		$container.find('.end_frame_wrap').each(function() {
			var $vid_container = $(this).closest('.vid_container');
			if ($vid_container.length) {
				var $vid = _get_video_container($container)
				var $temp = _get_video_duplicate($vid_container);
				$vid.replaceWith($temp);
				/// remove the classes added
				$vid_container.find('.playing').removeClass('playing');
				$vid_container.removeClass('vid_container');
				_kill($(this));
			}
		})
	}

	/**
	 * Have to duplicate the video like this because of IE8.
	 * @param {jQuery} $vid
	 * @returns void
	 */
	function _duplicate_video_object($container, $vid) {
		if ($container.length && $vid.length) {
			var temp = {};
			$.each($vid.get(0).attributes, function() {
				temp[this.name] = this.value;
			});
			$container.data('video_obj', temp);
			$container.data('video_content', $vid.data('content'));
		}
	}

	/**
	 * Finds the primary video container
	 * @param {jQuery} $element
	 * @returns {void}
	 */
	function _get_video_container($element) {
		var $vid = $();
		if ($element.siblings('.video').length) {
			$vid = $element.siblings('.video');
		} else if ($element.find('object').length) {
			$vid = $element.find('object').closest('.video');
		} else {
			$vid = $element.closest('.vid_container').find('>.video');
		}
		return $vid;
	}

	function _get_jwp_API($wrapper) {
		var vid_id = _get_video_container($wrapper).find('object').attr('id');
		// get the video api
		if (vid_id) {
			return jwplayer(vid_id);
		} else {
			return false;
		}
	}

	/**
	 * Rebuilds the video
	 * @param {jQuery} $container
	 * @returns {jQuery}
	 */
	function _get_video_duplicate($container) {
		var $temp = $('<div />', $container.data('video_obj')).append($container.data('video_content'));
		$temp.data('content', $container.data('video_content'));
		return $temp;
	}

	/**
	 * Send the the scroller to the correct slide when link with has is clicked
	 * @param {string} hash The name of the frame to scroll to
	 * @returns {void}
	 */
	function _navigate_to_hash(hash) {
		var modKey = 'mod';
		if (!mrm.util.isValidIdentifier(mrm.util.stripHash(hash))) {
			return;
		}
		var $content = $(hash);

		// iterate over replacements and look for dom-#id
		if ($content.length === 0) {
			$content = $(hash.replace(/^#/, '#' + mrm.util.getRenamedIdPrefix()));
		}
		if ($content.length === 0)
			return;

		// iterate over all embracing .mods
		$content.parents('.' + modKey).each(function(index, mod) {
			var cmpName = mrm.util.getModuleName($(this));
			if (mrm.cmp[cmpName] && typeof mrm.cmp[cmpName].switchToContent === 'function') {
				// call cmp-function to switch to content
				mrm.cmp[cmpName].switchToContent($content);
			} else if (mrm.mod[mrm.util.getTerrificModuleName(cmpName)]) {
				// its a terrific module
				var instance = mrm.util.getTerrificInstance($(mod));
				if (instance)
					instance.switchToContent($content);
			}
		});
	}

	/**
	 * Function find and update the caption on the main video player
	 * @param {string} caption
	 * @param {jQuery} $wrapper
	 * @returns {void}
	 */
	function _update_caption(caption, $wrapper) {
		caption = caption || '';
		if ($('div.modMm_gal_lq').find('div.caption').length) {
			if (caption.length) {
				$('div.modMm_gal_lq').children('div.panelWrp').children('div.inner').find('div.caption').html($('<div class="txtWrp" />').html(caption));
			} else {
				$('div.modMm_gal_lq').children('div.panelWrp').children('div.inner').find('div.caption').empty();
			}
		} else if ($wrapper && $wrapper.closest('#fancybox-content').length) {
			var $title = $wrapper.closest('#fancybox-content').siblings('#fancybox-title');
			if ($title.find('.indicator_number').length === 0 && $title.find('.indicator_dot').length === 0) {
				$title.html(caption);
			}
		} else if (_get_video_container($wrapper).siblings('figcaption').length) {
			var $title = _get_video_container($wrapper).siblings('figcaption');
			$title.html(caption);
		}
	}

	/**
	 * Finds the poster image and returns the url
	 * @param {jQuery} $wrapper
	 * @returns {String}
	 */
	function _get_poster_image_url($wrapper){
		var $container = _get_video_container($wrapper);
		if($container.closest('.hidden-video').length){
			return $('#'+ $container.closest('.hidden-video').data('vidId')).find('.hidden-video').data('posterimage') || '';
		}else{
			return $container.data('posterimage') || '';
		}
	}

	///// public functions
	return {
		initialize: _initialize,
		reset: _reset
	}
}(mrm.$);
(function($) {
	mrm.helper = mrm.helper || {};
		$.extend(mrm.helper, {
			clickTrackLinks: {
				tpl: ['02','05','06','12'],
				clickOrTouch: (mrm.util.touchDevice()) ? 'touchstart' : 'click',
				init: function() {
					var self = this;
					mrm.$(window).load(function(){
						if(typeof(pageTrackJSON) !== 'undefined'){
							self.initTracking();
						}
					});
				},
				initTracking: function(){
					var self = this;

					//Homepage masthead tracking
					//CTA button
					$('div.masthead ul.mmScrollItems li.mod h2.cta a').removeAttr('onclick');
                    $('div#modMh_1_ctaOverlay h2.cta span.centerContent').on( self.clickOrTouch, function (c) {
                        mrm.util.trackEvent('click_cta',{section: "masthead", linkname: "link:" + $.trim($(this).text())});
                    });

					// <<<<< Masthead Arrow Previous <<<<<
					$('div.modMh_1 div.mmScroll span.prev').on( self.clickOrTouch, function (c) {
						var photoname;
						if (mrm.util.curTemplate() === "02") { // homepage
							if ( $('div.modMh_1 div.mmScroll ul.mmScrollItems li.modMh_item_1.prev canvas').length > 0 ) { // homepage - modern browsers
								photoname = $('div.modMh_1 div.mmScroll ul.mmScrollItems li.modMh_item_1.prev canvas').attr('data-imgsrc');
							}
							else if ( $('ul.mmScrollItems li.modMh_item_1.prev').length > 0 ) { // homepage - ie8 native
								// photoname = $('div.modMh_scroller_1 div.mmScroll ul.mmScrollItems li.modMh_item_1.prev img').attr('orig-src').split('/').pop();  // works when rename attribute without hyphen
								photoname = $('ul.mmScrollItems li.modMh_item_1.prev').html();
								var y = photoname.search('<OBJECT id=externalms') - 4,
									x = photoname.search('imgsrc') + 8;
								photoname = photoname.slice( x, y );
							}
							else if ( $('.t02 .caroufredsel_wrapper img').length > 0 ) { // homepage - Type 1 scroller
								photoname = $('.t02 .caroufredsel_wrapper img').attr('src').split('/').pop();
							}
						mrm.util.trackEvent('click_cta',{section: "masthead", linkname: "arrow:prev:" + photoname});
						}
					});


					// >>>>> Masthead Arrow Next >>>>>
					$('div.modMh_1 div.mmScroll span.next').on( self.clickOrTouch, function (c) {
						var photoname;
						if (mrm.util.curTemplate() === "02") { // homepage
							if ( $('div.modMh_1 div.mmScroll ul.mmScrollItems li.modMh_item_1.next canvas').length > 0 ) { // homepage - modern browsers
								photoname = $('div.modMh_1 div.mmScroll ul.mmScrollItems li.modMh_item_1.next canvas').attr('data-imgsrc');
							}
							else if ( $('ul.mmScrollItems li.modMh_item_1.next').length > 0 ) { // homepage - ie8 native
								// photoname = $('div.modMh_scroller_1 div.mmScroll ul.mmScrollItems li.modMh_item_1.next img').attr('orig-src').split('/').pop();  // works when rename attribute without hyphen
								photoname = $('ul.mmScrollItems li.modMh_item_1.next').html();
								var y = photoname.search('<OBJECT id=externalms') - 4,
									x = photoname.search('imgsrc') + 8;
								photoname = photoname.slice( x, y );
							}
							else if ( $('.t02 .caroufredsel_wrapper img').length > 0 ) { // homepage - Type 1 scroller
								photoname = $('.t02 .caroufredsel_wrapper img').attr('src').split('/').pop();
							}
						mrm.util.trackEvent('click_cta',{section: "masthead", linkname: "arrow:next:" + photoname});
						}
					});


					// Masthead dots
					$('div.modMh_1 div.mmScrollPaginationWrp ol li a').on( self.clickOrTouch, function (c){
						var photoname = '';
						var src;
						if ( $('.t06c .caroufredsel_wrapper li.ui-helper-visible img') ) {
							src = $(".t06c .caroufredsel_wrapper li.ui-helper-visible img").attr('src');
						}
						else {
							src = $('div.modMh_scroller_1 div.mmScroll ul.mmScrollItems li.modMh_item_1 img').attr('src');
						}

					});


					//Scroll Previous
					$(document)
						.on('click', 'div.modMh_1 div.mmScroll ul.mmScrollItems li.modMh_item_1.prev', function(e) {
						var photoname = $('canvas', this).attr('data-imgsrc');
						mrm.util.trackEvent('click_cta',{section: "masthead", linkname: "scroll:prev:" + photoname});
					 });

					//Scroll Next
					$(document)
						.on('click', 'div.modMh_1 div.mmScroll ul.mmScrollItems li.modMh_item_1.next', function(e) {
						var photoname = $('canvas', this).attr('data-imgsrc');
						mrm.util.trackEvent('click_cta',{section: "masthead", linkname: "scroll:next:" + photoname});
					 });

					// kbb tile links (Teaser Tiles?)
					$("div.mds-area-pf6 div.mds-cmp-teaser05 ul.ull li a").on(self.clickOrTouch, function(c){
						if($(this).parents('form').length && $(this).parents('form').find('input').val() != ''){
							mrm.util.trackEvent('click_cta',{section: "dashboard", linkname: "zipcode"});
						} else{
						mrm.util.trackEvent('click_cta', {section: "dashboard", linkname: "link:" + $(this).text()});
						}
					});

					//Model-Selector
					//toggle click metric of the "show models for [whatever car]"
					$("div#nav_modelchanger_tab").on( self.clickOrTouch, function() {
						if (typeof (pageTrackJSON) != "undefined"){
							fireMetrics("model-selector")
						}
					});
					 // click for the flyout buttons
					$("div.nav_modelchanger_menu div.modVi_1 ul.cta li a").removeAttr('onclick');
					$("div.nav_modelchanger_menu div.modVi_1 ul.cta li a").on(self.clickOrTouch, function() {
						if (typeof (pageTrackJSON) != "undefined"){
							fireMetrics("model-car", {model_name:$(this).parents('.exp_lyr').siblings('.jellybean').find('h3.vt').text() , link_name:$(this).attr('title')})
						}
					});
				}
			}
		});
}(mrm.$)); (function($) { 
	mrm.helper = mrm.helper || {};
	$.extend(mrm.helper, {           
		equalHeights: {          
			/**
			 * JS for making related boxes (e.g. in a grid row) having the same height
			 * 
			 * @param {String} c DOM Context
			 */
			tpl: ['01', '02', '03', '05', '06', '08', '09', '10', '11', '13', '15', '16'],
			init: function(c) {    
				mrm.util.log('[mrm.cmp.equalHeights] Context: ' + c);
				// T16 - equal height for the list elements within the CMP select_brochure
				$('ul.brochurelist > li.request_type').equalHeights();
			}   
		}
	});
}(mrm.$));(function($) {
	mrm.ie = mrm.ie || {};
	$.extend(mrm.ie, {
		lastChild: {
			/**
			 * JS for classifying last-child elements as last-childs for non :last-child supporting browsers / ie
			 * 
			 * @param {String} c DOM Context
			 */
			init: function(c) {
				$('#container').children('.mds-area-header').find('div.modNav_tools_1')
					.find('dd.content > div:last').addClass('lastChild');
                $('.modCnt_tbl_fs_1 .tbl tfoot tr:last-child').addClass('lastChild');
			}
		}
	});
})(mrm.$);(function($) {
	$.extend(mrm.cmp, {
		cnt_tbl_comp_1: {
			
			model : {},
			item : {},
			collection : {},
			view : {},
			
			$ctx : null,
			
			init: function(c)
			{
				this.$ctx = $('.modCnt_tbl_comp_1');
				
				if( !this.$ctx.length )
				{
					return;
				}
				
				var collection = new mrm.cmp.cnt_tbl_comp_1.collection.Bodystyle(mrm.data.cnt_tbl_comp_1, {});
				
				var view = new mrm.cmp.cnt_tbl_comp_1.view.Table({
					el : this.$ctx.find('table').get(0),
					id : 'cnt_tbl_comp_1.view.Table',
					config : {},
					headerTemplateHtml : this.$ctx.find('script.prototype.headerEntry').html(),
					collection : collection
				});
				
				$.eventDispatcher.on('HMC_changeMode', $.proxy(function(event, data){
					this.$ctx.toggle(data.mode === 'compare');
				}, this));
			}
		}
	});
}(mrm.$));(function($)
{
	mrm.cmp.cnt_tbl_comp_1.item.Bodystyle = Backbone.Model.extend({
		
		idAttribute : 'bodystyleCode',
		
		initialize : function()
		{
//			console.log('init mrm.cmp.cnt_tbl_comp_1.item.Bodystyle');
		},
		
		parse : function(input)
		{
//			console.log('parse', input);
		},
		
		getByCategoryAndFeature : function(categoryId, featureId)
		{
			var categories = this.get('categories');
			
			if( categories && categories[categoryId] && categories[categoryId].features[featureId] )
			{
				return categories[categoryId].features[featureId];
			}
			else
			{
				return null;
			}
		},
		
		getFormattedFeature : function(feature, config)
		{
			if( !feature ) return '';

			switch(feature.featureType)
			{
				case 'SimpleFeature':
					return feature.avail;
					break;

				case 'ListFeature':
					return feature.formattedValues.join('<br/>');
					break;

				case 'ValueFeature':
					
					var value = (config.display === 'lowest') ? feature.formattedMin : feature.formattedMax;

					return config.prefix + ' ' + value + ' ' + config.suffix;
					break;
				default:
					return '-';
			}
		}
	
	
	});
}(mrm.$));(function($)
{
	mrm.cmp.cnt_tbl_comp_1.collection.Bodystyle = Backbone.Collection.extend({
		
		model : mrm.cmp.cnt_tbl_comp_1.item.Bodystyle,

		
		initialize : function(models, options)
		{
		},
		
		getBestChoice : function(categoryKey, featureKey, valueKey, sorting, modelIds)
		{
			var activeModels = this.filter(function(model){
				var data = model.toJSON();
				return _.contains(modelIds, model.id) && data.categories[categoryKey] && data.categories[categoryKey].features[featureKey];
			});
			
			var types = _.unique(_.map(activeModels, function(model){
				return model.toJSON().categories[categoryKey].features[featureKey].featureType;
			}, this));
			
			if( types.length !== 1 )
			{
//				console.log('DATATYPE MISMATCH');
				return [];
			}
			
			if( types[0] === 'ValueFeature')
			{
				var values = _.map(activeModels, function(model){
					return model.toJSON().categories[categoryKey].features[featureKey][valueKey];
				}, this);
				
				var bestValue = (sorting === 'lowest') ? _.min(values) : _.max(values);
				
				var matches = _.filter(activeModels, function(model){
					return model.toJSON().categories[categoryKey].features[featureKey][valueKey] === bestValue; 
				}, this);
				
				return matches;
			}
			
			return [];
		}
	});
}(mrm.$));(function($)
{
	mrm.cmp.cnt_tbl_comp_1.view.Table = Backbone.View.extend({

		$thead : null,
		$firstRow : null,
		$checkboxes : null,
		
		tableIndex : {},
		headerOffset : $('#mds-area-header').outerHeight(),
		theadHeight: 0,
		tableHead : [],
		slotManager : null,
		numberOfColumns : 0,
		
		valueKeyMapping : {
			'lowest' : 'min',
			'highest': 'max'
		},
		
		events : {
			'click .toggle' : 'onToggleClick',
			'click .back' : 'onBackClick',
			'click .remove' : 'onRemoveClick',
			'change input:checkbox' : 'onSelectionChange'
		},

		initialize : function(options)
		{
			this.$thead = this.$el.find('thead');
			this.$firstRow = this.$el.find('tbody:first tr:first > *');
			this.$checkboxes = this.$thead.find('th:first ul :checkbox');
			this.theadHeight = this.$thead.height();
			
			this.createTableIndex();

			this.columnHeaderTemplate = Handlebars.compile(options.headerTemplateHtml);
			this.numberOfColumns = this.tableHead.length;
			
			this.slotManager = new mrm.util.SlotManager(this.numberOfColumns);
			
			this.$thead.css('top', this.headerOffset);
			
			_.defer($.proxy(function(){
//				this.theadHeight = this.$thead.height();
//				this.$el.hide();
				$.eventDispatcher.trigger('HMC_clearAll');
			}, this));

			this.setBindings();
		},
		
		setBindings : function()
		{
			$(window).on('scroll', $.proxy(this.onScroll, this));

			$.eventDispatcher.on('HMC_addItem', $.proxy(this.onAddItem, this));
			$.eventDispatcher.on('HMC_removeItem', $.proxy(this.onRemoveItem, this));
			
			$.eventDispatcher.on('HMC_tableLock', $.proxy(function(){
				this.$checkboxes.filter(':not(:checked)').prop('disabled', true).checkBox('update');
			}, this));
			$.eventDispatcher.on('HMC_tableUnlock', $.proxy(function(){
				this.$checkboxes.prop('disabled', false).checkBox('update');
			}, this));
			
			$.eventDispatcher.on('HMC_clearAll', $.proxy(function(event, data){
				this.$checkboxes.prop('checked', false).prop('disabled', false).checkBox('update');
				_.times(this.numberOfColumns, function(index){
					this.clearColumn(index);
				}, this);
				this.slotManager.clearAll();
			}, this));
			
			$.eventDispatcher.on('HMC_changeMode', $.proxy(function(event, data){
				if(data.mode === 'compare'){
					this.resetCategoriesFolding();
				}
			}, this));
		},

		onToggleClick : function(event)
		{
			$(event.target).closest('tr').toggleClass('fold').nextAll().toggle();
		},

		onBackClick : function(event)
		{
			$.eventDispatcher.trigger('HMC_changeMode', { mode: 'choose'});
		},
		
		onRemoveClick : function(event)
		{
			event.preventDefault();
			
			$.eventDispatcher.trigger('HMC_removeItem', {
				items: [$(event.target).data('id')]
			});
		},

		onSelectionChange : function(event)
		{
			var $target = $(event.target);
			var eventName = $target.is(':checked') ? 'HMC_addItem' : 'HMC_removeItem';

			$.eventDispatcher.trigger(eventName, {
				items: [$target.val()]
			});
		},

		onAddItem : function(event, data)
		{
			_.each(data.items, function(item)
			{
				var index = this.slotManager.add(item);
				
				if( index >= 0 )
				{
					this.$checkboxes.filter('[value="'+item+'"]').prop('checked', true).checkBox('update');
					this.fillColumn(index, item);
					this.clearEmptyRows();
					
					if( this.slotManager.isFull() )
					{
						$.eventDispatcher.trigger('HMC_tableLock');
					}
				}
			}, this);
			
			this.setHighlighting();
		},

		onRemoveItem : function(event, data)
		{
			_.each(data.items, function(item)
			{		
				var index = this.slotManager.remove(item);
				
				if( index >= 0 )
				{
					this.$checkboxes.filter('[value="'+item+'"]').prop('checked', false).checkBox('update');
					this.clearColumn(index);
					
					if( !this.slotManager.isFull() )
					{
						$.eventDispatcher.trigger('HMC_tableUnlock');
					}
				}
			}, this);
			
			this.setHighlighting();
		},
		
		resetCategoriesFolding : function()
		{
			this.$el.find('tbody tr.thead:not(.fold) .toggle').trigger('click');
			this.$el.find('tbody:first tr.thead.fold:not(.empty) .toggle').trigger('click');
		},
		
		clearEmptyRows : function()
		{
			_.each(this.tableIndex, function(rows, categoryId)
			{
				var totalCells = 0;
				var totalEmptyCells = 0;
				_.each(rows, function(row, featureId)
				{
					var invalidContent = 0;
					_.each(row.cells, function(cell)
					{
						totalCells++;
						if(cell.html() == '<span class="status-n-a"></span>' || cell.html() == '')
						{
							invalidContent++;
							totalEmptyCells++;	
						}
					}, this);
					
					if(invalidContent == 3){
						row.cells[0].parent().addClass('empty');
					} else {
						row.cells[0].parent().removeClass('empty');
					}
					
				}, this);
				
				if(totalCells == totalEmptyCells){
					this.$el.find('tbody[data-category='+categoryId+'] tr.thead').addClass('empty');
				} else {
					this.$el.find('tbody[data-category='+categoryId+'] tr.thead').removeClass('empty');	
				}
			}, this);
		},

		fillColumn : function(colNum, id)
		{
			var model = this.collection.get(id);
			
			if( !model ) return;
			
			var tplData = _.extend({
				id: id
			}, mrm.conf.cmp.cnt_tbl_comp_1.bodystyles[id]);
	
			this.tableHead[colNum].html(this.columnHeaderTemplate(tplData));

			_.each(this.tableIndex, function(rows, categoryId)
			{
				_.each(rows, function(row, featureId)
				{
					var feature = model.getByCategoryAndFeature(categoryId, featureId);
					
					if( feature )
					{
						var content = '';
						
						if(feature.featureType === 'SimpleFeature')
						{
							content += '<span class="status-';
							
							switch(feature.avail)
							{
								case 'notAvailable':
									content += 'n-a';
									break;
									
								case 'standardForAll':
									content += 'standard';
									break;
									
								default:
									content += 'available';
									break;
							}
							content += '"></span>';
						}
						else
						{
							content = model.getFormattedFeature(feature, row.config)
						}
						row.cells[colNum].html(content);
					}
					else
					{
						row.cells[colNum].html('<span class="status-n-a"></span>');
					}
				}, this);
			}, this);
		},
		
		clearColumn : function(colNum)
		{
			this.tableHead[colNum].html('');
			
			_.each(this.tableIndex, function(rows)
			{
				_.each(rows, function(row)
				{
					row.cells[colNum].html('');
				}, this);
			}, this);
		},
		
		setHighlighting : function()
		{
			this.$('td.highlight').removeClass('highlight');
			
			var activeIds = _.compact(this.slotManager.toArray());
			
			if( activeIds.length < 2 ) return;
			
			_.each(this.tableIndex, function(rows, categoryId)
			{
				_.each(rows, function(row, featureId)
				{
					if( row.config.highlight !== 'none' )
					{
						var matches = this.collection.getBestChoice(categoryId, featureId, this.valueKeyMapping[row.config.display], row.config.highlight, activeIds);
						
						_.each(_.pluck(matches, 'id'), function(id){
							row.cells[this.slotManager.getIndexByContent(id)].addClass('highlight');
						}, this);
					}
				}, this);
			}, this);
		},
		
		onScroll : function(event)
		{
			var enableSticky = $(window).height() < this.$el.height()+this.theadHeight-this.$thead.height(); // keep height difference of smaller sticky head in the calculation, otherwise in border cases enable sticky gets toggled back andd forth resulting in fluttering sticky head
			var tableStartOffset = this.$el.offset().top/* + this.theadHeight*/;
			var tableEndOffset = this.$el.offset().top + this.$el.height() - this.$thead.height();
			var scrollTop = $(window).scrollTop() + this.headerOffset;

			if( enableSticky && !this.isSticky && scrollTop > tableStartOffset && scrollTop < tableEndOffset )
			{
				this.isSticky = true;

				this.$thead.addClass('sticky');
				this.$firstRow.css('padding-top', parseInt(this.$firstRow.css('padding-top')) + this.$thead.height());
			}

			else if( !enableSticky || (this.isSticky && (scrollTop > tableEndOffset || scrollTop < tableStartOffset)) )
			{
				this.isSticky = false;

				this.$firstRow.css('padding-top', parseInt(this.$firstRow.css('padding-top')) - this.$thead.height());
				this.$thead.removeClass('sticky');
			}
		},

		createTableIndex : function()
		{
			_.each(this.$el.find('thead tr:first th:not(:first)'), function(th, index){
				this.tableHead[index] = $(th);
			}, this);
			
			_.each(this.$el.find('tbody'), function(tbody, i)
			{
				var $tbody = $(tbody);
				var category = $tbody.data('category');
				this.tableIndex[category] = {};

				_.each($tbody.find('tr:not(.thead)'), function(tr, j)
				{
					var $tr = $(tr);
					var feature = $tr.data('feature');

					this.tableIndex[category][feature] = {
						config : $tr.data(),
						cells : []
					};
					
					_.each($tr.find('td'), function(td, k)
					{
						this.tableIndex[category][feature].cells[k] = $(td);
					}, this);
				}, this);
			}, this);
		}
		
	});
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		bbc_n01 : {
			/**
			 * Init menu events
			 * @name mrm.cmp.bbc_n01.init(c)
			 *
			 * @param {String} c DOM Context
			 */

			init: function(c) {
				var self = this;

				// loadBBC event triggered by nav_prim when AJAX call returns
				$('#mds-area-header').on('loadBBC', 'div.n01', function(e) {
					var $bbc = $(this);
					
					if ($bbc.find(".footer ul.ui-layout-justified").length > 0) {
						self.justifyFooter($bbc.find(".footer ul.ui-layout-justified"));
					}
				});
			},

			justifyFooter: function($targetUl){

				// UL containing ui-layout-justified needs to have a set width in CSS
				var containerWidth = $targetUl.width();
				var childrenTotalWidth = 0;

				// Get total width of all list items
				$targetUl.find("li").each(function(){
					childrenTotalWidth += $(this).outerWidth(true);
				});

				// Figure out the different between UL width and total list-item width
				var widthToAdd = (containerWidth - childrenTotalWidth) / $targetUl.find("li").length;

				// Expand each list-item to match full width of UL
				$targetUl.find("li").each(function(){
					var oldWidth = $(this).width();
					var newWidth = oldWidth + widthToAdd;
					$(this).css("width", newWidth);
				});
			}

		}
	});
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		bbc_n01b : {
			/**
			 * Init menu events
			 * @name mrm.cmp.bbc_n01b.init(c)
			 *
			 * @param {String} c DOM Context
			 */

			init: function(c) {
				this.setBindings();
			},

			setBindings: function() {
				var self = this;

				$('#mds-area-header').on('mouseleave', 'div.n01b ul.dropdown > li > a:not(.hasChildren)', function(e) {
					$(this).closest('li').removeClass('li_active');
				});

				$('#mds-area-header').on('bbcContentShow', 'div.n01b div.bbcContent', function(e) {
					var $carline = $(e.target);
					$(this).addClass('visible').parent('.content').addClass('bbcContentVisible');

					if ( !$carline.data('initDone') ) {
						mrm.util.initDomContent($carline.data('initDone', true));
					}

				}).on('bbcContentHide', 'div.n01b div.bbcContent', function(e) {
					$(this).removeClass('visible').parent('.content').removeClass('bbcContentVisible');
				});

				$('#mds-area-header').on('firstLevelNavHideAllClosedBbc', 'div.n01b', function(e) {
					$(this).children('.content').removeClass('bbcContentVisible');
				});

			}

		}
	});
}(mrm.$));
(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		bbc_n02b : {
			/**
			* Init menu events
			* @name mrm.cmp.bbc_n02.init(c)
			*
			* @param {String} c DOM Context
			*/
			$nugget : null,

			init: function(c) {
				this.$nugget = $('body').append().find('span.nugget').get(0);
				this.setBindings();
			},

			bbcShrinkHeightToViewport: function($imageContainer, $bodystyleNav) {
				
				var $header = $('#mds-area-header'),
					$bbc = $imageContainer.closest('div.modBaseballcard.n02b'),
					winHeight = $(window).height(),
					bbcHeight, heightDiff, reduceHeight;

				this.bbcResetHeight($imageContainer, $bodystyleNav);

				bbcHeight = $header.height() + $bbc.height();
				heightDiff = bbcHeight - winHeight;
				reduceHeight = winHeight < bbcHeight;

				$bbc.toggleClass('reducedHeight', reduceHeight);

				// adjust height only on brands with fixed headers
				if ( $header.css('position') !== "fixed" || !reduceHeight) {
					return false;
				}
				this.bbcHeightAdjust($imageContainer, $bodystyleNav, heightDiff);
			},

			bbcHeightAdjust: function($imageContainer, $bodystyleNav, heightDiff) {
				var newHeight;

				if ( !heightDiff ) {
					return;
				}

				newHeight = Math.max(30, $imageContainer.filter(':visible').height() - heightDiff);
				$imageContainer.height(newHeight);
				$imageContainer.find('img').css('margin-top', -heightDiff/2);

				$bodystyleNav.css('top', function(i, currentValue) {
					currentValue = parseInt(currentValue, 10);
					return (!heightDiff ? currentValue : Math.max(0, currentValue - heightDiff) ) + 'px';
				});
			},


			bbcResetHeight: function($imageContainer, $bodystyleNav) {
				// reset height
				$imageContainer.height('auto');
				$imageContainer.find('img').css('margin-top', 'auto');
				// bodystyleNav reset top value
				$bodystyleNav.css('top', function(i, currentValue) {
					if ( !$bodystyleNav.data('resetTop') ) {
						// keep track of the initial value
						$bodystyleNav.data('resetTop', $bodystyleNav.position().top);
					}
					return $bodystyleNav.data('resetTop') + 'px';
				});
			},
			setNetPricingCluetips: function() {
				$(".tn02b_nav_carline_detail .modNav_vehicle_selection_1 div dl dd a[cluetip-title*=' ']:not(.cluetip_vi_8_applied)").addClass("cluetip_vi_8 cluetip_vi_8_applied");
				var b = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
					titleAttribute: "cluetip-title",
					activation: "click",
					disableScroll: true
				});
				$('.cluetip_vi_8').removeClass("cluetip_vi_8").cluetipWrap(b);
			},
			setBindings: function() {
				var self = this,
					$header = $('#mds-area-header');

				$header.on('click', '.n02b .modNav_carline_selection_1 > ul > li a, .n02b .modNav_vehicle_selection_1 > dl li a, div.modVi_1 dl dt, div.modVi_1 dl dd', function(e) {
					e.preventDefault();
					if ( $('#cluetip').is(':visible') ) {
						$('#cluetip').css('display','none');
					}
				});

				$header.on('loadBBC', 'div.n02b', function(e) {
					var $attributeLists = $(this).find('div.modNav_vehicle_selection_1 li.attributes ul');
					var $carlineVis = $(this).find('div.modNav_carline_selection_1 div.modVi_1');
					// we should try to run equalHeights on the Vi_1 mods once the bbc has loaded (better fix for GMDSSDS-26295 than just inserting empty tags)
					// $carlineVis.equalHeights();
					$carlineVis.each(function() {
						var $currentVi = $(this);
						if ( !$currentVi.children('dl').length ) {
							$currentVi.append('<dl><dt>&nbsp;</dt><dd>&nbsp;</dd></dl>');
						}
					});
					$attributeLists.each(function() {
						var $currentList = $(this);
						if ( !$currentList.children('li').length && !$attributeLists.hasClass('ll')) { // checks for class of restructured node n02
							// $currentList.append('<li style="height:60px" class="bbc_n02b">&nbsp;</li>');
							$currentList.parent('li.attributes').remove(); // should be done by the cms
						}
					});
				});

				$header.on('click', '.n02b .modNav_carline_selection_1 > ul > li', function(e) {
					var $imageContainer, $bodystyleNav,
						$currentLi = $(this),
						$carline = $($currentLi.find('a').prop('hash')),
						$nugget  = $currentLi.addClass('active').siblings('.active')
							.removeClass('active').andSelf().children('.nugget');
					$currentLi.append(
						$nugget.length ? $nugget : $('<span />').addClass('nugget')
					).closest('ul').addClass('activated');

					if ( $(this).parents('.modNav_prim_2.grid_style').length ){ // hard coded flyout height for a n02 node navigation
						$(this).parents('.modNav_carline_selection_1').siblings('.nav_carline_bbc').height(382);
					}

					$carline.show({
						duration:0,
						complete: function(){
							// centering offset for bbc images in multiple carline groups when enhanced navigation grid style selected.
							if (!$(this).hasClass('configured') && $(this).parents('.modNav_prim_2.grid_style').length > 0) {
								$(this).addClass('configured');
								var imgs = $(this).find('img.mm');
								$.each(imgs, function(){
									var figWidth = $(this).parents('figure').width();
									var imgWidth = $(this).width();
									// if the image is smaller than the content area
									if (imgWidth < figWidth){ $(this).width(figWidth); }
									// if the image is larger than the content area
									if (imgWidth > figWidth){var posX = (imgWidth-figWidth)/2;$(this).css('margin-left', -posX);}
								});
							}
						}
					}).siblings('div.modNav_vehicle_selection_1').hide();

					$carline.children('dl').find('li').first().trigger('click');

					$currentLi.trigger('click.Nav_carline_selection_1');

					e.stopPropagation();

					$imageContainer = $carline.children('div').children('figure');
					$bodystyleNav = $carline.children('dl');
					self.bbcShrinkHeightToViewport($imageContainer, $bodystyleNav);
					self.setNetPricingCluetips();
				});

				$header.on('click', '.n02b .modNav_vehicle_selection_1 > dl li', function(e) {
					var $imageContainer, $bodystyleNav,
						$currentLi = $(this),
						$bodystyle = $($currentLi.find('a').prop('hash'));

					$currentLi.addClass('active').siblings('.active').removeClass('active');
					$bodystyle.show().siblings('div.modVi_8').hide();
					e.stopPropagation();

					$imageContainer = $bodystyle.children('figure');
					$bodystyleNav = $bodystyle.siblings('dl');
					self.bbcShrinkHeightToViewport($imageContainer, $bodystyleNav);
					self.setNetPricingCluetips();
				});

			}

		}
	});
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		body_style_selection: {
			init: function(c) {
				// add net pricing cluetip
				$(".modBody_style_selection ul li div a[cluetip-title*=' ']").addClass("cluetip_body_style_selection");
				var b = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
					titleAttribute: "cluetip-title",
					activation: "click"
				});
				$('.cluetip_body_style_selection').cluetipWrap(b);
			}
		}
	});
}(mrm.$));(function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		btn_cookie_privacy_1: {          
			/**
			 * JS for component btn_cookie_privacy_1
			 * 
			 * @param {String} c DOM Context
			 */
			
			$ctx : null,
			
			init: function(c)
			{
				this.$ctx = $('.modBtn_cookie_privacy_1');

				var provider = mrm.util.cookie.getConfirmedTrackingProvider();
				
				if( provider !== null )
				{
					if( provider.length > 0 )
					{
						this.$ctx.find('a.allow').addClass('ui-state-active');
					}
					else
					{
						this.$ctx.find('a.deny').addClass('ui-state-active');
					}
				}
				
				this.setBindings();
			},
			
			setBindings : function()
			{
				this.$ctx.find('a.deny').on('click', $.proxy(this.onDeny, this));
				this.$ctx.find('a.allow').on('click', $.proxy(this.onAllow, this));
			},
			
			onDeny : function(event)
			{
				event.preventDefault();
				mrm.util.cookie.denyTrackingProvider();
				this.$ctx.find('a.deny').addClass('ui-state-active');
			},
			
			onAllow : function(event)
			{
				event.preventDefault();
				mrm.util.cookie.allowTrackingProvider();
				this.$ctx.find('a.allow').addClass('ui-state-active');
				if(this.$ctx.hasClass('iframe_fallback')) location.reload();
			}
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Btn_lyr_1 = mrm.mod.AbstractMod.extend({
		events: {
		},

		prepare: function() {
			var cluetipCfg = mrm.$.extend({}, mrm.conf.plugin.cluetip || {}, {
				width: 125
			});

			this.$ctx.find('a').cluetipWrap(cluetipCfg);
                        this.initWindowCheck();
		},
                
                seconds: 1000, // 1000ms = 1s
                minutes: 60 * this.seconds,
                chatCheckInterval: 30, // minutes
                chatIntervalObj: {},
                $chatBtn: {},
                chatWindowAvailabilityStartArray: Array(),
                chatWindowAvailabilityEndArray: Array(),

                checkChatAvailability: function ( currentDate ) {
                    if (currentDate === undefined) {
                        currentDate = moment(); // Default to current timestamp
                    } else {
                        currentDate = moment(currentDate); // Make sure we have a moment object
                    }
                    console.log("current date: %o", currentDate);

                    //console.log("Current day of the week: %s", currentDate.day());
                    var chatWindowStart = this.chatWindowAvailabilityStartArray[currentDate.day()];
                    var chatWindowEnd = this.chatWindowAvailabilityEndArray[currentDate.day()];

                    // Keep the time, but change the date (day, month, year) to the client date so that isBetween() will work correctly
                    chatWindowStart = chatWindowStart.date(currentDate.date());
                    chatWindowStart = chatWindowStart.month(currentDate.month());
                    chatWindowStart = chatWindowStart.year(currentDate.year());
                    chatWindowEnd = chatWindowEnd.date(currentDate.date());
                    chatWindowEnd = chatWindowEnd.month(currentDate.month());
                    chatWindowEnd = chatWindowEnd.year(currentDate.year());

                    console.log("chat window start: %o", chatWindowStart.format());
                    console.log("current date: %o", currentDate.format());
                    console.log("chat window end: %o", chatWindowEnd.format());

                    // Check that the current time is between the chat schedule start and end times
                    if (currentDate.isBetween(chatWindowStart, chatWindowEnd)) {
                        this.$chatBtn.style.display = 'block';
                        console.log("Chat Active");
                    } else {
                        this.$chatBtn.style.display = 'none';
                        console.log("Chat Inactive");
                    }
                },
                
                initWindowArray: function ( startArray, endArray ) {
                    if (Array.isArray(startArray) && Array.isArray(endArray)) {
                        // Clone array-like startArray and endArray objects into arrays using slice(0)
                        this.chatWindowAvailabilityStartArray = startArray.slice(0);
                        this.chatWindowAvailabilityEndArray = endArray.slice(0);
                    }
                },

                initWindowCheck: function ( initDelay ) {
                    var maxDelay = 2000; // Max time in miliseconds to wait for the dom element to become ready after it finishes loading
                    var delayStep = 500; // Delay between dom element ready checks in miliseconds
                    if (initDelay === undefined || isNaN(initDelay)) {
                        initDelay = 10; // Default initial dom element ready delay in miliseconds
                    }
                    

                    /* Example expected DOM element structure
                    <div class="btn_lyr_c1">
                        <div class="mds-cmp-teaser04 btn_lyr_1 mod modBtn_lyr_1">
                            <a href="https://prechat.gmc.com/prechat.xhtml?channelID=cje7dk" onclick="getOmnitureLinktrackingCode('https://prechat.gmc.com/prechat.xhtml?channelID=cje7dk');
                            if(typeof(Omniture_s) != 'undefined'){mrm.util.tagging.omniture_tl(this, this.href, 'e', undefined, {'pageName':'gm:no:US:en:','prop32':'null:Live Chat'});}
                            window.open(this.href,'','width=400,height=600,scrollbars=yes,resizable=yes'); return false;" 
                            class="btn" target="_blank" title="Live Chat">
                                <img src="/content/dam/GMC/global/master/nscwebsite/en/home/Vehicles/Shared_resource/Images/gmc_chat_now.png" alt="GMC Chat Now" width="25" height="100">
                                <span>Live Chat</span>
                            </a>
                        </div>
                    </div>
                     */
                    
                    jQuery(".btn_lyr_c1").on('DOMContentLoaded', window.setTimeout(function() {
                        // Initalize the chat button now that the chat button element is ready
                        var btnQueryString = ".btn_lyr_c1 a.btn[title='Live Chat']";
                        if (document.querySelector(btnQueryString) && 0 != document.querySelector(btnQueryString).parentNode.length) {
                            // Set the chat button element
                            this.$chatBtn = document.querySelector(btnQueryString).parentNode;
                            //console.log("Chat Button Element: %o", $chatBtn);
                            this.$chatBtn.style.display = 'none'; // Start hidden

                            // Check that the chat window schedule arrays were initalized
                            if (0 == this.chatWindowAvailabilityStartArray.length || 0 == this.chatWindowAvailabilityEndArray.length) {
                                console.error("Chat availability windows are not initalized");
                                return false;
                            }

                            this.checkChatAvailability();  // Then run an availability check
                        } else {
                            //console.log("Chat Button Wrapper: %o", jQuery(".btn_lyr_c1"));
                            console.error("Chat button not found (%o)", initDelay);
                            if (maxDelay > initDelay) { // retry initalization a few times with increasing timeout delays
                                initWindowCheck(initDelay + delayStep);
                            } else {
                                // give up on initalization
                                document.querySelector(".btn_lyr_c1").style.display = 'none';
                            }
                            return false;
                        }

                        // Since the chat availability windows always start/end at :00 or :30 past the hour;
                        //    Delay the start of the interval check until the next :00 or :30 mark (+30s delay)
                        var minTillNextInterval = this.chatCheckInterval - (moment().minutes() % this.chatCheckInterval);
                        //console.log("Minutes until next chat interval: %o", minTillNextInterval);
                        
                        var buttonLayer1 = this;
                        window.setTimeout(function() {
                            buttonLayer1.checkChatAvailability();  // Run an check now
                            // Start the checkChatAvailability timer to display the chat button if the chat availability window is open
                            //console.log("Creating checkChatAvailability interval timer for %s minutes", chatCheckInterval);
                            buttonLayer1.chatIntervalObj = window.setInterval(buttonLayer1.checkChatAvailability, buttonLayer1.chatCheckInterval * buttonLayer1.minutes);
                        }, parseInt((minTillNextInterval * this.minutes) + (30*this.seconds)));
                    }, initDelay))  // For some reason a small (1 ms) delay is needed for the chat button element to be accessible
                },
	});
})(mrm.$);(function($) {
	$.extend(mrm.cmp, {
		cnt_acc_catalog_1: {
			/**
			 * JS for component cnt_acc_catalog_1
			 *
			 * @param {String} c DOM Context
			 */
			initMod: function($mod) {
				var $itemList = $('ul.accessory_items', $mod),
					$items = $itemList.children('li'),
					$dialogContentWrp = $(),
					self = this;

					if (typeof (self.leftNavigationSticky) === "object") {
						self.leftNavigationSticky.init();
					}

				$mod.find('.name_sort_asc, .name_sort_desc, .price_sort_asc, .price_sort_desc').on('click', function(e) {
					e.preventDefault();
					var sortTarget;
					var direction;
					if ($(this).hasClass("name_sort_asc") || $(this).hasClass("name_sort_desc")) {
						sortTarget = "sortName";
						direction = $(this).hasClass("name_sort_asc") ? 'asc' : 'desc';
					}
					if ($(this).hasClass("price_sort_asc") || $(this).hasClass("price_sort_desc")) {
						sortTarget = "sortPrice";
						direction = $(this).hasClass("price_sort_asc") ? 'asc' : 'desc';
					}

					var $sortedItems = $items.sort(function(a, b){
						var r = 0;
						if($(a).data(sortTarget) < $(b).data(sortTarget)) {
							r = direction == 'asc' ? -1 : 1;
						}
						if($(a).data(sortTarget) > $(b).data(sortTarget)) {
							r = direction == 'asc' ? 1 : -1;
						}
						return r;
					});
					$itemList.empty();
					$itemList.append($sortedItems);
					self.setupDialogEvents($mod, $items);

					//
					$(this).parent().find('.selected').removeClass('selected');
					$(this).addClass('selected');
				});

				$('ul.category_filters', $mod).on('click', 'a[data-category]', function(e) {
					e.preventDefault();
					$(this).closest('li').addClass('active').siblings().removeClass('active');
					var dataCategory = $(this).attr('data-category');
					if ( dataCategory === "all" ) {
						$items.hide().not(".featured").show();
						if (typeof (self.leftNavigationSticky) === "object") {
							self.leftNavigationSticky.calculateBounds();
						}
						return;
					}
					$items.hide().filter('.' + dataCategory).show();
					if (typeof (self.leftNavigationSticky) === "object") {
						self.leftNavigationSticky.calculateBounds();
					}
				}).find('a[data-category]:first').trigger('click');

				self.setupDialogEvents($mod, $items);
				$items.children('div').equalHeights();


				// Verify sticky scrolling.
				if ($mod.find('.category_filters').hasClass('ui-vertical-tabs')) {
					self.setSticky($mod, 'v');
				} else {
					self.setSticky($mod, 'h');
				}
			},
			setSticky: function ($mod, _d) {
				$mod.addClass(_d == 'v' ? 'stickyVertical' : 'stickyHorizontal');

				if (_d == 'v') { // Vertical sticky.

					var left		= $mod.find('.category_filters');
					window.onscroll = function (e) {
						if ($(document).scrollTop() >= $mod.find('.accessory_item_container').offset().top-$('#mds-area-header').height()) {

							var bottom = $mod.find('.accessory_item_container').offset().top-$('#mds-area-header').height() + $mod.find('.accessory_item_container').height() - left.height();
							if ($(document).scrollTop() >= bottom) {
								left.removeClass('sticky');
								left.addClass('stickyBottom');
							} else {
								left.removeClass('stickyBottom');
								left.addClass('sticky');
							}

						} else {
							left.removeClass('sticky');
							left.removeClass('bottom');
						}
					}
				} else { // Horizontal sticky.

					var left		= $mod.find('.category_filters');
					window.onscroll = function (e) {
						if ($(document).scrollTop() >= $mod.find('.accessory_item_container').offset().top-$('#mds-area-header').height()-left.height()) {

							var bottom = $mod.find('.accessory_item_container').offset().top-$('#mds-area-header').height() + $mod.find('.accessory_item_container').height()+left.height();
							if ($(document).scrollTop() >= bottom) {
								left.removeClass('sticky');
								$mod.find('.accessory_item_container').css('margin-top','0');
							} else {
								left.addClass('sticky');
								$mod.find('.accessory_item_container').css('margin-top',left.height()+'px');
							}
						} else {
							left.removeClass('sticky');
							$mod.find('.accessory_item_container').css('margin-top','0');
						}
					}
				}
			},
			setupDialogEvents: function($mod, $items){
				var self = this;
				$mod.find('.modCnt_accessory_item_1').on('click', 'a.accDetail', function(e) {
					var $catListItem = $(this).closest('li');
					var layerType = ($(this).closest(".ace_feed").length > 0) ? 'accessories_ace_1' : 'accessories_1';
					e.preventDefault();
					$dialogContentWrp = $('<div class="dialogContentWrp" />').mrmDialog({
						dialogClass : layerType,
						destroyOnClose: true,
						autoOpen: false,
						resizeEvent: 'updateDialogSize'
					});


					$dialogContentWrp.parent().find('.ui-widget-header').prepend('<a href="#" class="ui-dialog-titlebar-print ui-corner-all" role="button"><span class="ui-icon-printthick">Print</span></a>');
					$dialogContentWrp.parent().find('.ui-dialog-titlebar-print').click(function(_e){
						var data = $dialogContentWrp.html();
						var mywindow = window.open('', '', 'height=280,width=980');

						var head = $('head').html();
						head = head.replace('rel="stylesheet"', 'rel="stylesheet" media="print"');
						head = '<title>'+$dialogContentWrp.find('.tt').text()+'</title>';

						mywindow.document.write('<html><head>');
						mywindow.document.write(head);
						mywindow.document.write('</head><body >');
						mywindow.document.write(data);
						mywindow.document.write('</body></html>');

						mywindow.document.close();
						mywindow.print();

						_e.preventDefault();
					});


					$dialogContentWrp.dialog('widget').on('accCatshowPrevItem accCatshowNextItem', function(e, data) {
						var index = data.position || 0,
							$nextItem, url;
						if (e.type === 'accCatshowNextItem') {
							index++;
						} else {
							index--;
						}
						$nextItem = $items.filter(':visible').eq(index);
						url = $nextItem.find('a.accDetail').attr('href');

						if ( $nextItem.length && url )
						self.setDialogContent(url, $dialogContentWrp, $nextItem);
					});

					self.setDialogContent($(this).attr('href'), $dialogContentWrp, $catListItem);
				});
			},
			setDialogContent: function(url, $dialogContentWrp, $catListItem) {
				$.get(url, function(htmlSnippet) {
					var $allItems = $catListItem.siblings().andSelf().filter(':visible'),
						index = $allItems.index($catListItem),
						listLength = $allItems.length;

					$dialogContentWrp.dialog('open').empty().html(htmlSnippet);
					mrm.util.initDomContent($dialogContentWrp);
					$dialogContentWrp.trigger('updateDialogSize')
						.children('.mod').trigger('updatePagination', {position: index, total: listLength});
				});
			}
		}
	});
}(mrm.$));(function($) {
    mrm.track = mrm.track || {};
    $.extend(mrm.track, {
        cnt_acc_catalog_1: {
            initTrack: function($mod, section){
                var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
                
                // tracking for "sort by: Name | Price
                $mod.find('.catalog_sort > a').on(clickOrTouch, function(){
                    var linkname = $(this).text();
                    var tabText = $('.category_filters .active span').text();

                    tabText = tabText.substr(0, tabText.indexOf("("));
                    $.trim(tabText);

                    mrm.util.trackEvent("click_cta", {section: section, linkname: tabText + ":toggle:" + linkname});                    
                });

                // tracking for "left" navigation area
				$mod.find('ul.category_filters a').on(clickOrTouch, function(){
					var tabText = $(this).find("span").text();

                    tabText = tabText.substr(0, tabText.indexOf("("));
                    $.trim(tabText);

					mrm.util.trackEvent("click_cta", {section: section, linkname: "tab:" + tabText});
				});
            }           
        }
    });
}(mrm.$));/*
  2011 by Christian Zindel, Namics & Maximilian Franzke, MRM Worldwide
  2009 by Michael Sindlinger, Nolte & Lauth
 */
(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		cnt_accessories_1: {
			/**
			 * JS for component cnt_accessories_1
			 *
			 * @param {String} c DOM Context
			 */
			initMod: function($mod) {
				var self = this,
					$layerControlsWrp = $mod.find('div.detailsNavigation'),
					$dialog = $mod.closest(".ui-dialog"),
					listIndexData;
				
				$mod.imagesLoaded(function($images, $proper, $broken)
				{
					$('.mmScroll', $mod).mmScroll({
					animateControls: false,
						scroll: {
							duration: 0
						}
					});
					$mod.children("div.mmScroll, div.accessoryInfo").equalHeights();
					
					if ($dialog.height() > $(window).height()) {
						$dialog.css("top", ($(window).scrollTop() + 10) + "px");
					}

				});
				

				$layerControlsWrp.on('click', 'a.next:not(.disabled), a.prev:not(.disabled)', function(e) {
					var $btn = $(this),
						direction = $btn.hasClass('next') ? 'next' : 'prev';

					if (!self.isStepBlocked(direction, listIndexData)) {
						$(this).trigger($(this).hasClass('next') ? 'accCatshowNextItem' : 'accCatshowPrevItem', listIndexData);
					}
					return false;
				});

				$mod.on('updatePagination', function(e, data) {
					data = data || {};
					var pos = !isNaN(data.position) ? data.position + 1 : 0;
					listIndexData = {
						position: (!isNaN(data.position) ? data.position : 0),
						total: data.total || 0
					};
					$layerControlsWrp.find('a.prev').toggleClass('disabled', self.isStepBlocked('prev', listIndexData));
					$layerControlsWrp.find('a.next').toggleClass('disabled', self.isStepBlocked('next', listIndexData));

					$layerControlsWrp.children('.currentPosition').text(pos || 0);
					$layerControlsWrp.children('.totalPositions').text(data.total || '');
				});

				if ($mod.hasClass("ace_feed")) {
					self.setupTableEvents($mod);
				}

				if ($dialog.height() > $(window).height()) {
					$dialog.css("top", $(window).scrollTop() + "px");
				}

			},

			isStepBlocked: function(dir, indexData) {
				return (dir === 'next' && indexData.position === indexData.total - 1) || (dir === 'prev' && indexData.position === 0);
			},

			setupTableEvents: function($mod) {
				$slideContainer = $mod.find(".mmScrollItems");
				$rowToggles = $mod.find("tr.view_toggle");
				$rowToggles.each(function(count, row){
					$(row).on("click", function() {
						var imageId = $(this).data("imgId");
						$rowToggles.removeClass("active");
						$slideContainer.trigger("slideTo", $("#" + imageId));
						$(this).addClass("active");
					});
				});
			}
		}
	});
}(mrm.$));(function($) {
    mrm.track = mrm.track || {};
    $.extend(mrm.track, {
        cnt_accessories_1: {
            initTrack: function($mod, section){
                var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

                // Locate Store button
                $mod.find('.accessoryInfo .cta_nav_container a span').on(clickOrTouch, function(){
                    var linkname = $(this).text();
                    linkname = linkname.trim();
                    mrm.util.trackEvent("click_cta", {section: "modal", linkname: "button:" + linkname});                    
                });                 
                
                // tracking for "previous" navigation*/
                $mod.find('.detailsNavigation .prev span').on(clickOrTouch, function(){
                    var modalText = $('.accessoryInfo h3').text();

                    mrm.util.trackEvent("click_cta", {section: "modal", linkname: "arrow:prev:" + modalText});                                    
                });
                
                // tracking for "next" navigation
                $mod.find('.detailsNavigation .next span').on(clickOrTouch, function(){
                    var modalText = $('.accessoryInfo h3').text();

                    mrm.util.trackEvent("click_cta", {section: "modal", linkname: "arrow:next:" + modalText})                            
                });        
            }           
        }
    });
}(mrm.$));
;(function($) {
	mrm.mod.Cnt_accessory_item_1 = mrm.mod.AbstractMod.extend({
		
		events: {
		},

		prepare: function() {
			var self = this;

			var $description = this.$ctx.children("div.tx").find("span");
			var descriptionHeight = this.$ctx.children("div.tx").height();
			while ($description.outerHeight() > descriptionHeight) {
				$description.text(function (index, text) {
					return text.replace(/\W*\s(\S)*$/, '...');
				});
			}
		}
	});
})(mrm.$);(function($) {
    mrm.track = mrm.track || {};
    $.extend(mrm.track, {
        cnt_accessory_item_1: {
            initTrack: function($mod, section){
                var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
               
                // tracking for accessory page "a" link
                $mod.find('a.accDetail').on(clickOrTouch, function(){
					var linkname = $(this).attr('href');

                    var tabText = $('.category_filters .active span').text();
                    tabText = tabText.substr(0, tabText.indexOf("("));
                    tabText = $.trim(tabText);
                    
                    var parent = $(this).parent();
                    var caption = parent.find("figcaption span").text();

                    mrm.util.trackEvent("click_cta", {section: section, linkname: tabText + ":block:" + caption});                                 
                });
            }           
        }
    });
}(mrm.$));

;(function($) {
    mrm.mod.Cnt_background_1 = mrm.mod.AbstractMod.extend({
        events: {
        },
        maxWidth: 1920,
        prepare: function() {
            var self = this,
             $mod = self.$ctx,
             bgType = $mod.data("bg-type"),
             widthType = $mod.data("width-type"),
             xOffset = $mod.data("x-offset"),
             yOffset = $mod.data("y-offset"),
             zIndex = $mod.data("z-index"),
             width = $mod.data("width"),
             imgSrc = $mod.data("img-src"),
             colorType = $mod.data("color-type"),
             bgColor1 = "#" + $mod.attr("data-bg-color1"),
             bgColor2 = "#" + $mod.attr("data-bg-color2"),
             gradientDirection = $mod.data("gradient-direction"),
             height = $mod.data("height");

            switch (bgType) {
                case "image":
                    $mod.css("background-image","url('" + imgSrc + "')");
                    height = $mod.data("height");
                    break;
                case "color":
                    if (colorType === "solid") {
                        $mod.css("background-color",bgColor1);
                    }
                    else if (colorType === "gradient") {
                        // gradientDirection will be 'topToBottom' or 'leftToRight'
                        var deg = "180deg",
                            gradientType=0;
                        if (gradientDirection === "topToBottom") {
                            deg = "180deg";
                            gradientType = 0;
                        }
                        else if (gradientDirection === "leftToRight") {
                            deg = "90deg";
                            gradientType = 1;
                        }
                        
                        $mod.css('background', 'linear-gradient(' + deg + ', ' + bgColor1 + ', ' + bgColor2 + ')');
                        
                        // IE8/9 filter stuff here
                        if (mrm.util.ie8()) {
                            $mod.css("filter","progid:DXImageTransform.Microsoft.gradient(GradientType=" + gradientType + ",startColorstr='" + bgColor1 + "', endColorstr='" + bgColor2 + "')");
                            $mod.css("-ms-filter","progid:DXImageTransform.Microsoft.gradient(GradientType=" + gradientType + ",startColorstr='" + bgColor1 + "', endColorstr='" + bgColor2 + "')");
                        }
                        if ($.browser.msie  && parseInt($.browser.version, 10) === 9) {
                            $mod.css("filter","progid:DXImageTransform.Microsoft.gradient(GradientType=" + gradientType + ",startColorstr='" + bgColor1 + "', endColorstr='" + bgColor2 + "')");
                        }
                    }
                    break;
                case "custom":
                    // don't need to do anything?
                    break;
            }

            switch(widthType) {
                case "fixed":
                    $mod.width(width);
                    var newMarginLeft = (0-(width - 980) / 2) + xOffset;
                    $mod.css("margin-left", newMarginLeft + "px");
                    break;
                case "liquid":
                    $mod.width(width);
                    var newMarginLeft = 0-(width - 980) / 2;
                    $mod.css("margin-left", newMarginLeft + "px");
                    
                    // set current height, max-width and overflow on the scroller
                    $mod.css({height: $mod.height(), maxWidth: self.maxWidth, overflow: 'hidden'});
                    $mod.css({'overflow': 'visible', 'padding-left': 0, 'padding-right': 0});

                    // event listener for window resize
                    $(window).resize($.proxy(function() {
                        this.resize($mod);
                    }, this));

                    // initial call
                    self.resize($mod);
                    break;
            }

            $mod.css("margin-top",yOffset)
            $mod.css("z-index",zIndex);
            $mod.css("height",height);
        },
        resize: function($mod) {
            var self = this;

            var pageWidth = $(window).width(),
                containerWidth = 980;
            
            var nMargin = (containerWidth - pageWidth) * .5;
            nMargin = nMargin > 0 ? 0 : nMargin;

            // size the mod first it's the outter most
            $mod.css({'margin-left': nMargin, 'margin-right': nMargin});

            //center if over maxWidth
            if (pageWidth > self.maxWidth) {
                $mod.css('left', (pageWidth - self.maxWidth) * .5);
            } else {
                $mod.css('left', 0);
            }
            
        }
    });
})(mrm.$);;(function($) {
	mrm.mod.Cnt_btn_1 = mrm.mod.AbstractMod.extend({
		events: {
		},

		prepare: function() {
			var self = this;

			// popup with cose-button
			self.$ctx.find('a.btn_close').on('click', function() {
				window.close();
			});
		}
	});
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		cnt_btn_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				var parentMod = $mod.parents('.mod'); // for mods that use cnt_btn_1 inside them.
				/*	TODO: make this dynamic for multiple components,
				* 	getting the exact parent mod and creating a case basis for what to track for each,
			 	*	is possible for many to be in same section.
				*/ 
				section = (parentMod.length > 0 && parentMod.find('h2.hl_2 p').length > 0) ? $.trim(parentMod.find('h2.hl_2 p').text()) : section; // cnt_offer_1 mod tracking
				

				// Suppress inline tracking
				//	$mod.find('a').removeAttr('onclick');				

				// tracking for "explore" button on main page				
				$mod.find('a').on(clickOrTouch, function(){					
					var linkname = $.trim($(this).text());
					// if this is a dynamic masthead, grab the vehicle name and append to linkname
					var dyn_mh_veh = $(this).closest(".ui-helper-visible.dynamic").attr("id");
					if (typeof(dyn_mh_veh) !== "undefined") {
						linkname = dyn_mh_veh + ":button:" + linkname;
						} else{
						linkname = "button:" + linkname;
						}
					mrm.util.trackEvent("click_cta", {section: section, linkname: linkname});
				});
			}
		}
    });
}(mrm.$));<!-- ME BYO iframe RAQ deep linking update 2 -->
    jQuery(window).on('load',function() {

        jQuery(".quantum-tools a.shppngLnk.sl-raq").click(function(){
            var raqLink = jQuery('a.shppngLnk.sl-raq').attr('href');
            var raqLinkDec = decodeURIComponent(raqLink);
            var newRaqLink = raqLinkDec.replace("carline", "x-carline");
            newRaqLink = newRaqLink.replace("bodyType","x-bodystyle");
            newRaqLink = newRaqLink.replace("modelyear","x-modelyear");
            newRaqLink = newRaqLink.replace("trim","trimVcCode");
            jQuery('a.shppngLnk.sl-raq').attr('href', newRaqLink);
        });
    });

(function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		cnt_coupon_1: {          
			/**
			 * JS for component cnt_coupon_1
			 * 
			 * @param {String} c DOM Context
			 */
			init: function(c) {
				mrm.util.log('[mrm.cmp.cnt_coupon_1] Context: ' + c);
				
				$('.cnt_coupon_1 li.service-facebook a').on('click', function () { // facebook link clicked
					var gotCouponId = mrm.cmp.cnt_coupon_1.findCouponId( $(this) );
					mrm.util.trackEvent("click_cta", {section : gotCouponId, linkname : "facebook"});
				});

				$('.cnt_coupon_1 li.service-twitter a').on('click', function () { // twitter link clicked
					var gotCouponId = mrm.cmp.cnt_coupon_1.findCouponId( $(this) );
					mrm.util.trackEvent("click_cta", {section : gotCouponId, linkname : "twitter"});
				});

				$('.cnt_coupon_1 li.service-email a').on('click', function () { // email link clicked
					var gotCouponId = mrm.cmp.cnt_coupon_1.findCouponId( $(this) );
					mrm.util.trackEvent("click_cta", {section : gotCouponId, linkname : "email"});
				});
			},	
			
			findCouponId: function ( src ) { // Get value for coupon clicked
				var couponId = ( $(src).closest('.cnt_coupon_1').find('a:first').attr('name') ); // find the nearest anchor name for coupon set by content author

				if ( couponId == '') { // Anchor ID missing a name, then try ID of nearest .modCnt_well_1
					couponId = ( $(src).closest('.modCnt_well_1').attr('id') );

					if ( typeof couponId == 'undefined' ) { // both are not set, then pass message to tracking
						couponId = 'no section';
					}
				}

				return couponId;
			}
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Cnt_dealer_intro_1 = mrm.mod.AbstractMod.extend({

		events: {
			"click a.print": "onPrintClick"
		},

		options: {
			selector: '.modCnt_dealer_intro_1',
			buttonMapping: { // mapping between cms-config and button class-names
				'raq': 'requestQuote',
				'rtd': 'requestTestdrive',
				'ras': 'requestService'
			}
		},

		prepare: function() {
			var self = this;
			var $shoppingLinks = self.$ctx.find('.shoppingLink');

			// show/hide shopping-links
			$.each(self.options.buttonMapping, function(btnClass, configKey) {
				var cfg = self.cfg.shoppingLinks[configKey];

				// handle visibility
				var $li = $shoppingLinks.filter('.' + btnClass).closest('li')
					.toggleClass('ui-helper-hidden',  cfg !== true && cfg.visible !== true );

				if (!$.isPlainObject(cfg)) {
					return true;
				}

				// handle link params
				var additionalQuerystring;
				if (cfg.dealerBAC) {
					additionalQuerystring = 'dealerBAC=' + cfg.dealerBAC;
				} else if (cfg.dealerUPSC) {
					additionalQuerystring = 'dealerID=' + cfg.dealerUPSC + '&dealerCADC=' + (cfg.dealerCADC || '');
				}

				$li.find('a').attr('href', function(i, oldHref) {
					if (oldHref === '#') return oldHref;
					return oldHref + (oldHref.indexOf('?') === -1 ? '?' : '&') + additionalQuerystring;
				});
			});

			// switch to application text if available
			var $txCms = self.$ctx.find('.col:first > .text-cms');
			var $txApp = self.$ctx.find('.col:first > .text-application');
			if ($txApp.length > 0 && $.trim($txApp.html()) === '') {
				$txCms.toggleClass('ui-helper-hidden', false);
				$txApp.toggleClass('ui-helper-hidden', true);
			}

		},

		onPrintClick: function(e) {
			event.preventDefault();
			mrm.util.print();
		}

	});
})(mrm.$);
(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		cnt_dealermap_2: {
			/* GMDS */
			$dealerMapCmp: null,
			_externalDomain: '',
			/* private variables */
			_dataUrl: '/bypass/gmna/dealerlocator/services/getdealers?type=PostalCode&format=JSON&x-country='+ mrm.util.locale.getCountry().toUpperCase() + '&x-language=' + mrm.util.locale.getLang() + '&x-brand=Chevrolet&postalcode=',
			//_dataUrl:'/_tmp/json.php?zipcode=',
			_mainmap: null,
			_infowindow: null,
			_latlng: null,
			_cityState: '',
			_geo: null,
			_bounds: null,
			_markerArray: [],
			_dealerMapDOMObj: null,
			_conf: {
				defaultRadius: 30, // integer / default to 30
				defaultResults: 5, // integer
				availableMapViews: 'maps', // maps | satellite | both
				showDealerWebsiteLink: true, // true/false
				dealerWebsiteLabel: 'Dealer Website', // string
				showDistanceFromOrigin: true, // true/false
				distanceFromOriginLabel: 'Distance', //string
				allDealersUrl: null,
				showFax: true, // true/false
				setInfoWidth: true, //true = set info_container width based on map size  || false = does not set info_container width
				showPhone: true,
				servicesFilter: 'all', //string
				mapWidth: '100%', //string 100px or 100%
				mapHeight: '275px'
			},
			_advancedLink: '',
			_charArr: 'A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z'.split(','),
			_protocol: (location.protocol === "https:") ? 'https://' : 'http://',
			/* -----------------------------------
			 // -- Function: Init
			 // ----------------------------------- */
			init: function() {
				if (!$('html').hasClass('cq-wcm-edit')) {
					this.$dealerMapCmp = $('div.cnt_dealermap_2');
					this._dealerMapDOMObj = this.$dealerMapCmp.find('#gmv_dealermap')[0];
					this._externalDomain = (typeof (MRM_EXTERNAL_DOMAIN) != 'undefined') ? MRM_EXTERNAL_DOMAIN : '';
					// stop if nav_dealermap_2 is not present
					if (!this.$dealerMapCmp.length) {
						return;
					}
					var self = this;
					// set the globar var for link to the full dealer locator page
					self._conf.allDealersUrl = this.$dealerMapCmp.data('allDealerLink');
					// set conf overrides
					$.extend(this._conf, mrm.conf.cmp.cnt_dealermap_2 || {});
					// set the width/height properties
					if ((self._conf.mapWidth !== '') && (self._conf.mapWidth !== '0')) {
						if (!isNaN(self._conf.mapWidth))
							self._conf.mapWidth += 'px';
						this._dealerMapDOMObj.style.width = self._conf.mapWidth;
					}
					if ((self._conf.mapHeight !== '') && (self._conf.mapWidth !== '0')) {
						if (!isNaN(self._conf.mapHeight))
							self._conf.mapHeight += 'px';
						this._dealerMapDOMObj.style.height = self._conf.mapHeight;
					}
					// Set advanced link for NGDOE use or not.
					self._advancedLink = ($('div').hasClass('gmdsWidget')) ? self.$dealerMapCmp.find('.form_elements a:last-child').attr('href').split('/', 3).join('/') : '';
					//Set the 'View All Dealers' button
					self.$dealerMapCmp.find('div.dealer_all_results_container a.btn_sec:first').attr('href', self._conf.allDealersUrl);
					//check for zipcode
					var zipCode = null;
					if (mrm.util.cookie.get("cookie_customer_location") !== null) {
						try {
							var info = $.parseJSON(mrm.util.cookie.get("cookie_customer_location"));
							zipCode = info.zipcode;
						} catch (e) {
						}
					} else if (mrm.util.cookie.get("GMWP_location") !== null) {
						try {
							var info = mrm.util.cookie.get("GMWP_location");
							var arrInfo = info.split(',');
							for (i = 0; i < arrInfo.length; i++) {
								var keyval = arrInfo[i].split('=');
								if (keyval[0] === 'zip') {
									// pull out the first zipcode
									if (keyval[0] !== '') {
										zipCode = keyval[1].substr(0, 5);
									}
									break;
								}
							}
						} catch (e) {
						}
					}
					if (this._conf.leavingNotification) {
						self.initNotification();
					}
					if (zipCode !== null) {
						// prepopulate the zip code if the cookie exists through various means
						$('div.cnt_dealermap_2 div.form_elements input.gmv_zipcode').val(zipCode);
					}
					this.createBinds();
					if(self._conf.geoLocation === true){
						self.initGeoLocation();
					}
				}
			},
			initMap: function() {
				var self = this;
				// load up loading div
				self.$dealerMapCmp.find('div.service_loading').css('visibility', 'visible');
				// load up google maps
				if (window.google == null || window.google.maps == null) {
					$.getScript('//maps.googleapis.com/maps/api/js?client=gme-adamopelag&v=3.23&language=' + mrm.util.locale.getLang() + '&region=' + mrm.util.locale.getCountry(), function(data, textStatus, jqxhr) {
						if (textStatus === 'success') {
							self.initMapContinue();
						}
					});
				} else {
					self.initMapContinue();
				}
			},
			initMapContinue: function() {
				// set map options
				var self = this;
				var _zipcode = self.$dealerMapCmp.find('input.gmv_zipcode').val();
				var mapType = google.maps.MapTypeId.HYBRID;
				var mapControls = true;
				self.$dealerMapCmp.find('div.results_container').slideDown('slow');
				switch (self._conf.availableMapViews) {
					case 'satellite':
						mapType = google.maps.MapTypeId.HYBRID;
						mapControls = false;
						break;
					case 'maps':
						mapType = google.maps.MapTypeId.ROADMAP;
						mapControls = false;
						break;
				}
				// Creating a map
				self._mainmap = new google.maps.Map(
					this._dealerMapDOMObj, {
						zoom: 3,
						streetViewControl: false,
						scaleControl: true,
						mapTypeControl: mapControls,
						mapTypeId: mapType,
						zoomControlOptions: {
							style: google.maps.ZoomControlStyle.SMALL
						}

					});
				self._geo = new google.maps.Geocoder();
				self._infowindow = new google.maps.InfoWindow({
					content: "loading..."
				});
				self._mainmap.setCenter(new google.maps.LatLng(37.055177, -95.668945));
				self._mainmap.setZoom(4);
				// process map functionality
				$('div.gmv_maploading').css('height', '0').show();
				self.executeAJAX();
				// move the info container now that Google Maps has been loaded
				//edited to have results display below the map.
				if (!self.$dealerMapCmp.find('.info_container').length) {
					self.$dealerMapCmp.find('.dealer_all_results_container').prepend('<div class="info_container"><div class="dealer_info"></div><div class="dealer_shopping_links"></div></div>');
				}
				if (self._conf.setInfoWidth)
					self.$dealerMapCmp.find('.info_container').width(self.$dealerMapCmp.find('#gmv_dealermap').width() - 20);
				// self.$dealerMapCmp.find('.info_container')
				//     .append('<div class="dealer_background"></div>');
				//    // .appendTo('.dealer_all_results_container');


				if (typeof (Omniture_s) != 'undefined') {
                    mrm.util.tagging.omniture_tl(this, window.location.pathname, 'o', undefined, {
                        'events': 'event7',
                        'prop16': 'locate a dealer',
                        'prop27': 'global_nav:locate a dealer',
                        'prop32': 'global_nav: locate a dealer: go',
                        'eVar35': _zipcode

                    });
                }
			},
			initGeoLocation: function() {
				// Add the geoLocation button
				var locate = mrm.util.geoLocation,
					$mod = this.$dealerMapCmp,
					error_message = '';
				if (locate && locate.available()) {
					var $input = $mod.find('input');
					var error_message = this._conf.geoLocationError;
					$input.after($('<div id="error_msg">').text(error_message));
					$input.attr('rel', '#error_msg');
					$input.before($('<button class="btn_prim geolocate"><span title="'+this._conf.geoLocationTooltip+'">geo</span></button>').on('click', function(e) {
						e.preventDefault();
						e.stopPropagation();
						locate.getLocationZip(function(results) {
							if (results.status === 'success') {
								$input.val(results.postal_code);
								$mod.find('.gmv_infolink').click();
							} else {
								$input.addClass('gl_error');
							}
						});
					}));
					var cluetipCfg = {
						positionBy: 'auto',
						width: 'auto',
						local:true,
						hideLocal:true,
						cluetipClass: 'location_err',
						showTitle: false,
						splitTitle: '',
						cluezIndex: 9999999,
						onActivate: function(e){
							if(!$input.hasClass('gl_error')){
								return false;
							}
							return true;
						}
					}
					$input.cluetip(cluetipCfg);
				}
			},
			// -----------------------------------
			// -- Function: Execute AJAX call and return JSON
			// -----------------------------------
			executeAJAX: function() {
				var self = this;
				var _returnjson = '',
					_zipcode = self.$dealerMapCmp.find('input.gmv_zipcode').val();
				$.ajax({
					dataType: (self._externalDomain !== '') ? 'jsonp' : 'json',
					async: true,
					url: self._externalDomain + self._dataUrl + _zipcode,
					cache: true,
					success: function(_data, _response) {
						var _trueCount = 0;
						for (var _count = 0; _count < _data.length; _count++) {
							// filter if exists
							if ((self._conf.servicesFilter.toLowerCase() == 'all') || (self._conf.servicesFilter.toLowerCase() == '')) {
								if (_trueCount < self._conf.defaultResults)
									self.addMarker(_data[_count], _trueCount);
								_trueCount++;
							}
						}

						self.$dealerMapCmp.find('p.dealer_results').html((_data.length) + ' dealers found near ' + _zipcode);
						$('div.gmv_maploading').animate({height: self._conf.mapHeight});
						self.$dealerMapCmp.find('div.service_loading').css('visibility', 'hidden');
					},
					error: function() {
						self.$dealerMapCmp.prepend('<div class="error">'+self._conf.serviceUnavailableText+'</div>');
						self.$dealerMapCmp.find('div.error').fadeTo(0, 0).delay(1000).fadeTo(1000, 100).delay(5000).fadeTo(1000, 0);
					}
				});
				return _returnjson;
			},
			//* -----------------------------------
			// -- Function: Clear Map Markers
			// ----------------------------------- */
			clearMap: function() {
				var _count = 0;
				if (this._markerArray.length) {
					for (_count = 0; _count < this._markerArray.length; _count++) {
						this._markerArray[_count].setMap(null);
					}
					this._markerArray = [];
				}
			},
			/* -----------------------------------
			 // -- Function: Add Marker
			 // ----------------------------------- */
			addMarker: function(_dealer, _trueCount) {
				var self = this;
				var dealerTitle = (self._conf.showDealerWebsiteLink && (_dealer.url != '')) ? '<a href="' + _dealer.url + '" target="_blank">' + _dealer.brandSiteName + '</a>' : _dealer.brandSiteName;
				var dealerUrl = (self._conf.showDealerWebsiteLink && (_dealer.url != '')) ? '<br /><a href="' + _dealer.url + '" target="_blank">' + self._conf.dealerWebsiteLabel + '</a>' : '';
				if (this._conf.leavingNotification){
					dealerTitle = (self._conf.showDealerWebsiteLink && (_dealer.url != '')) ? '<a class="ddl-notification" href="javascript:void(0);" data-url="' + _dealer.url + '" target="_blank" onclick="return false;">' + _dealer.brandSiteName + '</a>' : _dealer.brandSiteName;
					dealerUrl = (self._conf.showDealerWebsiteLink && (_dealer.url != '')) ? '<br /><a class="ddl-notification" href="javascript:void(0);" data-url="' + _dealer.url + '" target="_blank" onclick="return false;">' + self._conf.dealerWebsiteLabel + '</a>' : '';
				}
				var dealerPhone = (self._conf.showPhone && (_dealer.contact.phone != '')) ? _dealer.contact.phone : '';
				var dealerFax = (self._conf.showFax && (_dealer.contact.fax != '')) ? 'FAX: ' + _dealer.contact.fax + '<br />' : '';
				var dealerDistance = (self._conf.showDistanceFromOrigin && (!isNaN(parseFloat(_dealer.distance.distance)))) ? '<br />Distance: ' + parseFloat(_dealer.distance.distance).toFixed(1) + ' ' + _dealer.distance.unitOfLength : '';
				var shoppingLinks = '';

				// driving directions - add once functionality is complete on Dealer Locator
				// shoppingLinks += '<a href="#" class="btn_prim">Driving Directions</a>';
				if (self._conf.shoppingLinks) {
					for (iShoppingLink = 0; iShoppingLink < self._conf.shoppingLinks.length; iShoppingLink++) {						
						// add dealerId
						var dealerId = (self._conf.shoppingLinks[iShoppingLink].url.indexOf('?') == -1) ? '?x-caller=lad&bacId=' + _dealer.dealerId : '&x-caller=lad&bacId=' + _dealer.dealerId;
						if ( _dealer.enableCID === '' && self._conf.shoppingLinks[iShoppingLink].id !== 'searchInventory' ) {
							// exclude empty CID and non 'Search Inventory' links
						} else {
							shoppingLinks += '<a href="' + self._advancedLink + self._conf.shoppingLinks[iShoppingLink].url + dealerId + '">' + self._conf.shoppingLinks[iShoppingLink].label + '</a>';
						}
					}
					if (shoppingLinks !== '')
						shoppingLinks = '<div class="shoppingLinks">' + shoppingLinks + '</div>';
				}
				var latLng = new google.maps.LatLng(parseFloat(_dealer.address.latitude), parseFloat(_dealer.address.longitud));
				var _marker = new google.maps.Marker({
					position: latLng,
					map: self._mainmap,
					title: _dealer.dealerName,
					html: '<div>' + '<p>' + _dealer.brandSiteName + '<br />' + _dealer.address.street + '<br />' + _dealer.address.city + ', ' + _dealer.address.province + ' ' + _dealer.address.postCode + '</p>' + '</div>',
					icon: self._protocol + 'www.google.com/mapfiles/marker' + self._charArr[_trueCount] + '.png'
				});

				var dealerObject = {'dealerTitle':dealerTitle,'dealerUrl':dealerUrl,'dealerPhone':dealerPhone,'dealerFax':dealerFax,'dealerDistance':dealerDistance};
				$.extend( true, dealerObject, _dealer);
				var dealerInfo = self.getDealerInfoHTML(_marker, dealerObject);

				google.maps.event.addListener(_marker, "click", function() {
					// fill dealer info
					self.showDealerInfo(dealerInfo, shoppingLinks);
					// analytics call
					if (typeof (Omniture_s) != 'undefined') {
						mrm.util.tagging.omniture_tl(true, window.location.pathname, 'o', undefined, {'prop16': 'Nav Dealer Locator Component', 'prop32': 'Dealer Map Marker - ' + _dealer.brandSiteName})
					}
				});
				self._markerArray.push(_marker);
				if (_trueCount === 0) {
					self._mainmap.setZoom(10);
					self._mainmap.panTo(latLng);
					self.showDealerInfo(dealerInfo, shoppingLinks);
				}
			},
			getDealerInfoHTML:function(markerObject, dealerObject)
			{
				var html = '';
				html += '<div style="background:url(' + markerObject.icon + ') no-repeat;">';
				html += 	'<h3>' + dealerObject.dealerTitle + '</h3>'
				html += 	'<p>';
				html += 		dealerObject.address.street;
				html += 		'<br />';
				html += 		dealerObject.address.city + ', ' + dealerObject.address.province + ' ' + dealerObject.address.postCode;
				html += 		'<br />';
				html += 		dealerObject.dealerPhone + dealerObject.dealerDistance /*+ dealerFax +  +*/ + dealerObject.dealerUrl;
				html += 	'</p>';
				html += '</div>';

				return html;
			},
			showDealerInfo: function(_dealerInfo, _shoppingLinks) {
				var self = this;
				self.$dealerMapCmp.find('div.info_container').slideUp('slow', function() {
					self.$dealerMapCmp.find('div.dealer_info').html(_dealerInfo);
					self.$dealerMapCmp.find('div.dealer_shopping_links').html(_shoppingLinks);
					$(this).slideDown('slow');
				});
			},
			checkZipCode: function(_event) {
				if (_event)
					_event.preventDefault();
				var self = this;
				var _check = self.$dealerMapCmp.find('input.gmv_zipcode').val();
				var _valid = "0123456789";
				var _count = 0;
				var _proceed = 1;
				var _temp = '';
				if (mrm.util.locale.getCountry().toUpperCase() === 'CA') {
					_check = _check.replace(/\s+/g, '');
					self.$dealerMapCmp.find('input.gmv_zipcode').val(_check);
					var postalCodeRegex = /\w\d\w\d\w\d/;
					var postalCodeRegexWithSpace = /\w\d\w[ ]\d\w\d/;
					if (!(postalCodeRegex.test(_check) || postalCodeRegexWithSpace.test(_check))) {
						alert(self._conf.searchboxInvalidText);
						proceed = 0;
						self.$dealerMapCmp.find('input.gmv_zipcode').addClass('err');
					}
				} else {
					if (_check.length != 5) {
						alert(self._conf.searchboxInvalidText);
						_proceed = 0;
						self.$dealerMapCmp.find('input.gmv_zipcode').addClass('err');
					} else {
						for (_count = 0; _count < 5; _count++) {
							_temp = '' + _check.substring(_count, (_count + 1));
							if (_valid.indexOf(_temp) == "-1") {
								_proceed = 0;
								alert("Invalid characters in your zip code. Please try again.");
								self.$dealerMapCmp.find('input.gmv_zipcode').addClass('err');
								return false;
							}
						}
					}
				}
				if (_proceed) {

					self.$dealerMapCmp.find('input.gmv_zipcode').removeClass('err gl_error');
					self.initMap();
					var info = (mrm.util.cookie.get("cookie_customer_location") !== null) ? $.parseJSON(mrm.util.cookie.get("cookie_customer_location")) : {
						zipcode: _check
					};
					info.zipcode = _check;
					mrm.util.cookie.set("cookie_customer_location", JSON.stringify(info), {path: '/'});
				}
			},
			/* -----------------------------------
			 // -- Function: Create Binds
			 // ----------------------------------- */
			createBinds: function() {
				var self = this;
				// Arrow - for map update
				self.$dealerMapCmp.find('div.form_elements a.arrow').on('click', function(e) {
					self.checkZipCode(e)
				});
				self.$dealerMapCmp.find('input.gmv_zipcode').keypress(function(e) {
					if (e.which == 13) {
						e.preventDefault();
						self.checkZipCode(e);
					}
				});
			},
			initNotification: function() {
				$("#ddl-body-title").text(this._conf.navBodyTitle);
				$("#ddl-independent").text(this._conf.navIndependent);
				$("#ddl-convenience").text(this._conf.navConvenience);
				$("#ddl-continue").text(this._conf.navContinueButton);
				$("#ddl-cancel").text(this._conf.navCancelButton);

				var dialog = $("#ddl-leaving-notification").dialog({
					dialogClass: "no-close",
					autoOpen: false,
					width: 575,
					modal: true
				});

				var dealer_url;

				//$(".content").on('click', ".page_dealer_list", function() {
				//	this.initNotification();
				//});

				$(".content").on('click', ".ddl-notification", function () {
					console.log("External Notification Has been clicked.");
					$("#ddl-leaving-notification").zIndex(100000);
					dialog.dialog("open");
					dealer_url = event.target.attributes.getNamedItem("data-url").nodeValue;
				});

				$("#ddl-leaving-notification").on('click', '#ddl-continue', function () {
					dialog.dialog("close");
					window.open(dealer_url, "newwin");
				});

				$("#ddl-leaving-notification").on('click','#ddl-cancel', function () {
					dialog.dialog("close");
				});
			}
		}
	});
}(mrm.$));/*
	C 2009 by Maximilian Franzke, MRM Worldwide
	updated: 2012 by Stephen Sawchuk, MRM Worldwide
*/
;(function($) {
	mrm.mod.Cnt_expander_1 = mrm.mod.AbstractMod.extend({
		prepare: function() {
			var self = this, 
				view = self.$ctx.hasClass('accordion') ? 'accordion' : 'expander';

			mrm.util.log('[mrm.cmp.cnt_expander_1] Context: ' + self.$ctx);
			
			if ( view === 'accordion' ) {
				self.$ctx.accordion({
					collapsible	: true,
					autoHeight	: false,
					header		: 'dt'
				});
				
			
				// Video should pause before the question collapses.
				self.$ctx.find("dt").on("click",function(e) {
					// jwplayer
					for (var i = jwplayer.getPlayers().length - 1; i >= 0; i--) {
						try {
							if (jwplayer.getPlayers()[i].getState() === "PLAYING") {
								jwplayer.getPlayers()[i].pause();
							}
						} catch(e) {}
					}

					// youtube
					if(typeof(aryPlayers) != "undefined"){
						for (var i = 0; i < aryPlayers.length; i++) {
							try {
								// pauseVideo() will continue loading video unlike stopVideo()
								aryPlayers[i].pauseVideo();
							}
							catch(e) {}
						}
					}
				});

				$(".nav_verticaltabs_1_nav_layer").find("li a").on("click",function() {
					// jwplayer
					for (var i = jwplayer.getPlayers().length - 1; i >= 0; i--) {
						try {
							if (jwplayer.getPlayers()[i].getState() === "PLAYING") {
								jwplayer.getPlayers()[i].pause();
							}
						} catch(e) {}
					}

					// youtube
					if(typeof(aryPlayers) != "undefined"){
						for (var i = 0; i < aryPlayers.length; i++) {
							try {
								// pauseVideo() will continue loading video unlike stopVideo()
								aryPlayers[i].pauseVideo();
							}
							catch(e) {}
						}
					}
				});

			}
			else if ( view === 'expander' ) {
				var
					content = { 'elem' : self.$ctx },
					expandContract = function ( ) {
						content.elem = $(this).next('dd');
						content.active = $(this).children('.ui-icon').hasClass('ui-icon-triangle-1-s');
						$(this).children('.ui-icon')
							.removeClass('ui-icon-triangle-1-' + ( content.active ? 's' : 'e' ))
							.addClass('ui-icon-triangle-1-' + ( content.active ? 'e' : 's' ))
						;
						content.elem.css('display', ( content.active ? 'none' : 'block' ));
					}
				;

				self.$ctx.delegate( 'dt.ln', 'click', expandContract );
			}
		},
		after: function() {
			var self = this;
			self.$ctx.find('dt a').on('click', function(e){
				e.stopPropagation();
			});				
		}
	});
})(mrm.$);;(function($) {
	mrm.mod.Cnt_faq_1 = mrm.mod.AbstractMod.extend({

		events: {
		},

		prepare: function() {
			var self = this;

			this.$ctx.accordion({
				collapsible: true,
				autoHeight: false,
				header: 'dt'
			});
		}
	});
})(mrm.$);(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		cnt_handraiser_1: {
			/**
			 * JS for component cnt_handraiser_1
			 *
			 * @param {jQuery} $mod module context
			 */
			modCfg: null, //add property modCfg, set to null(will be used as a placeholder for runWidth property)

			initMod: function( $mod ) {
				var self = this,
				confs = $.extend({}, mrm.conf.cmp.cnt_handraiser_opt_1);	// regex and errors stored in config file
				
				self.modCfg = mrm.conf.cmp.cnt_handraiser_1 || {}; //set modCfg = global config object

				if ($mod.closest('.modLyr_cnt_1').length) {	// search up the dom to see if mod is inside a modal wrapper
					// must wait until modal is created before configuring form because won't know width until the modal is opened.
					self.prepModal($mod, self, confs);
				} else {	// not in modal window
					self.configureForm($mod, self, confs);
				}
			},

			configureForm: function( $mod, self, confs ) {
				if ($mod.hasClass('formset')) { return; } // prevent run through more than once

				self.errorSettings($mod);					// Error Configuration and Setup
				self.setTabIndex();							// Set tabindex, add frmField class
				self.setColumnLayout($mod);					// Column layout
				// self.iframeSettings($mod);					// iframe actions
				self.lblSetPosition($mod, self);			// Set Label Position
				self.lblRequiredFields($mod);				// Set required character
				self.setLblFieldWidths($mod, self, confs);	// Set label and form field widths
				self.setPositionCTA($mod);					// Set CTA positioning
				self.setOmnitureEvents($mod, self);			// Omniture field event tracking

				var $form = $('form', $mod);
				$form.submit( function(event) {
					event.preventDefault();
					self.callOmnitureTracking($mod, $mod.find('.btn_prim'), 'caseFormSubmit');
					self.submitForm($mod, self, confs);
				});
				self.resetErrorMsg();

				$mod.addClass('formset');
			},

			prepModal: function( $mod, self, confs ) {
				// Add livequery event to modal windows if the handrasier form has a modal wrapper.
				// Note that the height of the modal window is configured on the page properties on
				// the form page in the author.  For Chevy US, 940 will make the modal full width
				$('.ui-widget-overlay').livequery( function() {	// when the modal is clicked and overlay appears
					var modalDiv = $mod.closest('.ui-dialog');

					modalDiv.addClass('handraiser-modal');

					if ( modalDiv.find('.modCnt_handraiser_1').length > 0 ) { // if modal contains a handraiser mod
						var modWidth = ( modalDiv.width() - parseInt( modalDiv.css('padding-left') )); // subtract padding of modal window.
						$mod.css('width', modWidth);
						modalDiv.find('.ui-dialog-content').css('height','auto'); // don't want to limit the height by author
					}
					// now we can configure the form after setting width on handraiser mod
					self.configureForm($mod, self, confs);
					self.repositionForm($mod, self);
				});
			},

			repositionForm: function($mod,self) {
				// check if popup form's height is greater than browser height and if we have a fixed position
				var $modal = $('.ui-dialog'), $window = $(window);
				if ($modal.height() > $window.height() || parseInt($modal.css("top").replace("px","")) < 0 ) {
					// position popup form so top of form is at current scroll position
					$modal.css({position: "absolute", top: $window.scrollTop() + "px"});
					// allow for scrolling of large modals when fixed
					if($modal.css('position') == "fixed") $modal.on('dialogclose', self.closeFormListener);
				}
			},

			closeFormListener: function(e){
				var $modal = $('.ui-dialog'), self = mrm.cmp.cnt_handraiser_1;
				//restore fixed position on close in case page is resized, also remove listener
				$modal.css("position", "fixed");
				$modal.off('dialogclose', self.closeFormListener);
			},

			errorSettings: function( $mod ) {
				// More detailed error messages may be set in cnt_handraiser_opt_1.js properties but will be used only if
				// div#error-tx is empty or in debug mode.  The authored error message found in this div will be used.
				if ($('#error-tx').html().length !== 0) {
					$('#error-tx').addClass('preset-err');	// add '.preset-err' class to prevent overwrite of authored error message
				}

				// add a '?debug' at end of url string to see more descriptive erros in debug mode
				var queryString = window.location.search.substr(1);

				if (window.self !== window.top) {
					queryString = parent.window.location.search.substr(1);
				}

				if (queryString === 'debug') {
					if ($('#error-tx').hasClass('preset-err')) {
						$('#error-tx').removeClass('preset-err');
					}
					$mod.addClass('valOnBlur'); // this class tells enables OnBlur validation of form
				}

			},

			setTabIndex: function() {
				// add tabindex to form elements before move into 2 columns
				$('#cnt_handraiser_1 li :input').each( function (i) {
					if ( $(this).attr('type') !== 'hidden' ) { // skip the hidden inputs
						$(this).attr('tabindex', i + 1).addClass('frmField');
						// $(this).find('select').addClass('frmField'); // let's not forget the select fields
					}
				});
				$('#cnt_handraiser_1').find('.ctaDiv :input').attr('tabindex', 20);
			},

			/*
			** COLUMN LAYOUT ** add to div.modCnt_handraiser_1 **
			*	[default]     - single column
			*	.twoCol 	  - js creates ol.col2 and moves every other field into it
			*				  - when in this mode, component is hidden by default until it loads to prevent shifting
			*	.twoCol.auth  - by default css will hide .twoCol until load, add .auth class to never hide for auth mode
			*/
			setColumnLayout: function( $mod ) {
				// By default the form is set up to render one column. check for .twoCol
				// class and splits form fields into 2 columns if class is present
				if ($mod.hasClass('twoCol')) {
					$mod.find('ol').addClass('col1'); // add .col1 class to existing column
					$('<ol class="col2"></ol>').insertAfter('ol.col1'); // create second column
					$mod.find('ol.col1 > li').each( function( index ){
						if (index % 2 !== 0) { // odd index number put into second column
							$(this).appendTo('ol.col2');
						}
					});
					$mod.fadeIn('slow');
				}
				$('<div class="clearfix"></div>').appendTo('#cnt_handraiser_1'); // prevents overflow issues after form
			},

			/*
			* Set width on mod if in iframe
			*/
			iframeSettings: function( $mod ) {
				if (window.self === window.top) {
					// NOT in an iframe
				} else { // in an iframe
					var $iframe = $('iframe#handraiserform_iframe', parent.document),
						setWidth = $iframe.width() - 5;
						formHeight = $mod.find('#cnt_handraiser_1').height();

					$mod.css('width', setWidth);
					if ( $iframe.attr('height') === undefined ) {
						$iframe.css('height', formHeight);
					}

				}
			},

			/*
			** LABEL POSITIONING ** add to div.modCnt_handraiser_1 **
			*	.lblPos1	- puts label above field
			*	.lblPos2	- puts label inline with form input fields
			*	.lblPos3	- puts label within input fields
			*/
			lblSetPosition: function( $mod, self ) {
				if ($mod.hasClass('lblPos3')) { // moves label into INPUT or SELECT, then hides label
					$('label[for]').each( function(index, label) {
						label = $(label);
						var associated = $('#' + label.attr('for'));
						if (associated.length) {
							self.fnInlineLabel(label, associated);
						}
					});
				}

			},

			/*
			** REQUIRED FIELD LABEL PROCESSING **
			*	For required fields, add '.required' class to input or select element, then js
			*	will create & append div.reqAsterisk to label.
			*/
			lblRequiredFields: function( $mod ) {
				var $requiredFlds = $('#cnt_handraiser_1 .required'),
					propReqChar = $mod.find('#propReqChar').html();

				if (propReqChar === '') { propReqChar = '*'; } // use asterisk if not set by author

				if ($mod.parents().hasClass('lblAlign2')) { // if label is set to align right
					$.each( $requiredFlds, function(i) {
						var id = $(this).attr('id');
						var $label = $('label[for='+id+']');
						$('<div class="reqAsterisk">'+propReqChar+'</div>').appendTo($label);
					});
				} else {
					$.each( $requiredFlds, function(i) {
						var id = $(this).attr('id');
						var $label = $('label[for='+id+']');
						$('<div class="reqAsterisk">'+propReqChar+'</div>').prependTo($label);
					});
				}

			},

			/*
			** SET LABEL AND FIELD WIDTHS **
			*	The js will dynamicallly set label width based on widest label
			*/
			setLblFieldWidths: function( $mod, self, confs ) {
				// padFactor is css left padding value + 1px border then multiplied by 2 for each side
				var padFactor = ( parseInt( $('#cnt_handraiser_1 input').css('padding-left') ) + 2 ) * 2,
					widestLbl = padFactor * 1.5; // will be used in calculating width of input boxes.

				if ($mod.hasClass('lblPos2')) { // when label is on same line as input field
					$('#cnt_handraiser_1 label').each( function(i) {
						if (this.offsetWidth > widestLbl) // look for widest label
						widestLbl = this.offsetWidth;
					});
					// set all labels to widest width
					$('#cnt_handraiser_1 label').css('width', widestLbl);
					widestLbl = widestLbl + padFactor + 16; // calc needed width of input fields
				}

				var liWidth = $('#cnt_handraiser_1 li').width(), // get width of <li> container
					frmFldWidth,
					$obj;

				if ($mod.hasClass('lblPos1')) { // when label is above input field
					frmFldWidth = liWidth;
				}

				/* interate through each form field */
				$('#cnt_handraiser_1 .frmField').each( function (i) {
					$obj = $(this);

					/* resize input elements unless inline override exists */
					if ($obj.get(0).tagName === 'SELECT') {
						frmFldWidth = frmFldWidth + padFactor;	// take padding of inputs into account (padFactor)
					} else {
						frmFldWidth = liWidth - widestLbl;	// take padding of inputs into account (padFactor);
					}

					if ($obj.attr('style') === undefined || $obj.attr('style').indexOf('width') !== 0) {  // check for inline style override
						if(self.modCfg.runWidth){ //check if runWidth property is true, if true then assign width to input
							$obj.css('width', frmFldWidth);
						}
					}

					/*
					* ADD FIELD EVENTS - clear error and or validate
					*/
					if ($mod.hasClass('valOnBlur')) {	/* clear error and validate */
						$obj.on( 'blur', function() {	// validate when user leaves field
							self._unHighlightFields($(this));
							self.validateField( $mod, confs, $(this));
						});
					} else { /* only clear the error */
						var onType;
						( $obj.get(0).tagName === 'SELECT' ) ? onType = 'change' : onType = 'keypress';

						$obj.on( onType, function() {
							self._unHighlightFields($(this));
						});
					}


				});

			},

			/*
			* Arrange CTA button and text positions
			** cta button positioning ** add to div.modCnt_handraiser_1 **
			*	[default] - Form - button left
			*	.ctaPos2  - Form - button inline left
			*	.ctaPos3  - Form - button right
			*	.ctaPos4  - Form - button inline right
			*/
			setPositionCTA: function( $mod ) {
				/* CTA POSITIONING: need to apply width to div.legal.tx to get it to float properly */
				if ($mod.hasClass('ctaPos2') || $mod.hasClass('ctaPos4')) {
				// don't need to do this if .lblPos1
					var legalWidth = $mod.width() - $mod.find('.ctaDiv').width() -20;
					$mod.find('div.legal').css('width', legalWidth);
				} else {
					$('.ctaDiv').insertAfter('#error-msg'); // ctaPos1 and ctaPos3 rearrange error msg order
				}
			},

			/*
			**** FIELD VALIDATION ***
			*	regex for field validations are stored in mrm.conf.cmp.cnt_handraiser_opt_1
			*/
			validateField: function( $mod, confs, $obj ) {
				var self = this;
					fldVal = $.trim( $obj.val() ),
					objId = $obj.attr('id'),
					errorMessage = '';

				if ($obj.hasClass('required')) {
					if (fldVal === '') { // check for empty field
						errorMessage = confs.error_ft0;
					}
				}

				/*
				*** AUTHORED VALIDATION OPTIONS ** field type definitions to be added at input or select-level **
				*	.required - dynamically appends asterisk div, and pulls the charachter from div#propReqChar set by author
				*	.ft1 - alphanumeric (both numbers and or letters) - .ft classes do not apply to select fields
				*	.ft2 - numeric (numbers only)
				*	.ft3 - alphabetic (letters only)
				*/
				if (fldVal === '') {
					// In cases where the zip and or city is not required (null allowed)
					// we need to clear errors after doing a checking city to zip.
					if ( objId === 'salesLeadaddresscity' || objId === 'salesLeadaddresszipCode' && !$obj.hasClass('required') ) {
						if ( $('#salesLeadaddresszipCode').hasClass('checkcity') && ( zipCodeFldVal === '' || fldVal === '' ) ) {
							self.clearErrorsCityZip(self);
						}
					}
				} else {
					/* field type validations */
					if ($obj.hasClass('ft1')) { // check for alphanumeric
						var regx = new RegExp(confs.test_ft1);
						if (!regx.test(fldVal)) {
							errorMessage = confs.error_ft1;
						}
					}
					if ($obj.hasClass('ft2')) { // check for numeric (numbers only)
						var regx = new RegExp(confs.test_ft2);
						if (!regx.test(fldVal)) {
							errorMessage = confs.error_ft2;
						}
					}
					if ($obj.hasClass('ft3')) { // check for alpha
						var regx = new RegExp(confs.test_ft3);
						if (!regx.test(fldVal)) {
							errorMessage = confs.error_ft3;
						}
					}

					/* ft4 is to make it a dropdown field */

					if ($obj.hasClass('ft5')) { // email validation
						var regx = new RegExp(confs.test_email);
						if (!regx.test(fldVal)) {
							errorMessage = confs.error_email;
						}
					}

					/*
					***	MASK VALIDATION *** Author-entered mask that the field will be required to conform to **
					*	If the attribute mask="#####" is found on the input field, the user will be required to
					*	have 5 numbers in order to validate. If the mask is "#A#A#A" then the user will be
					*	required to enter number, then letter and so on to validate.
					*/
					if ($obj.attr('mask') !== undefined) {
						var fldMsk = $obj.attr('mask'),
							fldVal = $obj.val();

						var regx = new RegExp(confs.dash_dot);
							fldVal = fldVal.replace(regx, '') // remove all but letters and numbers

						if (fldMsk.length !== fldVal.length) { // match lengths
							errorMessage = confs.error_msk1;
						} else {
							// compare entered value to mask
							for ( var i = 0; i < fldMsk.length; i++ ) {
								if (fldMsk[i] === '#') {
									if (isNaN(fldVal[i])) {
										errorMessage = confs.error_msk2;
									}
								} else { // it must be alpha
									var regx = new RegExp(confs.test_ft4);
									if (!regx.test(fldVal[i])) {
										errorMessage = confs.error_msk2;
									}

								}
							}
						}
					}

					/* field-specific validation */

					// email confirmation validation
					if (objId === 'emailconfirm') { // must match email field
						if (fldVal !== $.trim( $('#salesLeadcommunicationDetailsemailAddress').val() )) {
							errorMessage = confs.error_email2;
						}
					}

					// City and zipcode validation
					if (objId === 'salesLeadaddresscity' || objId === 'salesLeadaddresszipCode') { // if value entered is city or zip
						var zipCodeFldVal = $.trim( $('#salesLeadaddresszipCode').val() ),
							zipCityFldVal = $.trim( $('#salesLeadaddresscity').val() ).toUpperCase();

						// return if .checkcity class is not on zipcode field, zip code entered value is null, or entered
						// field value is null.  It is assumed that the city and zip are not required at this point.
						if ( !$('#salesLeadaddresszipCode').hasClass('checkcity') || zipCodeFldVal === '' || fldVal === '' ) { return; }

						self.clearErrorsCityZip(self);

						// validates zip code
						var regx = new RegExp(confs.test_zip);
						if (!regx.test(zipCodeFldVal)) { // make sure zip code is in a valid format
							errorMessage = confs.error_zip;
							self._highlightFields($('#salesLeadaddresszipCode'), errorMessage);
						}

						// zip code is valid if there are no errors, now check city to zip code
						if (errorMessage === '') {
							if (zipCityFldVal !== '' && zipCodeFldVal !== '') { // we need both if we are to compare them

								var valCities = self.getCitiesFromJSON(zipCodeFldVal);
								if (valCities === 'jsonCallFailure') { return; }; // if json zipcode validation is down, don't want to hang up form submissions
								self.clearErrorsCityZip(self);

								var cityMatch = 0; // may be more than one city per zip code
								for (var i=0; i < valCities.length; i++) {
									if (valCities[i] === zipCityFldVal) { // we have a match!
										cityMatch = cityMatch + 1;
									}
								}

								if (cityMatch) { // have at least one match
									errorMessage = '';
								} else { // there is no match!
									if ( $.trim( $('#propPostalCityValErrMsg').html() ).length !== 0) {
										errorMessage = $('#propPostalCityValErrMsg').text();
									} else {
										errorMessage = confs.error_zipCity;
									}
									self._highlightFields( $('#salesLeadaddresszipCode'), '');
									self._highlightFields( $('#salesLeadaddresscity'), '');
								}

							}
						}


					}

					// GMDSPLM-15710 - if any address field is entered (zipcode, city, state, address1, address2) then enable x-country
					// if disabled.  if all of these fileds are empty, then disable it to prevent it from being submitted with the form.
					// <input type="hidden" value="US" name="salesLead.address.countryCode">

					var $form = $('form', $mod);

					if ( $.trim($('#salesLeadaddressstreet').val()).length  === 0 &&
						 $.trim($('#salesLeadaddressline2').val()).length   === 0 &&
						 $.trim($('#salesLeadaddresscity').val()).length    === 0 &&
						 $.trim($('#salesLeadaddressstate').val()).length   === 0 &&
						 $.trim($('#salesLeadaddresszipCode').val()).length === 0 )
					{
						// all address fields are empty, disable country code
						$('input:hidden[name="salesLead.address.countryCode"]').attr('disabled', true);
					} else {
						// at least one address field is not empty, so remove disabled attribute
						$('input:hidden[name="salesLead.address.countryCode"]').removeAttr('disabled');
					}

				}

				// Renders error message if there is one.
				// Form will not submit if errors are present
				if (errorMessage !== '') {
					self._highlightFields( $obj, errorMessage );
					self.callOmnitureTracking($mod, $obj, 'caseError');
				} else {
					self.resetErrorMsg();
				}

			},

			getCitiesFromJSON: function( zipCodeFldVal ) {
				var jsonFile = '/zipdata/en-us/'+zipCodeFldVal+'.json'
					jsonCities = [];

				$.ajax({
					url: jsonFile,
					dataType: 'json',
					async: false,
					success: function (json) {
						jsonCities = json.cities;
					},
					error: function(XMLHttpRequest, textStatus, errorThrown) {
						jsonCities = 'jsonCallFailure';
						console.error("zipdata: " + textStatus + " | error: " + errorThrown);
					}
				});
				return jsonCities;
			},

			clearErrorsCityZip: function(self) {
				self._unHighlightFields( $('#salesLeadaddresszipCode') );
				self._unHighlightFields( $('#salesLeadaddresscity') );
			},


			_highlightFields: function( $obj, errorMessage ) {
				$('#error-msg').fadeIn('slow');
				$obj.parent().addClass('error-state');

				if ( !$('#error-tx').hasClass('preset-err') ) {
					$('#error-tx').text(errorMessage);
				}
			},

			_unHighlightFields: function( $obj ) {
				$obj.parent().removeClass('error-state');
				mrm.cmp.cnt_handraiser_1.resetErrorMsg();
			},

			resetErrorMsg: function() {
				if ($('li.error-state').length === 0) {
					$('#error-msg').fadeOut('slow');
				}
			},

			/* Makes label inline to input form field */
			fnInlineLabel: function( label, input ) {
				// If the field has something in it already, hide the label
				if (input.val() !== '') {
					label.addClass('hidden');
				}
				label.click(function() { label.addClass('hidden'); });
				input.focus(function() { label.addClass('hidden'); });
				input.blur(function() {
					if (input.val() === '') {
						label.removeClass('hidden');
					}
				});
			},

			submitForm: function( $mod, self, confs ) {
				var request;
				var $form = $('form', $mod),
					$fields = $('.frmField', $form);

				$.each( $fields, function( i ) {
					// self._unHighlightFields( $(this) );
					self.validateField( $mod, confs, $(this) );
				});

				// STOP if any errors are present
				if ( $('li.error-state').length !== 0 ) {
					// $fields.prop('disabled', false);
					return false;
				}

				/****************************************
				* AT THIS POINT FORM FIELDS ARE VALIDATED
				* and ready to be submitted
				****************************************/

				/** STRIP ON SUBMIT ** add 'sosub' class to input or select element **
				* .sosub - removes any characters that are not numbers on submit
				*/
				$.each( $fields, function( i ) {
					if ( $(this).hasClass('sosub')  && $(this).val() !== '' ) { // leave only numbers
						var regx = new RegExp(confs.test_sosub);
						$(this).val( $(this).val().replace(regx, '') );
					}
				});

				// serialize the data in the form
				var serializedData = $form.serialize();

				// disable inputs for the duration of the ajax request
				$fields.prop('disabled', true);

				var request = $.ajax({
					async: false,
					type: 'POST',
					url: $form.attr('action'),
					data: serializedData,
					dataType: 'json'
				});

				// Sales Lead mobile API will always return a 200 'request.success' response and in case of lead failure,
				// it will include an 'http_response_code' with 400/500. Only exception to this is, when SL application
				// itself is down in which case you will get a 500 'request.fail' response.
				request.success( function ( response, textStatus, jqXHR ){
					if ( response['http_response_code'] ) {
						$('#error-tx').text( 'error: ' + response['http_response_code'] + ': ' + response['message'] );
						$('#error-msg').fadeIn('slow');

					} else { // successful submissions don't return an http_response_code
						$mod.addClass('caseFormSubmit'); // class added on successful form submission success
						$("div#lyr_form").hide();
						$("div#lyr_success", $mod).show();
					}

				});

				// callback handler that will be called on failure
				request.fail( function (jqXHR, textStatus, errorThrown){
					// log the error to the console
					// console.error( 'The following error occured: ' + textStatus, errorThrown );
					$('#error-tx').text(confs.error_form);
					$('#error-msg').fadeIn('slow');
				});

				request.always( function () {
					// re-enable inputs
					$fields.prop('disabled', false);
				});

			},

			setOmnitureEvents: function( $mod, self ) {
				// Omniture field event tracking
				var runOnceFlag;
				$('.frmField').each( function() {

					$(this).on( 'focus', function(){
						if ( runOnceFlag !== 'true' ) {
							self.callOmnitureTracking($mod, $(this), 'caseInit'); // called only once
							runOnceFlag = 'true';

							// binding window event to check if Early Exit
							$(window).bind('beforeunload', function(){
								if (!$mod.hasClass('caseFormSubmit')) { // class added on successful form submission request.success
									self.callOmnitureTracking($mod, $(this), 'caseLeaveEarly');
								}
							});
						}
					});

					var oldVal = '';

					$(this).on( 'blur', function(){
						// for tracking caseLeaveEarly
						$('.lastBlur').removeClass('lastBlur');
						$(this).addClass('lastBlur');

						var val = this.value;
						if (val !== oldVal) {
							oldVal = val;
							self.callOmnitureTracking($mod, $(this), 'caseCompleteFld');
						}
					});

				});
			},

			callOmnitureTracking: function( $mod, $obj, trackingType ) {
				if (typeof(Omniture_s) === 'undefined') { return; }
				var brand = Omniture_s.prop18.toLowerCase(),
					pageName = Omniture_s.pageName;

				switch( trackingType ) {
					case 'caseInit': // Initiation of Form. Only fire on first gain of focus.
						mrm.util.tagging.omniture_tl (
							$obj, $obj.attr('name'), 'o', 'event1',  // linkObj, linkName, linkType, events
							{	// varsAndProps
								'events':'event1',
								'pageName':pageName,
								'eVar17':brand + ':get email updates',
								'eVar18':brand + ':get email updates',
								'eVar72':pageName + ':get email updates:' + $obj.prev('label').text(), //$obj.attr('name')
								'eVar73':pageName + ':get email updates:' + $obj.attr('id')
							}
						);
					break;

					case 'caseCompleteFld': // Only fire once on completion of each Field.
						mrm.util.tagging.omniture_tl (
							$obj, $obj.attr('name'), 'o', undefined,  // linkObj, linkName, linkType, events
							{	// varsAndProps
								'eVar16':pageName,
								'eVar17':brand + ':get email updates',
								'eVar18':brand + ':get email updates',
								'eVar72':pageName + ':get email updates:' + $obj.prev('label').text(),
								'eVar73':pageName + ':get email updates:' + $obj.attr('id')
							}
						);
					break;

					case 'caseLeaveEarly': // Early Exit of Form. Only fire on leaving Form Early.
						$obj = $mod.find('.lastBlur');
						mrm.util.tagging.omniture_tl (
							$obj, 'get email updates form', 'o', undefined,  // linkObj, linkName, linkType, events
							{	// varsAndProps
								'eVar16':pageName,
								'eVar17':brand + ':get email updates',
								'eVar18':brand + ':get email updates',
								'eVar72':pageName + ':get email updates:' + $obj.prev('label').text(),
								'eVar73':pageName + ':get email updates:' + $obj.attr('id'),
								'prop28':pageName + ':get email updates:' + $obj.attr('name')
							}
						);
					break;

					case 'caseError': // Only fire on Field Validation Error.
						mrm.util.tagging.omniture_tl (
							$obj, $obj.attr('name'), 'o', undefined,  // linkObj, linkName, linkType, events
							{	// varsAndProps
								'eVar16':pageName,
								'eVar17':brand + ':get email updates',
								'eVar18':brand + ':get email updates',
								'eVar72':pageName + ':get email updates:' + $obj.prev('label').text(),
								'eVar73':pageName + ':get email updates:' + $obj.attr('id'),
								'eVar74':pageName + ':get email updates:' + $mod.find('#error-tx').text()
							}
						);
					break;

					case 'caseFormSubmit': // click of submit button
						mrm.util.tagging.omniture_tl (
							$obj, 'submit button', 'o', 'event2',  // linkObj, linkName, linkType, events
							{	// varsAndProps
								's.events':'event2',
								'pageName':pageName,
								'prop27':pageName + ':get email updates:submit',
								'prop32':pageName + ':get email updates:submit'
							}
						);
					break;
				}
			}

		}
	});
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		cnt_hl_2: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				// tracking for "a" link
				$mod.find('a').on(clickOrTouch, function(){
					var linkname = $.trim($(this).text());
					mrm.util.trackEvent("click_cta", {section: section, linkname: "block:" + linkname});					
				});
			}			
		}
	});
}(mrm.$));
;(function($) {
	mrm.mod.Cnt_mmpar_1 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;
			var config = $.extend({}, self.cfg);
			
			// whats this for?
			var id = self.$ctx.find('dl').attr('id');
			if(mrm.conf.cmp[id]) {
				config.callbacks = mrm.conf.cmp[id];
			}

			config = $.extend(true, {
				caroufredsel: {
					'onCreate': function($items) {
						self.updateCaption($items);
						mrm.util.sharing.enableShare2Autorender(self.$ctx.find('.tx_cap'));
					},
					scroll: {
						'onBefore': function($oldItems, $newItems) {
							self.$ctx.find('.caroufredsel_wrapper').scrollLeft(0);
							self.updateCaption($newItems);
							self.$ctx.find('.tx_cap').trigger('renderShare2');
						}
					}
				},
				fancybox: {
					'onComplete': function() {
						$('#fancybox-title').trigger('renderShare2');
					}
				}
			}, config);
			self.$ctx.fancyCarousel(config);

            // check responibility for initializing video
            mrm.util.doInitVideo(self.$ctx);
		},

		updateCaption: function($container) {
			var self = this;
			// remove old
			self.$ctx.find('.tx_cap > .modShare_2').remove();
			// append
			var $share = $container.find('.modShare_2').clone();
			var $caption = self.$ctx.find('.tx_cap');
			$caption.append($share);
		},

		switchToContent: function($content) {
			var $scroller = $content.closest('ul');
			$scroller.trigger("slideTo", $content);
		}

	});
})(mrm.$);/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		cnt_opt_1: {
			/**
			 * JS for component cnt_opt_1
			 *
			 * @param {String} c DOM Context
			 */
			tpl: ['10', '16'],
			init: function(c) {
				mrm.util.log('[mrm.cmp.cnt_opt_1] Context: ' + c);
             
				// make sure options object is set, get brandspecific options if set
				mrm.conf.cmp.cnt_opt_1	= mrm.conf.cmp.cnt_opt_1 || {};
				mrm.conf.plugin.cluetip = mrm.conf.plugin.cluetip || {};
				// set options for touch devices.
				if (mrm.util.touchDevice()) {
					mrm.conf.cmp.cnt_opt_1_td = mrm.conf.cmp.cnt_opt_1_td || {};
				} else {
					mrm.conf.cmp.cnt_opt_1_td = {};
				}

				var $layerLinks = $('a.cnt_opt'),
					// merge plugin defaults with component defaults and brandspecific component config
					qtip_config = mrm.$.extend({}, mrm.conf.plugin.cluetip, mrm.conf.cmp.cnt_opt_1, mrm.conf.cmp.cnt_opt_1_td);

				// iterate through all options layers links
				$layerLinks.each( function(index) {
					// fetch links URL
					var $currentLink = $(this),
						cnt_opt_url = $currentLink.attr('href');

					// check for whether this link s target already got fetched
					if (cnt_opt_url.substr(0, 1) != "#") {

						// define an ID for the wrapper
						var wrapper_opt_cnt_id = 'opt_cnt_' + index;

						// create a wrapper for the external options content and load it's content
						// GMDSPLM-7775 - Show the snippets on demand instead of loading all on page load.
						//var wrapper_opt_cnt = $("<div>").addClass('cnt_opts').attr('id', wrapper_opt_cnt_id).load(cnt_opt_url);

						// replace all links with the current external options content URL in the DOM by that fetched content reference
						$('a.cnt_opt[href="' + cnt_opt_url + '"]').attr('rel', '#' + wrapper_opt_cnt_id).click(function(e) { e.preventDefault(); });

						// insert that wrapper
						// GMDSPLM-7775 - Show the snippets on demand instead of loading all on page load.
						//$('#container').after(wrapper_opt_cnt);
					}
					$(this).parent('th, td').addClass('has_cnt_opt_1');
				});

				// bind the tooltip for the links not hidden in a tab
				$layerLinks.not('.ui-tabs-hide a.cnt_opt').cluetipWrap(qtip_config);

				// let links previously hidden in tabs bind the tooltip on demand
				$layerLinks.filter('.ui-tabs-hide a.cnt_opt').on('newTabShown', function() {
					if (!$(this).closest('.ui-tabs-hide').length) {
						$(this).cluetipWrap(qtip_config).unbind('newTabShown');
					}
				});
			}
		}
	});
}(mrm.$));if (typeof (Omniture_s) !== "undefined"){
	if(Omniture_s.eVar18 == "vauxhall"){
		if(jQuery("#tel-number")){
			jQuery("#tel-number").attr('onblur','phnNumValidation(this)');
			function phnNumValidation(element){
			  var phoneNum = jQuery("#tel-number").val();
				var phnReg =  /^(?:(?:\(?(?:00|\+)([1-4]\d\d|[1-9]\d?)\)?)?[\-\.\ \\\/]?)?((?:\(?\d{1,}\)?[\-\.\ \\\/]?){0,})(?:[\-\.\ \\\/]?(?:#|ext\.?|extension|x)[\-\.\ \\\/]?(\d+))?$/i;
				if(phnReg.test(phoneNum) == true){
					jQuery(element).parent().removeClass("ui-state-error");
					jQuery(".phnError").remove();
				} else {
					jQuery(".phnError").remove();
					jQuery(element).parent().addClass("ui-state-error");
					if(jQuery('#salesleadsubmitInformation').has('.errorMessage').length == 0){
					  jQuery('#salesleadsubmitInformation').prepend('<div class="errorMessage"><p class="ui-state-error"> Please check your information below:</p><ul></ul>');
					}
					jQuery(".errorMessage ul").append("<li class='phnError'>There are required fields missing (Phone Number).</li>");
				}
			}
		}
	}
}(function($) { 
    mrm.cmp = mrm.cmp || {};
    $.extend( mrm.cmp, {           
        cnt_prices_1: {
            /**
             * JS for component cnt_prices_1
             * 
             * @param {String} c DOM Context
             */         
            init: function(c) {
                //Find Jquery UI dialog windows as they are created
                $( '.ui-widget-overlay' ).livequery( function() {

                    // searches for exsitence of .cnt_prices_1 and adds .dfc-modal class 
                    // to modal window if present
                    if ( $( this ).prev( '.ui-dialog' ).find( '.cnt_prices_1' ).length > 0 ) {
                        $( this ).prev( '.ui-dialog' ).addClass( 'dfc-modal' );                        
                    }

                });

            }   
        }
    });
}(mrm.$));(function($) {
			mrm.$("div.cnt_recall_component div.inputDiv .btn_prim").click(function(){
				var recallVin =  mrm.$("div.cnt_recall_component input.vinTextBox").val().toUpperCase();
				var cntRecallComponent = mrm.cntRecallComponent;

				if(recallVin.length != 0){
					var urlVin = '/apps/servlets/recall.json?requestInformation=' + recallVin + cntRecallComponent.recallTypeString + '&env=' + cntRecallComponent.recallEnv;
					mrm.$.ajax({
						type: 'GET',
						url:urlVin,
						dataType: 'json',
						success: function(response){

							var image = mrm.$("div.cnt_recall_component div.recallImage");
							var vinInformation = mrm.$("div.cnt_recall_component div.vinInformation");
							var lastUpdate = mrm.$("div.cnt_recall_component div.lastUpdate");
							var vinMessage = mrm.$("div.cnt_recall_component div.vinMessage");

							//The VIN entered has not been recognized, yellow color
							if(response.error_code){
								if(response.error_code == '91'){
									image.addClass("yellow").removeClass("green").removeClass("red").removeClass("warning");
									vinInformation.html(cntRecallComponent.invalidVinText + recallVin + cntRecallComponent.invalidVinText1);
									lastUpdate.html("");
									vinMessage.html("");
								}
								else if(response.error_code == '92'){
									image.addClass("warning").removeClass("red").removeClass("green").removeClass("yellow");													
									vinInformation.html(cntRecallComponent.systemErrorText);
									lastUpdate.html("");
									vinMessage.html("");
								}
							}
							//Outstanding recall with this VIN, red color
							else if(response.number_of_recalls > 0){
								var vinList = response.recalls[0].mfr_recall_number;
								for(var i = 1; i < response.recalls.length; i++) {
									vinList = vinList + ", " + response.recalls[i].mfr_recall_number;
								}
								image.addClass("red").removeClass("yellow").removeClass("green").removeClass("warning");														
								vinInformation.html("VIN:" + recallVin);
								lastUpdate.html("LAST UPDATE: " + response.refresh_date);
								vinMessage.html(cntRecallComponent.recallFoundTxt + vinList + cntRecallComponent.recallFoundTxt1);
								Omniture_s.eVar48 = recallVin;
								Omniture_s.t();
							}
							//valid VIN but no recall, green color
							else{
								image.addClass("green").removeClass("yellow").removeClass("red").removeClass("warning");
								vinInformation.html("VIN:" + recallVin);
								lastUpdate.html("LAST UPDATE: " + response.refresh_date);
								vinMessage.html(cntRecallComponent.noRecallText);
								Omniture_s.eVar48 = recallVin;
								Omniture_s.t();
							}
						}
					});
				}
			});
})(mrm.$);;(function($) {
	mrm.mod.Cnt_reevoo_1 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;

			mrm.util.externalServices.loadReevoo(function() {
				if (!window.Omniture_s) return;

				mrm.util.externalServices.loadReevooAPI(function() {
					// Bind to Reevoo-Button Click
					mrm.util.externalServices.onReevooClick(self.$ctx, function(target) {
						var type = $(target).find('.reevoomark_badge').data('badge-type');
						var obj = {};
						switch (type) {
							case 'product_reviews':
								obj.prop27 = 'reevoo_review';
								obj.prop32 = (Omniture_s.pageName || '') + ':reev:review';
							break;
							case 'ask_an_owner':
								obj.prop27 = 'reevoo_ask_owner';
								obj.prop32 = (Omniture_s.pageName || '') + ':reev:ask';
							break;
						}
						mrm.util.tagging.omniture_tl(target, window.location.pathname, 'o', undefined, obj);
					});
				});
			});
		}
	});
})(mrm.$);/* 2012 Sparsh Atre,MRM WOrldwide */

 (function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		cnt_rss_feed_1: {          
			/**
			 * JS for component cnt_rss_feed_1
			 * 
			 * @param {String} c DOM Context
			 */
			tpl: ['06'],

			init: function(c) {

				mrm.util.log('[mrm.cnt_rss_feed_1] Context: ' + c);

				$(document).ready(function() {
					//making activestory=0 on page load and activeStory=story in the deeplink url for sharing purposes.
					var urlStr=document.URL;
					var owenerstory=urlStr.substr(urlStr.indexOf("#") + 1);
					var pattern = /[0-9]+/g;
					var matches = owenerstory.match(pattern);
					var activestory=0;
					//Daving the id in a variable for its dynamic nature while being authored in CMS
					var feedId=$('.rssfeed_container').attr('id');
					
					if((urlStr.search(owenerstory))>0){
						activestory=matches;
					}
					else{
						activestory=0;
					}
					
					var maxlistItems=$("ul#storylist li.storyitem").size()-1;
					//grab the width and calculate left value
					var item_width = $('.rss_feed_stories ul#storylist li.storyitem').outerWidth();
					var left_value = item_width * (-1);
					 
					//move the last item before first item, just in case user click prev button
					//$('.rss_feed_stories ul#storylist li.storyitem:first').before($('.rss_feed_stories ul#storylist li.storyitem:last'));
				 
					//if user clicked on prev button
					$('#rssfeed_prev').click(function() {
							if(activestory>0){
								activestory=activestory-1;
							}
						else if(activestory==0){
								activestory=maxlistItems;							
						}
							//get the right position           
							var left_indent = parseInt($('.rss_feed_stories ul#storylist').css('left'), 10) + item_width;
				 
							//slide the item           
							$('.rss_feed_stories ul#storylist').animate({'left' : left_indent}, 200,function(){   
				 
								//move the last item and put it as first item              
								$('.rss_feed_stories ul#storylist li.storyitem:first').before($('.rss_feed_stories ul#storylist li.storyitem:last'));          
				 
								//set the default item to correct position
								$('.rss_feed_stories ul#storylist').css({'left' : '0'});
						 
							});
							//removing the old sharable component and adding the new one with active li
						$("#rssfeedOptions #sharecomp_recreated .modShare_2").remove();
   						$(".rss_feed_stories ul#storylist li#"+feedId+activestory).find('#shareitemwrapper .modShare_2').clone().appendTo("#rssfeedOptions #sharecomp_recreated");

						//cancel the link behavior           
						return false;
							 
					});
				 
				  
					//if user clicked on next button
					$('#rssfeed_next').click(function() {
						
						if(activestory<maxlistItems){
							activestory=activestory+1;
						}
						else if(activestory>=maxlistItems){
							activestory=activestory-maxlistItems; 
						}
						//get the right position
						var left_indent = parseInt($('.rss_feed_stories ul#storylist').css('left'), 10) - item_width;
						 
						//slide the item
						$('.rss_feed_stories ul#storylist').animate({'left' : left_indent}, 200, function () {
							 
							//move the first item and put it as last item
							$('.rss_feed_stories ul#storylist li.storyitem:last').after($('.rss_feed_stories ul#storylist li.storyitem:first'));                 
							 
							//set the default item to correct position
							$('.rss_feed_stories ul#storylist').css({'left' : '0'});
						 
						});
						
						//make Prev button visible after 1st next click
						$('.cntScrollBtn a.prev').css({'display' : 'block'});
						//removing the old sharable component and adding the new one with active li
						$("#rssfeedOptions #sharecomp_recreated .modShare_2").remove();
   						$(".rss_feed_stories ul#storylist li#"+feedId+activestory).find('#shareitemwrapper .modShare_2').clone().appendTo("#rssfeedOptions #sharecomp_recreated");

						//cancel the link behavior
						return false;
						 
					});  

					//Function to limit the charater size.
					$.fn.textlimit = function()
					{ 
						return this.each(function()                       
					{
						var $elem = mrm.$(this);    
						var $limit = 400;                // The number of characters to show
						var $str = $elem.html();     
						var $stryLen=$str.length;
						if($stryLen>$limit){
							var $strtemp = $str.substr(0,$limit);   // Get the visible part of the string
							$str = $strtemp + '<span class="hide" style="display:none;">' + $str.substr($limit,$str.length) + '</span><span><a class="readmorelink" href="#">Read More...</a></span>';  
							$elem.html($str);
						}
					});

				};
				// call the the function textLimit
				$('.rss_feed_stories ul#storylist li.storyitem #story_content').textlimit();
				
				
				//function to open readMore link in a modal
				$('.readmorelink').click(function(e){ 
					var $modalstorytitle=$('li#'+feedId+activestory+' .mh_title_1').html();
					var $modalstorycont=$('li#'+feedId+activestory+' #story_content').text().replace("Read More...","");
					var $modalfullstory=$modalstorytitle+'<br>'+$modalstorycont;
					var $dialog = $('<div></div>')
						.html($modalfullstory)
						.dialog({
							autoOpen: false,
							modal: true,
							width: '500'
						});
						$dialog.dialog('open');
					
							return false;
				});
				

				//function to recreate the share2 component on page load.
				$(function() {
					$(".rss_feed_stories ul#storylist li#"+feedId+activestory).find('#shareitemwrapper .modShare_2').clone().appendTo("#rssfeedOptions #sharecomp_recreated");	
					});

				});
					
			}
		}
		
	});
}(mrm.$));;(function($) {
	mrm.mod.Cnt_story_1 = mrm.mod.AbstractMod.extend({

		events: {
			"click": "onClick",
			"mouseenter": "onMouseEnter",
			"mouseleave": "onMouseLeave",
		},

		prepare: function() {
		},

		onClick: function(event) {
			var $btn = this.$ctx.find('.further > a');
			document.location.href = $btn.attr('href');
		},

		onMouseEnter: function(event) {
			var self = this;
			if (self.$ctx.closest('.modStory_overview').length !== 0 && self.$ctx.closest('.modStory_overview.ui-image-view').length === 0) return;
			// calculate top-position
			var $caption = self.$ctx.find('.content');
			if (!$caption.data('initial-y')) $caption.data('initial-y', $caption.position().top);
			var $mod = $caption.parent();
			var modHeight = $mod.height() + parseInt($mod.css('margin-top'), 10);
			$caption.stop().animate({
				top: modHeight - $caption.height()
			}, self.cfg.anim_speed);
		},

		onMouseLeave: function(event) {
			var self = this;
			if (self.$ctx.closest('.modStory_overview').length !== 0 && self.$ctx.closest('.modStory_overview.ui-image-view').length === 0) return;
			var $caption = self.$ctx.find('.content');
			$caption.stop().animate({
				top: $caption.data('initial-y')
			}, self.cfg.anim_speed);
		}

	});
})(mrm.$);/* Cnt_storyref_1 For Culture Redesign 2013 */
// Lou Bodde - MRM Detroit
( function ($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        cnt_storyref_1: {
			clickOrTouch: null,
			/**
			* JS for component Cnt_storyref_1
			*
			* @param {String} c DOM Context
			*/
			initMod: function($mod) {
				var self = this;
				self.clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				if(!$mod.hasClass('multiStory')) return;
				self.createScroller($mod);
			},
			loadImage: function($img) {
				$img = $img.parent("ul").find("li:visible"); // fix carousel bug
				$.each($img, function (k,v) {
					v = $(this).find('img.img');
					if ( v.attr('src').indexOf('culture-loader') > -1 ) {
						v.attr('src', v.data('original') );
					}
				});
			},
			bindArticleClicks: function($mod) {
				var self = this;
				$mod.find('.cnt_storyref_1_story').on('click', function (e){
					e.preventDefault();
					var $btn = $('.story-teasertext > a', this);
					document.location.href = $btn.attr('href');
				});
			},
        	createScroller: function($mod){
        		var self = this;
        		var carousel = $mod.find('.story_list ul').addClass('mmScroll');
        		// $mod.find('.story_list').removeClass('nonScroll'); commented to keep at 980 not 996
        		carousel.siblings('span').addClass('mmScrollBtn');
					var options = {
						height: 'variable',
						width: 980,
						auto: false,
						prev: {
							button: function() {
								return $(this).parent().prev('.prev');
							}
						},
						next: {
							button: function() {
								return $(this).parent().next('.next');
							}
						},
						items: {
							visible: 3,
							width: 316
						},
					pagination: {
						container: function(){
							return $('<div class="pager_wrap"><span class="pager_prevpage" id="pager_prevpage">&lt;</span><span class="pager"></span><span class="pager_nextpage" id="pager_nextpage">&gt;</span></div>')
							.prependTo($(this).parent().parent().parent().children('.intro_holder'))
							.children('.pager');
						},
						anchorBuilder: function(nr) {
							// [1][2][3]...
							return ' <a href="#" id="page_'+ nr + '" class="page"><span>'+nr+'</span></a>';
						}
					},
					scroll: {
						onAfter: function($oldItem, $newItem, newSize, duration){
							$(this).css('left', '0');
							self.loadImage($newItem);  // LazyLoad images on scroller after scroll.
					},
					wipe: true
					},
                     // pagination creation
					onCreate: function($oldItem, $newItem, newSize, duration) {
						// Google like pagination creation
						var _bulletsCenter = 7; // number of bullets in the middle, should always be an odd number
						var _bulletsSide = 0; // number of bullets left and right
						var _maxPagesDisplay = 7;
						self.loadImage($oldItem); //onload lazyLoad Scrollers

						$(this).bind('updatePageStatus.cfs', function() {
							var ancestorDiv = $(this).parent().parent().parent();

							if ($(ancestorDiv).find(".pager_wrap .pager a").length > _maxPagesDisplay) {
								var _itemsTotal = $(this).children().length;
								var _pagesCurrent = $(this).triggerHandler( 'currentPosition' ); // gets current position of carousel
								var currentPage = (_pagesCurrent / Math.floor(_maxPagesDisplay / 2)) + 1
								var numPages = Math.ceil(_itemsTotal / Math.floor(_maxPagesDisplay / 2));
								if (currentPage <= Math.ceil(_maxPagesDisplay / 2)) {
									// ex: [1][2][3][4][5][6][7] - page 1-4 selected
									$(".page").show();
									for (var i=_maxPagesDisplay + 1; i<=numPages; i++) {
										$("#page_" + i).hide();
									}
								}
								else if (currentPage > numPages - Math.ceil(_maxPagesDisplay / 2) ) {
									// ex: [6][7][8][9][10][11][12] - 12 total pages, 9-12 selected
									$(".page").hide();
									for (var i=numPages - Math.floor(_maxPagesDisplay-1); i<=numPages; i++) {
										$("#page_" + i).show();
									}
								}
								else {
									// ex: [5][6][7][8][9][10][11] - 12 total pages, 5-8 selected
									// console.log(Math.floor(_maxPagesDisplay / 2))
									$(".page").hide();
									for (var i = currentPage - Math.floor(_maxPagesDisplay / 2); i<=currentPage + Math.floor(_maxPagesDisplay / 2); i++) {
										// console.log(i); // get's not whole numbers??
										$("#page_" + i).show();
									}
								}

							// enable/disable prev/next arrows if necessary
						  	currentPage === 1 ? $(this).parents(".story_list").siblings('.intro_holder').find(".pager_prevpage").addClass("inactive") :$(this).parents(".story_list").siblings('.intro_holder').find(".pager_prevpage").removeClass("inactive");
	                        currentPage === numPages ? $(this).parents(".story_list").siblings('.intro_holder').find(".pager_nextpage").addClass("inactive") : $(this).parents(".story_list").siblings('.intro_holder').find(".pager_prevpage").removeClass("inactive");
							}
							else {
								ancestorDiv.find(".pager_prevpage").hide();
								ancestorDiv.find(".pager_nextpage").hide();
							}
						});
					} // oncreate end
                },

                cfg = $.extend(true, {}, options ), // extended to use touchwipe for touch devices.                 

                wipeConfig = {
					min_move_x: 30,
					min_move_y: 30,
					preventDefaultEventsHorizontal: (!cfg.scroll.noWipeDirection || cfg.scroll.noWipeDirection !== 'horizontal'),
					preventDefaultEventsVertical: (!cfg.scroll.noWipeDirection || cfg.scroll.noWipeDirection !== 'vertical'),
					wipeLeft:  function (e) { carousel.trigger('next'); },
					wipeRight: function (e) { carousel.trigger('prev'); }
				};
				// end of variables ^^ 

				if ($.fn.touchwipe && cfg.scroll.wipe) {
					carousel.touchwipe(wipeConfig); // additional support for touch devices.
					cfg.scroll.wipe = false; // keep caroufredsel from using it's built-in touchwipe support
				}
				
                carousel.carouFredSel( cfg ).css('left', '0'); // Create the carousel and overwrite left align. 
                $mod.find('.story_list.nonScroll').addClass('jsReady');

                // Click of the pagination arrows after they are created
                $mod.find('.intro_holder').on('click', '.pager_nextpage', function(event){ 
					$mod.find('ul').trigger('next');					
				});
				$mod.find('.intro_holder').on('click', '.pager_prevpage', function(event){
					$mod.find('ul').trigger('prev');					
				});
				self.bindArticleClicks($mod); // make the enitre story div clickable                
        	}
        }
    });
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		cnt_storyref_1: {
			initTrack: function($mod, section){
				section = ($mod.find('h2').text().length > 0) ? $.trim($mod.find('h2').text()) : section;
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				// Only used for multiStory scrolly configuration
				if ($mod.hasClass('multiStory')) {
					$mod.find(".story-teasertext.tx a[onclick]").removeAttr("onclick"); // remove onclick omiture
					// left arrow
					$mod.find('.prev').on(clickOrTouch, function(){
						mrm.util.trackEvent('click_cta', {section: section, linkname: "scroller:arrow:prev"});
					});
					// Scroller Right arrow
					$mod.find('.next').on(clickOrTouch, function(){
						mrm.util.trackEvent('click_cta', {section: section, linkname: "scroller:arrow:next"});
					});
					// Pagination left arrow (if present)
					$mod.find('.pager_prevpage').on(clickOrTouch, function(){
						mrm.util.trackEvent('click_cta', {section: section, linkname: "scroller:page:prev"});
					});
					// Pagination right arrow (if present)
					$mod.find('.pager_nextpage').on(clickOrTouch, function(){
						mrm.util.trackEvent('click_cta', {section: section, linkname: "scroller:page:next"});
					});
					// Pagination numbers (if present);
					$mod.find('.pager_wrap a').on(clickOrTouch, function(){
						mrm.util.trackEvent('click_cta', {section: section, linkname: "scroller:page:toggle"});
					});
					// Main Story div click
					$mod.find('.cnt_storyref_1_story').on(clickOrTouch, function(){
						var text = $(this).find("h3.tt").text();
						mrm.util.trackEvent('click_cta', {section: section, linkname: "scroller:story:" + text});
					});
					// The 'read me' link in every story
					$mod.find('.story-teasertext.tx a').on(clickOrTouch, function(event){
						event.stopPropagation(); // Stop the onclick of the main parent ( Story click ^^ ) for seperate tracking
						var headline = $(this).parent().parent().siblings('h3.tt').text();
						mrm.util.trackEvent('click_cta', {section: section, linkname: "scroller:read:" + headline});
					});
				}
			}
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Cnt_tbl_fs_1 = mrm.mod.AbstractMod.extend({
		cfg: {
			defaults: {}
		},

		prepare: function() {
			var self = this;
			this.cfg.defaults.$ctx = this.$ctx;
			this.cfg.defaults.id = this.id;
			this.cfg.defaults.sandbox = this.sandbox;

			var selectedIndexArray = [1];
			var maxCols = mrm.conf.cmp.cnt_tbl_fs_1.number_without_dropdowns || 4; // max number of columns to display
			var hashtag = mrm.util.getStrippedHash();

			// display type of prices configured in CMS (single or dual price)
			self.$ctx.find('.singlePriceDisplay, .dualPriceDisplay').hide();
			self.$ctx.find('.dualPriceDisplay .tx2.it').prepend(mrm.lbl.cnt_tbl_fs_1.pricePrefix || '', ' ').append(' ', mrm.lbl.cnt_tbl_fs_1.grossPriceSuffix || 'incl. VAT');
			self.$ctx.find('.dualPriceDisplay .tx2.et').prepend(mrm.lbl.cnt_tbl_fs_1.pricePrefix || '', ' ').append(' ', mrm.lbl.cnt_tbl_fs_1.netPriceSuffix || 'excl. VAT');
			if (self.cfg.dualPriceDisplay === true) {
				self.$ctx.find('.dualPriceDisplay').show();
			} else {
				self.$ctx.find('.singlePriceDisplay').show();
			}

			// generate IDs for all tables
			self.$ctx.attr('id', 'cnt_tbl_fs_1_table_' + self.id);

			if (hashtag.length) {
				self.$ctx.find('tr.thead:first th').each(function(i, th) {
					if (($(th).attr('class') || '').indexOf(hashtag) >= 0 ) {
						selectedIndexArray[0] = i;
					}
				});
			}

			selectedIndexArray[0] = self.cfg.defaults.s0 || selectedIndexArray[0];
			selectedIndexArray[1] = self.cfg.defaults.s1 || 2;
			selectedIndexArray[2] = self.cfg.defaults.s2 || 0;

			// check if table cells should be merged
			if (self.cfg.mergeEqualCells) self.$ctx.addClass('tbl_merge');

			self.$ctx.dyntable({
				dynCols: 3,
				minCols: ++maxCols,
				tbodyHeader: true, // if set to true the column heads are fetched from the first row of tbody instead of thead
				dropdownChooseText: mrm.lbl.cnt_tbl_fs_1.select || 'Please Choose',
				selectedIndex: selectedIndexArray,
				mergeEqualCells: self.cfg.mergeEqualCells || false
			});

			if (self.$ctx.hasClass('tbl_expander')) {
				// add show/hide all buttons
				var inject = '<tr class="expanderNav top"><td colspan="'+$('thead tr.caption', self.$ctx).find('> :first-child').attr('colspan')+'">'
							+ '<a class="showAll" href="#">'+(mrm.lbl.cnt_tbl_fs_1.showAll || 'Expand all')+'</a>'
							+ '<a class="hideAll" href="#">'+(mrm.lbl.cnt_tbl_fs_1.hideAll || 'Close all')+'</a>'
							+ '</td></tr>';

				$(inject).insertAfter($('thead tr.caption', self.$ctx)).addClass('top').filter(':last-child').addClass('lastChild');

				if (self.$ctx.find('tfoot tr:last-child a').length > 0) {
					$(inject).appendTo(self.$ctx.find('tfoot')).addClass('bottom lastChild');
				} else {
					$(inject).appendTo(self.$ctx.find('tfoot')).addClass('lastChild');
				}

				// show/hide single section
				self.$ctx.find('.tbl > tbody > tr.thead:first-child').each(function(index, thead) {

					var $head = $(thead);
					var $section = $head.siblings('tr');

					if (index === 0) {
						self.openSections($head, $section);
					} else {
						self.closeSections($head, $section);
					}

					// init event handler
					$head.on('click', function(e) {
						e.preventDefault();
						if ($head.hasClass('closed')) {
							self.openSections($head, $section);
						} else {
							self.closeSections($head, $section);
						}
					});
				});

				self.$ctx.find('.expanderNav a').on('click', function(e) {
					e.preventDefault();
					var $that = $(this);
					var $heads = $('.tbl > tbody > tr.thead:first-child', $that.closest('.cnt_tbl_fs_1'));
					var $sections = $heads.siblings('tr');

					if ($that.hasClass('showAll')) {
						self.openSections($heads, $sections);
					} else {
						self.closeSections($heads, $sections);
					}
				});
			}

			// sticky table navigation
			if (self.cfg.lockDropdowns) {
				var $curHead = self.$ctx.find('thead');
				var $curFoot = self.$ctx.find('tfoot');
				var $curTabs = self.$ctx.find('.modNav_tablay_1') || $();
				var headerHeight = ($('#mds-area-header').css('position') == 'fixed') ? $('#mds-area-header').height() : 0;
				var curHeadHeight = $curHead.height();
				var curFootHeight = $curFoot.height();
				var curTabsHeight = $curTabs.height();
				var offsetTop = ($curTabs.length) ? $curTabs.offset().top - headerHeight : $curHead.offset().top - headerHeight;

				//make sure tfoot is in place, or below calculation fails
				if ($curFoot.length === 0) {
					$curFoot = $('<tfoot>').appendTo(self.$ctx.find('table'));
				}

				$(window).on('scroll', function() {
					var docScroll = $(document).scrollTop();
					var offsetBottom = $curFoot.offset().top + curFootHeight - headerHeight - curHeadHeight;

					if (docScroll >= offsetTop && docScroll <= offsetBottom) {
						$curHead.addClass('fixed');
						$curTabs.addClass('fixed');
						self.$ctx.css('padding-top', (curTabsHeight+curHeadHeight)+'px');
						$curTabs.css('top', headerHeight+'px');
						$curHead.css('top', (headerHeight+curTabsHeight)+'px');
					} else {
						$curTabs.removeClass('fixed').css('top', 'auto');
						$curHead.removeClass('fixed').css('top', 'auto');
						self.$ctx.css('padding-top', 0);
					}
				});
			}
		},

		openSections: function($heads, $sections) {
			$heads.removeClass('closed').addClass('open');
			$sections.show();
		},

		closeSections: function($heads, $sections) {
			$heads.removeClass('open').addClass('closed');
			$sections.hide();
		}

	});
})(mrm.$);;(function($) {
    mrm.mod.Cnt_tbl_fs_2 = mrm.mod.AbstractMod.extend({
        stickyNav: {
            enabled:true,
            trim:null,
            trimDrive:null,
            trimDriveConfig:null
        },

        columnData: [
            {
                number: 1,
                featConfigured: false,
                capConfigured: false,
                conflict: false,
                conflictArea: null,
                config: null,
                prevConfig: null,
                trim: null,
                prevTrim: null,
                driveType: null,
                prevDriveType: null,
                style: null,
                prevStyle: null,
                trims: [],
                trimPrices: [],
                mmcPegs: [],
                imageUrls: [],
                price: null,
                prevPrice: null,
                engine: null,
                prevEngine: null,
                featData: null,
                capData: null
            },
            {
                number: 2,
                featConfigured: false,
                capConfigured: false,
                conflict: false,
                conflictArea: null,
                config: null,
                prevConfig: null,
                trim: null,
                prevTrim: null,
                driveType: null,
                prevDriveType: null,
                style: null,
                prevStyle: null,
                trims: [],
                trimPrices: [],
                mmcPegs: [],
                imageUrls: [],
                price: null,
                prevPrice: null,
                engine: null,
                prevEngine: null,
                featData: null,
                capData: null
            },
            {
                number: 3,
                featConfigured: false,
                capConfigured: false,
                conflict: false,
                conflictArea: null,
                config: null,
                prevConfig: null,
                trim: null,
                prevTrim: null,
                driveType: null,
                prevDriveType: null,
                style: null,
                prevStyle: null,
                trims: [],
                trimPrices: [],
                mmcPegs: [],
                imageUrls: [],
                price: null,
                prevPrice: null,
                engine: null,
                prevEngine: null,
                featData: null,
                capData: null
            }
        ],

        featData: null,
        capData: null,
        featConfigCount: null,
        capConfigCount: null,

        el: {},
        selectedSection: {
            // Use div IDs to split features/capabilities properties.
            featuresDiv: null,
            capabilitiesDiv: null
        },
        viewDiffsActive: {  // view-differences-only mode flags.
            // Use div IDs to split features/capabilities properties.
            featuresDiv: false,
            capabilitiesDiv: false
        },
        stickyNavStart: null,
        stickyNavReturn: null,
        tempResources: {
        // Locale-specific content items not currently config'ed in backend.
        // These items should eventually be moved to backend, and presented to
        // frontend via either HTML data-attributes or JS variables.
        },
        handleDebugMode: function () {
            // If a URL parameter debug is found and value is 1/yes/true,
            // flip mrm.debug flag to true to support logging via
            // mrm.util.log.
            // mrm.util.log first checks for presence of window.console,
            // so logging won't crash in browsers without consoles, like IE.
            var debugParam = mrm.util.getUrlParam('debug');
            var debugValues = ['1', 'yes', 'true'];
            var debugValuesLength = debugValues.length;

            for (i = 0; i < debugValuesLength; i++) {
                if (debugValues[i] == debugParam) {
                    mrm.debug = true;
                    break;
                }
            }
        },

        log: function (myMsg /* String */) {
            // Conditionally console.logs myMsg.
            var self = this;

            function getPaddedIntStr (myNbr /* Integer */, myTotalDigits /* Integer */) {
                // Returns a 2-digit, zero-padded integer string.
                var myIntStr = myNbr.toString();
                var myIntStrLength = myIntStr.length;

                if (myIntStrLength < myTotalDigits) {
                    for (var i = myIntStrLength; i < myTotalDigits; i++) {
                        myIntStr = '0' + myIntStr;
                    }
                    return myIntStr;
                } else {
                    return myIntStr;
                }
            }

            function getTimestampStr () {
                // Returns a string in format (hh:mm:ss.msecs);
                var myDate = new Date();
                var myTimeStr = myDate.getTime().toString();
                var myMsecs = myTimeStr.substr(myTimeStr.length - 3);

                return myDate.getHours().toString() + ':' +
                    getPaddedIntStr(myDate.getMinutes(), 2) + ':' +
                    getPaddedIntStr(myDate.getSeconds(), 2) + '.' +
                    myMsecs;
            }

            if (mrm.debug) {  // If mrm.debug's set to true by handleDebugMode...
                var myLogMsg = '';
                var myTimestampStr = getTimestampStr();
                if (myMsg.indexOf('<timestamp>') == -1) {  // If there's no "<timestamp>" placeholder...
                    // Append timestamp to myMsg.
                    myLogMsg = myMsg + ' (' + myTimestampStr + ')';
                } else {
                    // Replace "<timestamp>" placeholder with timestamp.
                    myLogMsg = myMsg.replace(/<timestamp>/gi, myTimestampStr);
                }
                console.log(myLogMsg);
            }
        },

        getStickyNavStart: function () {
            var self = this;
            self.stickyNavStart = self.el.$tabsDiv.offset().top;
            self.log('[Cnt_tbl_fs_2.getStickyNavStart] stickyNavStart: ' + self.stickyNavStart + '.');
        },
        prepare: function() {
            var self = this;
            self.log('[Cnt_tbl_fs_2.prepare] Method starting.');

            self.handleDebugMode();
            self.setupSelectors();

            // Data
            self.getInitColData();

            self.log('[Cnt_tbl_fs_2.prepare] Method completed.');
        },
        after: function() {
            var self = this;
            self.log('[Cnt_tbl_fs_2.after] Method starting.');

            // Get stick-nav waypoint.
            self.getStickyNavStart();

            // Expand default data section.
            self.preActivateSection();

            // Model-Year dropdown clicks.
            self.el.$yearDropdownLink.on('click', function (myEvt) {
                myEvt.preventDefault();
                self.el.$modelyearDiv.toggleClass('active');
            });

            self.el.$yearDropdownDiv.on('mouseleave', function (myEvt) {
                self.el.$modelyearDiv.removeClass('active');
            });

            // Features/Capabilities tab clicks.
            // Update activeTab & activeDiv flags.
            self.el.$tabsDiv.on('tabsenable', function (myEvt, myUi) {
                self.log('[Cnt_tbl_fs_2.after] tabsenable event-type: ' + myEvt.type + '.');
            })
            .on('tabsshow', function (myEvt, myUi) {
                var myNewPanelId = myUi.panel.id;
                    myNewPanelStr = (myNewPanelId == self.el.$ftrsDiv.attr('id'))? 'features': 'capabilities';
                self.el.$activeTab = self.el.$tabs.filter('.ui-state-active');
                self.el.$activeDiv = (myNewPanelStr == 'features')? self.el.$ftrsDiv: self.el.$capsDiv;
                if (self.selectedSection[self.el.$activeDiv.attr('id')] == null) {
                    self.preActivateSection();
                }
                self.log('[Cnt_tbl_fs_2.after] Tab clicked -- New panel ID ' + myNewPanelId + '.');
            });

            // jQuery-UI Dialog auto-close on click-away.
            $(document).on('click.autoclose', '.ui-widget-overlay', function () {
                $('.ui-dialog:visible > .ui-widget-content:first').dialog('close');
                self.log('[Cnt_tbl_fs_2.after] jQuery-UI Dialog auto-closed.');
            });

            // Bodystyle control cell clicks.
            self.el.$ftrsStyleCells.on('click', function (myEvt) {
                myEvt.stopPropagation();
                self.toggleBodystyleMenu(myEvt);
            });

            // Config link clicks.
            self.el.$capsControlCells.find('a.changeLink').on('click', function (myEvt) {
                myEvt.preventDefault();
                self.activateCapsMatrix(myEvt);
            });
            self.el.$capsConfigCell3.on('click', function (myEvt) {
                myEvt.preventDefault();
                if ($(myEvt.delegateTarget).hasClass('placeholder')) {
                    self.activateCapsMatrix(myEvt);
                }
            });
            // Capabilties matrix close link click.
            self.el.$capsMatrixDiv.find('a.closeLink').on('click', function (myEvt) {
                myEvt.preventDefault();
                self.deactivateCapsMatrix();
            });

            // Capabilities engine control-cell clicks.
            self.el.$capsControlCells.on('click', function (myEvt) {
                myEvt.stopPropagation();
                self.toggleEngineMenu(myEvt);
            });

            // View diffs checkbox clicks.
            mrm.$.merge(self.el.$ftrsDiffsChkbx, self.el.$capsDiffsChkbx).on('click', function (myEvt) {
                var myChecked = myEvt.delegateTarget.checked;
                if (myChecked) {
                    self.activateDiffs();
                } else {
                    self.deactivateDiffs();
                }
            });

            // Trim control cell clicks.
            self.el.$ftrsTrimCells.on('click', function (myEvt) {
                myEvt.stopPropagation();
                self.toggleTrimMenu(myEvt);
            });

            // Section-row clicks.
            $.merge(self.el.$ftrsSectionRows, self.el.$capsSectionRows).on('click', function (myEvt) {
                self.toggleSection(myEvt);
            });

            // Page-clicks (auto-hide active menu if click is outside).
            $('body').on('click', function (myEvt) {
                self.autoHideMenu(myEvt);
            });

            // Check window scroll for sticky-nav.
            $(window).on('scroll', _.throttle($.proxy(self.checkStickyNavScroll, self), 50));

            // Check window resize for stick-nav Return-to-MOV link positioning.
            $(window).on('resize', _.throttle($.proxy(self.adjustMovLink, self), 50));

            // Data
            self.setupDataEvents();

            // Load JSON data
            self.loadData("feat");
            self.loadData("cap");

            // Setup capabilities tab
            self.el.$tabsDiv.on( "tabsshow", function(event, ui) {
                if ($(ui.panel).attr("id") === "capabilitiesDiv") {
                    if (self.capConfigCount === 0) {
                        self.setupCapabilitiesTabs();
                    } else {
                        // If not, fire event function after data has loaded
                        $.eventDispatcher.on('capConfigReady', function(){
                            self.setupCapabilitiesTabs();
                        });
                    }
                }
            });

            // Setup features tab
            self.el.$tabsDiv.on( "tabsshow", function(event, ui) {
                if ($(ui.panel).attr("id") === "featuresDiv") {
                    if (self.featConfigCount === 0) {
                        self.setupFeaturesTab();
                    } else {
                        // If not, fire event function after data has loaded
                        $.eventDispatcher.on('featConfigReady', function(){
                            self.setupFeaturesTab();
                        });
                    }
                }
            });

            self.setupCfdLinks();
        },

        cfdPaths: [],
        centerDiv: function ($myDiv) {
            var self = this;
            var myDivWidth = $myDiv.outerWidth();
            var myDivHeight = $myDiv.outerHeight();
            var myWinWidth = $(window).width();
            var myWinHeight = $(window).height();
            var myDivTop = (myWinHeight - myDivHeight) / 2;
            var myDivLeft = (myWinWidth - myDivWidth) / 2;

            $myDiv.css({
                top: myDivTop,
                left: myDivLeft
            });

            self.log('[Cnt_tbl_fs_2.centerDiv] Div centered.  top: ' + myDivTop + '; left: ' + myDivLeft);
        },
        handleSmallCfdImg: function ($myDialog /* jQuery Object */) {
            // Contitionally add 'hasImg' classhook to parent div, and
            // If img is smaller than 608x342, add top margin to vertically center img.
            var self = this;
            var $dt = $myDialog.find('dt');
            var $img = $dt.find('img');
            var myImgNaturalHeight = null;
            var myMarginTop = null;

            function adjustTopMargin () {
                // Conditionally adds top margin to image if it's smaller than it should be (608x342).
                myImgNaturalHeight = $img[0].naturalHeight;
                if (myImgNaturalHeight < 342) {
                    myMarginTop = (($dt.height() - myImgNaturalHeight) / 2) + 'px';
                    $img.css('marginTop', myMarginTop);
                    self.log('[Cnt_tbl_fs_2.handleSmallCfdImg] Image is small (height ' + myImgNaturalHeight + '); added ' + myMarginTop + ' top margin.');
                } else {
                    self.log('[Cnt_tbl_fs_2.handleSmallCfdImg] Image is correct size (608x342); no top margin added.');
                  }
            }

            if ($img.length > 0) {  // If there's an image...
                $img.load(function () {
                    adjustTopMargin();
                });
                $dt.addClass('hasImg');
            }
        },
        updateCfdTitleAttr: function (myTitle /* String */) {
            var self = this;
            $('.ui-dialog.cnt_tbl_fs_2-dialog:visible').find('.ui-dialog-title').attr('title', myTitle);
        },
        updateCfdContent: function (myEvt /* Object: click event. */) {
            var self = this;
            var $btn = $(myEvt.currentTarget);
            var section = $btn.attr('data-section')
            var cfdPath = $btn.attr('data-cfdpath');
            var $cfdDialog = $btn.parents('.cnt_tbl_fs_2-dialog');
            var myPrevNextPaths = self.getCfdPrevNextPaths(section, cfdPath);
            var myPrevPath = myPrevNextPaths[0];
            var myNextPath = myPrevNextPaths[1];
            var $myPrevBtn = $cfdDialog.find('button.previous');
            var $myNextBtn = $cfdDialog.find('button.next');

            $.get(cfdPath, function (data) {
                // Move CFD title into ui-dialog title bar.
                var $data = $(data);
                var $myCfdHdr = $data.find('h3.pt');
                var myCfdTitle = $.trim($myCfdHdr.html());
                $myCfdHdr.remove();
                $cfdDialog.find('.ui-dialog-title').html(myCfdTitle);
                // Insert data (html content) into dl element.
                $cfdDialog.find('dl').html($data.find('dl').html());
                // Update and show/hide previous/next buttons.
                $myPrevBtn.attr('data-cfdpath', myPrevPath);
                $myNextBtn.attr('data-cfdpath', myNextPath);
                if (myPrevPath === '') {
                    $myPrevBtn.hide();
                } else {
                    $myPrevBtn.show();
                }
                if (myNextPath === '') {
                    $myNextBtn.hide();
                } else {
                    $myNextBtn.show();
                }
                self.updateCfdTitleAttr(myCfdTitle);
                self.handleSmallCfdImg($cfdDialog);

                self.log('[Cnt_tbl_fs_2.updateCfdContent] CFD content updated.');
            });
        },
        getCfdPrevNextPaths: function (mySection /* String */, myCfdPath /* String */) {
            var self = this;
            var myPrevNextPaths = [];
            var myCfdPaths = self.cfdPaths[mySection];
            var myCfdPathIdx = myCfdPaths.indexOf(myCfdPath);
            var myPrevPath = '';
            var myNextPath = '';
            switch (parseInt(myCfdPathIdx)) {
                case 0:  // targetHref is from first of category -- no myPrevPath...
                    myNextPath = myCfdPaths[1];
                    break;
                case (myCfdPaths.length - 1):  // targetHref is from last of category -- no myNextPath...
                    myPrevPath = myCfdPaths[myCfdPathIdx - 1];
                    break;
                default:  // targetHref is from middle of category -- has myPrevPath and myNextPath...
                    myPrevPath = myCfdPaths[myCfdPathIdx - 1];
                    myNextPath = myCfdPaths[myCfdPathIdx + 1];
            }
            return [myPrevPath, myNextPath];
        },
        createCfdControlBar: function (
            mySection /* String: category label */,
            myCfdPath /* Integer: array index of displayed CFD path */) {
            var self = this;
            var myCfdPaths = self.cfdPaths[mySection];
            var myCfdPathIdx = myCfdPaths.indexOf(myCfdPath);
            var $myControlBar = $("<div>").addClass("dialogControlBar");
            var myPrevNextPaths = self.getCfdPrevNextPaths(mySection, myCfdPath);
            var myPrevPath = myPrevNextPaths[0];
            var myNextPath = myPrevNextPaths[1];

            // TODO: Button labels needs to be provided by backend.
            // Assemble and append previous button.
            var $prevBtn = $("<button data-section='" + mySection + "' data-cfdpath='" + myPrevPath + "'>").addClass("previous");
            var $span = $("<span>").html(self.el.$tabsDiv.attr('data-previous-button-label'));
            $prevBtn.append($span);
            $myControlBar.append($prevBtn);
            // Assemble and append next button.
            var $nextBtn = $("<button data-section='" + mySection + "' data-cfdpath='" + myNextPath + "'>").addClass("next");
            var $span = $("<span>").html(self.el.$tabsDiv.attr('data-next-button-label'));
            $nextBtn.append($span);
            $myControlBar.append($nextBtn);
            // Hide previous/next button if no cfd path.
            if (myPrevPath === '') {
                $myControlBar.find('button.previous').hide();
            } else {
                $myControlBar.find('button.previous').show();
            }
            if (myNextPath === '') {
                $myControlBar.find('button.next').hide();
            } else {
                $myControlBar.find('button.next').show();
            }

            return $myControlBar;
        },
        createCfdDialog: function (mySection /* String */, myCfdPath /* String */) {
            var self = this;
            var $myCtrlBar = self.createCfdControlBar(mySection, myCfdPath);
            $.get(myCfdPath, function (data) {
                var $data = $(data);
                var $myCfdHdr = $data.find('h3.pt');
                var myCfdTitle = $.trim($myCfdHdr.html());
                $myCfdHdr.remove();

				var msg;
				if (mrm.util.locale.getCountry() == 'ca') {
					msg = $("<div class='usModelOnlyDisclaimer'>" + mrm.conf.usModelOnlyDisclaimer + "</div>");
				}

                var $dialogContent = $data.first().append(msg).append($myCtrlBar);
                var options = $.extend(mrm.conf.plugin.ui_dialog, {
                    open: function (event, ui) {
                            self.handleSmallCfdImg($dialogContent);
                        },
                    close: function(event, ui) {},
                    position: ['center', 'center'],
                    dialogClass: 'cnt_tbl_fs_2-dialog',
                    title: myCfdTitle
                });

                $dialogContent.dialog(options).load(function() {
                    // Fix dialog positioning in IE9.
                    if ($('html').hasClass('msie9')) {
                        self.centerDiv(self.el.$cfdDiv);
                    }
                });
                self.updateCfdTitleAttr(myCfdTitle);
				if (mrm.util.locale.getLang().toLowerCase()==="fr") {
					$('.ui-dialog.cnt_tbl_fs_2-dialog:visible').find('.ui-dialog-titlebar-close span').html("Fermer");
				}

                self.log("[Cnt_tbl_fs_2.createCfdDialog] CFD dialog created.");
            });
        },
        setupCfdLinks: function(){
            var self = this;
            self.log('[Cnt_tbl_fs_2.setupCfdLinks] Method starting.');
            self.el.$ftrsDataRows.find("a.detailsLink").on("click", function(event){
                if ($(this).attr("target") === "_blank") {
                    return;
                } else {
                    event.preventDefault();
                }

                var targetHref = $(this).attr("href");
                var $parentRow = $(this).parents("tr");

                // Get all active data-rows' CFD URLs from data category.
                var section = $parentRow.attr('data-category');
                var $sectionCfdLinks = $('tr.dataRow.active[data-category=' + section + ']').find('a.detailsLink');
                var sectionCfdLinksLength = $sectionCfdLinks.length;
                var sectionCfdHrefs = [];
                for (var i = 0; i < sectionCfdLinksLength; i++) {
                    sectionCfdHrefs.push($sectionCfdLinks.filter('a:eq(' + i + ')').attr('href'));
                }
                if (typeof self.cfdPaths[section] === 'undefined') {
                    self.cfdPaths[section] = sectionCfdHrefs;
                }

                self.createCfdDialog(section, targetHref);

            });

            self.log("[Cnt_tbl_fs_2.setupCfdLinks] CFD links setup completed.");
        },
        setupFeaturesTab: function(){
            var self = this;
            self.log('[Cnt_tbl_fs_2.setupFeaturesTab] Method starting.');
            var driveType = self.columnData[0].driveType;
            /* GMDSST-55078 - prevent automatic tracking of radio button
            $("#featuresDiv div.dt" + driveType + " input").trigger("click");*/

            self.log('[Cnt_tbl_fs_2.setupFeaturesTab] Method completed.');
        },
        setupSelectors: function(){
            var self = this;
            self.log('[Cnt_tbl_fs_2.setupSelectors] Method starting.');

            // this.$ctx comes for free with AbstractMod inheritence
            self.el.$tabsDiv = $('div.tabsDiv', self.$ctx);

            self.el.$modelyearDiv = $('div.year-switch', self.el.$tabsDiv);
            self.el.$yearDropdownLink = $('a.year', self.el.$modelYearDiv);
            self.el.$yearDropdownDiv = $('div.year-dropdown', self.el.$modelyearDiv);
            self.el.$yearLink = $('a', self.el.$yearDropdownDiv);

            self.el.$tabs = $('li.tabItem', self.el.$tabsDiv);
            self.el.$backToMOV = $('a.backToMOV', self.el.$tabsDiv );

            self.el.$ftrsDiv = $('#featuresDiv', self.el.$tabsDiv);

            self.el.$ftrsViewsTbl = $('table.viewsTable', self.el.$ftrsDiv);
            self.el.$ftrsImgCells = $('th.imageCell', self.el.$ftrsViewsTbl);
            self.el.$ftrsImgCell1 = $('th.imageCell.col1', self.el.$ftrsViewsTbl);
            self.el.$ftrsImgCell2 = $('th.imageCell.col2', self.el.$ftrsViewsTbl);
            self.el.$ftrsImgCell3 = $('th.imageCell.col3', self.el.$ftrsViewsTbl);

            self.el.$ftrsCtrlsTbl = $('table.controlsTable', self.el.$ftrsDiv);
            self.el.$ftrsDrivetypesCell = $('tr.controlsRow.bodystyles > td.controlCell.drivetypes', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsDrivetypeBtns = $('input[type=radio]', self.el.$ftrsDrivetypesCell);
            self.el.$ftrsDrivetypeBtn1 = $('div.drivetypeDiv:eq(0) input[type=radio]', self.el.$ftrsDrivetypesCell);
            self.el.$ftrsDrivetypeBtn2 = $('div.drivetypeDiv:eq(1) input[type=radio]', self.el.$ftrsDrivetypesCell);
            self.el.$ftrsStyleCells = $('tr.controlsRow.bodystyles > td.controlCell.bodystyle', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsStyleCell1 = $('tr.controlsRow.bodystyles > td.controlCell.bodystyle.col1', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsStyleCell2 = $('tr.controlsRow.bodystyles > td.controlCell.bodystyle.col2', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsStyleCell3 = $('tr.controlsRow.bodystyles > td.controlCell.bodystyle.col3', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsDiffsCell = $('tr.controlsRow.trims > td.controlCell.viewdiffs', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsDiffsChkbx = $('input#ftrsViewdiffsChkbx', self.el.$ftrsDiffsCell);
            self.el.$ftrsDiffsCell2 = $('tr.stickyNavRow > td.controlCell.viewdiffs.stickyNav', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsDiffsChkbx2 = $('input#ftrsViewdiffsChkbx2', self.el.$ftrsDiffsCell2);
            self.el.$ftrsTrimCells = $('tr.controlsRow.trims td.controlCell.trim', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsTrimCell1 = $('tr.controlsRow.trims td.controlCell.trim.col1', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsTrimCell2 = $('tr.controlsRow.trims td.controlCell.trim.col2', self.el.$ftrsCtrlsTbl);
            self.el.$ftrsTrimCell3 = $('tr.controlsRow.trims td.controlCell.trim.col3', self.el.$ftrsCtrlsTbl);

            self.el.$ftrsDataTbl = $('table.dataTable', self.$ctx);
            self.el.$ftrsSectionRows = $('tr.sectionRow', self.el.$ftrsDataTbl);
            self.el.$ftrsDataRows = $('tr.dataRow', self.el.$ftrsDataTbl);

            self.el.$ftrsAllMenus = $('ul.bodystyleList, ul.trimList', self.el.$ftrsDiv);
            self.el.$ftrsStyleMenus = $('ul.bodystyleList', self.el.$ftrsDiv);
            self.el.$ftrsStyleMenu1 = $('ul.bodystyleList.col1', self.el.$ftrsDiv);
            self.el.$ftrsStyleMenu2 = $('ul.bodystyleList.col2', self.el.$ftrsDiv);
            self.el.$ftrsStyleMenu3 = $('ul.bodystyleList.col3', self.el.$ftrsDiv);
            self.el.$ftrsTrimMenus = $('ul.trimList', self.el.$ftrsDiv);
            self.el.$ftrsTrimMenu1 = $('ul.trimList.col1', self.el.$ftrsDiv);
            self.el.$ftrsTrimMenu2 = $('ul.trimList.col2', self.el.$ftrsDiv);
            self.el.$ftrsTrimMenu3 = $('ul.trimList.col3', self.el.$ftrsDiv);

            self.el.$cfdDiv = $('div.ui-dialog.cnt_tbl_fs_2-dialog');

            self.el.$ftrsCtasRow = $('tfoot tr.ctasRow', self.el.$ftrsDataTbl);
            self.el.$ftrsCtaCells = $('td.ctaCell', self.el.$ftrsDataTbl);
            self.el.$ftrsCtaBtns = $('td.ctaCell a.btn_prim, a.btn_nba', self.el.$ftrsDataTbl);  /* Buick uses .btn_nba. */
            self.el.$ftrsCtaBtnsCol1 = $('td.ctaCell.col1 a.btn_prim, td.ctaCell.col1 a.btn_nba', self.el.$ftrsDataTbl);  /* Buick uses .btn_nba. */


            self.el.$capsDiv = $('#capabilitiesDiv', self.el.$tabsDiv);

            self.el.$capsConfigsTbl = $('table.capsConfigsTable', self.el.$capsDiv);
            self.el.$capsConfigCells = $('tr.configsRow td.configCell', self.el.$capsConfigsTbl);
            self.el.$capsConfigCell1 = $('tr.configsRow td.configCell.col1', self.el.$capsConfigsTbl);
            self.el.$capsConfigCell2 = $('tr.configsRow td.configCell.col2', self.el.$capsConfigsTbl);
            self.el.$capsConfigCell3 = $('tr.configsRow td.configCell.col3', self.el.$capsConfigsTbl);
            self.el.$capsDiffsCell = $('tr.controlsRow.configs td.controlCell.viewdiffs', self.el.$capsConfigsTbl);
            self.el.$capsDiffsChkbx = $('input#capsViewdiffsChkbx', self.el.$capsDiffsCell);
            self.el.$capsDiffsCell2 = $('tr.stickyNavRow td.controlCell.viewdiffs.stickyNav', self.el.$capsConfigsTbl);
            self.el.$capsDiffsChkbx2 = $('input#capsViewdiffsChkbx2', self.el.$capsDiffsCell2);
            self.el.$capsControlCells = $('tr.controlsRow td.controlCell[class*=col]', self.el.$capsConfigsTbl);
            self.el.$capsControlCell1 = $('tr.controlsRow td.controlCell.col1', self.el.$capsConfigsTbl);
            self.el.$capsControlCell2 = $('tr.controlsRow td.controlCell.col2', self.el.$capsConfigsTbl);
            self.el.$capsControlCell3 = $('tr.controlsRow td.controlCell.col3', self.el.$capsConfigsTbl);

            self.el.$capsDataTbl = $('table.capsDataTable', self.el.$capsDiv);
            self.el.$capsSectionRows = $('tr.sectionRow', self.el.$capsDataTbl);
            self.el.$capsDataRows = $('tr.dataRow', self.el.$capsDataTbl);
            self.el.$capsCtasRow = $('.ctasRow', self.el.$capsDataTbl);
            self.el.$capsCtaCells = $('.ctasRow .ctaCell', self.el.$capsCtasRow);

            self.el.$capsMatrixDiv = $('div#capsMatrixDiv', self.el.$capsDiv);
            self.el.$capsMatrixStyleHdrCells = $('th.matrixStyleCell', self.el.$capsMatrixDiv);
            self.el.$capsMatrixEngineHdrCells = $('th.matrixEngineCell', self.el.$capsMatrixDiv);

            self.el.$capsEngineMenus = $('ul.capsEngineList', self.el.$capsDiv);
            self.el.$capsEngineMenu1 = $('ul.capsEngineList.col1', self.el.$capsDiv);
            self.el.$capsEngineMenu2 = $('ul.capsEngineList.col2', self.el.$capsDiv);
            self.el.$capsEngineMenu3 = $('ul.capsEngineList.col3', self.el.$capsDiv);

            self.el.$tabsDiv.tabs();
            self.el.$capsMatrixDiv.dialog({
                autoOpen: false,
                modal: true,
                width: 960,
                dialogClass: 'capsMatrix'
            });

            self.el.$activeTab = self.el.$tabs.filter('.ui-state-active');
            if (self.el.$activeTab.find('a').attr('href') == '#featuresDiv') {
                self.el.$activeDiv = self.el.$ftrsDiv;
            } else {
                self.el.$activeDiv = self.el.$capsDiv;
            }

            // Populate text placeholders with backend-provided values (in .tabsDiv data attributes).
            // Control-cell labels.
            if (self.$ctx.hasClass('hasConfigurations')) {
                self.el.$ftrsStyleCells.filter('.placeholder').find('.styleLabelDiv > span').html(self.el.$tabsDiv.attr('data-configuration-select-label'));
            }
            self.el.$ftrsStyleCells.filter('.placeholder').find('.labeP > span').html(self.el.$tabsDiv.attr('data-trim-select-label'));
            self.el.$capsControlCells.filter('.config:not(.placeholder)').find('.changeLink > span').html(self.el.$tabsDiv.attr('data-change-configuration-label'));
            self.el.$capsControlCells.filter('.config.placeholder').find('.changeLink > span').html(self.el.$tabsDiv.attr('data-add-configuration-label'));

            // Change placeholder bodystyle images for vans.
                var myStyle = self.el.$ftrsStyleCell1.find('.styleImgDiv').attr('data-bodystyle');
            if (!self.$ctx.hasClass('noConfigurations')) {
                var myStyle = self.el.$ftrsStyleCell1.find('.styleImgDiv').attr('data-bodystyle');
                if (myStyle.indexOf('wheelbase') !== -1) {
                    $.merge(self.el.$ftrsStyleCells, self.el.$capsConfigCells).find('.styleImgDiv[data-bodystyle=placeholder]').css({
                        backgroundPosition: 'left -850px'
                    });
                }
            }

            /*GMDSST-55116*/
            self.el.$tabs.first().css("margin-left", (
                self.el.$modelyearDiv.outerWidth(true)
                + 30
                - parseInt(self.el.$tabs.first().css("padding-left"))
                ));
            self.el.$backToMOV.css("left", self.el.$tabs.last().position().left + self.el.$tabs.last().width() + 40 );

            // Handle any missing CTA cells.
            var myCtaCellHtml = '<td class="ctaCell"></td>';
            var myCtaCellsLength = self.el.$ftrsCtaCells.length;
            if (myCtaCellsLength < 2) {
                self.log('[Cnt_tbl_fs_2.setupSelectors] CTA cell(s) missing...');
                var $myCtaCell2 = $(myCtaCellHtml).addClass('col2');
                if (self.el.$ftrsImgCell2.hasClass('placeholder')) {
                    $myCtaCell2.addClass('ui-helper-hidden');
                }
                self.el.$ftrsCtasRow.append($myCtaCell2);
                self.el.$capsCtasRow.append($myCtaCell2.clone());
                self.log('[Cnt_tbl_fs_2.setupSelectors] CTA cells appended. column: 2.');
                self.el.$ftrsCtaCells = $('.ctaCell', self.el.$ftrsCtasRow);
                self.el.$capsCtaCells = $('.ctaCell', self.el.$capsCtasRow);
                if (myCtaCellsLength < 3) {
                    var $myCtaCell3 = $(myCtaCellHtml).addClass('col3');
                    if (self.el.$ftrsImgCell3.hasClass('placeholder')) {
                        $myCtaCell3.addClass('ui-helper-hidden');
                    }
                    self.el.$ftrsCtasRow.append($myCtaCell3);
                    self.el.$capsCtasRow.append($myCtaCell3.clone());
                    self.log('[Cnt_tbl_fs_2.setupSelectors] CTA cells appended. column: 3.');
                    self.el.$ftrsCtaCells = $('.ctaCell', self.el.$ftrsCtasRow);
                    self.el.$capsCtaCells = $('.ctaCell', self.el.$capsCtasRow);
                }
            } else {
                self.log('[Cnt_tbl_fs_2.setupSelectors] All three CTA cells already present.  No additions needed.');
            }

            self.log('[Cnt_tbl_fs_2.setupSelectors] Selectors setup completed.');
        },
        conflictMessage: {
            title_prefix: "",
            title: " model is not available in this ",
            title_suffix: " selection.",
            generic_title: "Some models are not available in this ",
            body_prefix :"If you continue with the selection of ",
            body: " will be removed and you may select another ",
            body_suffix :".",
            generic_body: "If you continue with this selection, some selections will be removed and you may select another.",
            trimName: "trim",
            configName: "cab and box",
            driveTypeName: "drive type",
            continue_button: "Continue with Selection",
            cancel_button: "Cancel",
            placeholder_config: "Select Cab Style",
            placeholder_trim: "SELECT MODEL",
            placeholder_engine: "Select Engine"
        },

        LSLR: {
            price_text: "STARTING MSRP<sup>1</sup>:"
        },

        setupDataEvents: function() {
            var self = this;
            self.log('[Cnt_tbl_fs_2.setupDataEvents] Method starting.');

            self.el.$ftrsDrivetypeBtns.off("click.dataEvents");
            self.el.$ftrsDrivetypeBtns.on("click.dataEvents", function (event) {
                self.log('[Cnt_tbl_fs_2.setupDataEvents] Drivetype button clicked! event.namespace: ' + event.namespace);

                if (event.target.className.indexOf('ui-radio') === -1) {
                    // Check if JSON AJAX requests have finished
                    if (self.featConfigCount === 0) {
                        self.handleFeatDriveType($(this));
                    } else {
                        // If not, fire event function after data has loaded
                        $.eventDispatcher.on('featConfigReady', function(){
                            self.handleFeatDriveType($(this));
                        });
                    }
                } else {
                    self.log('[Cnt_tbl_fs_2.setupDataEvents] Event handler not triggered -- duplicate event from jQuery-UI span.ui-radio.');
                }
            });

            $(".bodystyleItem", self.el.$ftrsStyleMenus).off("click.dataEvents");
            $(".bodystyleItem", self.el.$ftrsStyleMenus).on("click.dataEvents", function(){
                // Check if JSON AJAX requests have finished
                if (self.featConfigCount === 0) {
                    self.handleFeatConfig($(this));
                } else {
                    // If not, fire event function after data has loaded
                    $.eventDispatcher.on('featConfigReady', function(){
                        self.handleFeatConfig($(this));
                    });
                }
            });

            $(".trimItem", self.el.$ftrsDiv).off("click.dataEvents");
            $(".trimItem", self.el.$ftrsDiv).on("click.dataEvents", function(){
                // Check if JSON AJAX requests have finished
                if (self.featConfigCount === 0) {
                    self.handleFeatTrim($(this));
                } else {
                    // If not, fire event function after data has loaded
                    $.eventDispatcher.on('featConfigReady', function(){
                        self.handleFeatTrim($(this));
                    });
                }
            });
            $(".engineItem", self.el.$capsDiv).off("click.dataEvents");
            $(".engineItem", self.el.$capsDiv).on("click.dataEvents", function(){
                // Check if JSON AJAX requests have finished
                if (self.capConfigCount === 0) {
                    self.handleCapsDropdown($(this));
                } else {
                    // If not, fire event function after data has loaded
                    $.eventDispatcher.on('capConfigReady', function(){
                        self.handleCapsDropdown($(this));
                    });
                }
            });
            // CFD modal previous/next button clicks.
            $('.ui-dialog.cnt_tbl_fs_2-dialog .dialogControlBar button').live('click', function (event) {
                self.updateCfdContent(event);
            });
            // Conflict alert Undo link clicks.
            $('.undoLink', $('.conflictModal', self.el.$ftrsDiv)).off('click.conflictUndo');
            $('.undoLink', $('.conflictModal', self.el.$ftrsDiv)).on('click.conflictUndo', function (event) {
                self.handleConflictUndo(event);
            });

            self.log('[Cnt_tbl_fs_2.setupDataEvents] Data-events setup completed.');
        },
        removePlaceholderClasshooks: function (myCol) {
            // Remove 'placeholder' classhooks from column whose data are being added.
            var self = this;
            self.log('[Cnt_tbl_fs_2.removePlaceholderClasshooks] Method starting.');
            var $placeholders = $('.placeholder');
            $placeholders.filter('.col' + myCol).removeClass('placeholder');
            self.log('[Cnt_tbl_fs_2.removePlacholderClasshooks] Column ' + myCol + ' \'placeholder\' classhooks removed.');
            return true;

            self.log('[Cnt_tbl_fs_2.removePlaceholderClasshooks] Placholder classhooks removed. Column: ' + myCol);
        },
        handleCapsMatrix: function($target, dataTableColumn){
            var self = this;
            self.log('[Cnt_tbl_fs_2.handleCapsMatrix] Method starting.');
            var matrixColumn = self.getColNbr(self.getColClass($target.parent()));
            var $configCell = $target.parents("tbody").find(".matrixStylesRow .matrixStyleCell.col" + matrixColumn);
            var driveType = $.trim($target.data("drivetype"));
            var config = $.trim($configCell.find(".styleImgDiv").data("bodystyle"));
            // Strip HTML entities from engine data-attribute.
            // This is to be used as a JSON key to retrieve data, and
            // any invalid characters in the key would break retrievals.
            var myHtmlEntityPattern = /<[a-zA-Z]+>[^<]+<\/[a-zA-Z]+>/;
            var engine = $.trim($target.parents("tr").data("engine").replace(myHtmlEntityPattern, ''));

            $("#capsMatrixDiv .drivetypeDiv").removeClass("active");
            $target.addClass("active");

            if (self.el['$capsConfigCell' + dataTableColumn].hasClass('placeholder')) {
                // IF updating a placeholder dataTableColumn, remove 'placeholder' classhooks from dataTableColumn.
                self.log('[Cnt_tbl_fs_2.handleCapsMatrix] Removing table-column' + dataTableColumn + ' placeholder classhooks. ');
                self.removePlaceholderClasshooks(dataTableColumn);
            }

            self.columnData[dataTableColumn - 1].driveType = driveType;
            self.columnData[dataTableColumn - 1].config = config;
            self.columnData[dataTableColumn - 1].engine = engine;
            self.columnData[dataTableColumn - 1].capConfigured = true;

            self.populateData(self.columnData[dataTableColumn - 1]);
            self.updateCapsConfigCell(self.columnData[dataTableColumn - 1]);
            self.updateCapsTableData(self.columnData[dataTableColumn - 1]);

            if (self.viewDiffsActive[self.el.$activeDiv.attr('id')]) { // IF viewdiffs mode is ON...
                // Reactivate viewdiffs.
                self.activateDiffs();
            } else {  // IF viewdiffs mode is OFF...
                // Reset diff classes.
                self.setDiffClasses(self.el.$activeDiv);
            }
            self.deactivateCapsMatrix();

            self.log('[Cnt_tbl_fs_2.handleCapsMatrix] Capabilities matrix selection handled.');
        },
        handleCapsDropdown: function($target){
            var self = this;
            self.log('[Cnt_tbl_fs_2.handleCapsDropdown] Method starting.');
            var column = self.getColNbr(self.getColClass($target.parent()));
            var driveType = $.trim($target.data("driveType"));
            var engine =  $.trim($target.data("engine"));

            self.columnData[column - 1].driveType = driveType;
            self.columnData[column - 1].engine = engine;
            self.columnData[column - 1].config = "NoConfig";
            self.columnData[column - 1].capConfigured = true;

            self.populateData(self.columnData[column - 1]);
            self.updateCapsTableData(self.columnData[column - 1]);
            self.updateCapsDropdownControl(self.columnData[column - 1]);

            if (self.viewDiffsActive[self.el.$activeDiv.attr('id')]) { // IF viewdiffs mode is ON...
                // Reactivate viewdiffs.
                self.activateDiffs();
            } else {  // IF viewdiffs mode is OFF...
                // Reset diff classes.
                self.setDiffClasses(self.el.$activeDiv);
            }

            // Reveal CTA buttons.
            $(self.el.$capsCtaCells[column - 1]).removeClass('ui-helper-hidden');

            // Hide dropdowns.
            self.hideAllMenus();

            self.log('[Cnt_tbl_fs_2.handleCapsDropdown] Engine selection handled.  Column: ' + column);
        },
        handleFeatDriveType: function($target) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.handleFeatDriveType] Method starting.');

            var myDrivetype = $.trim($target.siblings('.drivetypeLabel').find(".drivetypeSpan").html());
            var myCurrColData = null;

            for (var x = 0; x < self.columnData.length; x++) {
                myCurrColData = self.columnData[x];
                var myColNbr = myCurrColData.number;
                // Do not update placeholder column.
                if (self.el['$ftrsStyleCell' + (x + 1)].hasClass('placeholder')) {
                    self.log('[Cnt_tbl_fs_2.handleFeatDriveType] Skipping columnData[' + x + '] updates' +
                        ' -- Col' + (x + 1) + ' is a placeholder column.');
                    break;
                }

                if (myCurrColData.conflict && $('.conflictModal').data('conflict-trigger') === 'featDriveType') {
                    // If conflict exists, restore previous selection and exit.
                    // restorePrevSelection clicks previously selected drivetype.
                    self.restorePrevSelection(myCurrColData);
                    return;
                } else {
                    self.backupPrevSelection(myCurrColData);
                }

                myCurrColData.driveType = myDrivetype;
                //self.populateData(self.columnData[x]);

                function handleNoConflict () {
                    // Updates data/displays.

                    self.updateFeatImage(myCurrColData);
                    self.updateFeatConfigControl(myCurrColData);
                    self.updateFeatTrimControl(myCurrColData);
                    self.updateFeatTableData(myCurrColData);
                    self.updateFeatPriceAndCta(myCurrColData);
                    // If previous conflict created conflict modal and hid column-data,
                    // destory & show.
                    self.destroyConflictModal(x + 1);
                    self.showColumnData(x + 1);
                    if (self.viewDiffsActive[self.el.$activeDiv.attr('id')]) { // IF viewdiffs mode is ON...
                        // Reactivate viewdiffs.
                        self.activateDiffs();
                    } else {  // IF viewdiffs mode is OFF...
                        // Reset diff classes.
                        self.setDiffClasses(self.el.$activeDiv);
                    }
                    self.log('[Cnt_tbl_fs_2.handleFeatDriveType] Data/displays handled -- no conflict.' +
                        '  Column: ' + myCurrColData.number);
                }
                function handleConflict () {
                    // Updates data/displays and calls createConflictModal.
                    var myConflictArea = myCurrColData.conflictArea;
                    self.log('[Cnt_tbl_fs_2.handleFeatDriveType] Conflict area: ' + myConflictArea);

                    // Display conflict message.
                    self.createConflictModal("featDriveType", myCurrColData);

                    // Make vehicle image placeholder version.
                    var $myImg = self.el['$ftrsImgCell' + myCurrColData.number].find('img');
                    var $myImgSrc0 = $myImg.attr('src');
                    $myImg.attr('src', $myImgSrc0.replace(/\/[^\/]+\.png/,'/Default.png'));

                    // Handle data/display changes based on columnData.conflictArea.
                    switch(myConflictArea) {
                        case 'config':
                            myCurrColData.featConfigured = false;
                            // clear config & trim data.
                            myCurrColData.config = null;
                            myCurrColData.style = null;
                            myCurrColData.trim = null;
                            myCurrColData.price = null;
                            // TODO: Update Bodystyle menu for selected drivetype.
                            // Update Trim menu for selected drivetype.
                            var $myTrimMenu = self.el['$ftrsTrimMenu' + myCurrColData.number];
                            var myTrims = myCurrColData.trims;
                            var myTrimsLength = myTrims.length;
                            $myTrimMenu.empty();
                            for (t = 0; t < myTrimsLength; t++) {
                                var $myNewItem =
                                    $('<li class="trimItem"><p class="labelP"></p><p class="priceP"><span class="descriptionSpan"></span><span class="priceSpan"></span></p></li>');
                                $myNewItem.attr('data-trimid', $.trim(myTrims[t])).attr('data-bodystyleid', myCurrColData.config);
                                $myNewItem.find('.labelP').html($.trim(myTrims[t]));
                                $myNewItem.find('.priceP .descriptionSpan').html(self.tempResources.priceDescrSpanHtml);
                                $myNewItem.find('.priceP .priceSpan').html($.trim(myCurrColData.trimPrices[t]));
                                $myTrimMenu.append($myNewItem);
                            }
                            // update displays.
                            self.el['$ftrsStyleCell' + myCurrColData.number].find('.styleLabelDiv span')
                                .html('Select Cab &amp; Box');

                            var $myTrimCell = self.el['$ftrsTrimCell' + myCurrColData.number];
                            $myTrimCell.find('.labelP span').html(self.conflictMessage.placeholder_trim);
							$myTrimCell.find('.labelP').addClass('unselected');
                            $myTrimCell.find('.priceP span').text('');
							$myTrimCell.find('.disclaimerList .cashCredit').text('');
							$myTrimCell.find('.disclaimerList .ownerCash').text('');
                            self.log('[Cnt_tbl_fs_2.handleFeatDriveType] Trim selection cleared. (<timestamp>)' +
                                '\n  myCurrColData.prevDriveType: ' + myCurrColData.prevDriveType +
                                '\n  myCurrColData.prevConfig: ' + myCurrColData.prevConfig +
                                '\n  myCurrColData.prevTrim: ' + myCurrColData.prevTrim +
                                '\n  myCurrColData.driveType: ' + myCurrColData.driveType +
                                '\n  myCurrColData.config: ' + myCurrColData.config +
                                '\n  myCurrColData.trim: ' + myCurrColData.trim);

                            break;

                        case 'trim':
                            // Clear trim selection.
                            myCurrColData.featConfigured = false;
                            myCurrColData.trim = null;
                            myCurrColData.price = null;
                            // Update Trim menu for selected drivetype.
                            var $myTrimMenu = self.el['$ftrsTrimMenu' + myCurrColData.number];
                            var myTrims = myCurrColData.trims;
                            var myTrimsLength = myTrims.length;
                            $myTrimMenu.empty();
                            for (t = 0; t < myTrimsLength; t++) {
                                var $myNewItem =
                                    $('<li class="trimItem"><p class="labelP"></p><p class="priceP"><span class="descriptionSpan"></span><span class="priceSpan"></span></p></li>');
                                $myNewItem.attr('data-trimid', $.trim(myTrims[t])).attr('data-bodystyleid', myCurrColData.config);
                                $myNewItem.find('.labelP').html($.trim(myTrims[t]));
                                $myNewItem.find('.priceP .descriptionSpan').html(self.tempResources.priceDescrSpanHtml);
                                $myNewItem.find('.priceP .priceSpan').html($.trim(myCurrColData.trimPrices[t]));
                                $myTrimMenu.append($myNewItem);
                            }
                            // Update displays.
                            var $myTrimCell = self.el['$ftrsTrimCell' + myCurrColData.number];
                            $myTrimCell.find('.labelP span').html(self.conflictMessage.placeholder_trim);
							$myTrimCell.find('.labelP').addClass('unselected');
                            $myTrimCell.find('.priceP span').text('');
							$myTrimCell.find('.disclaimerList .cashCredit').text('');
							$myTrimCell.find('.disclaimerList .ownerCash').text('');
                            self.log('[Cnt_tbl_fs_2.handleFeatDriveType] Trim selection cleared. (<timestamp>)' +
                                '\n  myCurrColData.prevDriveType: ' + myCurrColData.prevDriveType +
                                '\n  myCurrColData.prevConfig: ' + myCurrColData.prevConfig +
                                '\n  myCurrColData.prevTrim: ' + myCurrColData.prevTrim +
                                '\n  myCurrColData.driveType: ' + myCurrColData.driveType +
                                '\n  myCurrColData.config: ' + myCurrColData.config +
                                '\n  myCurrColData.trim: ' + myCurrColData.trim);

                            self.log('[Cnt_tbl_fs_2.handleFeatDriveType] Data/displays handled incl. conflict modal -- conflictArea: ' +
                                myCurrColData.conflictArea + '.' +
                                '  Column: ' + myCurrColData.number);
                            break;

                        default: break;
                    }
                }

                if (myCurrColData.featConfigured === true) {
                    // If all settings configured...
                    // Populate data, then handle data/displays depending on checkFeatConflicts() results.
                    // Leverages populateData()'s deferred promise to call appropriate handling function
                    // only after checkFeatConflicts() result is returned to populateData().
                    $.when(self.populateData(myCurrColData, 'drivetype')).then(handleNoConflict, handleConflict);
                } else {
                    // If settings not all configured...
                    self.populateData(myCurrColData, 'drivetype');
                    // Maybe update click events with new selectable options available
                    self.updateFeatConfigControl(myCurrColData);
                    self.updateFeatTrimControl(myCurrColData);
                    self.log('[Cnt_tbl_fs_2.handleFeatDriveType] Data/displays handled -- data not fully configured.' +
                        '  Column: ' + myCurrColData.number);
                }
            }
            self.setupDataEvents();
        },
        handleFeatConfig: function($target) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.handleFeatConfig] Method starting.');
            // Get bodystyle menu and column.
            var $myStyleMenu = $target.parents("ul");
            var column = self.getColNbr(self.getColClass($myStyleMenu));
            var myCurrColData = self.columnData[column - 1];

            // IF config was ADDED (to placeholder column), remove placeholder classhooks from column.
            if (self.el['$ftrsStyleCell' + column].hasClass('placeholder')) {
                self.removePlaceholderClasshooks(column);
            }

            // Restore/backup previous selection.
            if (myCurrColData.conflict) {
                self.restorePrevSelection(myCurrColData);
            } else {
                self.backupPrevSelection(myCurrColData);
            }

            // Get new config
            var config = $.trim($target.data("bodystyleid"));
            myCurrColData.config = config;

            function handleNoConflict () {
                // Handles data/displays, if no conflict detected.
                self.updateFeatImage(myCurrColData);
                self.updateFeatConfigControl(myCurrColData);
                self.updateFeatTrimControl(myCurrColData);
                self.updateFeatTableData(myCurrColData);
                self.updateFeatPriceAndCta(myCurrColData);
                // If previous conflict created conflict modal and hid column-data,
                // destory & show.
                self.destroyConflictModal(column);
                self.showColumnData(column);
                // Handle viewdiffs.
                if (self.viewDiffsActive[self.el.$activeDiv.attr('id')]) { // IF viewdiffs mode is ON...
                    // Reactivate viewdiffs.
                    self.activateDiffs();
                } else {  // IF viewdiffs mode is OFF...
                    // Reset diff classes.
                    self.setDiffClasses(self.el.$activeDiv);
                }
                self.log('[Cnt_tbl_fs_2.handleFeatConfig] Data/displays handled -- no conflict.' +
                    '  Column: ' + myCurrColData.number);
            }
            function handleConflict () {
                // Handles data/displays incl. conflict modal, if conflict is detected.
                var myConflictArea = myCurrColData.conflictArea;
                self.log('[Cnt_tbl_fs_2.handleFeatConfig] Conflict area: ' + myConflictArea);

                // Display conflict message.
                self.createConflictModal(myConflictArea, myCurrColData);

                // Make vehicle image placeholder version.
                var $myImg = self.el['$ftrsImgCell' + myCurrColData.number].find('img');
                var $myImgSrc0 = $myImg.attr('src');
                $myImg.attr('src', $myImgSrc0.replace(/\/[^\/]+\.png/,'/Default.png'));

                // Clear trim selection.
                myCurrColData.featConfigured = false;
                myCurrColData.trim = null;
                myCurrColData.price = null;
                // Update Trim menu for newly-selected config.
                var $myTrimMenu = self.el['$ftrsTrimMenu' + column];
                var myTrims = myCurrColData.trims;
                var myTrimsLength = myTrims.length;
                $myTrimMenu.empty();
                for (t = 0; t < myTrimsLength; t++) {
                    var $myNewItem =
                        $('<li class="trimItem"><p class="labelP"></p><p class="priceP"><span class="descriptionSpan"></span><span class="priceSpan"></span></p></li>');
                    $myNewItem.attr('data-trimid', $.trim(myTrims[t])).attr('data-bodystyleid', myCurrColData.config);
                    $myNewItem.find('.labelP').html($.trim(myTrims[t]));
                    $myNewItem.find('.priceP .descriptionSpan').html(self.tempResources.priceDescrSpanHtml);
                    $myNewItem.find('.priceP .priceSpan').html($.trim(myCurrColData.trimPrices[t]));
                    $myTrimMenu.append($myNewItem);
                }
                // Update displays.
                var $myStyleCell = self.el['$ftrsStyleCell' + column];
                var $myTrimCell = self.el['$ftrsTrimCell' + column];

                $myStyleCell.find('.styleLabelDiv span').html(myCurrColData.style);

                $myTrimCell.find('.labelP span').html(self.conflictMessage.placeholder_trim);
				$myTrimCell.find('.labelP').addClass('unselected');
                $myTrimCell.find('.priceP span').text('');
                self.log('[Cnt_tbl_fs_2.handleFeatConfig] Trim selection cleared. (<timestamp>)' +
                    '\n  myCurrColData.prevDriveType: ' + myCurrColData.prevDriveType +
                    '\n  myCurrColData.prevConfig: ' + myCurrColData.prevConfig +
                    '\n  myCurrColData.prevTrim: ' + myCurrColData.prevTrim +
                    '\n  myCurrColData.driveType: ' + myCurrColData.driveType +
                    '\n  myCurrColData.config: ' + myCurrColData.config +
                    '\n  myCurrColData.trim: ' + myCurrColData.trim);

                $myStyleMenu.removeClass('active');
                self.log('[Cnt_tbl_fs_2.handleFeatConfig] Data/displays handled incl. conflict modal -- conflictArea: ' +
                    myCurrColData.conflictArea + '.' +
                    '  Column: ' + column);
            }

            // Check if completely configured
            if (myCurrColData.featConfigured === true) {
                // If all settings configured, populate the rest of data into the internal column object
                // Populate data, then handle data/displays depending on checkFeatConflicts() results.
                // Leverages populateData()'s deferred promise to call appropriate handling function above,
                // only after checkFeatConflicts() result is returned to populateData().
                $.when(self.populateData(myCurrColData, 'config')).then(handleNoConflict, handleConflict);
            } else {
                self.populateData(myCurrColData, 'config');
                // Maybe update click events with new selectable options available
                self.updateFeatConfigControl(myCurrColData);
                self.updateFeatTrimControl(myCurrColData);
                self.log('[Cnt_tbl_fs_2.handleFeatConfig] Data/displays handled -- data not fully configured.' +
                        '  Column: ' + myCurrColData.number);
            }
            self.hideAllMenus();
            self.setupDataEvents();

            self.log('[Cnt_tbl_fs_2.handleFeatConfig] Features Configuration selection handled. Column: ' + column);
        },
        handleFeatTrim: function($target) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.handleFeatTrim] Method starting.');
            // Get current column
            var column = self.getColNbr(self.getColClass($target.parents("ul")));

            // Backup old selection
            self.backupPrevSelection(self.columnData[column - 1]);

            // Get new trim
            var trim = $target.data("trimid");
            self.columnData[column - 1].trim = $.trim(trim);

            self.columnData[column -1].featConfigured = true;

            self.populateData(self.columnData[column - 1], 'trim');
            self.updateFeatImage(self.columnData[column - 1]);
            self.updateFeatTrimControl(self.columnData[column - 1]);
            self.updateFeatTableData(self.columnData[column - 1]);
            self.updateFeatPriceAndCta(self.columnData[column - 1]);

            // If previous conflict created conflict modal and hid column-data,
            // destory & show.
            self.destroyConflictModal(column);
            self.showColumnData(column);

            // Handle viewdiffs.
            if (self.viewDiffsActive[self.el.$activeDiv.attr('id')]) { // IF viewdiffs mode is ON...
                // Reactivate viewdiffs.
                self.activateDiffs();
            } else {  // IF viewdiffs mode is OFF...
                // Reset diff classes.
                self.setDiffClasses(self.el.$activeDiv);
            }

            self.hideAllMenus();
            self.setupDataEvents();

            self.log('[Cnt_tbl_fs_2.handleFeatTrim] Features Trim selection handled. Column: ' + column);
        },
        populateData: function(columnData, selection) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.populateData] Method starting.');

            // Deferred object for handleFeatDriveType() and handleFeatConfig().
            var $myDeferred = $.Deferred();

            if (columnData.featConfigured === true) {
                var myConflictCheckResult = self.checkFeatConflicts(columnData, selection);
                // Reject/resolve deferred object based on conflict true/false.
                // This triggers appropriate handling function inside handleFeatDriveType()/handleFeatConfig().
                if (myConflictCheckResult.conflict) {
                    $myDeferred.reject(myConflictCheckResult.conflictArea);
                } else {
                    $myDeferred.resolve(myConflictCheckResult.conflictArea);
                }
            }
            /*self.log('[Cnt_tbl_fs_2.populateData] Conflict check result (<timestamp>):' +
                '\n  Conflict: ' + myConflictCheckResult.conflict +
                '\n  Conflict Area: ' + myConflictCheckResult.conflictArea);*/


            var driveType = columnData.driveType;
            var config = columnData.config;
            var trim = columnData.trim;
            if (columnData.engine === null && columnData.featConfigured === true) {
                for (var key in self.capData[columnData.config][columnData.driveType]) {
                    columnData.engine = $.trim(key);
                    columnData.capConfigured = true;
                    break;
                }
            }

            for (var x = 0; x < self.featData.configs.length; x++) {
                if (self.featData.configs[x].config === config || self.featData.configs[x].config === "") {
                    for (var y = 0; y < self.featData.configs[x].configDetails.length; y++) {
                        if (self.featData.configs[x].configDetails[y].type === driveType) {
                            columnData.trims = self.featData.configs[x].configDetails[y].trims;
                            columnData.trimPrices = self.featData.configs[x].configDetails[y].msrps;
                            columnData.mmcPegs = self.featData.configs[x].configDetails[y].mmcPegs;
                            columnData.imageUrls = self.featData.configs[x].configDetails[y].imageUrls;
                            if(mrm.util.locale.getCountry() === 'ca' && self.featData.configs[x].configDetails[y].regionalPrices !== undefined) {
                                columnData.regionalPrices = self.featData.configs[x].configDetails[y].regionalPrices;
                            }

                            break;
                        }
                    }
                    break;
                }
            }
            for (var x = 0; x < columnData.trims.length; x++) {
                if (columnData.trims[x] === trim && mrm.util.locale.getCountry() === 'ca' && columnData.regionalPrices !== undefined) {
                    //columnData.price = columnData.trimPrices[x]+columnData.regionalPrices[x].priceDisclaimerSymbol;
					columnData.mmcPeg = columnData.mmcPegs[x];
					columnData.region = mrm.util.locale.region != undefined ? mrm.util.locale.region : columnData.regionalPrices[x].region;
					columnData.price = $("#featuresDiv").data("Regions")[columnData.mmcPeg][columnData.region].formattedPrice;
                } else if (columnData.trims[x] === trim) {
                    columnData.price = columnData.trimPrices[x];
                }
            }

            var engine = columnData.engine;
            columnData.style = self.featData.configStyles[config];
            // ADJUST

            // prevent error from breaking the script if driveType doesn't undefined.
            try{
                if (columnData.featConfigured === true){
                    columnData.featData = self.featData[config][driveType][trim];
                }
                if (columnData.capConfigured === true){
                    columnData.capData = self.capData[config][driveType][engine];
                }
            }catch (exception) {
                // console.log('[Cnt_tbl_fs_2.populateData] ERROR: Cannot assign trim/engine data to featData/capData.')
            }

            self.log('[Cnt_tbl_fs_2.populateData] Data populated.');

            // Return deferred promise object to handleFeatDrivetype()/handleFeatConfig(),
            // so that they can continue running w/ conflict result already retrieved.
            return $myDeferred.promise();
        },
        handleConflictUndo: function (event) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.handleConflictUndo] Method starting.');
            event.preventDefault();
            var self = this;
            var $myConflictModal = $(event.delegateTarget).closest('.conflictModal');
            var myTrigger = $myConflictModal.attr('data-conflict-trigger');
            var myColNbr = self.getColNbr(self.getColClass($myConflictModal));

            self.restorePrevSelection(self.columnData[myColNbr - 1]);
            $myConflictModal.remove();

            self.log('[Cnt_tbl_fs_2.handleConflictUndo] Method completed.  conflict-trigger: ' + myTrigger + '.');
        },
        hideColumnData: function (myColNbr /* Integer */) {
            // Hides a data-table column's data, to indicate drivetype/config/trim selection conflict.
            var self = this;

            self.el.$ftrsDataRows.find('.detailCell' + myColNbr + ' .iconSpan').addClass('conflicted');

            self.log('[Cnt_tbl_fs_2.hideColumnData] Column ' + myColNbr + ' data hidden.');
        },
        showColumnData: function (myColNbr /* Integer */) {
            // Unhides a data-table column's data, after a drivetype/config/trim selection conflict is resolved.
            var self = this;

            self.el.$ftrsDataRows.find('.detailCell' + myColNbr + ' .iconSpan').removeClass('conflicted');

            self.log('[Cnt_tbl_fs_2.hideColumnData] Column ' + myColNbr + ' data hidden.');
        },

        createConflictModal: function (conflictTrigger /* String */, columnData /* Object */) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.createConflictModal] Method starting.');
            var column = columnData.number;
            var colClass = 'col' + column;
            var msgStr = '';
            var divTop = self.el.$ftrsDataRows.eq(0).find('.detailCell' + column).offset().top + 10 + 'px';
            var divLeft = self.el.$ftrsDataRows.eq(0).find('.detailCell' + column).offset().left + 10 + 'px';

            // Clear data-table column.
            self.hideColumnData(column);

            // Assemble message and update data/display.
            if (conflictTrigger === "trim") {  // User selects new Config but old Trim unavailable in current Drivetype.
                msgStr = self.el.$tabsDiv.attr('data-conflict-message-drive');
                msgStr = msgStr.replace(/\[configuration\]/gi, '<span class="configSpan">' + columnData.style) + '</span>';
                msgStr = msgStr.replace(/\[trim\]/gi, '&nbsp;<span class="trimSpan">' + columnData.trim + '</span>');
            } else if (conflictTrigger === "config") {  // User selects new Config but old Trim unavailable in new Config.
                msgStr = self.el.$tabsDiv.attr('data-conflict-message-configuration');
                msgStr = msgStr.replace(/\[trim\]/gi, '<span class="trimSpan">' + columnData.trim + '</span>');
            } else if (conflictTrigger === 'drive+config') {  // User selects new Drivetype but old Config unavailable for new Drivetype.
                msgStr = self.el.$tabsDiv.attr('data-conflict-message-drive-and-configuration');
                msgStr = msgStr.replace(/\[Configuration\]/gi, '<span class="bodystyleSpan">' + columnData.style + '</span>');
            }

            // Create conflict modal.
            var $modal = $('<div class="conflictModal"></div>');
            $modal.append('<div class="textDiv"><p class="conflictMsgP"></p></div>');
            $modal.append('<div class="controlsDiv"><a href="#" class="undoLink"><span>Undo</span></a></div>');
            $modal.addClass(colClass).attr('data-conflict-trigger', conflictTrigger);
            $modal.find('.conflictMsgP').html(msgStr);
            $modal.find('.undoLink span').html(self.el.$tabsDiv.attr('data-undo-selection-label'));
            self.el.$ftrsDiv.append($modal);
            $modal.addClass('active');

            self.log('[Cnt_tbl_fs_2.createConflictModal] Conflict Dialog displayed. Column: ' + column + ';  Message: ' + msgStr + '.');
        },
        destroyConflictModal: function (myColNbr /* Integer */) {
            $('.conflictModal.col' + myColNbr).remove();
        },
        updateFeatImage: function(columnData){
            var self = this;
            self.log('[Cnt_tbl_fs_2.updateFeatImage] Method starting.');
            var $cmp = self.$ctx;
            var $imgCell = self.el['$ftrsImgCell' + columnData.number];
            var $img = $imgCell.find('img.vehicleImg');
            var imageURL = "";

            for (trim in columnData.trims) {
                if (columnData.trim === columnData.trims[trim]) {
                    imageURL = columnData.imageUrls[trim];
                }
            }
            if ($img.length === 0) {
                $newImage = $("<img>").addClass("vehicleImg").addClass("col" + columnData.number).attr("src", imageURL);
                $imgCell.append($newImage);
            } else {
                $img.attr("src", imageURL);
            }
            if (columnData.featConfigured) {
                $imgCell.removeClass('placeholder');
                $imgCell.css('visibility','visible');
            } else {
                $imgCell.css('visibility','hidden');
            }

            self.log('[Cnt_tbl_fs_2.updateFeatImage] Features vehicle-image updated.  Column: ' + columnData.number + '.');
        },
        updateFeatConfigControl: function(columnData) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.updateFeatConfigControl] Method starting.');
            var $styleCell = self.el['$ftrsStyleCell' + columnData.number];
            var $styleMenu = self.el['$ftrsStyleMenu' + columnData.number];
            self.log('[Cnt_tbl_fs_2.updateFeatConfigControl] Updating.  [Column ' + columnData.number + ' is not a placeholder]');

            // Update the bodystyle control-cell.
            $styleCell.find(".styleLabelDiv").html(columnData.style);
            $styleCell.find(".styleImgDiv").attr("data-bodystyle", columnData.config);

            // Rebuild bodystyle menu.
            $styleMenu.empty();
            for (var x = 0; x < self.featData.configs.length; x++) {
                var bodystyle = (self.featData.configs[x].config === "") ? "NoConfig" : self.featData.configs[x].config;

                // Only list bodystyles in dropdown when available
                if (typeof self.featData[bodystyle][columnData.driveType] === "undefined") {
                    continue;
                }

                // Build out the markup for each list item
                var $listItem = $("<li>").attr("data-bodystyleid", self.featData.configs[x].config).addClass("bodystyleItem");
                var $listPara = $("<p>").addClass("labelP").html(self.featData.configs[x].style);
                var $listSpan = $("<span>").addClass("iconSpan");
                $listPara.appendTo($listItem);
                $listSpan.appendTo($listItem);

                // Attach that list item to the unordered list use for drop down menus
                $styleMenu.append($listItem);
            }

            self.log('[Cnt_tbl_fs_2.updateFeatConfigControl] Features Configuration control-cell updated. Column: ' + columnData.number + '.');
        },
        updateFeatTrimControl: function(columnData) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.updateFeatTrimControl] Method starting.');
            var $trimCell = self.el['$ftrsTrimCell' + columnData.number];
            var $trimMenu = self.el['$ftrsTrimMenu' + columnData.number];
            var priceDescrHtml = self.el.$tabsDiv.data('pricedescription');
            var bodystyleId = $.trim(columnData.config);

            // Create placeholder trim-price paragraph.
            var $pricePara = $(
                '<p class="priceP"><span class="descriptionSpan">' +
                priceDescrHtml +
                '</span>&nbsp;<span class="priceSpan"></span></p>');

            if (columnData.featConfigured === true) {
                // Update trim control-cell.
                $trimCell.removeClass('placeholder');
                $trimCell.find(".labelP span").html(columnData.trim);
                $trimCell.find(".priceP").html($pricePara.html());
                $trimCell.find(".priceSpan").html(columnData.price);

                var indy = columnData.trims.indexOf(columnData.trim);
                if(mrm.util.locale.getCountry() === 'ca') {
					$trimCell.addClass('dynPriceEh');
					$trimCell.attr('data-seriescode', columnData.mmcPeg);
					$trimCell.find(".priceSpan").addClass("priceEh");
                    if(columnData.regionalPrices[indy].cashCreditDisclaimer.text !== undefined && columnData.regionalPrices[indy].cashCreditDisclaimer.text !== "") {
                        //$trimCell.find(".cashCredit").html(columnData.regionalPrices[indy].cashCreditDisclaimer.text+columnData.regionalPrices[indy].cashCreditDisclaimer.symbol);
						$trimCell.find(".cashCredit").html($("#featuresDiv").data("Regions")[columnData.mmcPeg][columnData.region].cashCreditDisclaimer);
                    } else {
                        $trimCell.find(".cashCredit").html("");
                    }
                    if(columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashText !== undefined && columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashText !== "") {
                        //$trimCell.find(".ownerCash").html(columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashText+' (<a href="'+columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashDetailsLink+'">'+columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashDetailsLinkText+'</a>)'+columnData.regionalPrices[indy].cashCreditDisclaimer.symbol);
						$trimCell.find(".ownerCash").html($("#featuresDiv").data("Regions")[columnData.mmcPeg][columnData.region].ownerCashDisclaimer);
                    } else {
                        $trimCell.find(".ownerCash").html("");
                    }
                }

            }

            // Rebuild trim menu.
            $trimMenu.empty();
            for (var x = 0; x < columnData.trims.length; x++) {
                // Build out the markup for each list item
                var $listItem = $("<li>").attr('data-bodystyleid', $.trim(bodystyleId))
                    .attr("data-trimid", $.trim(columnData.trims[x]))
                    .addClass("trimItem");
                var $labelPara = $("<p>").addClass("labelP").html($.trim(columnData.trims[x]));
                var $pricePara = $(
                    '<p class="priceP"><span class="descriptionSpan">' +
                    priceDescrHtml +
                    '</span>&nbsp;<span class="priceSpan"></span></p>');

                if(mrm.util.locale.getCountry() === 'ca' && columnData.regionalPrices[x].priceDisclaimerSymbol !== undefined) {
					var thisPeg = columnData.mmcPegs[x];
					columnData.region = mrm.util.locale.region != undefined ? mrm.util.locale.region : columnData.regionalPrices[x].region;
                    $pricePara.find(".priceSpan").html($.trim($("#featuresDiv").data("Regions")[thisPeg][columnData.region].formattedPrice)).addClass("priceEh");
					$listItem.addClass("dynPriceEh");
					$listItem.attr('data-seriescode', columnData.mmcPegs[x]);
                } else {
                    $pricePara.find(".priceSpan").html($.trim(columnData.trimPrices[x]));
                }
                $labelPara.appendTo($listItem);
                $pricePara.appendTo($listItem);

                // Attach that list item to the unordered list use for drop down menus
                $trimMenu.append($listItem);
            }

            self.log('[Cnt_tbl_fs_2.updateFeatTrimControl] Features Trim control-cell updated. Column: ' + columnData.number + '.');
        },
        updateFeatTableData: function(columnData) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.updateFeatTableData] Method starting.');

            self.el.$ftrsDataRows.each(function (idx, ele) {
                var cellText = columnData.featData[idx];
                var cellClass = cellText.replace("/", "").toLowerCase();

				// french to eng
				if (cellClass === "s.o."){
					cellClass = "na";
				} else if (cellClass === "en option") {
					cellClass = "available";
				} else if (cellClass === "de srie") {
					cellClass = "standard";
				}

                if (cellClass !== "na" && cellClass !== "available" && cellClass !== "standard") {
                    cellClass = "";
                }
                $(ele).find(".detailCell" + columnData.number).empty();
                var $cellSpan = $("<span>").addClass("iconSpan").addClass(cellClass).html(cellText);
                $(ele).find(".detailCell" + columnData.number).append($cellSpan);
            });

            self.log('[Cnt_tbl_fs_2.updateFeatTableData] Features table-data updated.');
        },
        updateFeatPriceAndCta: function(columnData) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.updateFeatPriceAndCta] Method starting.');
            var $cmp = self.$ctx;
            var $ftrsDiv = self.el.$ftrsDiv;
            var $priceCell = $ftrsDiv.find(".priceCell.col" + columnData.number);
            var $ftrsCtaCell = $(self.el.$ftrsCtaCells[columnData.number - 1]);
            self.el.$capsCtaCells = $('.ctaCell', self.el.$capsCtasRow);
            var $capsCtaCell = $(self.el.$capsCtaCells[columnData.number - 1]);

            $priceCell.find(".trimP").html(columnData.trim);
            $priceCell.find(".priceSpan").html(columnData.price);
            if (mrm.util.locale.getCountry() === 'ca') {
				//for (var t = 0; t < columnData.mmcPegs.length; t++){
				//	if(columnData.mmcPegs[t].indexOf(columnData.trim)>0){
				//		columnData.mmcPeg = columnData.mmcPegs[t];
				//	}
				//}
				$priceCell.attr("data-seriescode", columnData.mmcPeg);
                var indy = columnData.trims.indexOf(columnData.trim);
                if(columnData.regionalPrices[indy].feeDisclaimerText !== undefined) {
                    //$priceCell.find(".feeText").html(columnData.regionalPrices[indy].feeDisclaimerText);
					$priceCell.find(".feeText").html($("#featuresDiv").data("Regions")[columnData.mmcPeg][columnData.region].feeDisclaimer);
                } else {
                    $priceCell.find(".feeText").html("");
                }
                if(columnData.regionalPrices[indy].cashCreditDisclaimer.text !== undefined) {
                    //$priceCell.find(".cashCredit").html(columnData.regionalPrices[indy].cashCreditDisclaimer.text+columnData.regionalPrices[indy].cashCreditDisclaimer.symbol);
					$priceCell.find(".cashCredit").html($("#featuresDiv").data("Regions")[columnData.mmcPeg][columnData.region].cashCreditDisclaimer);
                } else {
                    $priceCell.find(".cashCredit").html("");
                }
                if(columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashText !== undefined && columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashText !== "") {
                    //$priceCell.find(".ownerCash").html(columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashText+' (<a href="'+columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashDetailsLink+'">'+columnData.regionalPrices[indy].cashCreditDisclaimer.ownerCashDetailsLinkText+'</a>)'+columnData.regionalPrices[indy].cashCreditDisclaimer.symbol);
					$priceCell.find(".ownerCash").html($("#featuresDiv").data("Regions")[columnData.mmcPeg][columnData.region].ownerCashDisclaimer);
                } else {
                    $priceCell.find(".ownerCash").html("");
                }
                if(columnData.regionalPrices[indy].currentLocationPrefix !== undefined) {
					var postalCode = mrm.util.location.getPostalCode();
					if (postalCode) {
						while (postalCode.length < 6) {
							postalCode += '*';
						}
					} else {
						postalCode = "";
					}
                    $priceCell.find(".postalPrompt").html(columnData.regionalPrices[indy].currentLocationPrefix.replace(/&amp;/g, '&')+'<span class="postalCodeDisplay">'+postalCode+'</span> (<a >'+columnData.regionalPrices[indy].currentLocationLinkText+'</a>)');
                } else {
                    $priceCell.find(".postalPrompt").html("");
                }
            }

            // Inject CTA buttons if missing.
            if ($ftrsCtaCell.find('a.btn_prim, a.btn_nba').length == 0) {
                // Copy existing buttons from column 1.
                self.el.$ftrsCtaCells.filter(':eq(0)').find('a.btn_prim, a.btn_nba').each( function (idx, ele) {
                    $(ele).clone().appendTo($ftrsCtaCell);
                });
            }

            // Update x-series/trimVcCode parameter values with selected trim's mmcPegs code.
            var myCode = columnData.mmcPegs[columnData.trims.indexOf(columnData.trim)];
            var myCurrHref = null;
            var myCurrOnclick = null;
            $ftrsCtaCell.find('a.btn_prim, a.btn_nba').each( function (idx, ele) {
                myCurrHref = $(ele).attr('href');
                myCurrOnclick = $(ele).attr('onclick');
				var modelDesignator = myCode != null ? myCode.split("_")[0] : '';

                $(ele).attr('href', myCurrHref.replace(/x-series=[^&]+/, 'x-series=' + myCode).replace(/trimVcCode=[^&]+/, 'trimVcCode=' + myCode).replace(/modelDesignator=[^&]+/, 'modelDesignator=' + modelDesignator));
                $(ele).attr('onclick', myCurrOnclick.replace(/x-series=[^&]+/, 'x-series=' + myCode).replace(/trimVcCode=[^&]+/, 'trimVcCode=' + myCode));
            });

            $.merge($priceCell, $ftrsCtaCell).removeClass("ui-helper-hidden");
            $capsCtaCell.html($ftrsCtaCell.html()).removeClass('ui-helper-hidden');

            self.log('[Cnt_tbl_fs_2.updateFeatPriceAndCta] Price and CTAs updated. Column: ' + columnData.number + '.');
        },
        backupPrevSelection: function(columnData) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.backupPrevSelection] Method starting.');
            // In case of conflict
            columnData.prevDriveType = columnData.driveType;
            columnData.prevConfig = columnData.config;
            columnData.prevStyle = columnData.style;
            columnData.prevTrim = columnData.trim;
            columnData.prevPrice = columnData.price;
            columnData.prevEngine = columnData.engine;

            self.log('[Cnt_tbl_fs_2.backupPrevSelection] Previous selection backed up. Column: ' + columnData.number + '.');
        },
        restorePrevSelection: function(columnData) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.restorePrevSelection] Method starting.');
            var myColNbr = columnData.number;
            var $myDrivetypeBtns = self.el.$ftrsDrivetypeBtns;
            var $myStyleCell = self.el['$ftrsStyleCell' + myColNbr];
            var $myStyleLabelSpan = $myStyleCell.find('.styleLabelDiv span');
            var $myTrimCell = self.el['$ftrsTrimCell' + myColNbr];
            var $myTrimLabelSpan = $myTrimCell.find('.labelP span');
            var $myTrimPriceDescrSpan = $myTrimCell.find('.priceP .descriptionSpan');
            var $myTrimPriceSpan = $myTrimCell.find('.priceP .priceSpan');

            // Restore columnData.
            columnData.config = columnData.prevConfig;
            columnData.style = columnData.prevStyle;
            columnData.trim = columnData.prevTrim;
            columnData.price = columnData.prevPrice;
            columnData.engine = columnData.prevEngine;
            columnData.conflict = false;
            columnData.conflictArea = null;
            columnData.featConfigured = true;

            // Restore displays.
            $myStyleCell.find('.styleImgDiv').attr('data-bodystyle', columnData.config);
            $myStyleLabelSpan.html(columnData.style);
            $myTrimLabelSpan.html(columnData.trim);
            $myTrimPriceDescrSpan.html(self.el.$tabsDiv.data('pricedescription'));
            $myTrimPriceSpan.html(columnData.price);
            if (!$myDrivetypeBtns.hasClass('ui-helper-hidden-accessible')) {
                columnData.driveType = columnData.prevDriveType;
                $myDrivetypeBtns.not(':checked').click();
            } else {
                $myDrivetypeBtns.not(':checked').siblings('span.ui-radio').click();
            }

            // Reload data.
            self.loadData('feat');

            // Remove conflict display(s).
            self.showColumnData(myColNbr);
            self.destroyConflictModal(myColNbr);

            self.log('[Cnt_tbl_fs_2.restorePrevSelection] Previous selection restored. Column: ' + myColNbr);
        },
        checkFeatConflicts: function(columnData, selection) {
            var self = this;
            var tableColumnNbr = columnData.number;
            var myConflict = false;
            var myConflictArea = null;
            if (typeof self.featData[columnData.config] !== "undefined") {
                if (typeof self.featData[columnData.config][columnData.driveType] !== "undefined") {
                    if (typeof self.featData[columnData.config][columnData.driveType][columnData.trim] !== "undefined") {
                        myConflict = false;
                        myConflictArea = null;
                        self.log('[Cnt_tbl_fs_2.checkFeatConflicts] No conflict.  Table column: ' + tableColumnNbr);
                    } else {
                        myConflict = true;
                        myConflictArea = "trim";
                        self.log('[Cnt_tbl_fs_2.checkFeatConflicts] Conflict DETECTED for Trim!  Table column: ' + tableColumnNbr);
                    }
                } else {
                    myConflict = true;
                    switch (selection) {
                        case 'trim':
                            myConflictArea = "config";
                            self.log('[Cnt_tbl_fs_2.checkFeatConflicts] Conflict DETECTED for Drive Type (selected Trim unavailable)!  Table column: ' + tableColumnNbr);
                            break;
                        case 'config':
                            myConflictArea = 'drive+config';
                            self.log('[Cnt_tbl_fs_2.checkFeatConflicts] Conflict DETECTED for Drive Type (selected Config unavailable)!  Table column: ' + tableColumnNbr);
                    }
                }
            } else {
                myConflict = true;
                myConflictArea = "config";
                self.log('[Cnt_tbl_fs_2.checkFeatConflicts] Conflict DETECTED for Config!  Table column: ' + tableColumnNbr);
            }

            columnData.conflict = myConflict;
            columnData.conflictArea = myConflictArea;
            return {'conflict' : myConflict, 'conflictArea' : myConflictArea};

            self.log('[Cnt_tbl_fs_2.checkFeatConflicts] Features conflict checked. Column: ' + columnData.number + '.');
        },
        getInitColData: function() {
            var self = this;
            self.log('[Cnt_tbl_fs_2.getInitColData] Method starting.');
            var $ctx = self.$ctx;

            // Set up custom event handlers based on loaded markup and data config.
            if ($ctx.find(".bodystyle").length === 0) {
                // Check if JSON AJAX requests have finished
                if (self.featConfigCount === 0) {
                    self.setupColWithoutConfig();
                } else {
                    // If not, fire event function after data has loaded
                    $.eventDispatcher.on('featConfigReady', function(){
                        self.setupColWithoutConfig();
                    });
                }
            } else {
                // Check if JSON AJAX requests have finished
                if (self.featConfigCount === 0) {
                    self.setupColWithConfig();
                } else {
                    // If not, fire event function after data has loaded
                    $.eventDispatcher.on('featConfigReady', function(){
                        self.setupColWithConfig();
                    });
                }
            }

            self.log('[Cnt_tbl_fs_2.getInitColData] Method completed.');
        },
        setupColWithConfig: function(){
            var self = this;
            self.log('[Cnt_tbl_fs_2.setupColWithConfig] Method starting.');
            var $ctx = self.$ctx;
            var myDriveType = $.trim(self.el.$ftrsDrivetypeBtns.filter("input:checked")
                            .siblings("label").find(".drivetypeSpan").html());

            $ctx.find(".bodystyle").each(function(idx, ele){
                var $myCurrCell = $(ele);
                // Drive Type is available for all columns
                self.columnData[idx].driveType = myDriveType;
                // Check to see if column is configured
                if($myCurrCell.hasClass("placeholder") || $($ctx.find(".trim")[idx]).hasClass("placeholder")) {
                    // If not configured, make a note of that in the internal model
                    self.columnData[idx].featConfigured = false;
                    return;
                }

                // If Config and Trim are available for a column, set configured to true for internal model
                self.columnData[idx].featConfigured = true;

                // Determine values of the configuration for a configured column
                var myBodystyle = $.trim($myCurrCell.find(".styleImgDiv").data("bodystyle"));
                var myStyleLabel = $.trim($myCurrCell.find('.styleLabelDiv').html());
                var myTrim = $.trim($($ctx.find(".trim")[idx]).find(".labelP span").html());
                var myPrice = self.el['$ftrsTrimCell' + (idx + 1)].find('.priceSpan').html();

                // Set values within the internal model.
                self.columnData[idx].config = myBodystyle;
                self.columnData[idx].style = myStyleLabel;
                self.columnData[idx].price = myPrice;
                //if (myTrim.toLowerCase() !== 'select model') {
                //    self.columnData[idx].trim = myTrim;
                //} else {
                //    self.columnData[idx].featConfigured = false;
                //    self.columnData[idx].trim = null;
                //}
				if ($($ctx.find(".trim")[idx]).find(".unselected").length > 0) {
					self.columnData[idx].featConfigured = false;
					self.columnData[idx].trim = null;
				} else {
					self.columnData[idx].trim = myTrim;
				}

                //self.columnData[idx].featData = self.getFeatSelectionData(self.columnData[idx]);
            });
            // Populate Capabilities tab config-cell cab/box images.
            self.setCapsStyleImages();

            self.log('[Cnt_tbl_fs_2.setupColWithConfig] Columns setup completed with Configurations.');
        },
        setupColWithoutConfig: function(){
            var self = this;
            self.log('[Cnt_tbl_fs_2.setupColWithoutConfig] Method starting.');
            var $ctx = self.$ctx;
            var myDriveType = $ctx.find(".drivetypes input:checked").siblings("label").find(".drivetypeSpan").html();

            $ctx.find(".trim").each(function(idx, ele){
                // Drive Type is available for all columns
                self.columnData[idx].driveType = $.trim(myDriveType);

                var myBodystyle = (self.featData.configs[0].config === "") ? "NoConfig" : $.trim(self.featData.configs[0].config);
                var myTrim = $.trim($($ctx.find(".trim")[idx]).find(".labelP span").html());

                // Check to see if column is configured
                if ($($ctx.find(".trim")[idx]).find(".unselected").length > 0) {
                    // If not configured, make a note of that in the internal model
					self.conflictMessage.placeholder_trim = myTrim;
                    self.columnData[idx].featConfigured = false;
                    self.columnData[idx].config = myBodystyle;
                    self.columnData[idx].trim = null;
                    self.populateData(self.columnData[idx]);
                    self.updateFeatTrimControl(self.columnData[idx]);
                    self.setupDataEvents();
					$($ctx.find(".trim")[idx]).find(".labelP").removeClass("unselected");
                    return;
                }

                // If Config and Trim are available for a column, set configured to true for internal model
                self.columnData[idx].featConfigured = true;

                // Determine values of the configuration for a configured column
                //var myBodystyle = $(ele).find(".styleImgDiv").data("myBodystyle");


                // Set values within the internal model
                self.columnData[idx].config = myBodystyle;
                self.columnData[idx].trim = myTrim;

                //self.columnData[idx].featData = self.getFeatSelectionData(self.columnData[idx]);
            });

            self.log('[Cnt_tbl_fs_2.setupColWithoutConfig] Columns setup completed without Configurations.');
        },
        setCapsStyleImages: function () {
            // Sets Capabilties tab config-cell data-bodystyle attributes to enable image-styling.
            var self = this;
            self.log('[Cnt_tbl_fs_2.setCapsStyleImages] Method starting.');
            var myBodystyles = [];
            $(self.columnData).each( function (idx, ele) {
                if (idx < 2) {  // Only populate first two columns.  3rd column's always placeholder.
                    myBodystyles.push(ele.config);
                }
            });
            self.log('[Cnt_tbl_fs_2.setCapsStyleImages] Bodystyles columnData (<timestamp>):\n' +
                '    col1: ' + myBodystyles[0] +
                '\n    col2: ' + myBodystyles[1]);
            self.el.$capsConfigCells.each( function (idx, ele) {
                if (idx < 2) {  // Only populate first two columns.  3rd column's always placeholder.
                    $(ele).find('.styleImgDiv').attr('data-bodystyle', myBodystyles[idx]);
                }
            });

            self.log('[Cnt_tbl_fs_2.setCapsStyleImages] Capabilities tab .styleImgDiv data-bodystyle attributes populated.');
        },
        setupCapabilitiesTabs: function(){
            var self = this;
            self.log('[Cnt_tbl_fs_2.setupCapabilitiesTabs] Method starting.');
            var listItems = [];
            var $engineMenus = self.el.$capsEngineMenus;

            for (var x = 0; x < self.columnData.length; x++) {
                self.populateData(self.columnData[x]);
                if (self.columnData[x].capConfigured === true) {
                    if(self.capData.configs.length > 1) {
                        self.updateCapsConfigCell(self.columnData[x]);
                    } else {
                        self.updateCapsDropdownControl(self.columnData[x]);
                    }

                    self.updateCapsTableData(self.columnData[x]);
                }
            }

            if (self.capData.configs.length === 1) {
                for (x = 0; x < self.capData.configs[0].engineDriveTypes.length; x++) {
                    var driveType = self.capData.configs[0].engineDriveTypes[x].driveType;
                    for (y = 0; y < self.capData.configs[0].engineDriveTypes[x].engines.length; y++) {
                        var listProperties = {
                            text: "",
                            driveType: "",
                            engine: ""
                        }
                        var engine = self.capData.configs[0].engineDriveTypes[x].engines[y];
                        listProperties.text = engine + " " + driveType;
                        listProperties.driveType = driveType;
                        listProperties.engine = engine;
                        listItems.push(listProperties)
                    }
                }
            }
            $engineMenus.empty();
            for (x = 0; x < listItems.length; x++) {
                $listItem = $("<li>")
                    .addClass("engineItem")
                    .attr("data-engine", listItems[x].engine.replace(/<[a-zA-Z]+>[^<]+<\/[a-zA-Z]+>/g, ''))
                    .attr("data-drive-type", listItems[x].driveType);
                $itemPara = $("<p>").addClass("labelP").html(listItems[x].text);

                $listItem.append($itemPara);

                $engineMenus.append($listItem);
            }

            self.el.$capsCtaCells = $('.ctaCell', self.el.$capsCtasRow);

            self.setupDataEvents();

            self.log('[Cnt_tbl_fs_2.setupCapabilitiesTabs] Capabilities tabs setup completed.');
        },
        updateCapsConfigCell: function(columnData) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.updateCapsConfigCell] Method starting.');
            var $cmp = self.$ctx;
            var $capsDiv = $cmp.find("#capabilitiesDiv");
            var $capsConfigCell = self.el['$capsConfigCell' + columnData.number];
            var $capsEngineDrivetypeDiv = $('.engineDrivetypeLabelDiv', $capsConfigCell);
            var $capsChangeLink = self.el['$capsControlCell' + columnData.number].find('.changeLink');
            var $capsCtaCell = self.el.$capsDataTbl.find('tfoot > .ctasRow > .ctaCell').filter('.col' + columnData.number.toString());

            $capsConfigCell.find('.styleImgDiv').attr('data-bodystyle', columnData.config);
            $capsConfigCell.find(".styleLabelDiv").html(columnData.style);
            if ($capsEngineDrivetypeDiv.find('.engineSpan, .drivetypeSpan').length == 2) {
                $capsConfigCell.find(".engineSpan").html(columnData.engine);
                $capsConfigCell.find(".drivetypeSpan").html(columnData.driveType);
            } else {
                var $engineSpan = $('<span class="engineSpan" data-engine="' +
                    columnData.engine + '">' + columnData.engine + '</span>');
                var $drivetypeSpan = $('<span class="drivetypeSpan" data-drivetype="' +
                    columnData.driveType + '">' + columnData.driveType + '</span>');
                $capsEngineDrivetypeDiv.html('&nbsp;').prepend($engineSpan).append($drivetypeSpan);
            }

            // Update change link data attribute, and
            // replace content with non-placeholder content,
            // in case link was placeholder ("Add config..") before.
            $capsChangeLink.attr('data-bodystyle', columnData.config)
                .attr('title', 'change')
                .html(self.el.$tabsDiv.data('changeConfigurationMatrixLabel'));

            // Unhide CTA buttons.
            $capsCtaCell.removeClass('ui-helper-hidden');

            self.log('[Cnt_tbl_fs_2.updateCapsConfigCell] Capabilities Configuration cell updated. Column: ' + columnData.number + '.');
        },
        updateCapsDropdownControl: function(columnData){
            var self = this;
            self.log('[Cnt_tbl_fs_2.updateCapsDropdownControl] Method starting.');
            var $myControl = self.el['$capsControlCell' + columnData.number];
            var $myLabelP = $myControl.find('.labelP');
            var $myDescriptionSpan = $myControl.find('.priceP .descriptionSpan');
            var $myPriceSpan = $myControl.find('.priceP .priceSpan');

            $myLabelP.html(columnData.engine + " " + columnData.driveType);
            $myDescriptionSpan.html(self.el.$tabsDiv.data('pricedescription'));
            $myPriceSpan.html(columnData.price);

            self.log('[Cnt_tbl_fs_2.updateCapsDropdownControl] Capabilities Engine control-cell updated. Column: ' + columnData.number + '.');
        },
        updateCapsTableData: function(columnData) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.updateCapsTableData] Method starting.');
            var myCol = columnData.number;
            var myDriveType = columnData.driveType;
            var myConfig = columnData.config;
            var myEngine = columnData.engine;
            var myCapData = columnData.capData;
            var $myCtaCell = $(self.el.$capsCtaCells[myCol - 1]);
            var $myFtrsCtaCell = null;

            self.el.$capsDataRows.each(function(idx, ele){
                var cellText = columnData.capData[idx];
                var cellClass = cellText.replace("/", "").toLowerCase()
                if (cellClass !== "na" && cellClass !== "available" && cellClass !== "standard") {
                    cellClass = ""
                }
                $(ele).find(".detailCell" + myCol).empty();
                var $cellSpan = $("<span>").addClass("iconSpan").addClass(cellClass).html(cellText);
                $(ele).find(".detailCell" + myCol).append($cellSpan);
            });

            // Ensure CTA buttons display if not placeholder.
            // If buttons are missing, create them.
            if ($myCtaCell.children().length === 0) {
                self.log('[Cnt_tbl_fs_2.updateCapsTableData] CTA buttons are missing...');

                // Copy them from correspding/populated column in Features tab.
                for (var a = myCol; a > 0; a--) {
                    $myFtrsCtaCell = $(self.el.$ftrsCtaCells[a - 1]);
                    if ($myFtrsCtaCell.children().length === 0) {
                        self.log('[Cnt_tbl_fs_2.updateCapsTableData] Features CTA buttons not found: col' + a + '.');
                        continue;
                    } else {
                        self.log('[Cnt_tbl_fs_2.updateCapsTableData] Features CTA buttons found: col' + a + '.');
                        $myCtaCell.html($myFtrsCtaCell.html());
                        break;
                    }
                }

                self.log('[Cnt_tbl_fs_2.updateCapsTableData] CTA buttons created.');
            } else {
            }

            if (columnData.conflict) {
                self.log ("[Cnt_tbl_fs_2.updateCapsTableData] hey there's a conflict!");
            }

            self.log('[Cnt_tbl_fs_2.updateCapsTableData] Capabilities table-data updated.');
        },
        loadData: function (type) {
            // Load base JSON data
            var self = this;
            self.log('[Cnt_tbl_fs_2.loadData] Method starting.');

            if (type === "feat") {
                var basePath = self.$ctx.find("#featuresDiv").data("baseJson");
                self.getData(basePath, function(data) {
                    self.featData = data;
                    self.featConfigCount = self.featData.configs.length;
                    self.loadData("featConfigs");
                });
            } else if (type === "featConfigs") {
                $(self.featData.configs).each(function(count, value){
                    var configPath = self.featData.configs[count].filePath;
                    var configName = (self.featData.configs[count].config === "") ? "NoConfig" : self.featData.configs[count].config;
                    self.featData.configStyles = self.featData.configStyles || {};
                    self.featData.configStyles[self.featData.configs[count].config] = self.featData.configs[count].style;
                    self.getData(configPath, function(data){
                        self.featConfigCount--
                        if (self.featConfigCount === 0) {

                            $.eventDispatcher.trigger('featConfigReady');
                        }
                        self.featData[configName] = data;
                    });
                });
            } else if (type === "cap") {
                var basePath = self.$ctx.find("#capabilitiesDiv").data("baseJson");
                self.getData(basePath, function(data) {
                    self.capData = data;
                    self.capConfigCount = self.capData.configs.length;
                    self.loadData("capConfigs");
                });
            } else if (type === "capConfigs") {
                $(self.capData.configs).each(function(count, value){
                    var configPath = self.capData.configs[count].filePath;
                    var configName = (self.capData.configs[count].config === "") ? "NoConfig" : self.capData.configs[count].config;
                    self.getData(configPath, function(data){
                        self.capConfigCount--;

                        // If any engine key contains HTML entities (e.g., '<sup>&reg;</sup>'),
                        // strip them from the key string before assigning to capData.
                        // JSON keys cannot contain invalid characters such as HTML entities,
                        // otherwise data assignments would break.
                        var myCurrDrivetypeData = null;
                        var myRegexPattern = /<[a-zA-Z]+>[^<]+<\/[a-zA-Z]+>/;
                        var myCleanEngineStr = '';
                        for (var drivetype in data) {
                            myCurrDrivetypeData = data[drivetype];
                            for (var engine in myCurrDrivetypeData) {
                                if (myRegexPattern.test(engine)) {
                                    myCleanEngineStr = engine.replace(myRegexPattern, '');
                                    myCurrDrivetypeData[myCleanEngineStr] = myCurrDrivetypeData[engine];
                                    delete myCurrDrivetypeData[engine];
                                }
                            }
                        }

                        self.capData[configName] = data;
                        if (self.capConfigCount === 0) {
                            $.eventDispatcher.trigger('capConfigReady');
                        }
                    });
                });
            }

            self.log('[Cnt_tbl_fs_2.loadData] Data loaded.  Type: ' + type + '.');

			if (mrm.util.locale.getCountry().toLowerCase()==="ca") {
				var callYear = mrm.$(".tabsDiv").data().year;
				var callCarline = mrm.$(".tabsDiv").data().carline;
				var callBodystyle = mrm.$(".tabsDiv").data().bodystyle;
				var callPath = "/apps/servlets/bbcdataseries.json?segment=true&year="+callYear+"&carline="+callCarline+"&bodystyle="+callBodystyle+"&path="+$('meta[name="contentpath"]').attr('content');
				$.ajax({
					url: callPath,
					dataType: 'json',
					async: false,
					success: function(data) {
							$("#featuresDiv").data("Regions", data[callYear+"_"+callCarline+"_"+callBodystyle]);
							$("#featuresDiv").addClass("caData");
							var postalcode = mrm.util.location.getPostalCode();
							if(postalcode){
								var clippedChangeRegion = $.Event("newClippedRegionEh", {postalCode: postalcode});
								$("body").trigger(clippedChangeRegion);
							}
						}
				});
				//$.getJSON( callPath, function(data) {
				//	$("#featuresDiv").data("Regions", data[callYear+"_"+callCarline+"_"+callBodystyle]);
				//	$("#featuresDiv").addClass("caData");
				//	var postalcode = mrm.util.location.getPostalCode();
				//	if(postalcode){
				//		var clippedChangeRegion = $.Event("newClippedRegionEh", {postalCode: postalcode});
				//		$("body").trigger(clippedChangeRegion);
				//	}
				//});
			}
        },

        getData: function(path, callback) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.getData] Method starting.');

            if(mrm.util.locale.getCountry() === 'ca' && path.indexOf("fstable-options-trims") >= 0) {
				var callYear = mrm.$(".tabsDiv").data().year;
				var callCarline = mrm.$(".tabsDiv").data().carline;
				var callBodystyle = mrm.$(".tabsDiv").data().bodystyle;
                path = '/apps/servlets/regionalpricing.json?year='+callYear+'&carline='+callCarline+'&bodystyle='+callBodystyle+'&postalcode='+mrm.util.location.getPostalCode()+'&path='+$("meta[name='contentpath']").attr("content");
            }

            $.ajax({
                url:path,
                dataType:"json",
                async:true,
                success: callback,
                error: function(jqXHR, textStatus, errorThrown) {
                    self.log('[Cnt_tbl_fs_2.getData] ERROR: AJAX call failed (<timestamp>)!  path = ' + path + '.\n  '
                    + 'status = ' + textStatus + '; errorThrown = ' + errorThrown.toString());
                }
            });

            self.log('[Cnt_tbl_fs_2.getData] Data retrieved via AJAX (<timestamp>).  JSON-path: ' + path);
        },

        getColClass: function (myEle$ /* Ojbect: jQuery single-element array */) {
            // Finds and returns the col1/col2/col3 class from col-specific cells, menus, etc.
            var self = this;
            var myClass = myEle$.attr('class');
            var myClasses = myClass.split(' ');
            var myClassesLength = myClasses.length;

            for (i = 0; i < myClassesLength; i++) {
                if (myClasses[i].indexOf('col') != -1) {
                    return myClasses[i];
                }
            }
        },

        getColNbr: function (myColClass /* String */) {
            // Returns the numeric segment of column class (col1, col2, etc).
            var self = this;

            return myColClass.substr(myColClass.indexOf('col') + 3);
        },

        hideAllMenus: function () {
            // Deactivates all active bodystyles/trims menus/cells.
            var self = this;
            self.log('[Cnt_tbl_fs_2.hideAllMenus] Method starting.');
            $('.controlCell.active').removeClass('active');
            self.el.$ftrsAllMenus.removeClass('active');
            self.el.$ftrsStyleCells.removeClass('active');
            self.el.$ftrsTrimCells.removeClass('active');
            self.el.$capsEngineMenus.removeClass('active');

            self.log('[Cnt_tbl_fs_2.hideAllMenus] All menus hidden.');
        },

        autoHideMenu: function (myEvt) {
            // If a click occurs outside an active menu, deactivate it and its corresponding control cell.
            var self = this;
            self.log('[Cnt_tbl_fs_2.autoHideMenu] Method starting.');
            var myEvtX = myEvt.pageX;
            var myEvtY = myEvt.pageY;
            var $myActiveMenu = $('ul.active');

            function clickIsOutside($myEle) {
                // Checks if click is outside of active menu.

                var myEleOffset = $myEle.offset();
                var myEleLeft = myEleOffset.left;
                var myEleTop = myEleOffset.top;
                var myEleRight = myEleLeft + $myEle.outerWidth();
                var myEleBottom = myEleTop + $myEle.outerHeight();

                self.log('[Cnt_tbl_fs_2.autoHideMenu.clickIsOutside] \n    ' +
                    'Click coords: x=' + myEvtX + ', y=' + myEvtY + ';\n    ' +
                    'Active menu coords: left=' + myEleLeft + ', right=' + myEleRight + ', top=' + myEleTop + ', bottom=' + myEleBottom + '.');

                if (myEvtX <= myEleLeft || myEvtX >= myEleRight || myEvtY <= myEleTop || myEvtY >= myEleBottom) {
                    self.log('[Cnt_tbl_fs_2.autoHideMenu] Click is OUTSIDE active menu. ' + new Date().getTime());
                    return true;
                }
                self.log('[Cnt_tbl_fs_2.autoHideMenu] Click is INSIDE active menu.');
                return false;
            }

            if ($myActiveMenu.length > 0 && clickIsOutside($myActiveMenu)) {
                self.hideAllMenus();
                self.log('[Cnt_tbl_fs_2.autoHideMenu] Hiding active menu.');
            } else {
                self.log('[Cnt_tbl_fs_2.autoHideMenu] No menu to hide.');
            }
        },

        toggleBodystyleMenu: function (myEvt /* DOM event */) {
            // Shows/hides appropriate bodystyle list.
            var self = this;
            self.log('[Cnt_tbl_fs_2.toggleBodystyleMenu] Method starting.');
            var myCell = myEvt.delegateTarget;
            var $myCell = $(myCell);
            var myColClass = self.getColClass($myCell);
            var myColNbr = self.getColNbr(myColClass);
            var myCellBottom = $myCell.offset().top - this.$ctx.offset().top + $myCell.outerHeight();
            var $myMenu = $(self.el.$ftrsStyleMenus[myColNbr - 1]);
            self.log('[Cnt_tbl_fs_2.toggleBodystyleMenu] Clicked control cell column is ' + myColNbr + '. ');

            // Conditionally activate/deactivate menus/cells, based on clicked cell state ('active' classhook).
            if ($myCell.hasClass('active')) {  // If clicked control cell is already active...
                // Deactivate menu and cell.
                $myMenu.removeClass('active');
                $myCell.removeClass('active');
            } else {  // If clicked control cell is inactive...
                // Deactivate any active menus/cells.
                self.hideAllMenus();
                // Activate appropriate menu/cell.
                $myMenu.css('top', myCellBottom).addClass('active');
                $myCell.addClass('active');
                // Destroy any conflict modal.
                self.destroyConflictModal(myColNbr);
            }

            self.log('[Cnt_tbl_fs_2.toggleBodystyleMenu] Configuration menu toggled.  Column ' + myColNbr + '.');
        },

        toggleTrimMenu: function (myEvt /* DOM event */) {
            // Shows/hides appropriate bodystyle list.
            var self = this;
            self.log('[Cnt_tbl_fs_2.toggleTrimMenu] Method starting.');
            var myCell = myEvt.delegateTarget;
            var $myCell = $(myCell);
            var myColClass = self.getColClass($myCell);
            var myColNbr = self.getColNbr(myColClass);
            var myCellBottom = $myCell.offset().top - this.$ctx.offset().top + $myCell.outerHeight();
            var $myMenu = $(self.el.$ftrsTrimMenus[myColNbr - 1]);
            self.log('[Cnt_tbl_fs_2.toggleTrimMenu] Clicked control cell column is ' + myColNbr + '. ');

            // Conditionally activate/deactivate menus/cells, based on clicked cell state ('active' classhook).
            if ($myCell.hasClass('active')) {  // If clicked control cell is already active...
                // Deactivate menu and cell.
                $myMenu.removeClass('active');
                $myCell.removeClass('active');
            } else {  // If clicked control cell is inactive...
                // Deactivate any active menus/cells.
                self.hideAllMenus();
                // Activate appropriate menu/cell.
                $myMenu.css('top', myCellBottom).addClass('active');
                $myCell.addClass('active');
                // Destroy any conflict modal.
                self.destroyConflictModal(myColNbr);
            }

            self.log('[Cnt_tbl_fs_2.toggleTrimMenu] Trim menu toggled. Column: ' + myColNbr + '.');
        },

        toggleEngineMenu: function (myEvt /* DOM event */) {
            // Shows/hides appropriate bodystyle list.
            var self = this;
            self.log('[Cnt_tbl_fs_2.toggleEngineMenu] Method starting.');
            var myCell = myEvt.delegateTarget;
            var $myCell = $(myCell);
            var myColClass = self.getColClass($myCell);
            var myColNbr = self.getColNbr(myColClass);
            var myCellBottom = $myCell.offset().top - this.$ctx.offset().top + $myCell.outerHeight();
            var $myMenu = $(self.el.$capsEngineMenus[myColNbr - 1]);
            self.log('[Cnt_tbl_fs_2.toggleEngineMenu] Clicked control cell column is ' + myColNbr + '. ');

            // Conditionally activate/deactivate menus/cells, based on clicked cell state ('active' classhook).
            if ($myCell.hasClass('active')) {  // If clicked control cell is already active...
                // Deactivate menu and cell.
                $myMenu.removeClass('active');
                $myCell.removeClass('active');
                self.log('[Cnt_tbl_fs_2.toggleEngineMenu] Engine menu hidden. Column: ' + myColNbr + '.');
            } else {  // If clicked control cell is inactive...
                // Deactivate any active menus/cells.
                self.hideAllMenus();
                // Activate appropriate menu/cell.
                $myMenu.css('top', myCellBottom).addClass('active');
                $myCell.addClass('active');
                self.log('[Cnt_tbl_fs_2.toggleEngineMenu] Engine menu shown. Column: ' + myColNbr + '.');
            }
        },

        setDiffClasses: function ($myActiveDiv /* jQuery dom-element */, myCallback /* function */) {
            // Adds 'hasDiffs'/'noDiffs' classhooks to data rows to reflect detailCell values differences/sameness.
            var self = this;
            self.log('[Cnt_tbl_fs_2.setDiffClasses] Method starting.');

            function rowHasDiffs (myRow$ /* Object: jQuery row element. */) {
                // Checks a data row's iconSpan status classhooks ('Standard' | 'Available' | 'NA')
                // and returns true if there's a difference, false if there isn't.
                var myCategory = $.trim(myRow$.attr('data-category'));
                var myRowLabel = $.trim(myRow$.find('th span').html());
                var $mySpans = myRow$.find('td[class*=detailCell] span');
                var mySpansLength = $mySpans.length;
                var myCurrValue = '';
                var myValues = [];
                var myValuesLength = 0;
                var myValuesStr = '';

                // If two or more icon spans exist, check for value difference(s),
                // and if there's a difference return true.
                if (mySpansLength > 1) {
                    $mySpans.each(function (idx, ele) {
                        myCurrValue = $.trim($(ele).html());
                        if (myCurrValue !== '&nbsp;' && myCurrValue !== ' ' && myCurrValue !== '') {
                            myValues.push(myCurrValue);
                            if (myValuesStr.length != 0) {
                                myValuesStr += '\n    ';
                            }
                            myValuesStr += myCurrValue;
                        }
                    });
                    myValuesLength = myValues.length;


                    for (i = 1; i < myValuesLength; i++) {
                        if (myValues[i] !== myValues[0]) {
                            /*self.log('[mrm.mod.Cnt_tbl_fs_2.setDiffClasses] Row has diffs: ' +
                            myCategory + ' - ' + myRowLabel +
                            '\n    ' + myValuesStr);*/
                            return true;
                        }
                    }
                }

                // If only one or no icon span exists, or if all span values are same,
                // return false.
                /*self.log('[mrm.mod.Cnt_tbl_fs_2.setDiffClasses] Row has no diffs: ' +
                    myCategory + ' - ' + myRowLabel +
                        '\n    ' + myValuesStr);*/
                return false;
            }

            if (typeof $myActiveDiv !== 'undefined') {
                $myActiveDiv.find('tr.dataRow').each(function (idx, row) {
                    var $row = $(row);
                    if (rowHasDiffs($row)) {
                        $row.removeClass("noDiffs").addClass('hasDiffs');
                    } else {
                        $row.removeClass("hasDiffs").addClass('noDiffs');
                    }
                });
            } else {
                $('tr.dataRow').each(function (idx, row) {
                    var $row = $(row);
                    if (rowHasDiffs($row)) {
                        $row.removeClass("noDiffs").addClass('hasDiffs');
                    } else {
                        $row.removeClass("hasDiffs").addClass('noDiffs');
                    }
                });
            }

            if (typeof myCallback !== 'undefined') {
                myCallback();
            }

            self.log('[Cnt_tbl_fs_2.setDiffClasses] Diff-classes set.');
        },

        activateDiffs: function () {
            // Activates view-differences-only mode.
            var self = this;
            var myActiveDivId = self.el.$activeDiv.attr('id');

            self.setDiffClasses(self.el.$activeDiv, function () {
                // Expand all sections, then remove 'active' classhook from .dataRow.noDiffs.
                self.expandAllSections(function () {
                    self.el.$activeDiv.find('tr.dataRow.noDiffs').removeClass('active');
                });
            });

            self.viewDiffsActive[myActiveDivId] = true;

            self.log('[Cnt_tbl_fs_2.activateDiffs] View-diffs mode activated.');
        },

        deactivateDiffs: function () {
            // Deactivates view-differences-only mode.
            var self = this;
            var myActiveDivId = self.el.$activeDiv.attr('id');

            // No need to restore 'active' classhook to .dataRow.noDiffs.
            // Collapse all sections and activate previously-selected section.
            self.collapseAllSections();
            self.viewDiffsActive[myActiveDivId] = false;
            self.activateSection(self.selectedSection[myActiveDivId]);
            // Synchronize appropriate corresponding viewdiffsCheckbox.
            // Sticky-nav has its own its own vewdiffsCheckbox2.
            if (!self.el.$tabsDiv.hasClass('stickyNav')) {  // IF NOT in sticky-nav mode...
                self.el.$activeDiv.find('tr.stickyNavRow input[type=checkbox]').prop('checked', false);
            } else {  // IF in sticky-nav mode.
                self.el.$activeDiv.find('tr.controlsRow input[type=checkbox]').prop('checked', false);
            }

            self.log('[Cnt_tbl_fs_2.deactivateDiffs] View-diffs mode deactivated.');
        },

        activateCapsMatrix: function (myEvt) {
            // Displays capabilities matrix.
            // If data-column is not placeholder, display style/engine/drivetype pre-selection.
            var self = this;
            self.log('[Cnt_tbl_fs_2.activateCapsMatrix] Method starting.');
            var $matrixDiv = self.el.$capsMatrixDiv;
            var dataColumn = self.getColNbr(self.getColClass($(myEvt.target).closest('td')));
            var colData = self.columnData[dataColumn - 1];

            $matrixDiv.dialog("open");

            // Remove display of .drivetypeDiv previous selection.
            $matrixDiv.find('.drivetypeDiv.selected').removeClass('selected');

            // Add data-table clicked column classhook.
            $matrixDiv.attr('data-dataTableColumn', dataColumn);

            if (colData.capConfigured) {  // If columnData capabilities are configured...
                // Display current config/engine/drivetype selection.
                var currStyle = colData.config;
                var currEngine = colData.engine;
                var currDriveType = colData.driveType;
                var currMatrixColCls = $matrixDiv.find('.matrixStylesRow')
                    .find('.styleImgDiv[data-bodystyle=' + currStyle + ']')
                    .closest('.matrixStyleCell').attr('class').split(' ')[1];
                var currMatrixRowCls = '';

                // Get MatrixRowCls.
                // CSS data-attribute selectors and string-comparisons break if strings contain <sup> tag.
                $matrixDiv.find('.matrixDrivetypesRow').each(function (idx, ele) {
                    var $currRow = $(ele);
                    var currRowEngineCompare = $currRow.data('engine').replace(/<[a-z]+>[^<]+<\/[a-z]+>/gi, '');
                    var currEngineCompare = currEngine.replace(/<[a-z]+>[^<]+<\/[a-z]+>/gi, '');
                    if (currRowEngineCompare === currEngineCompare) {
                        currMatrixRowCls = $currRow.find('.matrixEngineCell').attr('class').split(' ')[1];
                        return false;
                    }
                });

                $matrixDiv.find('.matrixDrivetypeCell.' + currMatrixColCls + '.' + currMatrixRowCls)
                    .find('.drivetypeDiv[data-drivetype=' + currDriveType + ']')
                    .addClass('selected');
            }

            $matrixDiv.find(".drivetypeDiv").off("click.dataEvents");
            $matrixDiv.find(".drivetypeDiv").on("click.dataEvents", function(){
                // Remove display of .drivetypeDiv previous selection.
                self.el.$capsMatrixDiv.find('.drivetypeDiv.selected').removeClass('selected');

                // Check if JSON AJAX requests have finished
                if (self.capConfigCount === 0) {
                    self.handleCapsMatrix($(this), dataColumn);
                } else {
                    // If not, fire event function after data has loaded
                    $.eventDispatcher.on('capConfigReady', function(){
                        self.handleCapsMatrix($(this), dataColumn);
                    });
                }
            });

            self.log('[Cnt_tbl_fs_2.activateCapsMatrix] Capabilities Matrix activated.');
        },

        deactivateCapsMatrix: function () {
            // Hides capabiltities matrix.
            var self = this;
            var $matrixDiv = self.el.$capsMatrixDiv;
            self.log('[Cnt_tbl_fs_2.deactivateCapsMatrix] Method starting.');

            $matrixDiv.dialog('close');

            // Remove active classhook from data-table's control-cell.
            self.el.$capsControlCells.removeClass('active');

            self.log('[Cnt_tbl_fs_2.deactivateCapsMatrix] Capabilities Matrix deactivated.');
        },

        collapseAllSections: function (myCallback) {
            // Deactivates all active bodystyles/trims menus/cells.
            var self = this;
            self.log('[Cnt_tbl_fs_2.collapseAllSections] Method starting.');
            self.el.$activeDiv.find('tr.sectionRow, tr.subsectionRow, tr.dataRow').removeClass('active');

            if (typeof myCallback !== 'undefined') {
                myCallback();
            }

            self.log('[Cnt_tbl_fs_2.collapseAllSections] All sections collapsed.');
        },

        expandAllSections: function (myCallback) {
            // Activates all sections (for viewdiffs mode).
            var self = this;
            self.log('[Cnt_tbl_fs_2.expandAllSections] Method starting.');

            self.el.$activeDiv.find('tr.sectionRow, tr.subsectionRow, tr.dataRow').addClass('active');

            if (typeof myCallback !== 'undefined') {
                myCallback();
            }

            self.log('[Cnt_tbl_fs_2.expandAllSections] All sections expanded.');
        },

        activateSection: function (myCategory /* String: section row's data-category value */) {
            // Expands data section.
            var self = this;
            self.log('[Cnt_tbl_fs_2.activateSection] Method starting.');
            var myActiveDivId = self.el.$activeDiv.attr('id');

            // Expand section.
            if (!self.viewDiffsActive[myActiveDivId]) {  // IF view-differences-only mode is ON.
                $('tr[data-category="' + myCategory + '"]').addClass('active');
            } else {  // If view-differences-only mode is OFF.
                $('tr[data-category="' + myCategory + '"]').filter(':not(.noDiffs)').addClass('active');
            }

            self.selectedSection[myActiveDivId] = myCategory;

            self.log('[Cnt_tbl_fs_2.activateSection] Section activated: ' + myCategory + '.');
        },

        deactivateSection: function (myCategory /* String: section row's data-category value */) {
            // Collapses data section.
            var self = this;
            self.log('[Cnt_tbl_fs_2.deactivateSection] Method starting.');

            $('tr[data-category="' + myCategory + '"]').removeClass('active');

            self.log('[Cnt_tbl_fs_2.deactivateSection] Section deactivated: ' + myCategory + '.');
        },

        toggleSection: function (myEvt /* Object: Click event */) {
            // Expands/collapses section for clicked section row.
            var self = this;
            self.log('[Cnt_tbl_fs_2.toggleSection] Method starting.');
            var $myTarget = $(myEvt.delegateTarget);
            var myRowIsActive = $myTarget.attr('class').indexOf('active') != -1;
            var myCategory = $myTarget.attr('data-category');

            if (myRowIsActive) {
                self.deactivateSection(myCategory);

                self.log('[Cnt_tbl_fs_2.toggleSection] ' + myCategory + ' collapsed.');
            } else {
                self.activateSection(myCategory);

                self.log('[Cnt_tbl_fs_2.toggleSection] ' + myCategory + ' expanded.');
            }

        },

        preActivateSection: function () {
            // Expands default (1st) data-section if no section/tabdiv deeplink is detected.
            var self = this;
            self.log('[Cnt_tbl_fs_2.preActivateSection] Method starting.');
            var myHash = mrm.util.getHash();
            var $mySectionRow = self.el.$activeDiv.find('tr.sectionRow:first');
            var myCategory = $mySectionRow.attr('data-category');

            if (myHash == '' || myHash.indexOf('Div') != -1) {
                if (self.viewDiffsActive[self.el.$activeDiv.attr('id')]) {
                    self.activateSection(myCategory);
                } else {
                    self.collapseAllSections($.proxy(self.activateSection, self, myCategory));
                }
                self.log('[Cnt_tbl_fs_2.preActivateSection] Section pre-activated: ' + myCategory + '.');
            }
        },

        adjustSectionScroll: function ($mySectionRow /* jQuery dom-element array */) {
            // Adjusts scroll position of deeplink-activated section,
            // so that section-row is in correct vertical position.
            var self = this;
            self.log('[Cnt_tbl_fs_2.adjustSectionScroll] Method starting.');
            var mySectionRowTop = $mySectionRow.offset().top;

            if (self.el.$activeDiv === self.el.$ftrsDiv) {
                var myCtrlsTblBottom = self.el.$ftrsCtrlsTbl.offset().top + self.el.$ftrsCtrlsTbl.height();
            } else {
                var myCtrlsTblBottom = self.el.$capsConfigsTbl.offset().top + self.el.$capsConfigsTbl.height();
            }

            var myScrollBy = Math.round(mySectionRowTop - myCtrlsTblBottom);

            if (myScrollBy !== 0) {
                window.scrollBy(0, myScrollBy);
            }

            self.log('[Cnt_tbl_fs_2.adjustSectionScroll] scroll adjusted: ' + myScrollBy + 'px.');
        },

        switchToContent: function ($mySectionRow /* jQuery DOM-elements-array */) {
            var self = this;
            self.log('[Cnt_tbl_fs_2.switchToContent] Method starting.');
            // AbstractMod method def.
            // Called if a URL hash (e.g. #Mechanical) is detected.

            // Ignore if URL hash is for one of the Features/Capabilities tab-panel divs,
            // in which case the passed $mySectionRow would actually be a div.
            if ($mySectionRow.get(0).nodeName == 'DIV') {
                return false;
            }

            var mySectionId = $mySectionRow.attr('id');
            var myCategory = $mySectionRow.attr('data-category');
            var $myDesiredDiv = $mySectionRow.closest('div.ui-tabs-panel');
            var myDesiredDivId = $myDesiredDiv.attr('id');
            var myDesiredTabIndex = (myDesiredDivId == 'featuresDiv')? 0: 1;
            var myActiveDivId = self.el.$activeDiv.attr('id');

            // Conditionally activate appropriate tab.
            if (myDesiredDivId != myActiveDivId) {
                self.el.$tabsDiv.tabs('select', myDesiredTabIndex);
            }

            // Activate desired section.
            if (typeof mySectionId !== 'undefined') {
                self.collapseAllSections($.proxy(self.activateSection, self, myCategory));
                self.log('[Cnt_tbl_fs_2.switchToContent] Section deeplink: ' + mySectionId + '. ');
            }

            setTimeout($.proxy(self.adjustSectionScroll, self, $mySectionRow), 750);

            self.log('[Cnt_tbl_fs_2.switchToContent] Deeplinking to ' + myCategory + ' category.');
        },

        styleStickyNav: function () {
            // Manipulates DOM elements for sticky-nav mode.
            // Anything that CSS cannot handle for sticky-nav goes in here.
            var self = this;
            self.log('[Cnt_tbl_fs_2.styleStickyNav] Method starting.');

            // Style Return-to-Model-Overview link if it exists.
            var $myMovLink = $('.backToMOV', self.el.$tabsDiv);
            if ($myMovLink.length > 0) {
                // Only Buick has this link right now.
                // If another brand also adds this link, adjust myOffset by brand.
                var myOffset = 370;
                $myMovLink.css('left', (self.el.$tabsDiv.offset().left + myOffset) + 'px');
            }

            self.log('[Cnt_tbl_fs_2.styleStickyNav] Sticky-nav styling completed.');
        },
        unstyleStickyNav: function () {
            // Removes DOM manipulations from sticky-nav mode.
            // Anything that CSS cannot handle for sticky-nav goes in here.
            var self = this;
            self.log('[Cnt_tbl_fs_2.unstyleStickyNav] Method starting.');

            // Unstyle Return-to-Model-Overview link if it exists.
            var $myMovLink = $('.backToMOV', self.el.$tabsDiv);
            if ($myMovLink.length > 0) {
                $myMovLink[0].removeAttribute('style');
            }

            self.log('[Cnt_tbl_fs_2.unstyleStickyNav] Sticky-nav styling removed.');
        },
        adjustMovLink: function () {
            // Update Return-to-MOV link sticky-nav horizontal position (left rule) on window resize.
            var self = this;
            self.log('[Cnt_tbl_fs_2.adjustMovLink] Method starting.');

            // Style Return-to-Model-Overview link if it exists and in stickyNav mode.
            var $myMovLink = $('.backToMOV', self.el.$tabsDiv);
            if ($myMovLink.length > 0 && $myMovLink.closest('.tabsDiv').hasClass('stickyNav')) {
                // Only Buick has this link right now.
                // If another brand also adds this link, adjust myOffset by brand.
                var myOffset = 370;
                $myMovLink.css('left', (self.el.$tabsDiv.offset().left + myOffset) + 'px');
                self.log('[Cnt_tbl_fs_2.adjustMovLink] Return-to-Model-Overview link position adjusted for sticky-nav.');
            }
        },

        checkStickyNavScroll: function (myEvt) {
            var self = this;
            var myScrollTop = $(myEvt.delegateTarget).scrollTop();

            if (myScrollTop >= self.stickyNavStart) {
                if (!self.el.$tabsDiv.hasClass('stickyNav')) {
                    self.el.$tabsDiv.addClass('stickyNav');
                    self.styleStickyNav();
                    if (self.stickyNavReturn === null) {
                        self.stickyNavReturn = $('.sectionRow', self.el.$activeDiv).filter(':eq(0)').offset().top;
                    }
                    self.log('[Cnt_tbl_fs_2.checkStickyNavScroll] Sticky-nav activated.  stickyNavStart = ' + self.stickyNavStart + '; ' +
                        '; stickyNavReturn = ' + self.stickyNavReturn + '.');
                }
            } else if (myScrollTop < self.stickyNavReturn) {
                if (self.el.$tabsDiv.hasClass('stickyNav')) {
                    self.el.$tabsDiv.removeClass('stickyNav');
                    self.unstyleStickyNav();
                    self.log('[Cnt_tbl_fs_2.checkStickyNavScroll] Sticky-nav deactivated.  stickyNavStart = ' + self.stickyNavStart + '; ' +
                        '; stickyNavReturn = ' + self.stickyNavReturn + '.');
                }
            }
        }
    });
})(mrm.$);
(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		cnt_tbl_fs_2: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';						

				//top tab buttons
				$mod.find(".tabItem a").on(clickOrTouch, function () {
					var linkname = $(this).text();
					mrm.util.trackEvent("click_cta", {section : "features and specs", linkname : "tab:" + linkname});
				});
				
				//drive radio buttons
				$mod.find("input.drivetypeRadio").on(clickOrTouch, function () {
					var linkname = $(this).nextAll().find("span.drivetypeSpan").text();
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					mrm.util.trackEvent("click_cta", {section : section, linkname : "drive:" + linkname});
				});
				
				//difference checkbox
				$mod.find("input#ftrsViewdiffsChkbx, input#capsViewdiffsChkbx").on(clickOrTouch, function () {
					var linkname = $(this).nextAll("label").text();
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					mrm.util.trackEvent("click_cta", {section : section, linkname : linkname});
				});

				//body dropdowns
				$("#featuresDiv").on(clickOrTouch, ".bodystyleItem", function () {
					var linkname = $(this).find(".labelP").text();
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					mrm.util.trackEvent("click_cta", {section : section, linkname : "body:" + linkname});
				});

				//trim dropdowns
				$("#featuresDiv").on(clickOrTouch, ".trimItem", function () {
					var linkname = $(this).find(".labelP").text();
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					mrm.util.trackEvent("click_cta", {section : section, linkname : "trim:" + linkname});
				});
				
				//engine dropdowns
				$("#capabilitiesDiv").on(clickOrTouch, ".engineItem", function () {
					var linkname = $(this).find(".labelP").text();
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					mrm.util.trackEvent("click_cta", {section : section, linkname : "engine:" + linkname});
				});
				
				//accordions
				$mod.find(".sectionRow").on(clickOrTouch, function () {
					var linkname = "expand";
					if ($(this).hasClass("active")) {
						linkname = "collapse";
					}
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					var subsect = $(this).attr("id");					
					mrm.util.trackEvent("click_cta", {section : section + ":" + subsect, linkname : linkname});
				});

				//accordion links
				$mod.find(".dataTable .detailsLink").on(clickOrTouch, function () {
					var linkname = $(this).find("span").text();
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					var subsect = $(this).parents(".dataRow").prevAll(".sectionRow").attr("id");
					mrm.util.trackEvent("click_cta", {section : section + ":" + subsect, linkname : "link:" + linkname});
				});	

				//bottom buttons
				$mod.find(".ctasRow a.btn_prim").on(clickOrTouch, function () {
					var linkname = $(this).find("span").text();
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					mrm.util.trackEvent("click_cta", {section : section, linkname : "button:" + linkname});
				});				
				
				//change config links
				$mod.find(".capsConfigsTable a.changeLink").on(clickOrTouch, function () {
					var linkname = $(this).find("span").text().trim();
					var section = $mod.find(".tabsList .tabItem.ui-state-active a").text();
					mrm.util.trackEvent("click_cta", {section : section, linkname : linkname});
				});
				
				//change config matrix table
				$(".matrixTable").on(clickOrTouch, ".matrixDrivetypeCell .drivetypeDiv", function () {
					var linkEngine = $(this).parent().prevAll().find(".engineLabelDiv").text().trim();
					var linkBody = $(".matrixTable .matrixStylesRow ." + $(this).parent().attr("class").substr($(this).parent().attr("class").indexOf("col"), 5).trim() + " .styleLabelDiv span").text().trim();
					var linkDrive = $(this).find(".drivetypeLabelDiv").text().trim();
					mrm.util.trackEvent("click_cta", {section : "modal", linkname : linkEngine + ":" + linkBody + ":" + linkDrive});
				});
			}				
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Cnt_tbl_price_1 = mrm.mod.AbstractMod.extend({

		events: {
		},

		prepare: function() {
			var self = this;
			var label = $.extend({}, mrm.lbl.cnt_tbl_price_1 || {});

			this.$ctx.dyntable({
				colHeadReplaceTxt: label.tx_head || '',
				dropdownLabelTxt: label.lbl || '',
				outsideDropdown: true,
				dynCols: 1
			});
		}
	});
})(mrm.$);;(function($) {
	mrm.mod.Cnt_trim_1 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;

			var $mmScrollContainer = self.$ctx.find('div.mmScroll');
			var $mmScrollList = $mmScrollContainer.find('ul.mmScrollItems');
			var $mmScrollBtns = $mmScrollContainer.find('.mmScrollBtn');
			var $mmScrollListItems = $mmScrollList.children('li');
			var trimCount = $mmScrollList.children('li').length;
			
			$mmScrollListItems.find('dt').equalHeights();
			$mmScrollContainer.addClass('cols' + Math.min(6, trimCount)).mmScroll({
				circular: false,
				infinite: false,
				width: '100%',
				align: 'left',
				animateControls: false,
				items: {
					visible: 5
				},
				onCreate: function() {
					$mmScrollBtns.each(function() {
						$(this).filter('.disabled').hide();
					});
				},
				scroll: {
					fx: 'scroll',
					onBefore: function() {
						$mmScrollBtns.stop(true, true).each(function() {
							var $btn = $(this);
							$btn[$btn.hasClass('disabled') ? 'fadeOut' : 'fadeIn'](1500, 'easeInOutExpo');
						});
					}
				}
			});
			
			$mmScrollListItems.find('dd .tx').equalHeights();
			
			//forcing the polyfill browsers (safari,ie) to redraw
			self.$ctx.find("details").on("deets.opened", function() {
				$(this).addClass("open");
			});
			self.$ctx.find("details").on("deets.closed", function() {
				$(this).removeClass("open");
			});
		}
	});
})(mrm.$);
	+ (function ($) {

		mrm.cmp = mrm.cmp || {};
		
		var filter = {

			'data' : {
				'collection' : [],
				'slider' : {},
				'unit' : {}
			},
			'slide' : {
		
				'elem' : { /* populated at init() with $() element selectors. */ },

				'values' : { /* min and max values. */ },

				'popCollection' : function ( ) { /* populate vehicle bucket. */

					$.each( this.elem['bucket'].children(), function ( i ) {

						var thisElem = $(this);
						filter.data.collection.push({
							'value'		: thisElem.attr('rel'),
							'vehicle'	: thisElem
						});

					});

					this.setMinMax();

				},

				'getSizes' : function ( ) { /* returns integer sizes of elements / performs basic calculations. */
					
					return {
						'div$slider'	: Number( filter.slide.elem['div$sliderWidth'] ),
						'span$slider-l'	: filter.slide.elem['span$slider-l'].width(),
						'span$slider-r'	: filter.slide.elem['span$slider-r'].width(),
						'a$slider'		: /* Math.ceil replaced by */-~( filter.slide.elem['a$slider-l'].width() / 2 ),
						'unit-min'		: Number( filter.data.unit.min ),
						'unit-max'		: Number( filter.data.unit.max ),
						'max+min'		: Number( filter.data.unit.min ) + Number( filter.data.unit.max ),
						'max-min'		: Number( filter.data.unit.max ) - Number( filter.data.unit.min )
					};
					
				},

				'setValue' : function ( v ) {

					var s = this.getSizes();
					v = Number(v);

					if ( filter.data.slider.type === 'range' ) return;

					if ( v > s['unit-max'] ) v = s['unit-max'];
					else if ( v <= 0 ) v = 1;

					v = filter.data.slider.type === 'min-to-max' ? v - 30 : v + 30;

					v = Math.ceil( s['div$slider'] / ( s['unit-max'] / Number(v) ) );

					this.trackClicked({ 'manual' : v });

				},
				
				'setMinMax' : function ( ) { /* set minimum and maximum values for range slider. */

					var
						s		= this.getSizes(),
						ceil	= s['unit-max'] * 10,
						calc	= {
							'min' : Math.ceil( ( s['span$slider-l'] - s['a$slider'] ) * s['max-min'] / s['div$slider'] + s['unit-min'] ),
							'max' : Math.ceil( s['max+min'] - ( s['span$slider-r'] - s['a$slider'] ) * s['max-min'] / s['div$slider'] + s['unit-min'] )
						}
					;

					switch ( filter.data.slider.type ) {

						case 'min-to-max' :
							filter.slide.values.min = calc.min;
							filter.slide.values.max = ceil;
							break;

						case 'max-to-min' :
							filter.slide.values.min = 0;
							filter.slide.values.max = calc.max;
							break;

						case 'range' :
							filter.slide.values.min = calc.min;
							filter.slide.values.max = calc.max;
							break;

					}

					if ( s['span$slider-l'] >= s['div$slider'] || s['span$slider-r'] <= s['a$slider'] * 2 ) {
						filter.slide.values.max = ceil;
					}
					
					filter.slide.activateCollection();
					
				},
				
				'timeout' : function ( d ) { /* sets timeout if slider moves too quick to new resting position. */
					window.setTimeout( function ( ) { if ( d.start > d.end - 10 && d.start < d.move + 10 ) this.setMinMax(); }, 500 );
				},
				
				'sliderMoved' : function ( obj ) {
				
					var
						self			= this,
						elem			= this.elem,
						s				= this.getSizes(),
						range = {
							'start'		: Math.ceil( ( s['span$slider-l'] - s['a$slider'] ) * s['max-min'] / s['div$slider'] + s['unit-min'] ),
							'end'		: Math.ceil( s['max+min'] - ( s['span$slider-r'] - s['a$slider'] ) * s['max-min'] / s['div$slider'] + s['unit-min'] )
						},
						interval = {
							'unit'		: Number( filter.data.unit.min ),
							'px'		: ( /* Math.round replaced by */~~ (0.5 + s['div$slider'] / Number( filter.data.unit.max ) ) < 10 ) ? 10 : /* Math.round replaced by */~~ (0.5 + s['div$slider'] / Number( filter.data.unit.max ) )
						},
						clickedAt		= obj.clickedAt,
						distance		= 0,
						initSliderWidth = s['span$slider-' + obj.lr],
						inRange			= true,
						leftWidth		= 0,
						rightWidth		= 0
					;

					$('html, body').on( 'mousemove', function ( e ) {
						
						e.preventDefault();
						self.timeout({ 'start' : clickedAt, 'end' : e.pageX });
						leftWidth	= elem['span$slider-l'].width();
						rightWidth	= elem['span$slider-r'].width();
						distance	= ( ( obj.lr === 'l' ) ? e.pageX - clickedAt : clickedAt - e.pageX ) + initSliderWidth;
					
						if ( filter.data.slider.type === 'min-to-max' || filter.data.slider.type === 'max-to-min' ) {

							inRange	= ( obj.lr === 'l' ) ? ( ( distance < s['div$slider'] + s['a$slider'] && distance > s['a$slider'] ) ? true : false ) : ( s['div$slider'] - distance > -s['a$slider'] && distance > s['a$slider'] ) ? true : false;
							if ( !inRange ) return;

							elem['span$slider-' + obj.lr].css({ 'width' : distance });
							elem['track'].css({ 'width' : distance });
						
						} else if ( filter.data.slider.type === 'range' ) {
					
							inRange	= ( obj.lr === 'l' ) ? ( ( distance < 775 - s['span$slider-r'] - interval.px ) ? true : false ) : ( s['div$slider'] - distance > s['span$slider-l'] + interval.px ) ? true : false;
							if ( !inRange ) return;
							
							if ( distance > s['a$slider'] && distance < s['div$slider'] ) {
								
								elem['span$slider-' + obj.lr].css({ 'width' : distance });
								elem['track'].css({
									'left'	: leftWidth - s['a$slider'],
									'width' : s['div$slider'] - ( leftWidth + rightWidth ) + ( /* Math.round replaced by */~~ (0.5 + s['a$slider'] * 2 ) )
								});
								
							}
							
						}
						
						self.setMinMax();
							
					}).on( 'mouseup', function ( ) {

						$(this).off('mousemove');
						filter.slide.force = true;
						self.setMinMax();

					});

				},
				
				'trackMoved' : function ( obj ) { /* track dragged. */
					
					if ( filter.data.slider.type !== 'range' ) return;
					
					var
						self		= this,
						elem		= this.elem,
						clickedAt	= obj.clickedAt,
						clickDiff	= { 'left' : 0, 'right' : 0 },
						leftWidth	= filter.slide.elem['span$slider-l'].width(),
						rightWidth	= filter.slide.elem['span$slider-r'].width(),
						inRange		= { 'left' : true, 'right' : true },
						safe		= { 'left' : 0, 'right' : 0, 'leftCount' : 0, 'rightCount' : 0 }
					;

					$('html, body').on( 'mousemove', function ( e ) {
						
						self.timeout({ 'start' : clickedAt, 'end' : e.pageX });
						
						clickDiff = {
							'left'	: leftWidth + ( e.pageX - clickedAt ),
							'right'	: rightWidth - ( e.pageX - clickedAt )
						};
													
						if ( clickDiff.left <= 8 || clickDiff.right <= 8 ) return;
						
						inRange.left = ( filter.slide.elem['a$slider-l'].position().left > 0 );
						inRange.right = ( filter.slide.elem['span$slider-r'].position().left < 770 );

						if ( ! inRange.left ) {
							if ( safe.leftCount++ === 1 ) safe.left = e.pageX;
						} else if ( ! inRange.right ) {
							if ( safe.rightCount++ === 1 ) safe.right = e.pageX;
						}
						
						if ( ( inRange.left || e.pageX >= safe.left ) && ( inRange.right || e.pageX <= safe.right ) ) {
	
							elem['span$slider-l'].css( 'width', clickDiff.left );
							elem['span$slider-r'].css( 'width', clickDiff.right );
							elem['track'].css( 'left', clickDiff.left );
	
						}
							
						self.setMinMax();
												
					}).on( 'mouseup', function ( ) { $(this).off('mousemove'); self.setMinMax(); });
					
				},
				
				'trackClicked' : function ( e ) {

					var
						self	= this,
						elem	= this.elem,
						s		= this.getSizes(),
						slider	= {
							'l' : elem['div$slider'].offset().left
						},
						track	= {
							'l'	: elem['track'].position().left,
							'r'	: elem['track'].position().left + elem['track'].width()
						},
						clickedAt = e.manual || e.offsetX
					;
					
					if ( filter.data.slider.type === 'range' ) {

						var
							lr		= e.pageX - slider.l < track.l ? 'l' : 'r',
							newPos	= lr === 'l' ? clickedAt + s['a$slider'] : s['div$slider'] - ( e.pageX - slider.l ) + ( s['a$slider'] ),
							oldPos	= elem['span$slider-' + lr].width() - newPos,
							left	= lr === 'l' ? newPos : track.l,
							width	= elem['track'].width() + oldPos + 1
						;
								
						if ( e.pageX - slider.l < track.l || e.pageX - slider.l > track.r ) {

							elem['span$slider-' + lr].animate({ 'width' : newPos }, 1000);
							elem['track'].animate({ 'left' : left, 'width' : width }, 1000, function ( ) { filter.slide.setMinMax(); } );

						}

					} else {

						var
							lr = filter.data.slider.type === 'min-to-max' ? 'l' : 'r',
							inRange =
								lr === 'l' ? 
									clickedAt > track['r'] || clickedAt < ( track['r'] - ( s['a$slider'] * 2 ) )
								: lr === 'r' && typeof e.manual !== 'undefined' ?
									true
								: clickedAt < track['l'] || clickedAt > ( track['l'] - ( s['a$slider'] * 2 ) ),
							newPos =
								lr === 'l' ?
									clickedAt + s['a$slider']
								: typeof e.manual !== 'undefined' ?
									s['div$slider'] - clickedAt + s['a$slider']
								: s['div$slider'] - ( e.pageX - slider.l ) + ( s['a$slider'] )
						;

						if ( inRange ) {
	
							elem['span$slider-' + lr].animate({ 'width' : newPos }, 1000);
							elem['track'].animate({ 'width' : newPos }, 1000, function ( ) { filter.slide.setMinMax(); });
							
						}
						
					}
					
				},

				'cursor' : function ( c ) { /* toggles cursor state to open or closed hand icon. */

					if ( c.hasClass('cursor-open') ) {
						c.removeClass('cursor-open').addClass('cursor-close');
					} else {
						c.removeClass('cursor-close').addClass('cursor-open');
					}
					
					c.on( 'mouseup', function ( ) { filter.slide.cursor( $(this) ); } );

				},

				'toggleWrap' : function ( ) { /* animates opening and closing of wrap. */

					var
						self		= this,
						elem		= this.elem,
						wrapOpen	= elem['wrap'].is(':visible'),
						animated	= elem['wrap'].is(':animated')
					;

					if ( ! animated ) {
						elem['header$heading'].find( wrapOpen ? '.closed' : '.open' ).hide();
						elem['header$heading'].find( wrapOpen ? '.open' : '.closed' ).show();
						elem['wrap'].slideToggle(1000);
					}

				},
				
				'activateCollection' : function ( ) { /* animates vehicles in bucket. */

					if ( filter.slide.animating && ! filter.slide.force ) return;

					$.each( filter.data.collection, function ( ) {

						var
							value		= this['value'],
							curOpacity	= this['vehicle'].css('opacity'),
							newOpacity	= value >= filter.slide.values.min && value <= filter.slide.values.max ? '1' : '.1'
						;

						filter.slide.animating = true;
						
						if ( ! this['vehicle'].is(':animated') && curOpacity !== newOpacity ) {
							this['vehicle'].animate({ 'opacity' : newOpacity });
						}

					});
					
					window.setTimeout( function ( ) { filter.slide.animating = false; filter.slide.force = false; }, 500 );
					
				},

				'listeners' : function ( ) {
				
					var
						self	= this,
						elem	= this.elem,
						s		= this.getSizes()
					;

					// toggle module.
					elem['header$heading']
						.on( 'click', function ( ) { self.toggleWrap(); });

					// slider drag.
					elem['a$slider']
						.on( 'click', function ( e ) { e.preventDefault(); e.stopPropagation(); })
						.on( 'mousedown', function ( e ) {
							e.preventDefault();
							self.cursor( $(this) );
							self.sliderMoved({
								'lr'		: ( $(this).hasClass('l') ) ? 'l' : 'r',
								'clickedAt' : e.pageX
							});
						});
					
					// track drag.
					elem['track']
						.on( 'mousedown', function ( e ) {
							e.preventDefault();
							self.cursor( $(this) );
							self.trackMoved({ 'clickedAt' : e.pageX });
						});

					// animate to click.
					elem['div$slider']
						.on( 'click', function ( e ) {
							e.stopPropagation();
							self.trackClicked( e );
						});

					// baseball card selected.
					elem['div$filter']
						.on( 'click', 'article', function ( e ) {
							self.setValue( Number( $(this).attr('rel') ));
						});
					
				}
			
			},
			
			'init' : function ( obj ) {
			
				if ( $('div.modCnt_vehicle_filter_1').length < 1 ) return;
				
				this.slide.elem['div$filter']		= $('div.modCnt_vehicle_filter_1');
				this.slide.elem['header$heading']	= this.slide.elem['div$filter'].children('header');
				this.slide.elem['wrap']				= this.slide.elem['div$filter'].children('section');
				this.slide.elem['div$slider']		= this.slide.elem['div$filter'].find('div.slider');
				this.slide.elem['div$sliderWidth']	= this.slide.elem['div$slider'].width();
				this.slide.elem['bucket']			= this.slide.elem['wrap'].find('section');
				this.slide.elem['track']			= this.slide.elem['div$filter'].find('span.track');
				this.slide.elem['a$slider']			= this.slide.elem['div$filter'].find('a.slider');
				this.slide.elem['a$slider-l']		= this.slide.elem['div$filter'].find('a.slider.l');
				this.slide.elem['a$slider-r']		= this.slide.elem['div$filter'].find('a.slider.r');
				this.slide.elem['a$sliderWidth']	= this.slide.elem['a$slider'].width();
				this.slide.elem['span$slider-l']	= this.slide.elem['a$slider-l'].parent('span');
				this.slide.elem['span$slider-r']	= this.slide.elem['a$slider-r'].parent('span');

				this.data.slider.type				= this.slide.elem['div$filter'].data('type');
				this.data.slider.divisions			= this.slide.elem['div$filter'].data('divisions') || 5;
				this.data.unit.start				= this.slide.elem['div$filter'].data('start') || 0;
				this.data.unit.min					= this.slide.elem['div$filter'].data('min') || 0;
				this.data.unit.max					= this.slide.elem['div$filter'].data('max') || 15000;

				this.slide.elem['a$slider'].attr('hideFocus', 'true').css('outline', 'none'); /* remove ie7 selection outline. */

				this.slide.popCollection();

				this.slide.listeners();

				this.slide.setValue( this.data.unit.start );

			}

		};

		
		$.extend( mrm.cmp, {
			'cnt_vehicle_filter_1' : {
				'tpl' : ['06'],
				'init' : function ( c ) {
					filter.init();
				},
				'toggle' : function () { filter.slide.toggleWrap(); }
			}
		});
		
	})(jQuery);/*
 *  2013 by MRM Worldwide
 */
/*
 * @author Tony.Herford
 * @name javascript
 */
/* PUT IN CONFIG FILE TO CHANGE DEFAULT VALUES
 mrm.conf.cmp.cnt_Well_c2 = mrm.conf.cmp.cnt_Well_c2 || {};
 mrm.$.extend(mrm.conf.cmp.cnt_Well_c2, {
 max_width: 938,
 min_width: 730,
 start_height: 800,
 end_height: 685
 });
 */
(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		cnt_well_2: {
			initMod: function($mod) {
				mrm.util.log("[mrm.cmp.cnt_well_2] Context: " + $mod);

				if (!$('.modCnt_well_2').length)
					return;

				var $cntWell = $mod,
					self = this,
					$scrollItems;

				self.$cntWell = $cntWell;

				mrm.conf.cmp.cnt_Well_c2 = mrm.conf.cmp.cnt_Well_c2 || {};
				self.config = $.extend({
					/* default values */
					max_width: 938,
					min_width: 730,
					start_height: 685,
					end_height: 800
				}, mrm.conf.cmp.cnt_Well_c2 || {});

				// setup the scroller
				$scrollItems = $cntWell.find('.scrollItems');
				$scrollItems.after($('<div class="video-layer" />'));

				var $scroller = $cntWell.find('.mm_scroll, .scroll').first().addClass('mmScroll'),
					$items = $scroller.children('ul').children('li'),
					$videoLayer = $cntWell.find(".video-layer");


				// information for resizing
				// find out if the slide are all images
				$cntWell.data('allImages', $scrollItems.children('li').length === $scroller.find('.fs-content > img.mm').length);
				// find the tallest slide
				var tallest = 0;
				$items.each(function() {
					var $this = $(this);
					if ($this.outerHeight() > tallest)
						tallest = $this.outerHeight();
				});
				// get width
				var currentWidth = $scroller.outerWidth();
				// calculate the ratio
				$cntWell.data('sizeRatio', tallest / currentWidth);
				$cntWell.find(".mmScrollThumbnailPaginationWrp").data('origHeight', $cntWell.find(".mmScrollThumbnailPaginationWrp").outerHeight(true));

				$cntWell.find('img.mm').removeAttr('width height')//.css({'width': '100%','height': 'auto'}); // set height to auto for ie

				// back to top
				$cntWell.on('click', 'div.link.backtotop-text a', self._scrollToTop);


				// no scroller, activate video directly
				if ($scroller.length === 0)
					mrm.corcmp.mmVideo.activateVideo($cntWell);

				if ($items.length <= 0)
					return; // stop if list is empty

				if ($items.length === 1) {
					$scroller.find('.mmScrollBtn').removeClass('.mmScrollBtn').hide();
				} else {
					$scroller.children('span.prev, span.next').addClass('mmScrollBtn');
				}

				// make sure $scroller is visible, otherwise mmScroll() will fail
				if ($scroller.is(':hidden')) {
					return;
				}
				$scroller.data("indexBase", 0);

				var options = {
					height: 'variable',
					responsive: true,
					animateControls: false,
					onCreate: function($items) {
						self._activateScrollerVideo($scroller);
					},
					prev: {
						button: function() {
							return $scroller.find('> .prev');
						}
					},
					next: {
						button: function() {
							return $scroller.find('> .next');
						}
					},
					swipe: true,
					scroll: {
						noWipeDirection: 'vertical',
						onBefore: function($oldItem, $newItem, newSize, duration) {
							if ($videoLayer.length > 0) {
								$videoLayer.css("z-index", $scroller.data("indexBase") - 1);
							}

							var pos = $scroller.find("ul").triggerHandler('currentPosition');
							/* Reset and select the current thumbnail item */
							var $thumbs = $scroller.parent().find('.mmScrollThumbnailPaginationInnerWrp li');
							$thumbs.removeClass('selected');
							$thumbs.parent().find('.thumbnail-item-' + pos).addClass('selected');
							var items = $thumbs.parent().triggerHandler("currentVisible");

							items = items ? items.length : 0;
							/* Move the thumbnail to the right page */
							var page = Math.floor(pos / items);
							$thumbs.parent().trigger('slideToPage', page);

						},
						onAfter: function($oldItem, $newItem, newSize, duration) {
							self._activateScrollerVideo($scroller);
							mrm.corcmp.mmVideo.deactivateVideo($oldItem, $videoLayer);
							$videoLayer.hide();
							$videoLayer.empty();

							// WTF, better check for function-name existance...
							try {
								var newImage = $newItem.find('img').attr('src');
								newImage = newImage.substr(newImage.lastIndexOf('/') + 1);
							} catch (e) {
							}
						}
					}
				};

				// add config options
				options = $.extend(true, options, mrm.conf.cmp.cnt_Well_c2.options || {});

				if ($scroller.hasClass('ui-disable-loop')) {
					options.circular = false;
					options.infinite = false;
				}

				$cntWell.addClass('jsReady');

				// throttling the number of times the resize handler is called
				var throttled = _.throttle(function(e) {
					e.data = {context: self, selector: $cntWell.attr('id')};
					self.winResize(e);
					self._adjust_well_link($cntWell);
				}, 150);
				$(window).bind('resize', throttled);

				// check for images
				if ($cntWell.find('img.mm:eq(0)').length && $cntWell.find('li div[class*="grid_"]').length < 1) {
					$cntWell.find('img.mm:eq(0)').one('load', function(e) {
						e.data = {context: self, selector: $cntWell.attr('id')};
						self.winResize(e);
						self._adjust_well_link($cntWell);
						$scroller.mmScroll(options);
						// Setup thumbnail scroller of thumbnails have been enabled
						if ($cntWell.find(".mmScrollThumbnailPaginationWrp").length > 0) {
							self._setupThumbnailScroller($cntWell, $scroller);
						}
					}).each(function() {
						var $me = $(this);
						if (this.complete) $me.load();
						if (mrm.util.ie()) setTimeout(function(){$me.load()}, 1500);
					});
				} else {
					var e = {};
					e.type = 'load';
					e.currentTarget = $('.scrollItems li:eq(0)')[0];
					e.data = {context: self, selector: $cntWell.attr('id')};
					self.winResize(e);
					self._adjust_well_link($cntWell);
					$scroller.mmScroll(options);
					// Setup thumbnail scroller of thumbnails have been enabled
					if ($cntWell.find(".mmScrollThumbnailPaginationWrp").length > 0) {
						self._setupThumbnailScroller($cntWell, $scroller);
					}
				}
				var cluetipCfg = $.extend({}, mrm.conf.plugin.cluetip || {}, {
					local: true,
					arrows: true,
					sticky: false,
					width: 'auto',
					splitTitle: '',
					cluetipClass: 'cnt_well_2'
				});
				$cntWell.find(".mmScrollThumbnailPaginationWrp li").has('figcaption').cluetipWrap(cluetipCfg);

				/// hide scroll button until all images have been loaded
				//  first check to make sure they are being lazy loaded.
				if ($cntWell.find('img[data-'+mrm.ui.image_loader.src_attribute+']').length) {
					// hide the buttons
					$cntWell.find('.mmScrollBtn').addClass('ui-helper-hidden');
					$cntWell.find(".mmScrollThumbnailPaginationInnerWrp").css('opacity', 0);

					// listen for the image laod event and check to see if all the images have been loaded.
					var listener = $.eventDispatcher.on('image_loaded', function() {
						if ($cntWell.find('img.'+mrm.ui.image_loader.loaded_class).length === $cntWell.find('img[data-'+mrm.ui.image_loader.src_attribute+']').not('.' + mrm.ui.image_loader.onscroll_class).length) {
							// get the buttons remove the hidden class and fade them in
							var buttons = $cntWell.find('.mmScrollBtn');
							buttons.hide();
							buttons.removeClass('ui-helper-hidden');
							buttons.fadeIn();

							$cntWell.find(".mmScrollThumbnailPaginationInnerWrp").animate({opacity:1}, 400);
							// remove listener
							$.eventDispatcher.off(listener);
						}
					});
				}
			},
			thumbId: 0,
			_scrollToTop: function(e) {
				e.preventDefault();
				$("html, body").stop().animate({
					scrollTop: 0
				}, 1000, 'easeOutExpo')
			},
			_setupThumbnailScroller: function($cntWell, $scroller) {
				var self = this;

				var $thumbnailScroll = $cntWell.find(".mmScrollThumbnailPaginationInnerWrp ol").addClass('mmScroll');
				$thumbnailScroll.find('span.prev, span.next').addClass('mmScrollBtn');
				var $thumbnailItems = $thumbnailScroll.find("li");
				var scrollerWidth = $cntWell.find("img").first().width();

				///setup for cluetip
				$thumbnailItems.each(function() {
					var $this = $(this), id = 'thumbCap' + (self.thumbId++);
					var $figCap = $this.find('figcaption').attr('id', id);
					$this.attr('rel', '#' + id + ' p');
				});

				// Setup classes used for communication between large mmScroll and thumbnail mmScroll
				$thumbnailItems.first().addClass("selected");
				$thumbnailItems.each(function(i, val) {
					var $this = $(this);
					$this.addClass("thumbnail-item-" + i);
					/* add onclick event to thumbnail to make the main
					 carousel scroll to the right slide*/

					// check to see if there are is a link
					if($this.find('a').length){
						var $anchor = $this.find('a'),
							url = $anchor.attr('href');
						if(/^#.*?/gi.test(url)){
							// scroll to anchor
							$anchor.on('click', function(e){
								e.preventDefault();
								var offset = ($(url).offset().top) - self.config.scroll_offset;  // value comes from the config file and will change per site.
								$("html, body").stop().animate({
									scrollTop: offset
								}, 1500, 'easeOutExpo');

							});
						}
					}else{
						$this.click(function() {
							$scroller.find("ul").trigger('slideTo', [i, 0, true]);
							return false;
						});
					}
				});

				// mmScroll for thumbnails differs considerably from other mmScroll setups
				var thumbnailOptions = {
					width: '98%',
					align: 'left',
					auto: false,
					infinite: true,
					circular: true,
					swipe: true,
//                    animateControls: {
//                        fx: "none"
//                    },
					prev: {
						button: function() {
							return $(this).parent().prev(".prev")
						}
					},
					next: {
						button: function() {
							return $(this).parent().next(".next")
						}
					}
				};

				if ($scroller.hasClass('ui-disable-loop')) {
					thumbnailOptions.circular = false;
					thumbnailOptions.infinite = false;
				}


				$thumbnailScroll.mrmCarousel(thumbnailOptions);
			},
			_activateScrollerVideo: function($container) {
				var self = this;

				if (!$container || $container.length == 0)
					return;
				// find the deepest visible content-module
				var $deepest = mrm.util.deepest('.ui-helper-visible', $container);
				var $videoLayer = $container.find(".video-layer");
				var $video = $deepest.find("div.video");

				$video.attr('data-height', $video.parent().height());

				mrm.util.doInitVideo($deepest, true, $videoLayer, self.jwpOptions);
				if ($deepest.find("div.video").data("posterclick") === false) {
					$videoLayer.css("z-index", $container.data("indexBase") + 1).show();
				} else {
					$video.on("click", function() {
						$videoLayer.css({"z-index": $container.data("indexBase") + 1, width:$container.find('li').find('.fs-content').width(), height:$container.find('li').find('.fs-content').height()}).show();
						$videoLayer.find('div').css({width:$container.find('li').find('.fs-content').width(), height:$container.find('li').find('.fs-content').height()})
					});
				}
				$videoLayer.closest(".mod").off("mmVideoComplete");
				$videoLayer.closest(".mod").on("mmVideoComplete", function(e) {
					$videoLayer.css("z-index", $container.data("indexBase") - 1).hide();
				})
			},
			winResize: function(e) {
				var winHeight = $(window).height(),
					self = this,
					selector = e ? '' : '#' + self.$cntWell.attr('id');

				if (e) {
					self = e.data.context;
					selector = '#' + e.data.selector;
				}

				var config = self.config,
					winHeight = $(window).height(),
					$fs = $(selector),
					newWidth = 0,
					overlay = false;

				if (winHeight !== +$fs.data('last_window_height') || e.type === 'load') {
//					console.log('resizing', e.type);

					if (winHeight < config.start_height) {
						newWidth = config.min_width;

						if ($fs.data('allImages')) {
							overlay = true;
						}
					} else if (winHeight > config.end_height) {
						newWidth = config.max_width;
					} else {
						var chgHeight = config.end_height - config.start_height;
						var chgWidth = config.max_width - config.min_width;
						var ratio = (winHeight - config.start_height) / chgHeight;
						newWidth = Math.floor(config.min_width + (chgWidth * ratio));
					}

					$fs.width(newWidth);
					$fs.find('.scroll').width(newWidth);

//					if (e.type === 'load') {
//						$fs.find('.fs-content').height(e.currentTarget.height);
//					} else {
						$fs.find('.fs-content').height('auto');
//					}

					var $vidHolder = $fs.find('.fs-content > .video');
					if ($vidHolder.length) {
						$vidHolder.css({width: newWidth, height: 'auto'});
						var vidHolderHeight = $vidHolder.parent().height();

						$vidHolder.attr('data-width', newWidth);
						$vidHolder.attr('data-height', vidHolderHeight);

						$fs.find('.video-layer').css({width: newWidth, height: vidHolderHeight});
						$fs.find('.video-layer>div').css({width: newWidth, height: vidHolderHeight});
					}

					var thumbs = $fs.find('.mmScrollThumbnailPaginationWrp');
					if (overlay) {
						thumbs.addClass('overlay')
					} else {
						thumbs.removeClass('overlay')
					}
					thumbs.width(newWidth);
					$fs.data('last_window_height', winHeight);
				}
			},
			_adjust_well_link: function($well){
				if($well.find('.well_link').length){
					// check for collision
					var $title = $($well.find('.section-title').find('figcaption').find('.txtWrp')[0] || $well.find('.section-title').find('.caption')[0]),
						$all_links = $well.find('.well_link'),
						$well_link = $($all_links[0]),
						$top_link = $well.find('.link.backtotop-text').find('a'),
						titleRight = 0,
						linkLeft = $well.width() - $well_link.outerWidth(true),
						rightPos = 0;
					if($title.length){
						titleRight = $title.position().left + $title.width();
					}

					if(titleRight>linkLeft){
						// check if back to top link exist
						if($top_link.length){
							// calculate the distance from right side
//							rightPos = $top_link.outerWidth(true) + parseInt($top_link.css('right'));
							//$top_link.addClass('ui-helper-hidden')
						}
						// move the button
						$all_links.addClass('displaced');
					}else{
						$all_links.removeAttr('style').removeClass('displaced');
						$top_link.removeClass('ui-helper-hidden')
					}
				}
			}
		}
	});
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		cnt_well_2: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click'

				// back to top link tracking
				$mod.find(".backtotop-text").on(clickOrTouch, function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "back to top"});
				});

				// previous button tracking
				$mod.find(".mmScrollBtn.prev").on(clickOrTouch, function(){
					var photoname = $(this).next().find("img").attr("src");
					if (typeof(photoname) !== "undefined") {
						photoname = photoname.substr( photoname.lastIndexOf('/') + 1 );
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: "arrow:prev:" + photoname});
				});

				// next button tracking
				$mod.find(".mmScrollBtn.next").on(clickOrTouch, function(){
					var photoname = $(this).prevAll().find("ul li").next().find("img").attr("src");
					if (typeof(photoname) !== "undefined") {
						photoname = photoname.substr( photoname.lastIndexOf('/') + 1 );
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: "arrow:next:" + photoname});
				});

				// thumbnail previous button tracking
				$mod.find(".thumbsBtn.prev").on(clickOrTouch, function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "thumb:arrow:prev"});
				});

				// thumbnail next button tracking
				$mod.find(".thumbsBtn.next").on(clickOrTouch, function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "thumb:arrow:next"});
				});

				// thumbnail image tracking
				$mod.find(".mmScrollThumbnailPagination img").on(clickOrTouch, function(){
					var linkname = $(this).attr("src");
					linkname = linkname.substr( linkname.lastIndexOf('/') + 1 );
					mrm.util.trackEvent("click_cta", {section: section, linkname: "thumb:" + linkname});
				});
			}
		}
	});
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		cnt_well_exp_1: {
			tpl: ['05', '06', '08', '10'],
			initMod: function($mod) {
				this.setButtonSize($mod);
				this.setExpandButtons($mod);
			},
			
			/**
			 * Set buttons size for proper centering.
			 */
			setButtonSize: function($mod) {
				// Main button.
				if ($mod.find('.exp-switch.main a span').length > 0) {
					$mod.find('.exp-switch.main').width($mod.find('.exp-switch.main a span').width());
				} else {
					$mod.find('.exp-switch.main a img').load(function() {
						// Load image.
						$(this).parent().parent().width(this.width);
					}).each(function() {
						// Load image from cache.
						$(this).parent().parent().width(this.width);
					});
				}
				
				// Secondary.
				if ($mod.find('.exp-switch.secondary a span').length > 0) {
					$mod.find('.cnt_well_exp').addClass('expanded');
					$mod.find('.exp-switch.secondary').width($mod.find('.exp-switch.secondary a span').width());
					$mod.find('.cnt_well_exp').removeClass('expanded');
				} else {
					$mod.find('.exp-switch.secondary a img').load(function() {
						// Load image.
						$(this).parent().parent().width(this.width);
					}).each(function() {
						// Load image from cache.
						$(this).parent().parent().width(this.width);
					});
				}
			},
			
			/**
			 * Declare button callbacks.
			 */
			setExpandButtons: function($mod) {
				var self = this;
				// Set Expand buttons click.
				$mod.find('.exp-switch a').click(function(_e) {
					var val = $mod.find('.exp-switch.main').offset().top + 100;
					var wrapper = $(this).parent().parent();
					if (wrapper.hasClass('expanding') || wrapper.hasClass('expanded')) {
						if ($(this).find('span').length) {
							var label = wrapper.find('.exp-switch.main span').attr('data-label-expand');
							wrapper.find('.exp-switch.main span').text(label);
						}
						
						// Collapse.
						self.collapse(wrapper.parent(), _e, val);
					} else {
						if ($(this).find('span').length) {
							var label = wrapper.find('.exp-switch.main span').attr('data-label-close');
							wrapper.find('.exp-switch.main span').text(label);
						}
						
						// Expand.
						self.expand(wrapper.parent());
					}
					
					_e.preventDefault();
				});
			},
			
			/**
			 * Expand wrapper.
			 */
			expand: function($mod) {
				this.setButtonSize($mod);
				$mod.find('.cnt_well_exp').addClass('expanding');
				$mod.find('.cnt_well_exp .content-wrapper').slideDown('slow', function() {
					$mod.find('.cnt_well_exp').removeClass('expanding');
					$mod.find('.cnt_well_exp').addClass('expanded');
				});
			},
			
			/**
			 * Collapse wrapper.
			 */
			collapse: function($mod, e, val) {
				this.setButtonSize($mod);
				$mod.find('.cnt_well_exp').removeClass('expanding');
				$mod.find('.cnt_well_exp').removeClass('expanded');
				$mod.find('.cnt_well_exp .content-wrapper').stop().slideUp('fast', function() {
					if (!$(e.currentTarget).parent().hasClass('main')){
						window.scrollTo(0, val);
					}
					$(this).removeAttr('style');
				});
			}
		}
	});
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		colorizer: {
			/**
			 * JS for component mm_1
			 *
			 * @param {String} c DOM Context
			 */
			tpl: ['01', '02', '03', '04', '05', '06', '08', '12', '13', '14'],
			$colorizerModules: null,
			clickOrTouch: null,
			vehicleConfig: null,
			init: function(c)
			{
				var self = this;
				var $colorizerModules = this.$colorizerModules = $('div.modColorizer');
				self.clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				self.vehicleConfig = mrm.conf.util.vehicleConfig || {};

				// don't continue of MH colorizer doesn't exist.
				if (!$colorizerModules.length)
				{
					return;
				}

				var $scrollContainer = $colorizerModules.closest('div.mmScroll'),
						$fadeOutPerScrollerItem = $scrollContainer.find('li.colorizer_view').find('figcaption.legal'),
						$fadeOutAlways = $scrollContainer.closest('.modMh_scroller_1, .modMh_expander_1').children('.modConnect_1'),
						$currentScrollerItem = $(),
						fxCfg = mrm.conf.corcmp.mm_scroller || {},
						modCfg = $.extend({
					animateColorizerItems: true,
					animateControlsForTouch: true
				}, mrm.conf.cmp.colorizer || {});

				fxCfg = fxCfg.animateControls || {};
				fxCfg.speed = fxCfg.speed || 300;

				$colorizerModules.each(function() {
					var $colorizer = $(this),
							$colorLinks = $('ul.colors > li > a', $colorizer),
							colorizerId = $colorizer.attr('id'), //mm_colorizer_c1
							// everything that has to be shown/hidden per colorizer (depending on whether the visible scroller item belongs to the colorizer or not)
							$colorizerToggleItems = $colorizer.add(
							$scrollContainer.children('div.mh_default_content_wrapper.' + colorizerId)
							),
							$colorizerViews = $scrollContainer.find('li.colorizer_view'),
							$colorizerImages = $colorizerViews.find('figure > img'),
							$colorizerLegalTexts = $colorizerViews.find('figcaption'),
							colorizerCfg = mrm.conf.cmp.colorizer || {},
							cluetipCfg = $.extend({}, mrm.conf.plugin.cluetip, colorizerCfg.clueTipSettings);

					if ( colorizerBackgroundImage = $('ul.colors', $colorizer).attr('background-image-url') )
					{
						$colorizerViews.css('background-image', 'url("' + colorizerBackgroundImage + '")');
					}

					$colorLinks.first().closest("li").addClass("active");

					$colorizer.on('colorizerItemChange', function(e, $newItem, $oldItem, duration)
					{
						$currentScrollerItem = $newItem;
						if ($newItem.hasClass(colorizerId)) {
							$colorizerToggleItems.data('activeColorizer', true).fadeIn(duration);
						} else {
							$colorizerToggleItems.data('activeColorizer', false).fadeOut(duration);
						}
					});

					// listen for a vechileConfig object to be loaded.  if one is loaded, try to display the preferred/configured color
					$.eventDispatcher.on('vehicle_config_load', function(e){
							var c = mrm.util.vehicleConfig;
							var color = (c.isConfigured()) ? c.getConfiguredColor() : c.getPreferredColor();
							if(color){
								var thumb = $colorizer.find('li[data-colorid="'+color+'"]');
								if(!thumb.hasClass('active')){
									thumb.find('a').trigger("colorizer-custom-click");
								}
							}
					});

					// bind colorchanger events for the current colorizer
					var fadeOutTimeout;
					if ((typeof $colorLinks.data('events') === 'undefined')
							|| (typeof $colorLinks.data('events').fullPageColorizer === 'undefined'))
					{
						var eventListeners = self.clickOrTouch + " colorizer-custom-click";
						$colorLinks.on(eventListeners , function(e, eventParams)
						{
							eventParams = eventParams || [];
							var $currentLi = $(this).closest('li'),
									imageSource = $currentLi.data('imagesource'),
									newColorCode = $currentLi.data('colorid'),
									activeClass = 'active',
									posColorFileBase,
									currentColorCode,
									newSrc,
									colorFileBase = 'extra.png',
									newColorLabel;

							$currentLi.addClass(activeClass).siblings('.' + activeClass).removeClass(activeClass);

							/* do kung fu for colorizer scroller type 2 */
							if ($scrollContainer.hasClass('ui-scroller-type2') && (typeof(mrm.cmp.mh_1.scrollerType2) === 'object'))
							{
								mrm.cmp.mh_1.scrollerType2.colorizer($currentLi.data('colorpath'));
							}
							else
							{
								$colorizerImages.filter(function() {
									return $(this).parents('.modMh_scroller_1, .modMh_expander_1').has(e.target).length > 0;
								}).attr('src', function(i, oldSrc) {
									var $this = $(this),
										is_lazy = $this.hasClass(mrm.ui.image_loader.onload_class) && $this.is('[data-'+mrm.ui.image_loader.src_attribute+']');

									if (is_lazy) {
										oldSrc = $this.data(mrm.ui.image_loader.src_attribute);
									}

									if (imageSource === 'cgi')
									{
										posColorFileBase = oldSrc.indexOf(colorFileBase);
										currentColorCode = oldSrc.substr(posColorFileBase - 3, 3);
										newSrc = oldSrc.replace(currentColorCode + colorFileBase, newColorCode + colorFileBase);
										newColorLabel = newColorCode;
									}
									else
									{
										if ($currentLi.data("alt")!==undefined && $currentLi.data("alt")!=="") {
											newColorLabel = $currentLi.data('alt');
										} else {
											newColorLabel = $currentLi.data('colorpath').substr(0, $currentLi.data('colorpath').length - 1).split('/').pop();
										}
										newSrc = $currentLi.data('colorpath') + oldSrc.split('/').pop();
									}

									if (is_lazy) {
										$this.data(mrm.ui.image_loader.src_attribute, newSrc);
										return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"
									} else {
										return newSrc;
									}

								}).attr('alt', newColorLabel);
							}

							/* end kung fu */

							$colorizerLegalTexts.html($currentLi.data('text'));
							$colorizerLegalTexts.trigger('initTooltip');
							if ((self.clickOrTouch === 'touchstart') && ($("#cluetip").length > 0))
							{
								$(this).trigger('mouseover');
								clearTimeout(fadeOutTimeout);
								fadeOutTimeout = setTimeout(function()
								{
									$("#cluetip").fadeOut(1000);
								}, 4000);
							}
							// trigger full page colorizer
							// current label

							if (mrm.conf.cmp.colorizer.fullPageColorizer && (eventParams !== 'fromFPCBinding'))
							{
								$(document).trigger('fullPageColorizer', ['mastheadColorizer', newColorLabel]);
							}

							// save the choosen color to the vehicle config as the preferred color IF no configuration is present
							if(self.vehicleConfig.enabled){
								if(!mrm.util.vehicleConfig.isConfigured()){
									//determine if in Ext or Int View???
									//if(int) config.setPreferredIntColor(RPO CODE - get from data-RPO?)
									if(newColorCode && newColorCode != mrm.util.vehicleConfig.getPreferredColor() ){
										mrm.util.vehicleConfig.setPreferredColor(newColorCode);
									}
								}
							}
							return false;
						});

						if (colorizerCfg.useColorTip)
						{
							$colorLinks.on('mouseover', function(e)
							{
								clearTimeout(fadeOutTimeout);
								fadeOutTimeout = setTimeout(function()
								{
									$("#cluetip").fadeOut(1000);
								}, 4500);
							});
							($colorLinks).cluetipWrap(cluetipCfg);
						}
					}

					if ( $colorizer.parents('.modMh_expander_1').length < 1 && modCfg.enableScroller ) {
						self.initScrollableColorizer($colorizer, modCfg.maxVisibleColours, modCfg.scrollerSettings);
					}
				});

				modCfg.animateColorizerItems && $colorizerModules.closest('div.mmScroll').on('showControls hideControls', function(e)
				{
					if (!mrm.util.touchDevice() || (modCfg.animateControlsForTouch && mrm.util.touchDevice()))
					{
						var isShow = e.type === 'showControls';
						$colorizerModules.filter(function()
						{
							return $(this).data('activeColorizer') === true;
						}).stop(true, true)[isShow ? 'slideDown' : 'slideUp'](fxCfg.speed);

						$currentScrollerItem.find($fadeOutPerScrollerItem).add($fadeOutAlways).animate({opacity: isShow ? 1 : 0}, fxCfg.speed);
					}
				});

				// setup full page colorizer engine on MH colorizer and MM_3 colorizers
				if (mrm.conf.cmp.colorizer.fullPageColorizer)
				{

					this.fullPageColorizerBindings();
				}
			},
			fullPageColorizerBindings: function()
			{
				var self = this;

				// Bind full page colorizer event once
				if ((typeof $(document).data('events') === 'undefined') || (typeof $(document).data('events').fullPageColorizer === 'undefined'))
				{
					var fullPageColorizerEventHasFired = false;

					$(document).on('fullPageColorizer', function(e, source, color)
					{

						// Switch MH colorizer color
						if (self.$colorizerModules.length > 0)
						{
							if (source !== 'mastheadColorizer')
							{
								// send fromFPCBinding to call out that the fullPageColorizer has initiated this click, so don't retrigger and end up with a loop
								var tmpArr = $('div.modColorizer li:first').data('colorpath').split('/');
								tmpArr[tmpArr.length - 2] = color;

								$('div.modColorizer li[data-colorpath="' + tmpArr.join('/') + '"] a').trigger(self.clickOrTouch, ['fromFPCBinding']);
							}
						}

						// bind MM_3 full page colorizer listeners
						$('div.modMm_3.ui-colorizer').each(function(index)
						{
							// get path of last image
							var $thisMM3 = $(this),
									$prevImage = $thisMM3.find('img:last');

							if ($prevImage.length > 0)
							{
								// setup if this hasn't been set before
								if (!fullPageColorizerEventHasFired)
								{
									$prevImage.parent().css({position: 'relative', height: $prevImage.height()});
								}

								var $newImage = $("<img>");
								$newImage.fadeTo(0, 0).css({position: 'absolute', left: 0, top: 0});
								$prevImage.after($newImage).css({position: 'absolute', left: 0, top: 0});
								$newImage.load(function()
								{
									//$(this).parent().animate({height:$(this).height()}, 1000);
									$(this).fadeTo(1000, 1, function()
									{
										$thisMM3.find('img').not(':last').remove();
									});
								});
								var prevPath = $prevImage.attr('src');
								var newPathArray = prevPath.split('/');
								newPathArray[newPathArray.length - 2] = color;
								$newImage.attr('src', newPathArray.join('/'));
							}
						});

						fullPageColorizerEventHasFired = true;
						// Save Cookie
						var tmpColorArr = color.split('_');
						tmpColorArr.pop();
						mrm.util.cookie.set('lastColorizer', tmpColorArr.join('_'), {expires: 30, path: '/'});
					});

					// Execute full_page color from cookie if it exists
					if (mrm.util.cookie.get('lastColorizer'))
					{
						var colorToExecute,
								lastColor = mrm.util.cookie.get('lastColorizer');

						for (var i = 0; i < mrm.conf.cmp.colorizer.colorOptions.length; i++)
						{
							var color = mrm.conf.cmp.colorizer.colorOptions[i].name;

							var tmpColorArr = color.split('_');
							tmpColorArr.pop();
							if (tmpColorArr.join('_').toLowerCase() === lastColor.toLowerCase())
							{
								$(document).trigger('fullPageColorizer', ['cookie', color]);
							}
						}
					}
				}
			},
			initScrollableColorizer: function($mod, maxColours, scrollerConfig) {
				if ( $('ul.colors li', $mod).length > maxColours ) {
					if ( !$('ul.colors', $mod).hasClass('mmScrollItems') ) {
						$('ul.colors', $mod).addClass('mmScrollItems');
					}

					$('dd', $mod).addClass('mmScroll').mmScroll(scrollerConfig);
				}
			}
		}
	});
}(mrm.$));(function($) {
    mrm.track = mrm.track || {};
    $.extend(mrm.track, {
        colorizer: {
            initTrack: function($mod, section) {
                clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

                //colorizer chip tracking
                $mod.find("li.color-chip a").on(clickOrTouch, function() {
                    //this condition is here so GMC does not fire tracking twice for exterior view
                    //GMC colorizer tracking in mh_expander_1.all.js
                    if ($("a").parents("div").hasClass("mm_colorizer_c1_threesixty")) {
                        return;
                    } else {
                        colorname = $(this).text();
                        mrm.util.trackEvent("click_cta", {
                            section: 'masthead',
                        	linkname: 'color:' + colorname
                        });
                    }
                });
            }
        }
    });
}(mrm.$));;(function($) {
	mrm.mod.Connect_1 = mrm.mod.AbstractMod.extend({

		options: {
			selector: '.modConnect',
		},

		prepare: function() {
			var self = this;

			if (mrm.conf.util.sharing.socialPrivacy) {
				self.disableTags();
				self.$ctx.find('.deactivatedService').css('display', 'inline-block');
				mrm.util.sharing.initSocialSwitches(self.$ctx);
			}

			if (self.cfg.lazyLoad) {
				mrm.util.sharing.addToLazyLoad('.modConnect_1');
			}

			// only load the libs when we need to activate the sharing-buttons
			if (!mrm.conf.util.sharing.socialPrivacy) {
				mrm.util.sharing.loadTwitter();
				mrm.util.sharing.loadFacebook();
			}
		},

		/**
		 * Disable provider-tags so they are hidden from the the provider-scripts
		 * ex: converts "twitter-follow-button" to "disabled-twitter-follow-button"
		 */
		disableTags: function() {
			this.$ctx.find(' .fb-like, .twitter-follow-button').each(function(i, tag) {
				var $tag = $(tag);
				var cls = $tag.attr('class');
				$tag.attr('class', cls.replace(/(fb-like|twitter-follow-button)/, mrm.conf.util.sharing.disabledProviderTag + "$1"));
			});
		}

	});
})(mrm.$);
(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		connect_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				$('.socialSwitch', $mod).on(clickOrTouch, function() {
					var serviceClass = $(this).parents('.socialPrivacy').attr('class').match(/service[\w\-]*\b/)[0],
					    service = serviceClass.replace('service-', ''),
					    switchState = '';

					if ( $(this).hasClass('on') ) {
						switchState = 'soc_slider_on';
					} else {
						switchState = 'soc_slider_off';
					}

					if ( window.Omniture_s ) {
						mrm.util.tagging.omniture_tl(true, 'social_switch', 'o', '', {
							prop27: 'soc_slider',
							prop32: Omniture_s.pageName + ':' + switchState + ':' + service
						});
					}
				});
			}
		}
	});
}(mrm.$));(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        disclaimer_1: {
            /**
            * JS for component Disclaimer_1
            *
            * @param {String} c DOM Context
            */

            init: function(c) {
                this._initTooltip($('body'));
                this._bindEvents();
            },

            _bindEvents: function() {
                var self = this;

                $('body').on('click', function(event) {
                    self._hideTooltip();
                });
                $('#mds-area-header').on('headerFlyoutOpened', function() {
                    self._hideTooltip();                    
                });
                $('body').on('hideTooltip', function(event) {
                    self._hideTooltip();                    
                }).on('loadBBC', function(event) {
                    self._initTooltip($(event.target));
                }).on('initTooltip', function(event) {
                    self._initTooltip($(event.target));
                });
            },

            _initTooltip: function($container) {
                var $links = $('a.disclaimer_1', $container);
                if ($links.length == 0) return;

                // prepare tooltip-content
                $links.attr('rel', function() {
                    return '|' + $('.modDisclaimer_1 ' + $(this).attr('href')).html();
                });

                // init tooltip
                var config = $.extend(true, {}, mrm.conf.plugin.cluetip, mrm.conf.cmp.disclaimer_1.cluetip);
                $links.cluetipWrap(config);
            },

            _hideTooltip: function() {
                $(document).trigger('hideCluetip');
            }
        }
    });
}(mrm.$));;(function($) {
    mrm.mod.Divisional_logo = mrm.mod.AbstractMod.extend({
	    events: {
	    },
	    prepare: function() {
	        var self = this;
			var $mod = self.$ctx;

            if ($("#mds-area-header.enhanced_navigation").length) {
			    self.sticky_init();
            }
		},
		sticky_init: function () {
			var $topNav = $(".divisional_logo");
			var $navSec = $(".modNav_sec");
            var minTop = $topNav.outerHeight();

            
            $(window).scroll(function () {
                checkScrollPosition();
            });
            $(window).bind("touchmove", function (event) {
                checkScrollPosition();
            });
            $(document).onscroll = function () {
            	checkScrollPosition();
            };
            
            function checkScrollPosition() {
            	// function runs as user scrolls window
            	// will lock nav_anchor_1 in fixed position when scrolling down
            	var winScroll = $(window).scrollTop();

                var yOffset = 0;
                if ($navSec.length) {
            	   // fix nav_sec to top of document (-1 to not show top border)
            	   yOffset = parseInt($navSec.css("border-top-width").replace("px",""));
                }

            	// when component goes from position:relative to position:fixed, need
            	// to keep component's height by adding it to margin in component's parent
            	calcScroll = winScroll - minTop;
            	if ( calcScroll < 0) {
                    $("#mds-area-header").css("top", "-" + winScroll + "px");
                } else {
                    $("#mds-area-header").css("top", "-" + parseInt(minTop + yOffset) + "px");
                }
            }

            // this forces the nav to adjust when refreshing a page that has been scrolled.
            // Otherwise the nav doesn't adjust until the user scrolls
            checkScrollPosition();
        }
	});
})(mrm.$);/*
 * FlashCanvas Pro
 *
 * Copyright (c) 2009      Tim Cameron Ryan
 * Copyright (c) 2009-2011 Shinya Muramatsu
 */
 window.FlashCanvasOptions = {
    swfPath: '/static/cms/all/swf/',
    disableContextMenu: true
};
window.ActiveXObject && !window.CanvasRenderingContext2D && function (j, m) {
    function O(a) {
        this.code = a;
        this.message = ea[a]
    }
    function y(a, b, c) {
        if (!c) {
            c = [];
            for (var d = 0, e = a * b * 4; d < e; ++d) c[d] = 0
        }
        this.width = a;
        this.height = b;
        this.data = c
    }
    function fa(a) {
        this.width = a
    }
    function P(a) {
        this.id = a.I++
    }
    function z(a) {
        this.O = a;
        this.id = a.I++
    }
    function D(a, b) {
        this.canvas = a;
        this.w = b;
        this.f = a.uniqueID;
        this.J();
        this.I = 0;
        this.j = this.H = "";
        this.c = 0
    }
    function E() {
        if (m.readyState === "complete") {
            m.detachEvent(Q, E);
            for (var a = m.getElementsByTagName(u),
            b = 0, c = a.length; b < c; ++b) F.initElement(a[b])
        }
    }
    function R() {
        var a = event.srcElement,
            b = a.parentNode;
        a.blur();
        b.focus()
    }
    function G() {
        event.button & 2 && event.srcElement.parentNode.setCapture()
    }
    function H() {
        event.button & 2 && event.srcElement.parentNode.releaseCapture()
    }
    function S() {
        var a = event.propertyName;
        if (a === "width" || a === "height") {
            var b = event.srcElement,
                c = b[a],
                d = parseInt(c, 10);
            if (isNaN(d) || d < 0) d = a === "width" ? 300 : 150;
            if (c === d) {
                b.style[a] = d + "px";
                b.getContext("2d").P(b.width, b.height)
            } else b[a] = d
        }
    }
    function T() {
        j.detachEvent(U,
        T);
        for (var a in n) {
            var b = n[a],
                c = b.firstChild,
                d;
            for (d in c) if (typeof c[d] === "function") c[d] = k;
            for (d in b) if (typeof b[d] === "function") b[d] = k;
            c.detachEvent(V, R);
            c.detachEvent(I, G);
            b.detachEvent(J, H);
            b.detachEvent(W, S)
        }
        j[X] = k;
        j[Y] = k;
        j[Z] = k;
        j[K] = k;
        j[$] = k
    }
    function ga() {
        var a = m.getElementsByTagName("script");
        a = a[a.length - 1];
        return m.documentMode >= 8 ? a.src : a.getAttribute("src", 4)
    }
    function ha(a) {
        return a.toLowerCase()
    }
    function g(a) {
        throw new O(a);
    }
    function aa(a) {
        var b = parseInt(a.width, 10),
            c = parseInt(a.height,
            10);
        if (isNaN(b) || b < 0) b = 300;
        if (isNaN(c) || c < 0) c = 150;
        a.width = b;
        a.height = c
    }
    var k = null,
        u = "canvas",
        X = "CanvasRenderingContext2D",
        Y = "CanvasGradient",
        Z = "CanvasPattern",
        K = "FlashCanvas",
        $ = "G_vmlCanvasManager",
        V = "onfocus",
        I = "onmousedown",
        J = "onmouseup",
        W = "onpropertychange",
        Q = "onreadystatechange",
        U = "onunload",
        q;
    try {
        q = (new ActiveXObject("ShockwaveFlash.ShockwaveFlash")).GetVariable("$version").match(/[\d,]+/)[0].replace(/,/g, ".")
    } catch (ia) {
        q = 0
    }
    var r = j[K + "Options"] || {}, ba = r.swfPath || ga().replace(/[^\/]+$/, ""),
        x;
    x = parseInt(q) > 9 ? ba + "flash10canvas.swf" : ba + "flash9canvas.swf";
    var A = {}, B = {}, ca = {}, L = {}, v = {}, da = {}, n = {}, C = {}, l = {
        C: "turbo" in r ? r.turbo : 1,
        B: r.delay || 0,
        M: r.disableContextMenu || 0,
        N: r.imageCacheSize || 100,
        D: r.usePolicyFile || 0
    };
    if (q === "10.1.53.64") {
        l.C = 0;
        l.B = 30
    }
    D.prototype = {
        save: function () {
            this.e(15);
            this.L.push([this.l, this.m, this.v, this.k, this.p, this.n, this.o, this.q, this.t, this.u, this.r, this.s, this.j, this.z, this.A]);
            this.a.push("B")
        },
        restore: function () {
            var a = this.L;
            if (a.length) {
                a = a.pop();
                this.globalAlpha = a[0];
                this.globalCompositeOperation = a[1];
                this.strokeStyle = a[2];
                this.fillStyle = a[3];
                this.lineWidth = a[4];
                this.lineCap = a[5];
                this.lineJoin = a[6];
                this.miterLimit = a[7];
                this.shadowOffsetX = a[8];
                this.shadowOffsetY = a[9];
                this.shadowBlur = a[10];
                this.shadowColor = a[11];
                this.font = a[12];
                this.textAlign = a[13];
                this.textBaseline = a[14]
            }
            this.a.push("C")
        },
        scale: function (a, b) {
            this.a.push("D", a, b)
        },
        rotate: function (a) {
            this.a.push("E", a)
        },
        translate: function (a, b) {
            this.a.push("F", a, b)
        },
        transform: function (a, b, c, d, e, f) {
            this.a.push("G",
            a, b, c, d, e, f)
        },
        setTransform: function (a, b, c, d, e, f) {
            this.a.push("H", a, b, c, d, e, f)
        },
        createLinearGradient: function (a, b, c, d) {
            isFinite(a) && isFinite(b) && isFinite(c) && isFinite(d) || g(9);
            this.a.push("M", a, b, c, d);
            return new z(this)
        },
        createRadialGradient: function (a, b, c, d, e, f) {
            isFinite(a) && isFinite(b) && isFinite(c) && isFinite(d) && isFinite(e) && isFinite(f) || g(9);
            if (c < 0 || f < 0) g(1);
            this.a.push("N", a, b, c, d, e, f);
            return new z(this)
        },
        createPattern: function (a, b) {
            a || g(17);
            var c = a.tagName,
                d, e, f, h = this.f;
            if (c) {
                c = c.toLowerCase();
                if (c === "img") d = a.getAttribute("src", 2);
                else if (c === u) {
                    e = this.G(a);
                    f = a !== this.canvas
                } else if (c === "video") return;
                else g(17)
            } else if (a.src) d = a.src;
            else g(17);
            b === "repeat" || b === "no-repeat" || b === "repeat-x" || b === "repeat-y" || b === "" || b === k || g(12);
            if (!e) {
                e = B[h][d];
                if (f = e === void 0) e = this.F(d)
            }
            this.a.push("O", e, b);
            if (f && A[h]) {
                this.g();
                ++v[h]
            }
            return new P(this)
        },
        clearRect: function (a, b, c, d) {
            this.a.push("X", a, b, c, d);
            this.b || this.d();
            this.c = 0
        },
        fillRect: function (a, b, c, d) {
            this.e(1);
            this.a.push("Y", a, b, c, d);
            this.b || this.d();
            this.c = 0
        },
        strokeRect: function (a, b, c, d) {
            this.e(6);
            this.a.push("Z", a, b, c, d);
            this.b || this.d();
            this.c = 0
        },
        beginPath: function () {
            this.a.push("a")
        },
        closePath: function () {
            this.a.push("b")
        },
        moveTo: function (a, b) {
            this.a.push("c", a, b)
        },
        lineTo: function (a, b) {
            this.a.push("d", a, b)
        },
        quadraticCurveTo: function (a, b, c, d) {
            this.a.push("e", a, b, c, d)
        },
        bezierCurveTo: function (a, b, c, d, e, f) {
            this.a.push("f", a, b, c, d, e, f)
        },
        arcTo: function (a, b, c, d, e) {
            e < 0 && isFinite(e) && g(1);
            this.a.push("g", a, b, c, d, e)
        },
        rect: function (a, b, c, d) {
            this.a.push("h",
            a, b, c, d)
        },
        arc: function (a, b, c, d, e, f) {
            c < 0 && isFinite(c) && g(1);
            this.a.push("i", a, b, c, d, e, f ? 1 : 0)
        },
        fill: function () {
            this.e(1);
            this.a.push("j");
            this.b || this.d();
            this.c = 0
        },
        stroke: function () {
            this.e(6);
            this.a.push("k");
            this.b || this.d();
            this.c = 0
        },
        clip: function () {
            this.a.push("l")
        },
        isPointInPath: function (a, b) {
            this.a.push("m", a, b);
            return this.g() === "true"
        },
        fillText: function (a, b, c, d) {
            this.e(9);
            this.h.push(this.a.length + 1);
            this.a.push("r", a, b, c, d === void 0 ? Infinity : d);
            this.b || this.d();
            this.c = 0
        },
        strokeText: function (a,
        b, c, d) {
            this.e(10);
            this.h.push(this.a.length + 1);
            this.a.push("s", a, b, c, d === void 0 ? Infinity : d);
            this.b || this.d();
            this.c = 0
        },
        measureText: function (a) {
            var b = C[this.f];
            try {
                b.style.font = this.font
            } catch (c) {}
            b.innerText = a.replace(/[ \n\f\r]/g, "\t");
            return new fa(b.offsetWidth)
        },
        drawImage: function (a, b, c, d, e, f, h, i, s) {
            a || g(17);
            var o = a.tagName,
                t, p, M, w = arguments.length,
                N = this.f;
            if (o) {
                o = o.toLowerCase();
                if (o === "img") t = a.getAttribute("src", 2);
                else if (o === u) {
                    p = this.G(a);
                    M = a !== this.canvas
                } else if (o === "video") return;
                else g(17)
            } else if (a.src) t = a.src;
            else g(17);
            if (!p) {
                p = B[N][t];
                if (M = p === void 0) p = this.F(t)
            }
            this.e(0);
            if (w === 3) this.a.push("u", w, p, b, c);
            else if (w === 5) this.a.push("u", w, p, b, c, d, e);
            else if (w === 9) {
                if (d === 0 || e === 0) g(1);
                this.a.push("u", w, p, b, c, d, e, f, h, i, s)
            } else return;
            if (M && A[N]) {
                this.g();
                ++v[N]
            } else this.b || this.d();
            this.c = 0
        },
        createImageData: function (a, b) {
            var c = Math.ceil;
            if (arguments.length === 2) {
                isFinite(a) && isFinite(b) || g(9);
                if (a === 0 || b === 0) g(1)
            } else {
                a instanceof y || g(9);
                b = a.height;
                a = a.width
            }
            a = c(a < 0 ? -a : a);
            b = c(b < 0 ? -b : b);
            return new y(a,
            b)
        },
        getImageData: function (a, b, c, d) {
            isFinite(a) && isFinite(b) && isFinite(c) && isFinite(d) || g(9);
            if (c === 0 || d === 0) g(1);
            this.a.push("w", a, b, c, d);
            a = this.g();
            c = typeof JSON === "object" ? JSON.parse(a) : m.documentMode ? eval(a) : a.slice(1, -1).split(",");
            a = c.shift();
            b = c.shift();
            return new y(a, b, c)
        },
        putImageData: function (a, b, c, d, e, f, h) {
            a instanceof y || g(17);
            isFinite(b) && isFinite(c) || g(9);
            var i = arguments.length,
                s = a.width,
                o = a.height,
                t = a.data;
            if (i === 3) this.a.push("x", i, s, o, t.toString(), b, c);
            else if (i === 7) {
                isFinite(d) && isFinite(e) && isFinite(f) && isFinite(h) || g(9);
                this.a.push("x", i, s, o, t.toString(), b, c, d, e, f, h)
            }
            this.b || this.d();
            this.c = 0
        },
        J: function () {
            this.globalAlpha = this.l = 1;
            this.globalCompositeOperation = this.m = "source-over";
            this.fillStyle = this.k = this.strokeStyle = this.v = "#000000";
            this.lineWidth = this.p = 1;
            this.lineCap = this.n = "butt";
            this.lineJoin = this.o = "miter";
            this.miterLimit = this.q = 10;
            this.shadowBlur = this.r = this.shadowOffsetY = this.u = this.shadowOffsetX = this.t = 0;
            this.shadowColor = this.s = "rgba(0, 0, 0, 0.0)";
            this.font = this.j = "10px sans-serif";
            this.textAlign = this.z = "start";
            this.textBaseline = this.A = "alphabetic";
            this.a = [];
            this.L = [];
            this.i = [];
            this.h = [];
            this.b = k;
            this.K = 1
        },
        e: function (a) {
            var b = this.a,
                c;
            if (this.l !== this.globalAlpha) b.push("I", this.l = this.globalAlpha);
            if (this.m !== this.globalCompositeOperation) b.push("J", this.m = this.globalCompositeOperation);
            if (this.t !== this.shadowOffsetX) b.push("T", this.t = this.shadowOffsetX);
            if (this.u !== this.shadowOffsetY) b.push("U", this.u = this.shadowOffsetY);
            if (this.r !== this.shadowBlur) b.push("V",
            this.r = this.shadowBlur);
            if (this.s !== this.shadowColor) {
                c = this.s = this.shadowColor;
                ("" + c).indexOf("%") > 0 && this.i.push(b.length + 1);
                b.push("W", c)
            }
            if (a & 1) if (this.k !== this.fillStyle) {
                c = this.k = this.fillStyle;
                if (typeof c === "object") c = c.id;
                else("" + c).indexOf("%") > 0 && this.i.push(b.length + 1);
                b.push("L", c)
            }
            if (a & 2) if (this.v !== this.strokeStyle) {
                c = this.v = this.strokeStyle;
                if (typeof c === "object") c = c.id;
                else("" + c).indexOf("%") > 0 && this.i.push(b.length + 1);
                b.push("K", c)
            }
            if (a & 4) {
                if (this.p !== this.lineWidth) b.push("P", this.p = this.lineWidth);
                if (this.n !== this.lineCap) b.push("Q", this.n = this.lineCap);
                if (this.o !== this.lineJoin) b.push("R", this.o = this.lineJoin);
                if (this.q !== this.miterLimit) b.push("S", this.q = this.miterLimit)
            }
            if (a & 8) {
                if (this.j !== this.font) {
                    a = C[this.f].offsetHeight;
                    this.h.push(b.length + 2);
                    b.push("o", a, this.j = this.font)
                }
                if (this.z !== this.textAlign) b.push("p", this.z = this.textAlign);
                if (this.A !== this.textBaseline) b.push("q", this.A = this.textBaseline);
                if (this.H !== this.canvas.currentStyle.direction) b.push("1", this.H = this.canvas.currentStyle.direction)
            }
        },
        d: function () {
            var a = this;
            a.b = setTimeout(function () {
                if (v[a.f]) a.d();
                else {
                    a.b = k;
                    a.g(l.C)
                }
            }, l.B)
        },
        Q: function () {
            clearTimeout(this.b);
            this.b = k
        },
        g: function (a) {
            var b, c, d, e = this.i,
                f = this.h,
                h = this.a,
                i = this.w;
            if (h.length) {
                this.b && this.Q();
                if (a) {
                    b = 0;
                    for (c = e.length; b < c; ++b) {
                        d = e[b];
                        h[d] = encodeURI(h[d])
                    }
                    b = 0;
                    for (c = f.length; b < c; ++b) {
                        d = f[b];
                        h[d] = encodeURIComponent(h[d])
                    }
                } else {
                    b = 0;
                    for (c = f.length; b < c; ++b) {
                        d = f[b];
                        h[d] = ("" + h[d]).replace(/&/g, "&amp;").replace(/</g, "&lt;")
                    }
                }
                b = h.join("\u0001");
                this.a = [];
                this.i = [];
                this.h = [];
                if (a) {
                    i.flashvars = "c=" + b;
                    i.width = i.clientWidth + this.K;
                    this.K ^= -2
                } else return i.CallFunction('<invoke name="executeCommand" returntype="javascript"><arguments><string>' + b + "</string></arguments></invoke>")
            }
        },
        P: function (a, b) {
            this.g();
            this.J();
            if (a > 0) this.w.width = a;
            if (b > 0) this.w.height = b;
            this.a.push("2", a, b);
            this.b || this.d();
            this.c = 0
        },
        G: function (a) {
            var b = a.uniqueID,
                c = u + ":" + b;
            if (a.width === 0 || a.height === 0) g(11);
            if (b !== this.f) {
                a = n[b].getContext("2d");
                if (!a.c) {
                    b = ++da[b];
                    c += ":" + b;
                    a.a.push("3", b);
                    a.b || a.d();
                    a.c = 1
                }
            }
            return c
        },
        F: function (a) {
            var b = this.f,
                c = B[b],
                d = ca[b],
                e = c[a] = L[b]++;
            if (e >= l.N - 1) L[b] = 0;
            e in d && delete c[d[e]];
            this.h.push(this.a.length + 2);
            this.a.push("5", e, a);
            d[e] = a;
            return e
        }
    };
    z.prototype = {
        addColorStop: function (a, b) {
            if (isNaN(a) || a < 0 || a > 1) g(1);
            var c = this.O,
                d = this.id;
            ("" + b).indexOf("%") > 0 && c.i.push(c.a.length + 3);
            c.a.push("y", d, a, b)
        }
    };
    O.prototype = Error();
    var ea = {
        1: "INDEX_SIZE_ERR",
        9: "NOT_SUPPORTED_ERR",
        11: "INVALID_STATE_ERR",
        12: "SYNTAX_ERR",
        17: "TYPE_MISMATCH_ERR",
        18: "SECURITY_ERR"
    }, F = {
        initElement: function (a) {
            if (a.getContext) return a;
            var b = a.uniqueID,
                c = "external" + b;
            A[b] = 0;
            B[b] = {};
            ca[b] = [];
            L[b] = 0;
            v[b] = 1;
            da[b] = 0;
            aa(a);
            a.innerHTML = '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" codebase="' + location.protocol + '//fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" width="100%" height="100%" id="' + c + '"><param name="allowScriptAccess" value="always"><param name="flashvars" value="id=' + c + '"><param name="wmode" value="transparent"></object><span style="margin:0;padding:0;border:0;display:inline-block;position:static;height:1em;overflow:visible;white-space:nowrap"></span>';
            n[b] = a;
            var d = a.firstChild;
            C[b] = a.lastChild;
            var e = m.body.contains;
            if (e(a)) d.movie = x;
            else var f = setInterval(function () {
                if (e(a)) {
                    clearInterval(f);
                    d.movie = x
                }
            }, 0);
            if (m.compatMode === "BackCompat" || !j.XMLHttpRequest) C[b].style.overflow = "hidden";
            var h = new D(a, d);
            a.getContext = function (i) {
                return i === "2d" ? h : k
            };
            a.toDataURL = function (i, s) {
                if (a.width === 0 || a.height === 0) return "data:,";
                ("" + i).replace(/[A-Z]+/g, ha) === "image/jpeg" ? h.a.push("A", i, typeof s === "number" ? s : "") : h.a.push("A", i);
                return h.g().slice(1, -1)
            };
            d.attachEvent(V,
            R);
            if (l.M) {
                d.attachEvent(I, G);
                a.attachEvent(J, H)
            }
            l.D && h.a.push("4", "usePolicyFile", l.D);
            return a
        },
        saveImage: function (a) {
            a.firstChild.saveImage()
        },
        setOptions: function (a) {
            for (var b in a) {
                var c = a[b];
                switch (b) {
                    case "turbo":
                        l.C = c;
                        break;
                    case "delay":
                        l.B = c;
                        break;
                    case "disableContextMenu":
                        var d = l.M = c;
                        c = void 0;
                        for (c in n) {
                            var e = n[c],
                                f = d ? "attachEvent" : "detachEvent";
                            e.firstChild[f](I, G);
                            e[f](J, H)
                        }
                        break;
                    case "imageCacheSize":
                        l.N = c;
                        break;
                    case "usePolicyFile":
                        d = b;
                        c = l.D = c ? 1 : 0;
                        e = void 0;
                        for (e in n) {
                            f = n[e].getContext("2d");
                            f.h.push(f.a.length + 2);
                            f.a.push("4", d, c)
                        }
                }
            }
        },
        trigger: function (a, b) {
            n[a].fireEvent("on" + b)
        },
        unlock: function (a, b) {
            v[a] && --v[a];
            if (b) {
                var c = n[a],
                    d = c.firstChild,
                    e, f;
                aa(c);
                e = c.width;
                f = c.height;
                c.style.width = e + "px";
                c.style.height = f + "px";
                if (e > 0) d.width = e;
                if (f > 0) d.height = f;
                d.resize(e, f);
                c.attachEvent(W, S);
                A[a] = 1
            }
        }
    };
    m.createElement(u);
    m.createStyleSheet().cssText = u + "{display:inline-block;overflow:hidden;width:300px;height:150px}";
    m.readyState === "complete" ? E() : m.attachEvent(Q, E);
    j.attachEvent(U, T);
    if (x.indexOf(location.protocol + "//" + location.host + "/") === 0) {
        q = new ActiveXObject("Microsoft.XMLHTTP");
        q.open("GET", x, false);
        q.send(k)
    }
    j[X] = D;
    j[Y] = z;
    j[Z] = P;
    j[K] = F;
    j[$] = {
        init: function () {},
        init_: function () {},
        initElement: F.initElement
    }
}(window, document);(function($)
{
	$.extend(true, mrm.cmp, {
		hmc_1 : {
			/**
			 * JS for component hmc_1
			 * 
			 * @param {String}
			 *            c DOM Context
			 */
			
			filters : {},
			$segmentFilter : null,
			$sortingSelect : null,

			init : function(c)
			{
				this.$ctx = $('.modHmc_1');
				if( !this.$ctx.length ) return;
				
				this.$segmentFilter = this.$ctx.find('.hmc_segment_filter_1');
				this.$sortingSelect = this.$ctx.find('.hmc_sort_1 select');
				

				_.each(this.$ctx.find('.hmc_filter_1'), function(filter)
				{
					var $filter = $(filter);
					
					var $slider = $filter.find('.slider');
					if( $slider.length )
					{
						this.initSlider($slider);
					}
					
					var $buttonGroup = $filter.find('.button-group');
					if( $buttonGroup.length )
					{
						this.initButtonGroup($buttonGroup);
					}
				}, this);
				
				this.initSegmentFilter();
				
				this.$sortingSelect.on('change', $.proxy(this.onSortingChange, this));
				
				$.eventDispatcher.on('HMC_changeMode', $.proxy(function(event, data){
					this.$ctx.toggle(data.mode === 'choose');
				}, this));
				
				/**
				 * defer is used to take care that other modules are initialized when event are triggered
				 */ 
				_.defer($.proxy(function(){
					this.$sortingSelect.trigger('change');
					$.eventDispatcher.trigger('HMC_filterComplete', this.filters);
					$.eventDispatcher.trigger('HMC_changeMode', { mode: 'choose'});
				}, this));
				
				this.$ctx.addClass('jsReady');
				
				if( this.$ctx.closest('div.masthead').length )
				{
					this.$ctx.css('margin-top', function (val) {
						return '-' + $(this).height() + 'px'; }
					);
				}
			},

			initSlider : function($slider)
			{
				var self = this;
				var config = $slider.data('filter');
				var $valueDisplay = $slider.siblings('div.values');
				var sliderSetup = {
					range : config.sliderType == 'range' || (config.sliderType == 'maxToMin' ? 'min' : 'max'),
					min : config.minValue,
					max : config.maxValue,
					step : config.sliderIncrement,
					create : function(e, ui)
					{
						self.onSliderCreate($(this), $valueDisplay);
					},
					stop : function(e, ui)
					{
						self.onSliderStop($(this), $valueDisplay, ui);
					},
					slide : function(e, ui)
					{
						self.onSliderSlide($(this), $valueDisplay, ui);
					}
				};

				if( sliderSetup.range !== true )
				{
					sliderSetup.value = sliderSetup[sliderSetup.range === 'min' ? 'max' : 'min'];
				}
				else
				{
					sliderSetup.values = [ sliderSetup['min'], sliderSetup['max'] ];
				}

				$slider.slider(sliderSetup);
			},
			
			onSliderCreate : function($slider, $valueDisplay)
			{
				var values = [ $slider.slider('values', 0) ];

				if( $slider.slider('option', 'range') === true )
				{
					values.push($slider.slider('values', 1));
				}

				$slider.data('lastValues', values);

				var filterData = $slider.data('filter');
				this.displaySliderValues($valueDisplay, values, filterData);
				
				this.filters[filterData.attributeId] = {
					type : 'range',
					params : this.getFilterRangeData($slider, values)
				};
			},

			onSliderSlide : function($slider, $valueDisplay, ui)
			{
				var values = ui.values || [ ui.value ];
				var filterData = $slider.data('filter');

				this.displaySliderValues($valueDisplay, values, filterData);

				this.filters[filterData.attributeId] = {
					type : 'range',
					params : this.getFilterRangeData($slider, values)
				};
				
				$.eventDispatcher.trigger('HMC_filterChange', this.filters);
			},

			onSliderStop : function($slider, $valueDisplay, ui)
			{
				var values = ui.values || [ ui.value ];
				var filterData = $slider.data('filter');

				window.clearTimeout(this.slideTimeoutId);
				
				this.filters[filterData.attributeId] = {
					type : 'range',
					params : this.getFilterRangeData($slider, values)
				};
				
				$.eventDispatcher.trigger('HMC_filterComplete', this.filters);
			},

			initSegmentFilter: function()
		   {
			this.$segmentFilter.on('change', $.proxy(this.onSegmentChange, this));
			
			var preselectedSegments = (mrm.util.getUrlParam('segments') || '').split(',');
			
			// TODO select preselected segments
			// for now preselect 'all' by triggering onSegmentChange
			if(preselectedSegments == '') {
			 if (this.$segmentFilter.find('.checked'))//Check if exists a default option
			 {
			   if($('html').hasClass('msie8')){
				 $(window).load(function () {
				  $('.hmc_segment_filter_1').find('li.checked').find('span').click(); 
				 });     
			   }
			   else{
				 $(window).load(function () {
				  $('.hmc_segment_filter_1').find('li.checked').find('*').click(); 
				 });
			   }
			 }
			 else
			 {
			  this.$segmentFilter.find('.showAll').trigger('change'); 
			 }
		
			} 
		   },
			
			onSegmentChange : function(event)
			{
				var $target = $(event.target);
				
				// Omniture
				if (window.Omniture_s) {
					var pageName = Omniture_s.pageName;
					mrm.util.tagging.omniture_tl (
					$target, $target.parent().find('label').text(), 'o', 'my_toggle',
						{
							'pageName':pageName,
							'prop27':'model year toggle',
							'prop32':pageName+':model year toggle:'+$target.parent().find('label').text()
						}
					);
				}

				if( $target.is('.showAll') )
				{
					$target.prop('checked', true).checkBox('update');
					this.$segmentFilter.find(':checkbox:not(.showAll)').prop('checked', false).checkBox('update');
					delete this.filters.segment;
					
					$target.parent('li')
					.addClass('checked')
					.siblings().removeClass('checked');
				}
				else
				{
					this.$segmentFilter.find('.showAll').prop('checked', false).checkBox('update').parent('li').removeClass('checked');
					
					var $checked = this.$segmentFilter.find(':checkbox:not(.showAll):checked');
					
					var list = _.map($checked, function(item){
						return $(item).val();
					}, this);
					
					if( list.length )
					{
						this.filters.segment = {
							type : 'segment',
							list : list
						};
					}
					else
					{
						delete this.filters.segment;
					}
					
					$target.parent().parent().find('li.checked').removeClass('checked');
					$checked.parent('li').addClass('checked');
				}
				
				
				
				$.eventDispatcher.trigger('HMC_filterComplete', this.filters);
			},
			
			initButtonGroup : function($buttonGroup)
			{
				$buttonGroup.on('click', $.proxy(this.onButtonGroupClick, this));
			},
			
			onButtonGroupClick: function(event)
			{
				event.preventDefault();
				
				var $btn = $(event.target).closest('a');
				var filterData = $btn.data('filter');
				var $buttonGroup = $btn.closest('ul.button-group');
				
				if( $btn.hasClass('selected') )
				{
					$btn.removeClass('selected');
					
					delete this.filters[filterData.attributeId];
				}
				else
				{
					$buttonGroup.find('a.btn.selected').removeClass('selected');
					$btn.addClass('selected');
					
					if( filterData.minValue !== undefined ) // filter by range
					{
						this.filters[filterData.attributeId] = {
							type : 'range',
							params : {
								start: parseFloat(filterData.minValue),
								end: parseFloat(filterData.maxValue)
							}
						};
					}
					else if( filterData.value !== undefined ) // filter by value
					{
						this.filters[filterData.attributeId] = {
							type : 'value',
							value : filterData.value
						};
					}
				}
				
				$.eventDispatcher.trigger('HMC_filterComplete', this.filters);
			},
			
			getFilterRangeData : function($slider, values)
			{
				var filterData = $slider.data('filter');
				var lastValues = $slider.data('lastValues');
				var rangeStart = 0;
				var rangeEnd = Number.MAX_VALUE;
				var isMaxToMinSlider;

				if( values.length > 1 )
				{
					// range slider (2 handles)
					rangeStart = values[0];

					if( values[1] != filterData.maxValue )
					{
						rangeEnd = values[1];
					}
				}
				else
				{
					// not a range slider (1 handle)
					isMaxToMinSlider = filterData.sliderType == 'maxToMin';
					if( isMaxToMinSlider && values[0] != filterData.maxValue )
					{
						rangeEnd = values[0];
					}
					if( !isMaxToMinSlider )
					{
						rangeStart = values[0];
					}
				}
				
				$slider.data('lastValues', values);
				
				return {
					start : rangeStart,
					end : rangeEnd
				};
			},

			displaySliderValues : function($valueDisplay, values, filterData)
			{
				var orGreaterIndicator = filterData.sliderType != 'minToMax' && values[values.length - 1] == filterData.maxValue ? '+' : '';
				if( values.length == 1 )
				{
					// not a range slider (1 handle)
					$('.end', $valueDisplay).text(this.valueFormat(values[0], filterData) + orGreaterIndicator);
				}
				else
				{
					// range slider (2 handles)
					$('.start', $valueDisplay).text(this.valueFormat(values[0], filterData));
					$('.end', $valueDisplay).text(this.valueFormat(values[1], filterData) + orGreaterIndicator);
				}
			},
			
			onSortingChange : function(event)
			{
				var $target = $(event.target);
				
				// Omniture
				if (window.Omniture_s) {
					var pageName = Omniture_s.pageName;
					mrm.util.tagging.omniture_tl (
					$target, $target.find(':selected').text(), 'o', 'sort_filter',
						{
							'pageName':pageName,
							'prop27':'sort filter',
							'prop32':pageName+':sort filter:'+$target.find(':selected').text()
						}
					);
				}
				
				$.eventDispatcher.trigger('HMC_sortingChange', _.extend({attribute:$target.val()}, $target.find(':selected').data()));
			},

			valueFormat : function(value, cfg)
			{
				if( cfg.formatAsNumber || cfg.showAsCurrency )
				{
					return mrm.util.numberFormat(value, cfg.numberOfDecimals, cfg.showAsCurrency);
				}
				
				return parseFloat(value).toFixed(cfg.numberOfDecimals);
			}
		}
	});
})(mrm.$);(function($)
{
	$.extend(true, mrm.cmp, {
		hmc_result_1 : {

			bodystyleCollection : null,
			bodystyleViews : {},

			allIds : [],
			activeIds : [],
			passiveIds : [],
			sortedList : null,
			
			$ctx : null,
			$resultList : null,
			$noResultContainer : null,
			$checkboxes : null,
			
			sizeClasses : ['size_1', 'size_2', 'size_3'],

			init : function(c)
			{
				this.$ctx = $('.modHmc_result_1');
				
				if( !this.$ctx.length ) return;
				
				this.$checkboxes = this.$ctx.find(':checkbox');
				this.$resultList = this.$ctx.find('ul.tiles');
				this.$resultList.show();
				this.$noResultContainer = this.$ctx.find('div.msg.noResult');
				
				var tooltipConfig = $.extend({}, mrm.conf.plugin.cluetip, {
					prepareTitleAttr: true,
					cluetipClass: 'hmc',
					positionByMethod: '',
					positionBy: 'mouse',
					width:150,
					topOffset: -20,
					onShow: function($ct){
						if($(this).find('.ui-checkbox-disabled').length) {
							$ct.addClass('disabled');
							$(this).css('cursor', 'auto');
						}
					}
				});

				this.bodystyleCollection = new Backbone.Collection();

				_.each(this.$resultList.children(), function(item)
				{
					var $item = $(item);
					var data = $item.data('bodystyle');
					data.id = $item.attr('id');

					var model = new Backbone.Model(data);
					this.bodystyleCollection.add(model);

					this.bodystyleViews[data.id] = new Backbone.View({
						model : model,
						el : '#' + data.id
					});
					
					if (!mrm.util.touchDevice()) {
						var $toggleBtn = $item.find('a.toggle-details');
						$toggleBtn
						.attr('title', '|'+$toggleBtn.text())
						.cluetipWrap(tooltipConfig);
					}
					
				}, this);
				
				if (!mrm.util.touchDevice()) {
					this.$checkboxes.each(function(){
						var $cBoxWrapper = $(this).parent('div.checkbox-wrapper');
						$cBoxWrapper
						.attr('title', '|'+$cBoxWrapper.attr('title'))
						.cluetipWrap(tooltipConfig);
					});
				}

				this.allIds = _.pluck(this.bodystyleCollection.toJSON(), 'id');

				this.setBindings();
			},
			
			setBindings : function()
			{
				this.$ctx.on('change', $.proxy(function(event){
					var $target = $(event.target);
					var eventName = $target.is(':checked') ? 'HMC_addItem' : 'HMC_removeItem';
					
					$.eventDispatcher.trigger(eventName, {
						items: [$target.val()]
					});
				}, this));

				this.$ctx.on('click', '.ui-checkbox-disabled', $.proxy(function(event){
					$.eventDispatcher.trigger('HMC_showList');
				}, this));
				
				this.$ctx.on('click', 'a.compare', $.proxy(function(event){
					event.preventDefault();
					
					this.compareBySegment($(event.target).data('segment'));
				}, this));
			
				$('ul.size_2 a.toggle-details, ul.size_3 a.toggle-details').live('click', $.proxy(this.onToggleClick, this));
				
				$.eventDispatcher.on('HMC_filterChange', _.throttle($.proxy(this.onFilterChange, this), 100));
				$.eventDispatcher.on('HMC_filterComplete', $.proxy(this.onFilterComplete, this));
				$.eventDispatcher.on('HMC_sortingChange', $.proxy(this.onSortingChange, this));
								
				$.eventDispatcher.on('HMC_addItem', $.proxy(function(event, data)
				{
					_.each(data.items, function(item){
						this.$ctx.find(':checkbox[value="'+item+'"]').prop('checked', true).checkBox('update');
					}, this);
				}, this));
				$.eventDispatcher.on('HMC_removeItem', $.proxy(function(event, data)
				{
					_.each(data.items, function(item){
						this.$ctx.find(':checkbox[value="'+item+'"]').prop('checked', false).checkBox('update');
					}, this);
				}, this));
				
				$.eventDispatcher.on('HMC_tableLock', $.proxy(function()
				{
					this.$checkboxes.filter(':not(:checked)').prop('disabled', true).checkBox('update');
				}, this));
				$.eventDispatcher.on('HMC_tableUnlock', $.proxy(function()
				{
					this.$checkboxes.prop('disabled', false).checkBox('update');
				}, this));
				
				$.eventDispatcher.on('HMC_changeMode', $.proxy(function(event, data){
					this.$ctx.toggle(data.mode === 'choose');
				}, this));

				$.eventDispatcher.on('HMC_clearAll', $.proxy(function(event, data){
					this.$checkboxes.prop('checked', false).checkBox('update');
				}, this));
			},

			onFilterChange : function(event, data)
			{
				this.computeActiveTiles(data);

				_.each(this.activeIds, function(id)
				{
					this.bodystyleViews[id].$el.removeClass('toBeRemoved');
				}, this);

				_.each(this.passiveIds, function(id)
				{
					this.bodystyleViews[id].$el.addClass('toBeRemoved');
				}, this);
				
				this.$noResultContainer.toggle(!this.activeIds.length);
			},

			onFilterComplete : function(event, data)
			{
				this.computeActiveTiles(data);

				_.each(this.activeIds, function(id)
				{
					this.bodystyleViews[id].$el.removeClass('toBeRemoved');
					this.bodystyleViews[id].$el.show();
				}, this);

				_.each(this.passiveIds, function(id)
				{
					this.bodystyleViews[id].$el.hide();
				}, this);
				
				this.updateList();
				this.prepareTiles();
			},

			onSortingChange : function(event, data)
			{
				this.sortedList = this.getSortedList(data.attribute);
				
				_.each(this.sortedList, function(id){
					this.$resultList.append(this.bodystyleViews[id].$el);
				}, this);
				
				this.prepareTiles();
			},
			
			positionSegmentTitels : function()
			{
				_.each(_.groupBy(this.bodystyleCollection.toJSON(), 'segment'), function(list, segment)
				{
					var bodystyleId = _.first(_.intersection(this.sortedList, _.pluck(list, 'id')));
					var $tile = $('#'+bodystyleId);
					$tile.addClass('hasSegmentTitle');	
					var $segmentTitle = $('<h2>').addClass('hl_s segmentTitle').text($tile.data('bodystyle').label);
					
					if(typeof mrm.conf.cmp.cnt_tbl_comp_1 !== 'undefined' && typeof mrm.conf.cmp.cnt_tbl_comp_1.compareSegmentTitleLabel !== 'undefined' && mrm.conf.cmp.cnt_tbl_comp_1.comparisonEnabled != false){
					$segmentTitle.append($('<a>').attr('href','#').addClass('compare').text(mrm.conf.cmp.cnt_tbl_comp_1.compareSegmentTitleLabel).attr('data-segment', $tile.data('bodystyle').segment));
					}
					
					$tile.prepend($segmentTitle);
					
					var $tileRowSiblings = $tile.siblings().filter(function() { 
						return $(this).data('row') == $tile.data('row');
					});
					$tileRowSiblings.addClass('hasSegmentTitle');
					
					//calculate vertical position of segment title
					if($segmentTitle.length) {
						var segTitleHeight = $segmentTitle.height();
						var tileTitleHeight = parseFloat($segmentTitle.parent().css('margin-top'));
						$segmentTitle.css('margin-top', (tileTitleHeight - segTitleHeight) / 2 + 'px');
					}
					
				}, this);
			},
			
			compareBySegment : function(segmentId)
			{
				var entries = _.pluck(this.bodystyleCollection.where({segment:segmentId}), 'id');
		// TODO make max number of item configurable
				var activeSorted = _.first(_.intersection(this.sortedList, this.activeIds, entries), 3);
	
				$.eventDispatcher.trigger('HMC_clearAll');
				$.eventDispatcher.trigger('HMC_addItem', {
					items : activeSorted
				});
				$.eventDispatcher.trigger('HMC_changeMode', { mode:'compare'});
			},
			
			updateList : function()
			{
				var visibleTilesCount = this.activeIds.length;
				var sizeClass = this.sizeClasses[2];

				this.$resultList.toggleClass('noResultsVisible', !visibleTilesCount);
				this.$noResultContainer.toggle(!visibleTilesCount);

				if (visibleTilesCount < 9 && visibleTilesCount > 4) {
					sizeClass = this.sizeClasses[1];
				} else if (visibleTilesCount < 5) {
					sizeClass = this.sizeClasses[0];
				}
				
				this.$resultList.removeClass(this.sizeClasses.join(' ')).addClass(sizeClass);
				
				var $activeTiles = _.reduce(this.activeIds, function($memo, id){
					return $memo.add(this.bodystyleViews[id].$el);
				}, $(), this);
				
				$activeTiles.find('img.size_1').removeClass('active');
				
				$activeTiles.children().height('auto');
				if (sizeClass !== this.sizeClasses[0])
				{
					$activeTiles.children().equalHeights();
				}

				// getting the IDs without suffix from the checkboxes within the active list items
				// these are needed for updating the compare list
				var activeCheckboxValues = [];
				_.each(this.activeIds, function(item) {
					activeCheckboxValues.push( $('#' + item).find('.checkbox-wrapper input').attr('value') );
				}, self);
				
				$.eventDispatcher.trigger('HMC_update', {
					activeIds : activeCheckboxValues
				});
				
				this.$ctx.trigger('HMC_update');
			},
			
			getSortedList : function(attribute)
			{
				// TODO ascending/descending
				return _.pluck(_.sortBy(this.bodystyleCollection.toJSON(), function(item){
					var sortValue = item.sorting[attribute];
					if(isNaN(sortValue) == false){
						sortValue = parseFloat(sortValue);
					}
					return sortValue;
				}, this), 'id');
			},
			
			computeActiveTiles : function(data)
			{
				var list = this.bodystyleCollection.toJSON();

				_.each(data, function(filter, filterName)
				{
					switch(filter.type)
					{
						case 'range':
							list = _.filter(list, function(entry)
							{
								return entry.filtering[filterName] >= filter.params.start && entry.filtering[filterName] <= filter.params.end;
							});
							break;
							
						case 'segment':
							list = _.filter(list, function(entry)
							{
								
								var evaluateYear = false;
								var evaluateSegment = false;
								var returnYear = false;
								var returnSegment = false;
								mrm.$.each(filter.list, function(index,value) {
									if(!isNaN(value)) {
										evaluateYear = true;
									} else {
										evaluateSegment = true;
									}

								});
								if (evaluateYear) {
									returnYear = _.contains(filter.list, String(entry.modelyear));
								} else {
									returnYear = true;
								}
								if (evaluateSegment) {
									returnSegment = _.indexOf(filter.list, entry.segment) > -1;
								} else {
									returnSegment = true;
								}
								return (returnYear && returnSegment);
								
							});
							break;
							
						case 'value':
							list = _.filter(list, function(entry)
							{
								return entry.filtering[filterName] === filter.value;
							});
							break;
					}
				}, this);

				this.activeIds = _.pluck(list, 'id');
				this.passiveIds = _.difference(this.allIds, this.activeIds);
			},
			
			onCloseClick: function(e)
			{
				e.preventDefault();
				
				var self = this;
				var $allTiles = self.$resultList.children();
				$allTiles.filter('.expanded').find('a.toggle-details').trigger('click');
			},
			
			onToggleClick : function(e)
			{
				e.preventDefault();
				
				var self = this;
				var $toggleBtn = $(e.target);
				var $tile = $toggleBtn.parents('li.tile');
				var $allTiles = self.$resultList.children();
				var $allVisibleTiles = $allTiles.filter(':visible:not(.tileOverlay)');
				var $lastItem;
				var tilePosition = $allVisibleTiles.index($tile) + 1;
				var perRow = 6;
				
				if($tile.parent().hasClass('size_3')){
					perRow = 6;
				} else if ($tile.parent().hasClass('size_2')) {
					perRow = 4;
				}
				
				var maxRows = Math.ceil($allVisibleTiles.length / perRow);
				for (var i = 1; i <= maxRows; i++) { 
					if(tilePosition <= (i * perRow)){
						$lastItem = $allVisibleTiles.eq((i * perRow) - 1);
						
						if($allVisibleTiles.length < (i * perRow)){
							$lastItem = $allVisibleTiles.eq($allVisibleTiles.length - 1);	
						}
						
						break;
					}
				}
				
				var $copyItems = $tile.find('.modVi_hmc_1').children().clone();
				$copyItems.find('.ui-checkbox, input[type=checkbox]').remove();
				
				if($copyItems.find('.modMm_colorizer').length == 1){
					var overlayColorizerId = $copyItems.find('.modMm_colorizer').attr('id');
					$copyItems.find('.modMm_colorizer').attr('id', 'overlay_'+overlayColorizerId);
					$copyItems.find('li.'+overlayColorizerId)
					.removeClass(overlayColorizerId)
					.addClass('overlay_'+overlayColorizerId);
				}
				
				var $newOverlay = $('<li>')
				.addClass('tileOverlay')
				.append($copyItems)
				.data('row', $tile.data('row'))
				.insertAfter($lastItem);
				
				// show colorizer if available, or fall back to image
				if($newOverlay.find('.hasColorizer').length == 1){
					$newOverlay.find('.hasColorizer').addClass('active');
				} else {
					$newOverlay.find('img.size_1').addClass('active');
				}
				
				// show overlay
				var $visibleOverlay = $allTiles.filter('.tileOverlay:visible');
				if($visibleOverlay.data('row') == $lastItem.data('row')){
					$visibleOverlay.remove();
					$newOverlay.show();
					self.initScroll($newOverlay);
					
					$.eventDispatcher.trigger('HMC_load_colorizer', {
						colorizer : $newOverlay.find('.modMm_colorizer')
					});
				} else {
					$visibleOverlay.slideUp(300, function(){$(this).remove()});
					$newOverlay.slideDown(300, function(){
						self.initScroll($newOverlay);
						
						$.eventDispatcher.trigger('HMC_load_colorizer', {
							colorizer : $newOverlay.find('.modMm_colorizer')
						});	
					});
				}
				
				if($tile.hasClass('expanded')){
					$tile.removeClass('expanded');	
					$newOverlay.slideUp(300, function(){$(this).remove()});
				} else {
					$allVisibleTiles.removeClass('expanded');
					$tile.addClass('expanded');	
					$('.tileOverlay dl.hide_price_six_column').show();
					$('.tileOverlay dl.six_column_atributes').hide();
				}
			},
			
			prepareTiles : function()
			{
				var self = this;
				var $allTiles = self.$resultList.children();
				
				// clear out previous prep work
				$allTiles.removeClass('hasSegmentTitle expanded last-in-row last-row first-in-row');
				$allTiles.find('h2.segmentTitle').remove();
				$allTiles.find('img.size_1').removeClass('active');
				$allTiles.filter('.tileOverlay:visible').remove();
				
				var $allVisibleTiles = $allTiles.filter(':visible:not(.tileOverlay)');
				if($allVisibleTiles.length == 0){
					return;
				}
				
				var perRow = 6;
				
				if(self.$resultList.hasClass('size_3')){
					perRow = 6;
				} else if (self.$resultList.hasClass('size_2')) {
					perRow = 4;
				} else if (self.$resultList.hasClass('size_1')) {
					perRow = 1;
				}
				
				// prep tiles				
				var cols = 0;
				var row = 0;
				var maxRows = Math.ceil($allVisibleTiles.length / perRow);
				
				$allTiles.data('row', row);
				
				$allVisibleTiles.each(function(index, value){
					cols++;
					if(cols == (perRow) || ($allVisibleTiles.index($(this)) + 1) == $allVisibleTiles.length){
						$(this).addClass('last-in-row');
					}
					if(cols == (perRow+1)){
						cols = 1;	
					}
					if(cols == 1){
						$(this).addClass('first-in-row');
						row++;
					}
					if(row == maxRows){
						$(this).addClass('last-row');	
					}
					$(this)
					.data('row', row);
				});
				
				if($allVisibleTiles.parent().hasClass('size_1')){
					$allVisibleTiles.each(function(){
						
						// show colorizer if available, or fall back to image
						if($(this).find('.hasColorizer').length == 1){
							$(this).find('.hasColorizer').addClass('active');
							self.initScroll($(this));
							$.eventDispatcher.trigger('HMC_show_colorizer', {
								colorizer : $(this).find('.modMm_colorizer')
							});
						} else {
							$(this).find('img.size_1').addClass('active');
						}	
					});
				}
				
				if($('#hmc_sort_1 option:selected').val() == 'segment'){
					if(typeof mrm.conf.cmp.hmc_result_1 !== 'undefined' && typeof mrm.conf.cmp.hmc_result_1.showSegmentTitles !== 'undefined' && mrm.conf.cmp.hmc_result_1.showSegmentTitles == true){
						self.positionSegmentTitels();
					}
				}
				
				$('dl.six_column_atributes').css('font-size','0.83em');
				if($('div#container div.mod ul.tiles').hasClass('size_3')) {
					$('dl.hide_price_six_column').hide();
					$('dl.six_column_atributes').show();
				} else {
					$('dl.hide_price_six_column').show();
					$('dl.six_column_atributes').hide();
					if (!$("div#container div.mod ul.tiles").hasClass("size_1")) {
                    	this.updateList()
                    }
				}
				
				
			},
			initTooltip : function($mm1) {
				var $links = $('a.disclaimer_1',$mm1);
                // prepare tooltip-content
                $links.attr('rel', function() {
                    return '|' + $('.modDisclaimer_1 ' + $(this).attr('href')).html();
                });

                // init tooltip
                var config = $.extend(true, {}, mrm.conf.plugin.cluetip, mrm.conf.cmp.disclaimer_1.cluetip);
                $links.cluetipWrap(config);
			},
			initScroll : function($mm1)
			{
				var self = this;
				self.initTooltip($mm1);

				var $mmScroll = $mm1.find('.mm_scroll, .mmScroll').addClass('mmScroll'),
					$items = $mmScroll.children('ul').children('li');

				// no scroller, activate video directly
				//if ($mmScroll.length == 0) mrm.corcmp.mmVideo.activateVideo($mm1);

				if( $items.length <= 0 ) return; // stop if list is empty
				$mmScroll.children('span.prev, span.next').addClass('mmScrollBtn');

				var options = {
					height: 'variable',
					onCreate: function($items) {
						
//slated for removal GMDSSDS-62922
//					},
//					scroll: {
//						noWipeDirection: 'vertical',
//						onAfter: function($oldItem, $newItem, newSize, duration) {
//							// WTF, better check for function-name existance...
//							try {
//								var newImage = $newItem.find('img').attr('src');
//								newImage = newImage.substr( newImage.lastIndexOf('/') + 1 );
//								fireMetrics('mm_1', 'photoname::' + newImage);
//							} catch (e) { }
//						}
					}
				};

				// add config options
				options = $.extend(true,options, mrm.conf.cmp.mm_1 || {});
				
				if ($mmScroll.hasClass('disable-looping')) {
					options.circular = false;
					options.infinite = false;
				}

				// check if the scroller is supposed to open a layer on click
				if($mmScroll.hasClass('use-lightbox')) {

					// init the lightbox scroller if needed
					// TODO: This is crap since all existing element-IDs got cloned, too
					var $dialogContainer = $mmScroll.parent().clone().appendTo($mmScroll.parent().parent()),
						$dialogMmScroll = $dialogContainer.find('.mm_scroll').addClass('mmScroll'),
						$dialogScroller = $dialogMmScroll.children('ul'),
						$mmScrollScroller = $mmScroll.children('ul');

					// quickfix: find elements with ID`s and make them unique
					var $uniqueElements = $dialogContainer.find("[id]");
					$uniqueElements.attr('id', function(idx, val) {
						return mrm.util.getRandomString('cloned', '_') + val;
					});

					$dialogScroller.children('li').each(function() {
						var ld = $(this).find('figure, dl.figure').data();

						// replace the context of the items when the data is set correctly
						if ( ld.lightboxTitle && ld.lightboxCaption && ld.lightboxImage && ld.lightboxImageWidth && ld.lightboxImageHeight ) {
							$(this).find('img.mm').attr('src', ld.lightboxImage).attr('width', ld.lightboxImageWidth).attr('height', ld.lightboxImageHeight);
							$(this).find('figcaption .txtWrp, dfn').text(ld.lightboxCaption);
						}
					});

					$dialogMmScroll.mmScroll($.extend({}, options, {
						// put lightbox specific scroller cfg here
						width: 'variable',
						scroll: {
							fx: 'none'//, // enlarged images could be variable sizes, animations wouldn't look good
							/*onAfter: function($oldItem, $newItem, newSize, duration) {
								self._activateScrollerVideo($dialogMmScroll);
								mrm.corcmp.mmVideo.deactivateVideo($oldItem);
							}*/
						}
					}));

					$dialogContainer.hide();

					$dialogContainer.mrmDialog($.extend(true, {}, mrm.conf.plugin.ui_dialog || {}, {
						autoOpen: false,
						width: $dialogContainer.outerWidth(),
						dialogClass : 'mm-content'
					}));

					$items.on('click', function() {
						var startIndex = $mmScrollScroller.triggerHandler('currentPosition');
						$dialogContainer.dialog('open');
						$dialogScroller.trigger('slideTo', startIndex);
						//self._activateScrollerVideo($dialogContainer);
					});
				}

				$mmScroll.mmScroll( options );
			}
		}
	});
})(mrm.$);(function($) {
	$.extend(mrm.track, {
		hmc_result_1: {
			
			isFirstUpdate : true,
			
			
			initTrack: function($mod, section){

				$mod.on('HMC_update', $.proxy(function(){
					
					if( this.isFirstUpdate )
					{
						mrm.util.tagging.omniture_tl (true, 'HMC init', 'o', 'event19',  {});
						
						this.isFirstUpdate = false;
					}
					else
					{
						mrm.util.tagging.omniture_tl (true, 'HMC filter change', 'o', 'event20',  {});
					}
				}, this));
				
				$mod.on('click', 'ul.tiles li', function (_e) {
					$(this).find('div a').removeAttr('onclick');
					$(this).find('div div h3 a').removeAttr('onclick');
					var $target = $(_e.target);
					
					// Omniture
					if (window.Omniture_s) {
						var pageName = Omniture_s.pageName;
						mrm.util.tagging.omniture_tl (
						$target, $(this).find('div div h3 a').text(), 'o', 'choose_vehicle',
							{
								'pageName':pageName,
								'prop27':'model select',
								'prop32':pageName+':model select:'+$(this).find('div div h3 a').text()
							}
						);
					}
				});
			}
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Iframe_2 = mrm.mod.AbstractMod.extend({

		$iframe: $(),
		$closeButton: $(),
		$reopenButtonArea: $(),
		iframeSrc: undefined,

		events: {
			'click .close' : 'onCloseClick',
			'click .further > *' : 'onReopenClick'
		},

		prepare: function() {
			var self = this;

			self.$iframe = self.$ctx.find('iframe');
			self.$closeButton = self.$ctx.find('a.close');
			self.$reopenButtonArea = self.$ctx.find('.further');

			// save src for reopening the iframe
			self.iframeSrc = self.$iframe.attr('src');

			if (self.$iframe.data('autoheight')) {
				self.$iframe.responsiveIframe({
					scrollToTop: false
				});
			}
		},

		onCloseClick: function(e) {
			var self = this;
			e.preventDefault();
			self.$iframe.addClass('ui-helper-hidden').attr('src', '');
			self.$closeButton.addClass('ui-helper-hidden');
			self.$reopenButtonArea.removeClass('ui-helper-hidden');
		},

		onReopenClick: function(e) {
			var self = this;
			e.preventDefault();
			self.$iframe.removeClass('ui-helper-hidden').attr('src', self.iframeSrc);
			self.$closeButton.removeClass('ui-helper-hidden');
			self.$reopenButtonArea.addClass('ui-helper-hidden');
		}

	});
})(mrm.$);


;(function($) {
	mrm.mod.Ilike_btn = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;
			if (mrm.conf.util.sharing.socialPrivacy) {
				self.disableTags();
				mrm.util.sharing.initSocialSwitches(self.$ctx);
			}
		},

		/**
		 * Disable provider-tags so they are hidden from the the provider-scripts
		 * ex: converts "fb-like" to "disabled-fb-like"
		 */
		disableTags: function() {
			this.$ctx.find('.fb-like').each(function(i, tag) {
				var $tag = $(tag);
				var cls = $tag.attr('class');
				$tag.attr('class', cls.replace(/(fb-like)/, mrm.conf.util.sharing.disabledProviderTag + "$1"));
			});
		}

	});
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		ilike_btn: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				$('.socialSwitch', $mod).on(clickOrTouch, function() {
					var serviceClass = $(this).parents('.socialPrivacy').attr('class').match(/service[\w\-]*\b/)[0],
					    service = serviceClass.replace('service-', ''),
					    switchState = '';

					if ( $(this).hasClass('on') ) {
						switchState = 'soc_slider_on';
					} else {
						switchState = 'soc_slider_off';
					}

					if ( window.Omniture_s ) {
						mrm.util.tagging.omniture_tl(true, 'social_switch', 'o', '', {
							prop27: 'soc_slider',
							prop32: Omniture_s.pageName + ':' + switchState + ':' + service
						});
					}
				});
			}
		}
	});
}(mrm.$));(function () {
	mrm.$(window).load(function () {
		if (document.getElementById("_bapw-icon")) {
			var e = document,
				b, a = (e.location.protocol == "https:" ? "https" : "http"),
				c = (a == "https" ? "https://info.evidon.com/c/betrad/pub/" : "http://cdn.betrad.com/pub/");
			e.getElementById("_bapw-icon").src = c + "icon1.png";
			if (mrm.util.locale.getCountry().toLowerCase() === "ca") {
				if (mrm.util.locale.getLang().toLowerCase() === "fr") {
					(function () {
						var ev = document.createElement('script');
						ev.type = 'text/javascript';
						ev.async = true;
						ev.setAttribute('data-ev-tag-pid', 1112);
						ev.setAttribute('data-ev-tag-ocid', 797);
						ev.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'c.betrad.com/pub/tag.js';
						var s = document.getElementsByTagName('script')[0];
						s.parentNode.insertBefore(ev, s);
					})();
					(function () {
						var hn = document.createElement('script');
						hn.type = 'text/javascript';
						hn.async = true;
						hn.setAttribute('data-ev-hover-pid', 1112);
						hn.setAttribute('data-ev-hover-ocid', 797);
						hn.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'c.betrad.com/geo/h1.js';
						var s = document.getElementsByTagName('script')[0];
						s.parentNode.insertBefore(hn, s);
					})();
				} else {
					(function () {
						var ev = document.createElement('script');
						ev.type = 'text/javascript';
						ev.async = true;
						ev.setAttribute('data-ev-tag-pid', 1111);
						ev.setAttribute('data-ev-tag-ocid', 797);
						ev.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'c.betrad.com/pub/tag.js';
						var s = document.getElementsByTagName('script')[0];
						s.parentNode.insertBefore(ev, s);
					})();
					(function () {
						var hn = document.createElement('script');
						hn.type = 'text/javascript';
						hn.async = true;
						hn.setAttribute('data-ev-hover-pid', 1111);
						hn.setAttribute('data-ev-hover-ocid', 797);
						hn.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'c.betrad.com/geo/h1.js';
						var s = document.getElementsByTagName('script')[0];
						s.parentNode.insertBefore(hn, s);
					})();
				}
			} else {
				e.getElementById("_bapw-link").onclick = function () {
					var f = this;

					function d(i, l) {
						var j = e.getElementsByTagName("head")[0] || e.documentElement,
							h = false,
							g = e.createElement("script");

						function k() {
							g.onload = g.onreadystatechange = null;
							j.removeChild(g);
							l()
						}

						g.src = i;
						g.onreadystatechange = function () {
							if (!h && (this.readyState == "loaded" || this.readyState == "complete")) {
								h = true;
								k()
							}
						};
						g.onload = k;
						j.insertBefore(g, j.firstChild)
					}

					this.onclick = "return false";
					d(a + "://ajax.googleapis.com/ajax/libs/jquery/1.12.2/jquery.min.js", function () {
						d(c + "pub1.js", function () {
							BAPW.i(f, {
								pid: 45,
								ocid: 797
							}, false)
						})
					});
					return false
				};
				b = e.createElement("img");
				b.src = a + "://l.betrad.com/pub/p.gif?pid=45&ocid=797&ii=1&r=" + Math.random();
				b.height = "1";
				b.width = "1";
				e.body.appendChild(b)
			}
		}
	});
}());;(function($) {
	mrm.mod.Lyr_email_1 = mrm.mod.AbstractMod.extend({
		prepare: function() {
			// custom inputs
			var self = this,
				$mod = this.$ctx,
				$form = $("form", $mod),
				callerData = $mod.data('callerData') || {},
				options = $.extend({}, mrm.conf.cmp.lyr_email_1);

			// Special handling of mm_1 when they appear in jQuery dialogs
			if ($mod.closest(".ui-dialog").length) {
				$mod.closest(".ui-dialog").addClass('email_background');
			}

			if (callerData.js_field_name) {
				$form.append('<input type="hidden" name="' + callerData.js_field_name + '" value="1" />');
			}

			$form.submit(function(event) {
				event.preventDefault();
				var $fields = $("li:has(:input)", $mod);
				var result = self._validateFields($fields);
				if (result['success'] == true) {
					$.ajax({
						type: 'POST',
						url: $form.attr("action"),
						data: $(this).serialize(),
						dataType: "json",
						success: function(data) {
							if (data.success) {
								$form.hide();
								$("div.lyr_success", $mod).show();
							}
							var obj = data.fields;
							self._highlightFields($mod, obj);
						},
						error: function() {
							// fallback
							var obj = {tx_error:{
								"highlight": true,
								"msg": options.errormsg
							}};
							self._highlightFields($mod, obj);
						}
					});
				} else {
					result['fields']['tx_error'] = {
						"highlight": true,
						"msg": options.validationmsg
					};
					self._highlightFields($mod, result['fields']);
				}
				return false;
			});

			// legal links
			$(".lyr_success > .tx > a", $mod).on("click", function(event){
				$mod.parent().dialog("close");
			});

			// legal links
			$('textarea[data-type="multi-email"]', $mod).on("keyup input", function(event){
				var $field = $(event.target).closest('textarea, input');
				self.onTypeMultiEmail( $field, event );
			});
		},

		_highlightFields: function($mod, fields) {
			if (!fields) return;
			$.each(fields, function(field){
				var obj = fields[field];
				var $elem = $("." + field, $mod);
				if (obj["highlight"]) {
					if (field == "tx_error") $elem.css('display', "block");
					$elem.addClass('ui-state-error');
				} else {
					if (field == "tx_error") $elem.css('display', "none");
					$elem.removeClass('ui-state-error');
				}
				// replace text?
				if (obj["msg"]) {
					var $label = $("label", $elem);
					$elem = $label.length == 0 ? $elem : $label;
					$elem.html(obj["msg"]);
				}
			});
		},

		_isEmail: function(value) {
			return /^[a-zA-Z0-9._%\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,4}$/.test(value);
		},

		_extractMultiEmailChunks: function(value) {
			var emails;
			value = value.replace(/[ ,;\n]+/g, ',');

			if ( value.substr(-1) === ',' ) {
				value = value.substr(0, value.length - 1);
			}
			emails = value.split(',');
			return ( emails.length == 1 && emails[0] == '' ) ? [] : emails;
		},

		onTypeMultiEmail: function( $field ) {
			var value = $field.val(),
				emails = this._extractMultiEmailChunks(value);

			if ( emails.length <= 10 ) {
				return;
			}

			// cut anything beyond the 10th "email adress" chunk
			$field.val(value.substring(0, value.lastIndexOf(emails[9]) + emails[9].length ));
		},

		_validateFields: function($fields) {
			// init
			var self = this,
				success = true;
				$sendToSelfCheckbox = $fields.find('input:checkbox'),
				outputObject = {
					fields: {}
				};

			$fields.each(function() {
				// pattern from ffe
				var currentField, emails,
					$input = $(":input", this),
					fieldName = $(this).attr("class").match(/(form_.*?)\b/)[1] || '',
					value = $input.val(),
					required = $input.attr("required") == "required" ? true : false,
					maxLength = $input.attr("maxlength") || 0,
					hasError = false;

				if ( $input.is(':checkbox') ) {
					return true;
				}

				outputObject.fields[fieldName] = outputObject.fields[fieldName] || {
					highlight: false
				};

				hasError = required && (value.length == 0);

				if ( !hasError && maxLength > 0 ) {
					hasError = value.length > maxLength;
				}

				switch( $input.data("type") || "text" ) {
					case "email":
						hasError = !self._isEmail(value);
						break;
					case "multi-email":
// ToDo: remove next line once the markup is updated (required attribute removed)
hasError = false;
						emails = self._extractMultiEmailChunks(value);
						required = !$sendToSelfCheckbox.prop('checked');
						outputObject.fields[fieldName].tooManyEmails = false;

						if ( required && !emails.length ) {
							hasError = true;
							break;
						}

						if ( emails.length > 10 ) {
							emails.length = 10;
							$input.val(emails.join(','));
						}

						for (var i = 0; i < emails.length; i++) {
							if ( !self._isEmail(emails[i]) ) {
								hasError = true;
								break; // leave loop
							}
						}
						break;
				}
				outputObject.fields[fieldName].highlight = hasError;
				success = hasError == true ? false : success;
			});
			outputObject['success'] = success;
			return outputObject;
		}
	});
})(mrm.$);
/*
 *  2014 by MRM Worldwide
 */
/*
 * @author tony.herford
 * @name mh_1
 */
(function($) {
	mrm.cmp = mrm.cmp || {};
	mrm.cmp.mh_1 = $.extend(mrm.cmp.mh_1, {
//		tpl: ["6", "16"],
		/**
		 * Kick off the whole thing
		 * @param {jQuery} $mod
		 * @returns {void}
		 */
		init: function($mod) {
			// if there is not title then don't worry about the rest
			if (!$('.mh_title_1').length)
				return;

			if(mrm.util.curTemplate()==='16'){
				$.eventDispatcher.on('vehicle_config_change', this.render_text);
				$.eventDispatcher.on('vehicle_config_load', this.render_text);
			}
		},
		initMod: function($mod) {
			var self = this;
			// if not scroller this will start it.
			self._checkImageWidth($mod);

			// when the scroller is ready then run
			$.eventDispatcher.on('mh_scroller_ready', function() {
				self._checkImageWidth($mod);
			})
		},
		/**
		 * Render the text replacing the variables with the correct values
		 * @param {string} name
		 * @param {object} data
		 * @returns {void}
		 */
		render_text: function(name, data) {
			// get vehicle data
			var page_data = pageData['vehicle-info'];
			data = localStorage.byo
			//console.log('data', data);
			if (data) {
				data = JSON.parse(data);
				if (data && data[page_data.year] && data[page_data.year][page_data.carline] && data[page_data.year][page_data.carline][page_data.bodystyle]) {
					data = data[page_data.year][page_data.carline][page_data.bodystyle];
					// find all the mh_title_1 components
					$('.mh_title_1:has(.tx p)').each(function() {
						var $this = $(this);
						// Get the template from data or the content of component or blank screen
						var tmp = $this.data('template') || $this.find('.tx p').html() || '';
						// Check template to make sure it contains the TrimName and TrimPrice placeholders
						if (/\[[\s\S]*?TrimName[\s\S]*?TrimPrice[\s\S]*?\]|\[[\s\S]*?TrimPrice[\s\S]*?TrimName[\s\S]*?\]/gi.test(tmp)) {
							// Save the template to component data
							if (!$this.data('template')) {
								$this.data('template', tmp);
							}
							// Check to make sure all the data is available
							if (data.calculated_msrp && data.vehicle_name) {
								tmp = tmp.replace(/TrimName/gi, data.vehicle_name);
								tmp = tmp.replace(/TrimPrice/gi, mrm.cmp.mh_1.format_price(data.calculated_msrp));
								tmp = tmp.replace(/[\[\]]/gi, '');
								$this.find('.tx p').html(tmp);
								$this.show();
							} else {
								$this.hide();
							}
						}
					})
				}
			} else {
				if(/\[[\s\S]*?TrimName[\s\S]*?TrimPrice[\s\S]*?\]|\[[\s\S]*?TrimPrice[\s\S]*?TrimName[\s\S]*?\]/gi.test($('.mh_title_1:has(.tx p)').html())){
					$('.mh_title_1:has(.tx p)').hide();
					setTimeout(mrm.cmp.mh_1.render_text, 200);
				}
			}
		},
		/**
		 * Format the price with the local object
		 * @param {string || int} price
		 * @returns {string}
		 */
		format_price: function(price) {
			var locale = mrm.conf.locale || {};
			locale.numberFormatting.separator.decimals = '.'; //doesn't matter because pricing doesn't include decimals
			locale.numberFormatting.separator.thousands = ',';
			locale.numberFormatting.currency.before = true;
			locale.numberFormatting.currency.symbol = '$';
			try {
				var price = (!_.isEmpty(price)) ? price : 0;
			} catch (e) {
				mrm.util.log(e)
			}

			price = (price + '').replace(/\D/g, ''); // remove non-digit characters

			return mrm.util.numberFormat(price, 0, true).replace(' ', '');
		},
		/**
		 * Checks the width of the image and if its larger than the container
		 * it increases the width of the masthead and centers it.
		 * Configuration must mastheadWidthSet must be set to true for this
		 * function to work.
		 * @param {jQuery} $mod
		 * @returns {void}
		 */
		_checkImageWidth: function($mod) {
			// check configuration
			if (mrm.conf.cmp.mh_expander_1.mastheadWidthSet || mrm.conf.cmp.mh_scroller_1.mastheadWidthSet || mrm.conf.cmp.mh_1.mastheadWidthSet) {
				// get the first image in the scroller
				var $masthead = $mod.closest('.masthead'),
					$firstImage = $($masthead.find('img:visible')[0]),
					imageWidth = parseInt($firstImage.attr('width') || '0'),
					imageHeight = parseInt($firstImage.attr('height') || '0');
				// if image is larger than 40px more than container
				if (imageWidth > $('#container').width() + 40) {
					$mod = $mod.closest('.mod.modMh_1');
					var offset = Math.round(imageWidth * .5);
					// add the image height to the masthead container to keep it open when masthead is changes to absolute
					$masthead.css({'height': imageHeight, 'position': 'relative'});
					// position the masthead absolute and center
					$mod.css({'width': imageWidth, 'margin-left': -offset, 'position': 'absolute', 'left': '50%', 'top': 0});
					// adjust the width and height of the scroller
					$mod.find('div.mod.modMh_scroller_1').css({
						'width': imageWidth,
						'height': imageHeight
					})
					// adjust the width of the expander panel
					$mod.find('div.modMh_expander_1 div.expander-container').css({
						'width': imageWidth,
					})

					// add to the configuration
					mrm.conf.cmp.mh_scroller_1 = mrm.conf.cmp.mh_scroller_1 || {};
					mrm.conf.cmp.mh_scroller_1.height = 'auto';
					mrm.conf.cmp.mh_scroller_1.width = imageWidth;
				}
			}
		},
	})

})(mrm.$);(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp.mh_1, {
        // extend onto mh_1
        full_masthead_video: {
            /**
            * JS for component mh_playvideo_1
            *
            * @param {String} c DOM Context
            */
            tpl: ['06'],
            $mod: $('div.modMh_1 div.full_masthead_video:first'),
            defaults :{onLoadAutoPlay: 0, onLoadWithoutSound: 0, scrollInstance: '',playWithoutSound:0, videoContainerID: ''},
            touchOrClick:'click',
            init: function() {
                // stop if no playvideo component is present
                if (!this.$mod.length) return;
            
                // setup options
                $.extend(true, this.defaults, mrm.conf.cmp.mh_1.full_masthead_video.options);
                
                // other setup
                this.$mod.find('div#' + this.defaults.videoContainerID + '_wrapper').addClass('mastheadVideoPlayer');
                $('div.masthead').addClass('withMHVideoPlayer');
                //iPad responsiveness
                this.touchOrClick = (mrm.util.touchDevice()) ? 'touchend' : 'click';                
                
                
                if (this.defaults.onLoadAutoPlay && (!mrm.util.touchDevice())) {
                    this.$mod.show();
                    jwplayer(this.defaults.videoContainerID)
                        .setMute(this.defaults.onLoadWithoutSound)
                        .play(true);

                }
                    
               

                // create the close button
                this.$mod.append('<a href="#" class="close"><span>close</span></a>');
                // event bindings
                this.eventBindings();
                
            },
            closeVideo:function() {    
                var self = this;
                jwplayer(self.defaults.videoContainerID).pause(true);
                $('div#'+self.defaults.videoContainerID + '_wrapper').fadeTo(1000, 0, function(){
                    self.$mod.hide();
                });
            },
            eventBindings:function() {
                var self = this;
                // replay click
                $('div.mh_playvideo_1 a.play').on(self.touchOrClick, function() { 
                    jwplayer(self.defaults.videoContainerID).setMute($(this).hasClass('mute'));  
                    // double check that the opacity is set to 0 before showing (done for iPad)
                    $('div#'+self.defaults.videoContainerID + '_wrapper').fadeTo(0, 0, function(){
                        self.$mod.show();
                        $(this).fadeTo(1000, 1, function() {
                            jwplayer(self.defaults.videoContainerID).play(true);
                        });
                    });
                                      
                    return false;
                });

                // close masthead video
                self.$mod.find('a.close').on(self.touchOrClick, function() {
                    self.closeVideo();
                    return false;
                });
                
                // video complete
                jwplayer(this.defaults.videoContainerID).onComplete(function() {
                    self.closeVideo();
                });

            }
            
        }
    });
}(mrm.$));(function($) {
    mrm.cmp = mrm.cmp || {};

    $.extend(mrm.cmp, {
        mh1_colorizerthreesixty: {
            /**
             * JS for component mh_expander_1
             *
             */
            intOrExt: null,
            intDirection: null,
            nextFrame: null,
            totalFrames: null,
            delay: 250,
            view360Fade: 250,
            testing: false,
            rotationSpeed: 90,
            topOffset: 0,
            centered: false,
            $context: null,
            prevFrame: 1,
            suffix: "_perspective_img_",
            tpl: ['04', '06'],
            init: function(c) {
                if ($('.modMh_expander_1').length === 0) return;
                var self = this;
            },
            build360: function(context, angles, path, altText) {
                this.$context = context;
                var imgBox = $('div.mh_default_content_wrapper');


                totalFrames = angles;
                // context should be .modMh_expander_1 ul.mmScrollItems
                //Bind event listeners to 360 rotation buttons
                this.controlEvents(context.find('.spinItem.rightArrow'));
                this.controlEvents(context.find('.spinItem.leftArrow'));

                //Initialize the 360 jquery reel plugin
                this.$context.find('img').reel({
                    revolution: 360,
                    wheelable: false,
                    cw: false,
                    path: path,
                    attr: {
                        "alt": altText
                    },
                    frames: angles,
                    frame: this.prevFrame,
                    cursor: "hand",
                    preloader: 0,
                    //annotations: annotype,
                    images: this.returnFrames(this.suffix, angles)
                }).bind('frameChange', function(evnt, nothing, reeling) {
                    if (reeling !== 1) {
                        imgBox.stop().animate({
                            opacity: 0
                        }, 100);
                    } else {
                        if ($.browser.msie && $.browser.version < 9) {
                            imgBox.stop().animate({
                                opacity: 1
                            }, 1500);
                        } else {
                            imgBox.stop().animate({
                                opacity: 1
                            }, 500);
                        }
                    }

                    //output current frame
                    mrm.cmp.mh1_colorizerthreesixty.prevFrame = $(this).data("frame");
                });

                this.$context.parent('.mmScroll').addClass('jsReady');
            },
            teardown: function() {
                this.$context.find('img').trigger('teardown');
            },
            controlEvents: function(elem) {
                var timeOut, playInt;
                var self = this;
                elem.off('.colorizerThreeSixty');
                elem.on('touchstart.colorizerThreeSixty', function(e) {
                    e.preventDefault();
                    clickHold($(this));
                }).on('touchend.colorizerThreeSixty', function(e) {
                    e.preventDefault();
                    clearTimeout(timeOut);
                    clearInterval(playInt);
                    onClick($(this));
                });

                elem.on('mousedown.colorizerThreeSixty', function() {
                    clickHold($(this));
                    $(document).mousemove(function(e) {
                        $(document).mouseup(function(e) {
                            clearTimeout(timeOut);
                            clearInterval(playInt);
                            $(document).unbind('mousemove mouseup');
                        });
                        return false;
                    });
                }).on('click.colorizerThreeSixty', function() {
                    onClick($(this));
                    $(document).unbind('mousemove mouseup');
                });

                elem.on('mousedown.colorizerThreeSixty', function(e) {
                    // You can record the starting position with
                    var start_x = e.pageX;
                    var start_y = e.pageY;

                    $().mousemove(function(e) {
                        // And you can get the distance moved by
                        var offset_x = e.pageX - start_x;
                        var offset_y = e.pageY - start_y;

                        return false;
                    });

                    $().one('mouseup', function() {
                        $().unbind();
                    });

                    // Using return false prevents browser's default,
                    // often unwanted mousemove actions (drag & drop)
                    return false;
                });

                function clickHold(elem) {
                    intDirection = String(elem.attr('class').split(' ').splice(-1, 1));
                    timeOut = setTimeout(function() {
                        playInt = setInterval(function() {
                            self.frameAdvance(intDirection);
                        }, self.rotationSpeed);
                    }, self.delay);

                    return false;
                }

                function onClick(elem) {

                    // hide title image
                    // $('.modMh_expander_1').find('div.mh_content').css('display','none');
                    /* tracking */
                    switch (self.intOrExt) {
                    case "int":
                        if (typeof(pageTrackJSON) != "undefined") {
                            mrm.util.trackEvent('click_cta', {
                                section: 'masthead',
                                linkname: 'interior:360 spin view'
                            });
                        }
                        break;
                    case "ext":
                        if (typeof(pageTrackJSON) != "undefined") {
                            mrm.util.trackEvent('click_cta', {
                                section: 'masthead',
                                linkname: 'exterior:360 spin view'
                            });
                        }
                        break;
                    }

                    clearTimeout(timeOut);
                    clearInterval(playInt);
                    var direction = String(elem.attr('class').split(' ').slice(-1));
                    self.frameAdvance(direction);
                }
            },
            returnFrames: function(image, total) {
                var stack = [];
                var colorCount;
                for (i = 1; i <= total; i++) {
                    if (i <= 9) {
                        colorCount = '0' + i;
                    } else {
                        colorCount = i;
                    }

                    var name = colorCount + image + i + ".jpg";

                    stack.push(name);
                }
                return stack;
            },
            frameAdvance: function(dir) {
                var $image = this.$context.find('img');
                var nextFrame;
                var curFrame = $image.data("frame");
                if (dir === 'ccw') {
                    nextFrame = (curFrame === 1) ? this.totalFrames : curFrame - 1;
                } else {
                    nextFrame = (curFrame === this.totalFrames) ? 1 : curFrame + 1;
                }
                $image.reel('frame', nextFrame);
            }
        }
    });
}(mrm.$));(function($) {
    // declaring variables here to keep from polluting the global scope changed 01/18/2013
    var totalExpanders, currentColorName, colorBars = [],
        self;
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        mh_expander_1: {
            /**
             * JS for component mh_expander_1
             *
             */
            config: $.extend({
                mastheadWidth: 980,
                mastheadHeight: 347,
                buttonMargin: 10,
                chipMargin: 10,
                chipWidth: 25,
                showOnDemand: false
            }, mrm.conf.cmp.mh_expander_1 || {}),
            $threesixty_loaded: false,
            color_prefix: '',
            tpl: ['04', '06', '10'],
            init: function(c) {
                if ($('.modMh_expander_1').length === 0)
                    return;

                //mrm.debug=true;
                //mrm.util.log("debugging");

                totalExpanders = 0;
                var $clickanddrag;
                self = this;

                // shift up 60px

                // make sure mm_scroller_1 setup code runs first
                mrm.cmp.mh_scroller_1.setupScroller($(".modMh_expander_1"));

                $('.modMh_1 .mmScroll').addClass('topShift');

                // these scroll buttons appear when a 360 is the default. so this should hide them until they are needed.
                $('.modMh_expander_1 .mmScrollBtn.next').css("visibility", "hidden");
                $('.modMh_expander_1 .mmScrollBtn.prev').css("visibility", "hidden");
                this.adjustScrollerControls();

                // init the first colorizer (context)
                this.launchColorizer($('div.modColorizer:eq(0)'), true);

                // adjust widths of color bars
                this.setColorBarWidths();

                // expand the first expander
                this.autoLaunchFirstExpander();


                $('.expander-button-cell').on('click', function() {
                    self.closeAllExpanders();
                    var $hotLI = $(this).next();
                    $hotLI.addClass('expanded');
                    $hotLI.find('div.color-bar').addClass('expanded');
                    $(this).addClass('active');

                    self.adjustContainerLeft();
                    self.centerLabelText();

                    // launch new colorizer; send the ID of the clicked app
                    var scope = $(this).next().find('div.modColorizer');
                    self.launchColorizer(scope);

                    /* tracking */
                    var secTitle = $(this).find('div.expander-button').text();
                    if (typeof(pageTrackJSON) != "undefined") {
                        mrm.util.trackEvent('click_cta', {section: 'masthead', linkname: 'button:' + secTitle});
                    }
                    self.setInteriorOrExterior(secTitle.toLowerCase());

                });

                $('.expander-button-cell').on('mouseenter mouseleave', function() {
                    $(this).toggleClass('over');
                });


				//JMethod call
				if($('.mm_colorizer_c1 .placeholder_c1.section').length){
					$(".mod .toggle_holder").clone().appendTo(".mm_colorizer_c1 .placeholder_c1.section");
					self.setExteriorInterior();
				}
				//end JMethod call

                $(window).resize(function() {
                    self.adjustScrollerControls();
                });
            },
            setColorBarEvents: function(context) {
                // ADDED THESE FOR GMC VARIATION
                // rollover events for color chips; changes Color Name textfield
                var self = this;
                var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
                var captionTimeouts = [];

                // unbind first
                context.find('ul.colors > li > a').unbind('mouseenter');
                context.find('ul.colors > li > a').unbind('mouseleave');
                context.find('ul.colors > li > a').unbind(clickOrTouch);


                context.find('ul.colors > li > a').on(clickOrTouch, function(e) {
                    e.preventDefault();
                    var eventSelf = this;
                    currentColorName = $(this).attr('title');
                    view = $(".expanded .colorbar-title p").text();
                    $(this).hover().addClass('chipSelected');
                    $(this).parentsUntil("modColorizer").children("dt").text(self.color_prefix + currentColorName);

                    //colorizer color chip tracking
                    switch (mrm.cmp.mh1_colorizerthreesixty.intOrExt) {
                        case "int":
                            mrm.util.trackEvent("click_cta", {
                                section: 'masthead',
                                linkname: 'color:interior:' + currentColorName
                            });
                            break;
                        case "ext":
                            mrm.util.trackEvent("click_cta", {
                                section: 'masthead',
                                linkname: 'color:exterior:' + currentColorName
                            });
                            break;
                    }
                    $(this).parent().siblings().find('a').hover().removeClass('chipSelected');

                    // if threesixty, change colors
                    if ($(this).closest('.modColorizer').hasClass("mm_colorizer_c1_threesixty")) {
                        self.launchNewThreeSixty($(this));
                    }
                    if (self.config.showOnDemand && mrm.util.touchDevice()) {

                        $(eventSelf).parentsUntil(".modColorizer").children("dt").show();
                        for (var i = 0; i < captionTimeouts.length; i++) {
                            clearTimeout(captionTimeouts[i]);
                        }

                        captionTimeouts = [];


                        captionTimeouts.push(setTimeout(function() {

                            context.find("ul.colors").removeClass("hoverActive");
                            context.find(".color-bar dt").hide();
                        }, 5000));

                    }


                });

                //Only return color-title text to currently selected color when leaving the color-selection bar entirely
                context.find("div.color-bar").on("mouseleave", function(e) {
                    if (!self.config.showOnDemand) {
                        $(this).find("ul.colors > li > a").parentsUntil(".modColorizer").children("dt").text(self.color_prefix + currentColorName);
                    }
                });

                context.find('ul.colors > li > a').on('mouseenter', function(e) {
                    var colorText = $(this).attr('title');
                    $(this).parentsUntil('.modColorizer').children('dt').text(self.color_prefix + colorText);
                    $(this).addClass('chipHover');
                    if (self.config.showOnDemand && !mrm.util.touchDevice()) {
                        $(this).parentsUntil('.modColorizer').children('dt').show();
                    }
                });

                context.find('ul.colors > li > a').on('mouseleave', function(e) {
                    $(this).removeClass('chipHover');
                    if (self.config.showOnDemand && !mrm.util.touchDevice()) {
                        $(this).parentsUntil('.modColorizer').children('dt').hide();
                    }
                });

            },
            adjustScrollerControls: function() {
                // this is a hack to move the mmScroll arrows around. if there is a better way, ill kill it.

                var offset = $("div.modMh_expander_1").offset();

                // move left arrow
                $('.modMh_expander_1 .mmScrollBtn.prev').css("top", (offset.top + 26));
                $('.modMh_1 .mmScrollBtn.prev').css("left", 0);

                // move next arrow
                $('.modMh_expander_1 .mmScrollBtn.next').css("top", (offset.top + 26));
                $('.modMh_expander_1 .mmScrollBtn.next').css("left", 930);
            },
            setColorBarWidths: function() {

                // get color bar numbers
                $('ul.colors').each(function(index) {

                    totalExpanders += 1;
                    var $colorbar = $(this),
                        $totalGroups = $(this).find('li.color-title').length,
                        $totalChips = $(this).find('li.color-chip').length,
                        $groupTextWidth = 0;

                    var newWidth = $('.colorbar-title').width(); // does nothing   + ($totalGroups * 75); // width of title, subtitles + spacer
                    newWidth += $totalChips * (self.config.chipWidth + self.config.chipMargin); //chip width +spacer

                    //set the widths for each
                    // move to adjustContainerLeft
                    //$(this).closest('li.expander-cell').css('width', newWidth);
                    //$(this).closest('.color-bar').css('width', newWidth);

                    // save withs in an array
                    colorBars.push(newWidth);

                });
            },
            autoLaunchFirstExpander: function() {
                var expItem = $('li.expander-cell:eq(0)');

                expItem.addClass('expanded');
                expItem.addClass('first-expander');
                expItem.find('div.color-bar').addClass('expanded');

                var expButton = $('li.expander-button-cell:eq(0)');
                expButton.addClass('active');

                this.setInteriorOrExterior(expItem.find('span.colorbar-title').text().toLowerCase()); // tracking

                // this.setColorBarEvents(expItem);  // ADDED TO EXTEND COLORIZER
                this.setToFirstColorName(expItem); // SETS FIRST/DEFAULT COLOR NAME
                this.adjustContainerLeft();
                this.adjustClickAndDrag(); // SETS LEFT MARGIN FOR 360 CLICKANDDRAG
                this.centerLabelText();

                $('.modMh_expander_1').find('div.mh_content').css({
                    'display': 'block',
                    'opacity': "1"
                });
            },
            setInteriorOrExterior: function(t) {
                // sends button title to 360 for tracking

                var iCheck = t.indexOf("interior");
                if (iCheck != -1) {
                    mrm.cmp.mh1_colorizerthreesixty.intOrExt = "int";
                }

                var eCheck = t.indexOf("exterior");
                if (eCheck != -1) {
                    mrm.cmp.mh1_colorizerthreesixty.intOrExt = "ext";
                }

                //mrm.util.log(' >> '+ iCheck +" :: "+eCheck);

            },
            launchNewThreeSixty: function(chip) {
                // chip is the chip that was clicked
                this.$threesixty_loaded = true;
                var path = chip.parent().data('colorpath');
                var altText = chip.parent().data('alt');
                var angles = chip.closest('ul.colors').attr('no-of-perspective');

                var $context = $('.modMh_expander_1').find('ul.mmScrollItems');



                // first preload first frame
                var cmpC360PrevFrames = mrm.cmp.mh1_colorizerthreesixty.prevFrame;
                var cmpC360ReturnFrames = mrm.cmp.mh1_colorizerthreesixty.returnFrames(mrm.cmp.mh1_colorizerthreesixty.suffix, angles);
                var frameURLToPreload = path + cmpC360ReturnFrames[cmpC360PrevFrames-1];
                $('body').append('<img class="imagePreload360" src="'+frameURLToPreload+'" height="0" width="0" />');

                // after preloaded first frame
                var self = this;
                $('.imagePreload360').imagesLoaded().always( function( instance ) {
                    frameURLCurrentlyLoaded = $('.reel').attr('src');
                    //console.log(frameURLToPreload + '========' + frameURLCurrentlyLoaded);

                    mrm.cmp.mh1_colorizerthreesixty.teardown();
                    $context.empty();

                    $context.html('<img src="'+frameURLCurrentlyLoaded+'" width="' + self.config.mastheadWidth + '" height="' + self.config.mastheadHeight + '" />');
                    $context.append('<img class="tempFrameImg" src="'+frameURLToPreload+'" style="display:none;position:absolute;left:0;top:0;z-index:0;" width="' + self.config.mastheadWidth + '" height="' + self.config.mastheadHeight + '" />');


                    $('.tempFrameImg').fadeIn( 300, function() {
                        // Animation complete
                        $context.html('<img src="'+frameURLToPreload+'" width="' + self.config.mastheadWidth + '" height="' + self.config.mastheadHeight + '" />');

                        $context.append(self.create360HTML(chip.parent()));
                        mrm.cmp.mh1_colorizerthreesixty.build360($context, angles, path, altText);
                    });

                });

            },
            setToFirstColorName: function(c) {
            	var firstColorItem = c.find('ul.colors > li:eq(0) > a').attr('title'),
            		$colorDT = $(c.find('dt'));
                self.color_prefix = (!$colorDT.data('prefix-set')) ? $.trim($colorDT.text()) + " " : self.color_prefix; //this function is called twice.  Only set the prefix the first time
                $colorDT.data('prefix-set', true);
                c.find('dt').text(self.color_prefix + firstColorItem);
                currentColorName = firstColorItem;
                c.find('ul.colors > li').siblings().find('a').hover().removeClass('chipSelected');
                c.find('ul.colors > li:eq(0) > a').addClass('chipSelected');

            },
            create360HTML: function(colorPath) {
                var curImageNum = mrm.cmp.mh1_colorizerthreesixty.prevFrame;
                var $hardcodedfilename;

                if (curImageNum >= 10) {
                    $hardcodedfilename = curImageNum + "_perspective_img_" + curImageNum + ".jpg";
                } else {
                    $hardcodedfilename = "0" + curImageNum + "_perspective_img_" + curImageNum + ".jpg";
                }

                var $colorizerViewHTML = "";
                $colorizerViewHTML += '<span class="spinItem leftArrow control-threesixty ccw"></span>' +
                    '   <li class="mod modMh_item_1 colorizer_view mm_colorizerthreesixty_c1">' +
                    '       <figure>' +
                    '           <img id="threesixty-image" class="threesixty-image" src="' + colorPath.data('colorpath') + $hardcodedfilename + '" width="' + self.config.mastheadWidth + '" height="' + self.config.mastheadHeight + '" />' +
                    '           <figcaption class="legal">' + colorPath.data('text') + '</figcaption>' +
                    '       </figure>' +
                    '   </li>' +
                    '<span class="spinItem rightArrow control-threesixty cw"></span>';
                return $colorizerViewHTML;
            },
            launchColorizer: function(context, initial) {
                if (!context.hasClass("mm_colorizer_c1_threesixty")) {

                    if (this.$threesixty_loaded) {
                        mrm.cmp.mh1_colorizerthreesixty.teardown();
                    };

                    this.$threesixty_loaded = false;

                    $('.modMh_expander_1 .mmScrollBtn.next').css("visibility", "visible");
                    $('.modMh_expander_1 .mmScrollBtn.prev').css("visibility", "visible");

                    // write UL based on first LI in the colorizer list
                    // data-perspectives is for colorizer perspectives
                    $('.modMh_expander_1').find('ul.mmScrollItems').empty();
                    $('.modMh_expander_1').find('ul.mmScrollItems').trigger('destroy');

                    // get #
                    var $perspectives = context.find('ul.colors').attr('no-of-perspective');
                    var $firstLi = context.find('ul.colors > li.color-chip:eq(0)'); // has to be color-chip or it will pick up color-title
                    var $parentCell = context.closest('li.expander-cell');
                    this.setColorBarEvents($parentCell);
                    this.setToFirstColorName($parentCell);
                    var $colorizerViewHTML = "";
                    var colorPath,
                        colorText,
                        colorCount;

                    // for each, write an LI
                    for (var i = 1; i <= $perspectives; i++) {
                        $colorizerViewHTML = "";
                        colorPath = $firstLi.data("colorpath");
                        colorText = $firstLi.data('text');
                        colorAlt = $firstLi.data('alt');


                        if (i <= 9) {
                            colorCount = '0' + i;
                        } else {
                            colorCount = i;
                        }

						//var isLazy = true;
						if(initial && i > 1){
							$colorizerViewHTML += '<li class="mod modMh_item_1 colorizer_view mm_colorizer_c1" id="cq-id-' + i + '">' +
								'   <figure>' +
								'       <img class="onload" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-'+mrm.ui.image_loader.src_attribute+'="' + colorPath + colorCount + '_perspective_img_' + i + '.jpg" alt="' + colorAlt + '"width="' + self.config.mastheadWidth + '" height="' + self.config.mastheadHeight + '">' +
								'   <figcaption class="legal">' + colorText + '</figcaption>' +
								'   </figure>' +
								'</li>';
						}else{
							$colorizerViewHTML += '<li class="mod modMh_item_1 colorizer_view mm_colorizer_c1" id="cq-id-' + i + '">' +
								'   <figure>' +
								'       <img src="' + colorPath + colorCount + '_perspective_img_' + i + '.jpg" alt="' + colorAlt + '"width="' + self.config.mastheadWidth + '" height="' + self.config.mastheadHeight + '">' +
								'   <figcaption class="legal">' + colorText + '</figcaption>' +
								'   </figure>' +
								'</li>';
						}

                        $('.modMh_expander_1').find('ul.mmScrollItems').append($colorizerViewHTML);
                    }
                    mrm.cmp.mh_scroller_1.setupScroller($(".modMh_expander_1"));
                    $('div.modColorizer').each(function() {
                        $(this).unbind('colorizerItemChange');
                    });
                    mrm.cmp.colorizer.init();
                    if ($(context).parentsUntil("ul").hasClass("first-expander")) {
                        $('.modMh_expander_1').find('div.mh_content').css({
                            'display': 'block',
                            'opacity': "1"
                        });
                    } else {
                        $('.modMh_expander_1').find('div.mh_content').css('display', 'none');
                    }
                } else {
                    // teardown if there is one already here
                    if (this.$threesixty_loaded) {
                        mrm.cmp.mh1_colorizerthreesixty.teardown();
                    };

                    $('.modMh_expander_1').find('ul.mmScrollItems').trigger('destroy');

                    var $context = $('.modMh_expander_1 ul.mmScrollItems');
                    $context.empty();

                    // mrm.cmp.mh_1.init(); // say no to caroufredsel

                    // write UL
                    // data-perspectives is the # of threesixty angles
                    var angles = context.find('ul.colors').attr('no-of-perspective');
                    var $firstLi = context.find('ul.colors > li.color-chip:eq(0)');
                    var $parentCell = context.closest('li.expander-cell');
                    this.setColorBarEvents($parentCell);
                    this.setToFirstColorName($parentCell);

                    /*                         var $hardcodedfilename = "01_perspective_img_1.jpg";
					 var $colorizerViewHTML = "";
					 $colorizerViewHTML += '<span class="spinItem leftArrow control-threesixty ccw"></span>' +
					 '   <li class="mod modMh_item_1 colorizer_view mm_colorizerthreesixty_c1">' +
					 '       <img id="threesixty-image" class="threesixty-image" src="' + $firstLi.data('colorpath') + $hardcodedfilename + '" width="' + self.config.mastheadWidth + '" height="' + self.config.mastheadHeight + '" />' +
					 '   </li>' +
					 '<span class="spinItem rightArrow control-threesixty cw"></span>';
					 */
                    $context.append(this.create360HTML($firstLi));


                    var path = $firstLi.data('colorpath');
                    var altText = $firstLi.data('alt');
                    mrm.cmp.mh1_colorizerthreesixty.build360($context, angles, path, altText);
                    this.$threesixty_loaded = true;
                    if ($(context).parentsUntil("ul").hasClass("first-expander")) {
                        $('.modMh_expander_1').find('div.mh_content').css({
                            'display': 'block',
                            'opacity': "1"
                        });
                    } else {
                        $('.modMh_expander_1').find('div.mh_content').css('display', 'none');
                    }
                }
            },
			positionImage: function (_e) {
				var cWidthProp 	= $(document).width() * 100 / 1920;
				var cHeightProp = Math.max(487, cWidthProp * 730 / 100);
				$("div.mod div.mmScroll div.caroufredsel_wrapper").css('height',cHeightProp);
				$("div.mod div.mmScroll div.caroufredsel_wrapper ul.mmScrollItems").css('height',cHeightProp);
				return cHeightProp;
			},
			//JMethod
			setExteriorInterior: function(){
					var $mod=$('.mod');

					var heightFigure = this.positionImage(),
                        clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
					$(window).resize(this.positionImage);

					$("div.mh_content div.placeholder_c1 div.toggle_holder div.int_ext_toggle p:first-child").addClass("activeToggle");
					$("div.mh_content div.placeholder_c1 div.toggle_holder div.int_ext_toggle p:first-child").addClass("btn_exterior");
					$("div.mh_content div.placeholder_c1 div.toggle_holder div.int_ext_toggle p:nth-child(2)").addClass("btn_interior");
					$(".modMh_expander_1 .expander-container").addClass('colorizerPos');//Set coloraizer position
					$(".expander-cell.expanded.first-expander").addClass("col_exterior");
					$(".expander-button-container .expander-cell:last-child").addClass("col_interior");
					$(".col_interior").find('div.modColorizer').addClass("colorizerIntPos");
					$("div#cluetip").addClass("disNone");//Hide Cluetip
					$("div.mm_colorizer_c1 div#mm_colorizer_c1.mod dl dt").addClass("disNone"); //hide text color
					$("ul.mmScrollItems figure .legal").addClass("posPrice");//set price position
					$(".modMh_expander_1 .mmScrollPaginationWrp").addClass("dots");//set dots position
					$("div.modMh_expander_1 .mmScroll .mmScrollBtn.prev").addClass("prevPos");
					$("div.modMh_expander_1 .mmScroll .mmScrollBtn.next").addClass("nextPos");
					if($('html').hasClass('msie8')){
						$('.expander-container #mm_colorizer_c1').addClass('colorizerie8');
					};
					$($mod).on(clickOrTouch,'.btn_exterior', function(){
						$(".expander-cell.col_exterior").show();
						$(".btn_exterior").addClass('activeToggle');
						$(".btn_interior").removeClass('activeToggle');
						$(".expander-cell.col_interior").hide();
						var scope = $(".col_exterior").find('div.modColorizer');
						self.launchColorizer(scope);
						$(".mm_colorizer_c1").find("div.mh_content").css("display","block");
						$("ul.mmScrollItems figure .legal").addClass("posPrice");//set price position
					});

					$($mod).on(clickOrTouch,'.btn_interior', function(){
						$(".expander-cell.col_interior, .color-bar").show();
						$(".btn_interior").addClass('activeToggle');
						$(".btn_exterior").removeClass('activeToggle');
						$(".expander-cell.col_exterior").hide();
						var scope = $(".col_interior").find('div.modColorizer');
						self.launchColorizer(scope);
						$(".mm_colorizer_c1").find("div.mh_content").css("display","block");
						//set the height containers
						$("div.mod div.mmScroll div.caroufredsel_wrapper").css('height',heightFigure);
						$("div.mod div.mmScroll div.caroufredsel_wrapper ul.mmScrollItems").css('height',heightFigure);
                        $("div.mod div.mmScroll div.caroufredsel_wrapper ul.mmScrollItems li").css('height',heightFigure);
						$("ul.mmScrollItems figure .legal").addClass("posPrice");//set price position
						var firstColorid = $('.expander-cell.col_interior .colors li:first-child').attr('data-colorid');
						mrm.util.vehicleConfig.setPreferredIntColor(firstColorid); //set storeLocator IntColor attr
						$(".expander-cell.col_interior ul.colors li.color-chip a").on('click',function(){
							var rop= $(this).closest('li').attr('data-colorid');
							mrm.util.vehicleConfig.setPreferredIntColor(rop); //set storeLocator IntColor attr
						});
					});
			},// end JMethod
            closeAllExpanders: function() {
                $('li.expander-cell').each(function() {
                    var expId = $(this).attr('id');
                    $(this).removeClass('expanded');
                    $(this).find('div.color-bar').removeClass('expanded');
                });
                $('.expander-button-cell').each(function() {
                    $(this).removeClass('active');
                });
            },
            centerLabelText: function() {
                $container = $('div.expander-button-container');

                // Center Color Bar Label Text
                var cbTitleParaHeight = $container.find('li.expanded .colorbar-title p').height();
                var cbTitleHeight = $container.find('li.expanded .colorbar-title').height();
                var cbTitleMargin = (cbTitleHeight - cbTitleParaHeight) / 2;
                /// fix height calculations for IE
                if ($.browser.msie)
                    cbTitleMargin = (Math.round(cbTitleMargin) === cbTitleMargin) ? cbTitleMargin + 1 : Math.ceil(cbTitleMargin);

                $container.find('li.expanded .colorbar-title p').css("margin-top", cbTitleMargin);

                // Center Expander Button Label Text

                $container.find('.expander-button').each(function() {
                    var ebTitleParaHeight = $(this).find("p").height();
                    var ebTitleHeight = $(this).height();
                    var ebTitleMargin = (ebTitleHeight - ebTitleParaHeight) / 2;
                    /// fix height calculations for IE
                    if ($.browser.msie)
                        ebTitleMargin = (Math.round(ebTitleMargin) === ebTitleMargin) ? ebTitleMargin + 1 : Math.ceil(ebTitleMargin);


                    $(this).find("p").css("margin-top", ebTitleMargin);

                });
            },
            adjustContainerLeft: function() {
                var movewidth = 0,
                    barwidth = 0,
                    btnwidth = 0,
                    lblwidth = 0,
                    $container = $('div.expander-button-container');

                $('.expander-button').not("li.active .expander-button").each(function() {
                    btnwidth += $(this).outerWidth(true) + self.config.buttonMargin;
                    //debugger;
                })
                movewidth = btnwidth;
                lblwidth = $container.find('li.expanded').find('.colorbar-title').width();

                // if one is expanded
                $('li.expander-cell').each(function(index) {
                    if ($(this).hasClass('expanded')) {
                        barwidth = colorBars[index] + lblwidth + 20; /* padding on either side of the label*/
                        movewidth = btnwidth + barwidth + self.config.buttonMargin;
                    }
                });

                $container.css('width', movewidth);
                $container.find('li.expanded').find('.colorbar-title').width(lblwidth);
                $container.find('li.expander-cell').css('width', barwidth);
                $container.find('.color-bar').css('width', barwidth);

            },
            adjustClickAndDrag: function() {
                if ($('div.clickanddragicon').length != 0) {
                    var container_width = $('div.expander-button-container').width();
                    var mh_expander_width = $('.masthead .modMh_expander_1').width();
                    var padding_needed = 35;
                    var left_margin = (mh_expander_width - container_width) - padding_needed;
                    $('.modMh_expander_1 div.clickanddragicon').css('margin-left', '-' + left_margin + 'px');
                }
            }


        }
    });
}(mrm.$));;(function($) {
	mrm.mod.Mh_item_1 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;

			if (mrm.util.curTemplate() === "05" || mrm.util.curTemplate() === "06" || mrm.util.curTemplate() === "12" || mrm.util.curTemplate() === "13") {
				// While Masthead video is present, hide the #mastheadShadow div created in chevy mh_scroller_1.js
				// so video controls are usable. 
				self.$ctx.on('mmVideoPlay', function(){
					if ($('div#mastheadShadow').length){
						$('div#mastheadShadow').css('z-index', '-1');
					}
				});
				self.$ctx.on("mmVideoComplete", function(){
					if ($('div#mastheadShadow').length){
						$('div#mastheadShadow').css('z-index', '1');
					}
				});
			}

		}
	});
})(mrm.$);(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		mh_scroller_1: {
			/**
			 * JS for component Mh_scroller_1
			 *
			 * @param {String} c DOM Context
			 */
			$scrollerWrp: null,
			$globalMod: null,
			/* configurable list of modules that use text indicators*/
			textIndicatorModules: ['.modVi_trim_1'],
			/* modules that use thumbnail indicators */
			thumbnailIndicatorModules: ['.modVi_trim_1', '.modMh_item_1', '.modMh_col_item_1', '.modMm_hotspot_1'],
			initMod: function($mod) {
				var self = this;
				self.$globalMod = $mod;
				var intIndexTextIndicatorModule = this.indexOfTextIndicatorModule($mod, this.textIndicatorModules);
				if ($mod.find(".mm_colorizerthreesixty_c1").length > 0)
					return;

				// check if vehicleConfig is enabled in localStorage
				if ($mod.find(".dynamic_teaser_scroller").length > 0) {
					if (typeof mrm.conf.util.vehicleConfig !== 'undefined' && mrm.conf.util.vehicleConfig.enabled) {
						// have to wait until vehicleConfig is loaded from localStorage
						$.eventDispatcher.on("vehicle_config_load", function() {
							self.setupDynamicMasthead($mod, true);
							self.setupScroller($mod, intIndexTextIndicatorModule);
						});
					}
					else {
						// setup mastheads without checking localStorage
						self.setupDynamicMasthead($mod, false);
						self.setupScroller($mod, intIndexTextIndicatorModule);
					}
				}
				else {
					self.setupScroller($mod, intIndexTextIndicatorModule);
				}
			},
			setupDynamicMasthead: function($mod, useLocalStorage) {
				var self = this;
				var dynamicID = '';
				var cookie = mrm.util.cookie.get("current-vehicle");

                var year = '';
                var carline = '';
                // check localStorage first
                if (useLocalStorage && typeof mrm.util.vehicleConfig.getCurrentVehicle() !== 'undefined') {
                	year = mrm.util.vehicleConfig.getCurrentVehicle().generalParams.year.toString();
                	carline = mrm.util.vehicleConfig.getCurrentVehicle().generalParams.carline;
                }
                if (year.length > 0 && carline.length > 0) {
                	dynamicID = year + "-" + carline;
					Omniture_s.linkTrackVars = "eVar40";
					Omniture_s.eVar40 = dynamicID.replace('-', ':') + ":repeat";
					Omniture_s.tl(true, 'o', 'gmds');
                }
                else if (typeof cookie !== "undefined") {
                    dynamicID = decodeURIComponent(cookie);
                    if (dynamicID.length === 0 || dynamicID === 'null') {
                        // cookie is blank - try hash
                        dynamicID = window.location.hash.replace("#","");
                    }
                }
                else {
                    // cookie is undefined - try hash
                    dynamicID = window.location.hash.replace("#","");
                }
				// disable next/prev buttons
				$mod.find('.mmScrollBtn').addClass('disabled');
				if (dynamicID.length && $mod.find("#" + dynamicID + ".dynamic").length && !$mod.find('.multiAsset').length) {
					// detach all items that aren't the requested one
					$mod.find(".dynamic").not("#" + dynamicID).detach();
					// set dynamic masthead as first image
					var $correct_slide = $mod.find("#" + dynamicID + ".dynamic")
					$correct_slide.parent().prepend($("#" + dynamicID));
					$correct_slide.find(".dynamic_teaser_scroller").css("visibility", "visible");
					$correct_slide.css("visibility", "visible");

					$.eventDispatcher.trigger('onDynamicMastheadShow', $mod);
				}
				else {
					$.eventDispatcher.trigger('onDynamicMastheadRemove', $mod);
					// no dynamic mastheads should be viewable - remove all
					$mod.find(".dynamic").detach();// shouldn't this be remove?  detach keeps it in memory
					$mod.find(".mmScrollItems li").not(".dynamic").find(".dynamic_teaser_scroller").css("visibility", "visible"); //GMDSST-54595
					$('.modMh_scroller_1').find('.modMh_item_1').not('.dynamic').css("visibility", "visible");
				}
			},
			setupScroller: function($mod, intIndexTextIndicatorModule) {
				var self = this;
				var $colorizer = $(".modColorizer", $mod);
				var modCfg = mrm.conf.cmp.mh_scroller_1 || {};
				var mandatoryConfig;
				var $mmScroll = $mod.find('.mmScroll').first();
				var scrollerCanvas = false;

				$.eventDispatcher.trigger('mh_scroller_ready');

				self.$scrollerWrp = $('div.mmScroll:eq(0)', $mod);

				// Check for basic canvas trasition
				if (self.$scrollerWrp.hasClass('ui-scroller-canvas') && typeof (self.canvasTransition) === "object" && (mrm.util.curTemplate() !== "02")) {
					scrollerCanvas = true
				}

				var trackingKey = $('div.mmScroll', $mod).data('trackingKey'),
					trackingConfig = {
						callbacks: {}
					};
				if (mrm.conf.cmp[trackingKey]) {
					trackingConfig.callbacks = mrm.conf.cmp[trackingKey];
				}

				mandatoryConfig = $.extend(true, {}, modCfg, trackingConfig, {
					hiddenItemOverride: true,
					onCreate: function($newItems, newSizes) {
						self.checkAndPrepareTextPagination($mod, intIndexTextIndicatorModule);
						$.eventDispatcher.trigger("colorizer_initialized");
						$colorizer.trigger('colorizerItemChange', [$newItems, $([]), 0]);
						self._activateVideo($mod);
						return (modCfg.onCreate || $.noop)($newItems, newSizes);
					},
					scroll: {
						onBefore: function($oldItems, $newItems, newSizes, duration) {
							if (!$colorizer.hasClass('noFade')) {
								$colorizer.trigger('colorizerItemChange', [$newItems, $oldItems, duration]);
							}
							if (scrollerCanvas) {
								self.canvasTransition.slide($oldItems, $newItems);
							}
							return (modCfg.scroll.onBefore || $.noop)($oldItems, $newItems, newSizes, duration);
						},
						onAfter: function($oldItems, $newItems, newSizes, duration) {
							if ($('div.mmScroll', $mod).hasClass('indicator-thumbnails')) {
								self.updateThumbnailPagination($mod, $newItems);
							}
							self._activateVideo($mod);

							// check for a video-layer and remove it if it exists
							// this is only for the videos in mh_teasers
							if ($oldItems.find('.video-layer').length) {
								var $vid_layer = $mod.find('.video-layer');
								mrm.corcmp.mmVideo.deactivateVideo($oldItems, $vid_layer);
								$vid_layer.empty();
								$vid_layer.remove();

							} else {
								mrm.corcmp.mmVideo.deactivateVideo($oldItems);
							}

							var direction = ($oldItems.index() > 1) ? 'next' : 'prev';
							if (self.slideOnThumbnail === true) {
								self.slideOnThumbnail = false;
							} else {
								$newItems.trigger('tracking', direction);
							}

							return (modCfg.scroll.onAfter || $.noop)($oldItems, $newItems, newSizes, duration);
						}
					}
				});

				// test if scroller indicators are set to thumbnails
				if ($('div.mmScroll', $mod).hasClass('indicator-thumbnails')) {
					// prevent main scroller from building a pagination
					mandatoryConfig.pagination = {
						container: null,
						anchorBuilder: null
					};
				} else {
					self.checkAndSetTextPagination($mod, mandatoryConfig, intIndexTextIndicatorModule);
				}

				if (this.$scrollerWrp.hasClass('ui-disable-loop')) {
					mandatoryConfig.circular = false;
					mandatoryConfig.infinite = false;
				}

				// Check for advanced polygon canvas and init scroller
				if (this.$scrollerWrp.hasClass('ui-scroller-type2') && (typeof (this.scrollerType2) === 'object')) {
					this.scrollerType2.init(mandatoryConfig);
				}

				//  NEW TRANSITION
				else if (scrollerCanvas) {
					var imageWidth = $(".mmScroll ul li img").first().width();
					if (imageWidth >= 1280 && imageWidth < 1500) {
						if (!$(".mmScroll").hasClass("ui-full-width")) {

							$(".masthead").css("max-width", imageWidth + 'px');
							$(".masthead > .mod, .masthead > .mh_c1 > .mod").css("max-width", imageWidth + "px");
							$(".masthead").css("margin", "0 auto");

							// position price info
							if ($.os.name === "ipad") {
								$(".masthead figcaption.legal").css("margin-right", "175px");
							}
							else {
								$(".masthead figcaption.legal").css("margin-right", ((imageWidth - 1280) / 2) + "px");
							}

							$(document).ready(function() {
								$(".modMh_1 #mastheadShadow").css("width", '100%');
								$(".modMh_1 #mastheadShadow").css("left", '0');
								$(".modMh_1 #mastheadShadow").css("z-index", '1');
							});
						}
					}
					if (typeof (self.canvasTransition) !== 'undefined') {
						this.$scrollerWrp.mmScroll(mandatoryConfig);
						self.canvasTransition.initMod(this.$scrollerWrp);
					}
					else {
						this.$scrollerWrp.mmScroll(mandatoryConfig);
					}
				}
				else {
					this.$scrollerWrp.mmScroll(mandatoryConfig);
				}

				// for full width
				if (typeof (self.fullWidth) !== 'undefined') {
					self.fullWidth.initMod(this.$scrollerWrp);
				}

				// test if scroller indicators are set to thumbnails
				if ($('div.mmScroll', $mod).hasClass('indicator-thumbnails')) {
					// setup thumbnail pagination scroller
					self.setupThumbnailPagination($mod, $('ul.mmScrollItems', $mod));
				}

				// prev/next button-images depends on the content height or used cmps
				if (modCfg.smallContentMaxHeight || modCfg.smallContentComponents) {
					if (($mod.height() <= (parseInt(modCfg.smallContentMaxHeight, 10) || 0)) || $mod.find(modCfg.smallContentComponents).length) {
						this.$scrollerWrp.addClass('smallContent');
					}
				}

				// init full width masthead video if it exists
				if (typeof (this.full_masthead_video) !== 'undefined')
					this.full_masthead_video.init();

                // adjust canvas to account for secondary navigation
                if ($(".modNav_sec").length) {
                    var logo = $(".divisional_logo").outerHeight();
                    var modNav = $(".modNav_sec").height();
                    modNav -= 25;
                    $(".modMh_scroller_1 .mmScroll canvas").css("top", (logo + modNav) + "px");
                }

				this.setBindings($mod);

				// bind event for tracking
				$mod.on('tracking', function(event, action) {
					var trackingObj, placeholder = "<trackingObject>";

					switch (action) {
						case 'prev':
							if (typeof mandatoryConfig.callbacks.onScrollerPrev === "function") {
								trackingObj = $(event.target).data('trackingObject').replace(/'/g, '"').replace(placeholder, 'arrow_pre');
								mandatoryConfig.callbacks.onScrollerPrev($.parseJSON(trackingObj));
							}
							break;
						case 'next':
							if (typeof mandatoryConfig.callbacks.onScrollerNext === "function") {
								trackingObj = $(event.target).data('trackingObject').replace(/'/g, '"').replace(placeholder, 'arrow_nxt');
								mandatoryConfig.callbacks.onScrollerNext($.parseJSON(trackingObj));
							}
							break;
						case 'thumbnail':
							if (typeof mandatoryConfig.callbacks.onThumbnailClick === "function") {
								trackingObj = $(event.target).data('trackingObject').replace(/'/g, '"');
								mandatoryConfig.callbacks.onThumbnailClick($.parseJSON(trackingObj));
							}
							break;
					}
				});

				self._setupLazyLoad($mmScroll)
			},
			_setupLazyLoad: function($mmScroll){
				/// hide scroll button until all images have been loaded
				//  first check to make sure they are being lazy loaded.
				if ($mmScroll.find('img[data-' + mrm.ui.image_loader.src_attribute + ']').length) {
					// listen for the image laod event and check to see if all the images have been loaded.
					var listener = $.eventDispatcher.on('image_loaded', function() {
					if ($mmScroll.find('img.' + mrm.ui.image_loader.loaded_class).length === $mmScroll.find('img[data-' + mrm.ui.image_loader.src_attribute + ']').not('.' + mrm.ui.image_loader.onscroll_class).length) {
						// if not dynamic then show buttons
						if($mmScroll.find('.modMh_item_1.dynamic').length === 0){
							// get the buttons remove the hidden class and fade them in
							var buttons = $mmScroll.find('.mmScrollBtn:not(.disabled)');
							buttons.hide();
							buttons.fadeIn();
						}
						// remove listener
						$.eventDispatcher.off(listener);
					}
					});
				}
			},
			_activateVideo: function($container) {
				var self = this;
				if (!$container || $container.length === 0)	return;

				// find the deepest visible content-module
				var $deepest = mrm.util.deepest('.ui-helper-visible', $container);

				/**
				 * If video is in a mh_teaser then make it expand to the size of the masthead
				 */
				if ($deepest.find('.mh_teaser').find('.video').length) {
					self._activate_teaser_video($deepest);
				} else {
					mrm.util.doInitVideo($deepest);
				}
			},
			_activate_teaser_video: function($deepest) {
				// Create a video layer target
				var $vid_layer = $('<div />', {
					"class": "video-layer"
				}).appendTo($deepest);

				var $video = $deepest.find('.mh_teaser').find('.video');

				// Initalize video
				mrm.util.doInitVideo($deepest, $vid_layer);

				// Listen for when the poster frame is click
				$video.on('click', 'img', function() {
					var $this = $(this);
					// Create a dummy object to avoid errors
					var thePlayer = {
						onPlay: function() {
						},
						onComplete: function() {
						}
					};
					// Find the video player object
					$.each(jwplayer.getPlayers(), function() {
						if ($(this.container).closest('.video-layer').length) {
							thePlayer = this;
						}
					});

					// get the relative position of the thumbnail and size
					var pOffset = $deepest.offset();
					var cOffset = $this.offset();
					var relativePos = {top: cOffset.top - pOffset.top, left: cOffset.left - pOffset.left};
					var teaserImgSize = {width: $this.width(), height: $this.height()};

					// start video-layer of over the thumbnail
					$vid_layer.css({
						'left': relativePos.left,
						'top': relativePos.top,
						'width': teaserImgSize.width,
						'height': teaserImgSize.height
					});

					// Animate the video-layer to the size of the masthead
					$vid_layer.animate({
						'left': 0,
						'top': 0,
						'width': $deepest.width(),
						'height': $deepest.height()
					}, 500, 'easeOutQuart');

					// When complete remove the video-layer
					thePlayer.onComplete(function() {
						// animate back to the thumbnail
						$vid_layer.removeClass('playing').animate({
							'left': relativePos.left,
							'top': relativePos.top,
							'width': teaserImgSize.width,
							'height': teaserImgSize.height
						}, 250, 'easeInQuad', function() {
							// empty and move the video-layer out of sight
							$vid_layer.css({
								top: 999999999999,
								left: 999999999999
							});
							$vid_layer.empty();
						});

					});
					thePlayer.onPause(function() {
						$vid_layer.removeClass('playing');
					});
					thePlayer.onPlay(function() {
						$vid_layer.addClass('playing')
					})
				});
			},
			setBindings: function($mod) {
				var self = this,
					$pagination = this.$scrollerWrp.find('.mmScrollPaginationWrp:visible'),
					fxCfg = mrm.conf.corcmp.mm_scroller || {},
					modCfg = $.extend({
						animatePagination: true
					}, mrm.conf.cmp.mh_scroller_1 || {});

				fxCfg = fxCfg.animateControls || {};
				fxCfg.speed = fxCfg.speed || 300;

				$('.mh_nav.play-video', $mod).on('click', function(event) {
					//TODO $(this).parents().find('.hidden-video').trigger('click');
					event.preventDefault();
				});

				if (modCfg.animatePagination) {
					this.$scrollerWrp.on('hideControls', function(e) {
						// called when the buttons hide
						$pagination.stop(true, true).fadeOut(fxCfg.speed);
					}).on('showControls', function(e) {
						// called when the buttons show
						$pagination.stop(true, true).fadeIn(fxCfg.speed);
					});
				}
			},
			// used by deeplinking.js
			switchToContent: function($content) {
				if (this.$globalMod.find('.multiAsset').length > 0) {
					$('.mmScrollItems', this.$scrollerWrp).children('.multiAsset').hide();
					$content.parents('.multiAsset').show();
				} else {
					/* needs possible carofredsel plugin work on slideTo for IE */
					$('.mmScrollItems', this.$scrollerWrp).trigger("slideTo", $content);
				}
			},
			checkAndSetTextPagination: function($mod, objConfig, intIndexTextIndicatorModule) {
				var strTextIndicators = null, arrTextIndicators = null;

				if (intIndexTextIndicatorModule > -1) {
					var blankClassName = this.textIndicatorModules[intIndexTextIndicatorModule].replace(/.mod/, "");
					strTextIndicators = decodeURIComponent($mod.data('textindicators'));

					if ((strTextIndicators !== null) && (strTextIndicators.length > 0) && (strTextIndicators !== 'undefined')) {
						arrTextIndicators = mrm.$.parseJSON(strTextIndicators);
						if (arrTextIndicators !== null) {
							objConfig.pagination = {
								anchorBuilder: function(nr) {
									return "<li><a href=\"#\">" + arrTextIndicators[nr - 1] + "</a></li>";
								}
							};
						}
					}
					if (!$mod.hasClass("contentIs" + blankClassName)) {
						$mod.addClass("contentIs" + blankClassName);
					}
				}
			},
			checkAndPrepareTextPagination: function($mod, intIndexTextIndicatorModule) {
				var $label, $mmScrollPagination;
				if (intIndexTextIndicatorModule > -1) {
					$mmScrollPagination = $mod.find('.mmScrollPagination');
					$label = $mod.find('.lbl');
					$($label).remove().insertBefore($mmScrollPagination);
					$mmScrollPagination.css('display', 'inline-block');
				}
			},
			indexOfTextIndicatorModule: function($mod, arrTextIndicatorModules) {
				var i, $textIndicatorModule, intIndexTextIndicatorModule = -1;

				for (i = 0; i < arrTextIndicatorModules.length; i++) {
					$textIndicatorModule = $mod.find('ul.mmScrollItems li ' + arrTextIndicatorModules[i]);
					if ($textIndicatorModule.length > 0) {
						intIndexTextIndicatorModule = i;
						break;
					}
				}
				return intIndexTextIndicatorModule;
			},
			setupThumbnailPagination: function($mod, $mainScroller) {
				var self = this,
					$thumbnailPagination = $('.mmScrollThumbnailPagination', $mod),
					$thumbnailPaginationItems = $('li', $thumbnailPagination),
					$thumbnailPaginationCurrentItem = $('#thumb_' + $('li:first', $mainScroller).data('mmscrollId')), // for deeplinking
					thumbnailPaginationLoop = ($('div.mmScroll', $mod).hasClass('ui-disable-loop')) ? false : true,
					thumbnailPaginationConfig = {
						circular: thumbnailPaginationLoop,
						infinite: thumbnailPaginationLoop,
						width: '100%',
						height: 'auto',
						items: {
							visible: 'variable'
						},
						scroll: {
							wipe: false,
							noWipeDirection: false,
							fx: 'slide'
						},
						auto: {
							play: false,
							pauseDuration: 5000
						},
						prev: {
							button: function() {
								return $(this).parent().prev('.thumbsBtn.prev');
							}
						},
						next: {
							button: function() {
								return $(this).parent().next('.thumbsBtn.next');
							}
						}
					},
				thumbnailWipeConfig = {
					min_move_x: 30,
					min_move_y: 30,
					preventDefaultEvents: false,
					preventDefaultEventsHorizontal: false,
					preventDefaultEventsVertical: false,
					wipeLeft: function(e) {
						$thumbnailPagination.trigger('next');
					},
					wipeRight: function(e) {
						$thumbnailPagination.trigger('prev');
					}
				};

				// adjust width of thumbnail containers
				$thumbnailPaginationItems.each(function() {
					$(this).width($('.img.thumbnail', this).width());
				});

				// initialise thumbnail pagination scroller
				$thumbnailPagination.carouFredSel(thumbnailPaginationConfig);
				if ($.fn.touchwipe) {
					$thumbnailPagination.touchwipe(thumbnailWipeConfig);
				}

				// highlight and slide to initially selected item (e.g. for deeplinking)
				if ($thumbnailPaginationCurrentItem.length > 0) {
					$thumbnailPaginationCurrentItem.addClass('selected');
					$thumbnailPagination.trigger('slideTo', $thumbnailPaginationCurrentItem);
				}

				// add click events to thumbnails
				$thumbnailPaginationItems.on('click', function(event) {
					var thumbnailId = $(this).attr('id'),
						scrollerId = thumbnailId.split('thumb_').join('');

					self.slideOnThumbnail = true;
					$(this).trigger('tracking', 'thumbnail');

					$mainScroller.trigger('slideTo', $('li[data-mmscroll-id=' + scrollerId + ']'));
					$thumbnailPaginationItems.removeClass('selected');
					$(this).addClass('selected');
				});
			},
			// update thumbnail pagination scroller when main scroller was actively scrolled
			updateThumbnailPagination: function($mod, $newItems) {
				var currentScrollerId = $newItems.data('mmscrollId'),
					currentThumbnailId = '#thumb_' + currentScrollerId,
					$currentThumbnail = $(currentThumbnailId),
					$thumbnailPagination = $('.mmScrollThumbnailPagination', $mod),
					currentVisible = $thumbnailPagination.triggerHandler('currentVisible');

				// highlight thumbnail belonging to selected main scroller item
				$('li', $thumbnailPagination).removeClass('selected');
				if ($currentThumbnail.length > 0)
					$currentThumbnail.addClass('selected');

				// scroll to selected thumbnail if existent and not visible
				if ($currentThumbnail.length > 0 && currentVisible.filter(currentThumbnailId).length < 1) {
					$thumbnailPagination.trigger('slideTo', $currentThumbnail);
				}
			}
		}
	});
}(mrm.$));
/*
 * @author Jacob Bolton - MRM-DET
 * New 2013 Chevy Rebrand custom polygon masking/animating of masthead scroller.
 *
 * Chad Wilson ported to /public/modules/Mh_scroller_1/brands/chevrolet2013/js/mh_scroller_1.js
 */
(function($) {
	if (mrm.util.curTemplate() === "05" || mrm.util.curTemplate() === "06" || mrm.util.curTemplate() === "12" || mrm.util.curTemplate() === "13") {
        $(document).ready(function() {
            //Adding a shadow div to make flipper dots and as shown text more visible
            $('.masthead').find('.mmScroll').append('<div id="mastheadShadow"></div>');

			if ( $('.modMh_scroller_1', '.modMh_1').length || $('.modMm_visualizer_1', '.modMh_1').length ) {
				var navHeight = $(".divisional_logo").outerHeight();
				if ($('.modNav_sec').length) {
					var nav_secHeight = $(".modNav_sec").height();
					nav_secHeight -= 25;
					$('.modMh_1').css('margin-top', (navHeight + nav_secHeight) + 'px');
				} else {
					$('.modMh_1').css('margin-top', navHeight + 'px');
				}
			}
        });
    }

	// update masthead max-width for Culture pages
	if ( mrm.util.curTemplate() === '12' || mrm.util.curTemplate() === '13' ) {
		var imageWidth = $(".mmScroll ul li img").first().width();
        if ( imageWidth >= 1280 && imageWidth < 1500) {
			$(".masthead > .mod, .masthead > .mh_c1 > .mod").css("max-width", imageWidth + "px");
		}

		// set masthead height to 0 to prevent multiple mastheads flashing on Culture Scroller pages
		/*if ($(".modStory_overview").hasClass("scrollerInit")) {
			$(".masthead .modMh_1").css("height","0px")
		}*/
	}

    /* reset the video size if it's homepage masthead video */
    if ((mrm.util.curTemplate() === "02") && (typeof (mrm.corcmp.mmVideo) === "object") && (mrm.$('div.modMh_1 video.mm').length === 1)) {
        mrm.$('div.modMh_1 video.mm').attr('width', mrm.$(window).width());
        mrm.$(window).resize(function () {
            var jwp = jwplayer();
            if (typeof(jwp) === 'object') {
                jwp.resize(mrm.$(window).width(), mrm.$("div.modMh_1").height());
            }
        });
    }
    if ((mrm.util.curTemplate() === "02") && ($('div.mmScroll.ui-scroller-type2 ul li div.video img:first').length)) {
        /* prepare hidden-video images for polygon transforming */
        $('div.mmScroll.ui-scroller-type2 ul li div.video img').each(function() {
			//$('div.mmScroll.ui-scroller-type2 ul li.modMh_item_1 img').each(function() {
            $(this)
                .attr('orig-src', $(this).attr('src'))
                .attr('src', '#')
                .addClass('lazy-load');
        });
    }

    mrm.cmp.mh_scroller_1 = mrm.cmp.mh_scroller_1 || {};

	mrm.cmp.mh_scroller_1.canvasTransition = {
				config: {
				duration: 800,
				easing: 'easeInCubic',
				angleInDegrees: 64,
				fps: mrm.util.iOS() ? 40 : 60
			},
			init: function() {
				//console.log('overall setup');
			},
			/**
			 * Initialize the component
			 * @param {jQuery} $mod
			 * @returns {void}
			 */
			initMod: function($mod) {
				// <editor-fold desc="POLYFILL FOR requestAnimationFrame" >
				// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
				// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

				// requestAnimationFrame polyfill by Erik Mller
				// fixes from Paul Irish and Tino Zijdel

				var lastTime = 0;
				var vendors = ['ms', 'moz', 'webkit', 'o'];
				for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
					window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
					window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
						|| window[vendors[x] + 'CancelRequestAnimationFrame'];
				}

				if (!window.requestAnimationFrame)
					window.requestAnimationFrame = function(callback, element) {
						var currTime = new Date().getTime();
						var timeToCall = Math.max(0, 16 - (currTime - lastTime));
						var id = window.setTimeout(function() {
							callback(currTime + timeToCall);
						},
							timeToCall);
						lastTime = currTime + timeToCall;
						return id;
					};

				if (!window.cancelAnimationFrame)
					window.cancelAnimationFrame = function(id) {
						clearTimeout(id);
					};
				// </editor-fold>
				//console.log('init for scroller');
				/* create the canvas transition layers */
				var canvas = document.createElement('canvas');

				canvas.width = $mod.width();
				canvas.height = $mod.height();

				$mod.append($(canvas).hide());
				//IE compatiblity
				//if (typeof FlashCanvas !== "undefined") {
				//	FlashCanvas.initElement(canvas);
				//}

				// if ($.os.name === "ipad") {
				// 	var textWidth = 980 - parseInt($(".mh_content").css("width"));
				// 	$(".mh_content").css("width",textWidth);
				// }

				// center mh_storydetails_1 for ipad
                if ($.os.name === "ipad" && mrm.util.curTemplate() !== '12' ) {
					$mod.find(".modMh_storydetails_1").css("margin-left", 0 - $mod.find(".modMh_storydetails_1").outerWidth() / 2 + "px");
				}
			},
			/**
			 * Prepares for the animation
			 * @param {jQuery} $itm
			 * @param {jQuery} $itmNext
			 * @returns {void}
			 */
			slide: function($itm, $itmNext) {
				mrm.util.log('slide working');
				var $scroller = $itm.closest('.mmScroll'),
					$mm1 = $itm.closest('.modMh_scroller_1'),
					img = $itm.find('img')[0],
					imgNext = $itmNext.find('img')[0],
					imageWidth = $(imgNext).width(),
					scrollerHeight = $scroller.height(),
					scrollerWidth = $scroller.width(),
					$canvas = $scroller.children('canvas'),
					img1Num = $itm.index(),
					img2Num = $itmNext.index(),
					direction = img1Num < img2Num ? 'next' : 'prev';

				var xOffset,
					textDirection = $('html').attr('dir') || 'ltr';

				if ($(".mmScroll").hasClass("ui-full-width")) {
					xOffset = parseInt($scroller.find('ul').css('margin-left'));
					xOffset = xOffset > 0 ? 0 : xOffset;
				} else {
					var difference = ($(window).width() - $('.modMh_1').outerWidth(false)) / 2;

					difference = difference > 0 ? 0 : difference;
					xOffset = difference <= -150 ? -150 : difference;

					// for RTL text direction the xOffset has to be negated and rounded up
					xOffset = (textDirection === 'rtl') ? Math.ceil(-xOffset) : parseInt(xOffset);
				}

				$canvas.css('z-index', $mm1.data("indexBase"));
				$canvas[0].width = imageWidth;
				$canvas[0].height = scrollerHeight;

				// a little trig to figure out correct offset length based on the angle given in config.
				var angleLength = Math.round(scrollerHeight / Math.tan(this.config.angleInDegrees / 180 * Math.PI));

				var polygon_arr = [
					/* X,Y coordinates */
					{x: 0, y: 0}, /* left bottom */
					{x: -angleLength, y: scrollerHeight}, /* left top */
					{x: scrollerWidth, y: scrollerHeight}, /* right top */
					{x: scrollerWidth + angleLength, y: 0}]/*right bottom*/;

				// check if png then assume it's transparent
				var transparent = false;
				if ($.os.name === "ipad" || typeof img !== 'undefined') {
					if(/\.png$/.test(img.src)){
						$scroller.find('img').hide();
						transparent = true;
					}
				}

				var theImages = {img: img, img2:imgNext, x: xOffset, y: parseInt($(imgNext).css('margin-top')), w: imageWidth, h: imgNext.height};

				this.drawImages({ctx: $canvas[0].getContext('2d'), direction: direction, polygon_arr: polygon_arr, images: theImages, angleLength: angleLength, transparent: transparent});
			},
			/**
			 * Controls starts animation and controls frame rate
			 * @param {object} options
			 * @returns {void}
			 */
			drawImages: function(options) {
				var self = this;

				// reset the animation
				cancelAnimationFrame(self.animationId);

				// make canvas visible
				$(options.ctx.canvas).show();

				var startTime = new Date().getTime(),
					lastExec = startTime,
					firstTime = true;

				// start things
				(function canvasAnimate() {
					var now = new Date().getTime(),
						t = now - startTime,
						b = 0,
						c = options.polygon_arr[3].x,
						d = self.config.duration,
						p = $.easing[self.config.easing](null, t,b,c,d);

					options._offset = (options.direction === 'next') ? p*-1 : p;

					// calculate if its time to display the next frame based on the fps
					if ((now - lastExec) > (1000 / self.config.fps) || firstTime) {
						firstTime = false;
						lastExec = new Date().getTime();
						self.wipeAnimation(options);
					}

					if (t <= d+15) {
						self.animationId = requestAnimationFrame(canvasAnimate);
					} else {
						//options.ctx.clearRect(0, 0, options.ctx.canvas.width, options.ctx.canvas.height);
						if (!options.transparent)
							$(options.ctx.canvas).hide(0);
					}
				})();// call it
			},
			/**
			 * Draws the images on the canvas
			 * @param {object} options
			 * @returns {Boolean}
			 */
			wipeAnimation: function(options) {
				var self = mrm.cmp.mm_1.canvasTransition;
				var ctx = options.ctx;
				var _offset = options._offset;


				// clear the whole canvas
				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

				var theImage = options.images;

				if(options.transparent){
					ctx.beginPath();
					if(options.direction === 'next'){
						ctx.moveTo(parseInt(options.polygon_arr[2].x) + _offset, parseInt(options.polygon_arr[2].y));
						ctx.lineTo(parseInt(options.polygon_arr[3].x) + _offset, parseInt(options.polygon_arr[3].y));
						ctx.lineTo(parseInt(options.polygon_arr[3].x) + theImage.w, parseInt(options.polygon_arr[3].y));
						ctx.lineTo(parseInt(options.polygon_arr[2].x) + theImage.w, parseInt(options.polygon_arr[2].y));
					}else{
						ctx.moveTo(parseInt(options.polygon_arr[0].x) + _offset, parseInt(options.polygon_arr[0].y));
						ctx.lineTo(parseInt(options.polygon_arr[1].x) + _offset, parseInt(options.polygon_arr[1].y));
						ctx.lineTo(parseInt(options.polygon_arr[1].x) - theImage.w, parseInt(options.polygon_arr[1].y));
						ctx.lineTo(parseInt(options.polygon_arr[0].x) - theImage.w, parseInt(options.polygon_arr[0].y));
					}

					ctx.closePath();
					ctx.save();
					ctx.clip();

					ctx.drawImage(theImage.img2, theImage.x, theImage.y, theImage.w, theImage.h);
					ctx.restore();
				}

				// draw the masked image
				ctx.beginPath();
				for (var i = 0; i < (options.polygon_arr.length); i++) {
					var x = parseInt(options.polygon_arr[i].x) + _offset;
					var y = parseInt(options.polygon_arr[i].y);
					if (i === 0)
						ctx.moveTo(x, y);
					else
						ctx.lineTo(x, y);
				}
				ctx.closePath();

				/* draw shadow - not used in IOS for performance reasons  */
				if (!mrm.util.iOS() && !options.transparent) {
					ctx.shadowColor = "rgba(0, 0, 0, .5)";
					ctx.shadowBlur = 10;
					ctx.shadowOffsetX = (options.direction === 'next') ? 10 : -10;
					ctx.shadowOffsetY = 0;
					ctx.fillStyle = "black";
					ctx.fill();
				}

				ctx.save();
				ctx.clip(); // Clip to whatever path is on the context

				if ($.os.name === "ipad" || typeof theImage.img !== 'undefined') {
					ctx.drawImage(theImage.img, theImage.x, theImage.y, theImage.w, theImage.h);
				}
				ctx.restore();
			}
		},
		mrm.cmp.mh_scroller_1.fullWidth = {
            config: $.extend(mrm.conf.cmp.mh_scroller_1 || {}, {
                maxWidth: 1920
            }),
            init: function($mod) {
                //console.log('fullWidth setup');
            },
            initMod: function($mod) {
                if($mod.hasClass('ui-full-width')){

					if ((mrm.util.curTemplate() === '12')) {
						$('.modMh_1, .modMh_1 .modMh_item_1 > img').css('height', 'auto');
						$('.modMh_1, .modMh_1 .modMh_item_1').css('max-height', '551px');
					}

					$mod.parents('.modMh_1, .masthead').css('width','100%');
                    //  find the original width and height and save them to data
                    $mod.find('img').each(function() {
						var $this = $(this);
						// console.log($this.parent().hasClass('.modMh_item_1'));
                        $this.data('origSize', {height: $this.height(), width: $this.width()});
                        // set css width and remove the width and height attributes
                        $this.css({width: $this.attr('width')});
                        $this.removeAttr('height width');
                    });

                    // set current height, max-width and overflow on the scroller
                    $mod.css({height: $mod.height(), maxWidth: this.config.maxWidth, overflow: 'hidden'});
                    $mod.parents('.masthead, .modMh_1').css( {maxWidth: this.config.maxWidth, overflow: 'hidden'});
                    $mod.parent('.mod.modMh_scroller_1').css({'overflow': 'visible', 'padding-left': 0, 'padding-right': 0});

                    // event listener for window resize
                    $(window).resize($.proxy(function() {
                        this.resize($mod);
                    }, this));

                    // initial call
                    this.resize($mod);
                }
            },
            resize: function($mod) {
                var pageWidth = $(window).width(),
                    containerWidth = $('.modMh_scroller_1').width();
                $mod.closest('.modMh_scroller_1').css({marginLeft:0, marginRight:0});

                var nMargin = (containerWidth - pageWidth)*.5;

                    nMargin = nMargin > 0 ? 0 : nMargin;
                    nMargin = pageWidth > 1920 ? 0 : nMargin;

                // size the mod first it's the outter most
                $mod.css({'margin-left': nMargin, 'margin-right':nMargin});
                $mod.parents('.modMh_scroller_1').css({'margin-left': nMargin, 'margin-right':nMargin});

                // find the top image
                var $topImage = $mod.find('img:eq(0)'),
                    modWidth = $mod.width();

                // size the carousel second
                $mod.find('.caroufredsel_wrapper').width(modWidth);

                // if larger then original size then set all images to width and
                // calculate the top negitive margin for centering the image vertically.
                if (modWidth >= $topImage.data('origSize').width) {
                    //var $allImages = $mod.find('.modMh_item_1 img');

					// keep text in masthead within 980 safe area
					$mod.find('.mh_content_wrapper').each( function(j,k) {
						$(k).css("margin-left",(modWidth - $topImage.data('origSize').width)/2+"px" );
					});

					$mod.find('.modMh_item_1').each( function(_i) {
						$allImages = $(this).find('img').first();

						var topMargin = Math.floor(((($topImage.data('origSize').width * $topImage.data('origSize').height) / modWidth) - $topImage.data('origSize').height) * .5);
						$allImages.css({'margin-top': topMargin, 'width': modWidth});
						$mod.find('.caroufredsel_wrapper > ul').css({'margin-left': 0});

						// Keep 'as shown' relative to its parents edge.
						var windowCurrentWidth = Math.max( parseInt($('#container').css('min-width')), pageWidth);
						if (pageWidth <= 1920) {
							$mod.find('figcaption.legal').css('left', (windowCurrentWidth-200)+'px');
						}
					});
                } else {
                    var leftMargin = (modWidth - $topImage.data('origSize').width) *.5;
                    $mod.find('.caroufredsel_wrapper > ul').css({'margin-left': leftMargin});

					// Keep 'as shown' relative to its parents edge.
					var windowCurrentWidth = Math.max( parseInt($('#container').css('min-width')), pageWidth);
					$mod.find('figcaption.legal').css('left', (windowCurrentWidth-200-leftMargin)+'px');

					// keep text in masthead within 980 safe area
					// this will only matter when user is resizing window so fast that above code doesn't trigger
					$mod.find('.mh_content_wrapper').each( function(j,k) {
						$(k).css("margin-left","0px" );
					});
                }

				// Remove unnecessary styles.
				$mod.find('figcaption.legal').css('top', '500px');
				$mod.find('figcaption.legal').css('bottom', 0);
				$mod.find('figcaption.legal').css('right', 0);

                //center if over maxWidth
                if (pageWidth > this.config.maxWidth){
                    $mod.css('left', (pageWidth-this.config.maxWidth)*.5);
                } else {
                    $mod.css('left', 0);
                }
            }
        },

		/* reset img tags for scrollerType2 */
    	mrm.cmp.mh_scroller_1.scrollerType2 = {
            _isAnimating: false,
            _isColorizing: false,
            _config: null,
            _parentConfig:null,
            _leftOffset: 0,
            _screenCompressed: true,
            _dirOptions: {},
            _lefts: {
                prev: 0,
                active: 0,
                next: 0
            },
            _autoAnimatePaused: false,
            _usePagination: true,
            _autoAnimateInterval: null,
            _lastDirection: 'next',
            $mod: $('div.modMh_1:first'),
            $mmScrollBtns: $('div.modMh_1 div.mmScroll.ui-scroller-type2 span.mmScrollBtn'),

            init: function (_config) {
				if (!this.$mod.length) return;
				var self = this;
                self._parentConfig = _config;
                self._config = self._parentConfig.scrollerType2;
                $('body').addClass('withType2Scroller');

                /* set overall imagewidth */
                if (self.$mod.find('div.mmScroll li.modMh_item_1 img:first').length)
                    self._config.imageWidth = parseInt(self.$mod.find('div.mmScroll li.modMh_item_1 img:first').attr('width'));

                /* pre populate polygon/angles/strings for Chevy 2013 */
                self._config.polygon_arr = [
                	/* X,Y coordinates */
	                0, self._config.height,
	                self._config.angleLength, 0,
	                self._config.imageWidth, 0,
	                (self._config.imageWidth - self._config.angleLength), self._config.height
                ];

                /* rearrange the order to match with CQ */
				for ( i=0; i<2; i++ ) {
						self.$mod.find('div.modMh_scroller_1 div.mmScroll li.modMh_item_1:last').prependTo(
						self.$mod.find('div.modMh_scroller_1 div.mmScroll li.modMh_item_1:last').parent()
					);
				}

				/* self.$mod.find('div.mmScroll li.modMh_item_1:last').prependTo(
					self.$mod.find('div.mmScroll li.modMh_item_1:last').parent()
				);*/

                /* set each image with a polymask */
                self.$mod.find('div.mmScroll li.modMh_item_1').each( function(_index) {
                    /* arrange position */
                    var $item = $(this),
                        left = 0,
                        zIndex = self._config.zIndexBase - 1;

					if ($('.modMh_item_1').length < 5) {
	                    switch (_index) {
	                        case 0:
	                            $item.addClass('prev');
	                            break;
	                        case 1:
	                            $item.addClass('active');
	                            break;
	                        case 2:
	                            $item.addClass('next');
	                            break;
	                    }
					} else {
	                    switch (_index) {
	                        case 1:
	                            $item.addClass('prev');
	                            break;
	                        case 2:
	                            $item.addClass('active');
	                            break;
	                        case 3:
	                            $item.addClass('next');
	                            break;
	                    }

					}

                    if ($item.hasClass('active')) {
                        left = 0;
                        zIndex = self._config.zIndexBase;
                    } else if ($item.hasClass('prev')) {
                        left = -(self._config.width - self._config.angleLength);
                        zIndex = self._config.zIndexBase + 1;
                    } else if ($item.hasClass('next')) {
                        left = ($('li.modMh_item_1.active').first().position().left + self._config.width - self._config.angleLength);
                        zIndex = self._config.zIndexBase + 2;
                    } else {
                        left = $(window).width() * 2;
                    }

                    $item.css({
                        'left': (left),
                        'z-index': zIndex,
                        'width' : self._config.imageWidth,
                        'height' : self._config.height
                    });

                    /* disable video click events and reset in the bindings */
                    $item.off('click');

                    /* draw polygon canvas */

                    // there is no lazy-load img

                    var $polyImg = $item.find('img.lazy-load');
                    $(this).attr('data-colorpath', $polyImg.attr('orig-src'));
                    if ($polyImg.length) {
                        self.drawCanvasImages($polyImg);
                    }
                });

                /* add animated captions - move the CSS to a CSS file */
                $('body').prepend('<div id="modMh_1_ctaOverlay"><h2 class="cta"><span class="leftCap"></span><span class="centerContent"></span><span class="rightCap"></span></h2></div>');
                /* cleanup old click tracking */
                self.$mod.find("li.modMh_item_1.active h2.cta a").attr('onclick', '');
                $('#modMh_1_ctaOverlay h2.cta span.centerContent').html(self.$mod.find("li.modMh_item_1.active h2.cta:first").html());

                self.resetLeftPositions();
                self.resetCta();

                /* supress if CTA text is empty */
                if ($.trim( self.$mod.find("li.modMh_item_1.active h2.cta:first").html()) === '') {
                    $('#modMh_1_ctaOverlay').css('display','none');
                } else {
                    $('#modMh_1_ctaOverlay').css('display','block');
                }

                if (self._usePagination) {
                    var $pagination = $('<div class="mmScrollPaginationWrp"><ol class="mmScrollPagination"></ol></div>');
                    self.$mod.find('div.mmScroll li.modMh_item_1').each(function(_index) {
                        $pagination.find('ol.mmScrollPagination').append('<li><a href="#">' + (_index+1) + '</a></li>');
                    });
                    $pagination.find('ol.mmScrollPagination li').first().addClass('selected');
                    self.$mod.find('div.mmScroll').append($pagination);
                }
                self.prepareHiddenVideos();
                self.setBindings();

                self.$mod.find('.mmScroll').addClass('jsReady');

                self.autoAnimate();
                /* set auto hiding of arrows */
                self.autoHideArrows();
            },
            drawCanvasImages: function ($img) {
                var self = this;

                /* create loading graphic */
                if (typeof (self._config.loadingImgSrc) === "string") {}
                var $imgLoading = $('<img src="' + self._config.loadingImgSrc + '" border="0" class="ajax-loader" />');
                $img.after($imgLoading);

                /* create canvas element */
                var canvas = document.createElement('canvas');
                canvas.width = self._config.imageWidth;
                canvas.height = self._config.height;
                $img.after(canvas);

                /* initiate Flash Canvas for older browsers */
                if (typeof FlashCanvas !== "undefined") {
                    FlashCanvas.initElement(canvas);
                }

                /* canvas context */
                var ctx = canvas.getContext('2d');

                /* do everything after loading */
                var tmpImg = $('<img />').load(function() {
                    var that = this;
                    var canvasTimeout = 0;
                    if (mrm.util.ie8()) {
                        canvasTimeout = 500;
                    }

                    //set timeout for IE8
                    setTimeout(function() {
                        /* draw and save */
                        ctx.save();
                        ctx.beginPath();

                        /* draw polygon path */
                        for (var i = 0; i < (self._config.polygon_arr.length); i += 2) {
                            var x = parseInt(self._config.polygon_arr[i]);
                            var y = parseInt(self._config.polygon_arr[i + 1]);

                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.clip();
                        ctx.drawImage($(that).get(0), 0, 0);
                        ctx.restore();

                        var imgFilename = $img.attr('orig-src').substr($img.attr('orig-src').lastIndexOf('/') + 1);
                        $(canvas).attr('data-imgSrc', imgFilename);

                        $img.remove();

                        /* do any post processing scripts */
                        if (typeof (self._config.onItemLoad) === 'function') {
                            self._config.onItemLoad(ctx);
                        }
                        /* fade out the loading graphic and fade in the image */
                        $imgLoading.fadeOut(500, function () {
                            $(that).remove();
                        });
                        $(canvas).fadeTo(1000, 1, function() {
                            $(that).prev('canvas').fadeTo(1000,0, function() {
                                self._isColorizing = false;
                                $(canvas).prevAll().remove();
                            });
                        });
                    },canvasTimeout);
                });
                tmpImg.attr('src', $img.attr('orig-src') + '?ieReload=1');
            },
            animate: function (_dir) {
                var self = this;
                if (self._isAnimating) return;
                else self._isAnimating = true;

                self.resetHiddenVideos();
                self.resetCta();
                self.$mod.find('li.modMh_item_1.active div.legal').hide();

                var asc = (_dir === 'next'),
                    lastNxtTile = self.$mod.find('li.modMh_item_1.next'),
                    lastActTile = self.$mod.find('li.modMh_item_1.active'),
                    lastPrevTile = self.$mod.find('li.modMh_item_1.prev'),
                    paginationDots = self.$mod.find('ol.mmScrollPagination li'),
                	newTile = (asc) ? lastNxtTile.next() : lastPrevTile.prev();

                if ($('.modMh_item_1').length < 5) {
					if (asc) {
						newTile = lastNxtTile.next().length ? lastNxtTile.next() : lastPrevTile;
					} else {
						newTile = lastPrevTile.prev().length ? lastPrevTile.prev() : lastNxtTile;
					}
				}

                self._dirOptions = {
                    animateDir: (asc) ? '-=' : '+=',
                    animateTime: {
                        minTime: self._config.animateTime.minTime,
                        maxTime: self._config.animateTime.maxTime,
                        leftTile: self._config.animateTime.minTime,//(asc) ? self._config.animateTime.maxTime : self._config.animateTime.minTime,
                        centerTile: self._config.animateTime.minTime,//(self._config.animateTime.maxTime / self._config.animateTime.minTime) * self._config.animateTime.minTime,
                        rightTile: self._config.animateTime.minTime,//(asc) ? self._config.animateTime.minTime : self._config.animateTime.maxTime,
                        newTile: self._config.animateTime.minTime
                        //lastPrevTile: (asc) ?
                    },
                    zIndex: {
                        leftTile: (asc) ? self._config.zIndexBase + 3 : self._config.zIndexBase,
                        centerTile: self._config.zIndexBase + 1,
                        rightTile: self._config.zIndexBase + 2,
                        newTile: (asc) ? self._config.zIndexBase + 3 : self._config.zIndexBase
                    },
                    lefts: {
                        newTile: (asc) ? self._lefts.next : self._lefts.prev,
                        lastActTile: (asc) ? self._lefts.prev : self._lefts.next,
                        lastNxtTile: (asc) ? self._lefts.active : self._lefts.next * 2,
                        lastPrevTile: (asc) ? self._lefts.prev * 2 : self._lefts.active,
                        ctaOffScreen: (asc) ? 2000 : -2000
                    },
                    finalLeft: 0 // for use if screen size is less than the maximum width
                };

                var dirOpt = self._dirOptions;

                /* reset new labels */
                lastNxtTile.removeClass('next');
                lastActTile.removeClass('active');
                lastPrevTile.removeClass('prev');

                var $nextDot = paginationDots.filter('.selected').removeClass('selected');

                if (asc) {
                    lastNxtTile.addClass('active');
                    lastActTile.addClass('prev');
                    newTile.addClass('next');
                    if (!self._screenCompressed) {
                         //dirOpt.animateTime.newTile =self._config.animateTime.minTime+50
                        //dirOpt.lefts.lastActTile = self._lefts.active - (self._config.imageWidth - self._config.angleLength + 1);
                        //dirOpt.lefts.newTile = self._lefts.active + (self._config.imageWidth - self._config.angleLength + 1);
                    }

                    if ($nextDot.next().length) {
                        $nextDot.next().addClass('selected');
                    } else {
                        paginationDots.first().addClass('selected');
                    }
                } else {
                    lastPrevTile.addClass('active');
                    lastActTile.addClass('next');
                    newTile.addClass('prev');
                    if (self._screenCompressed) {
                        //dirOpt.lefts.lastActTile = self._lefts.active + (self._config.imageWidth - self._config.angleLength + 1);
                        //dirOpt.lefts.newTile = self._lefts.active - (self._config.imageWidth - self._config.angleLength + 1)
                    }

                    if ($nextDot.prev().length) {
                        $nextDot.prev().addClass('selected');
                    } else {
                        paginationDots.last().addClass('selected');
                    }
                }

                /* setup newTile's left */
                newTile.css('left', dirOpt.lefts.newTile * 2);
                var easing = 'easeInOutCubic';
                /* animate last next */
                lastNxtTile.css('z-index', dirOpt.zIndex.rightTile).stop()
                    .animate({
                        left: dirOpt.lefts.lastNxtTile
                    }, dirOpt.animateTime.leftTile, easing);

                /* animate last active */
                lastActTile.css('z-index', dirOpt.zIndex.centerTile).stop()
                    .animate({
                        left: dirOpt.lefts.lastActTile
                    }, dirOpt.animateTime.centerTile, easing);

                /* animate last prev */
                lastPrevTile.css('z-index', dirOpt.zIndex.leftTile).stop()
                    .animate({
                        left: dirOpt.lefts.lastPrevTile
                    }, dirOpt.animateTime.centerTile, easing);

                /* animate new */
                newTile.css('z-index', dirOpt.zIndex.newTile).stop()
                    .animate({
                        left: dirOpt.lefts.newTile
                    }, dirOpt.animateTime.newTile, easing);

                /* animate the CTA and set the active -- this is commented out as a precaution of the the CAOR changing their minds. */
                /* Animated CTA
                $('#modMh_1_ctaOverlay h2').stop().animate({
                    right: dirOpt.lefts.ctaOffScreen
                }, 750, "easeInOutExpo", function () {
                    // after it's out of view, then reset the text content
                    $(this).children(0).html(self.$mod.find("li.modMh_item_1.active h2.cta:first").html());
                    // now animate back into view
                    $(this).css({
                        right: -dirOpt.lefts.ctaOffScreen
                    }).animate({
                        right: self._lefts.cta
                    }, 1000, "easeOutExpo");
                });
                */

                /* supress if CTA text is empty */
                if ( $.trim( self.$mod.find("li.modMh_item_1.active h2.cta:first").html()) === '' ) {
                    $('#modMh_1_ctaOverlay').css('display','none');
                } else {
                    $('#modMh_1_ctaOverlay').css('display','block');
                }

                /* fade in / fade out */
                $('#modMh_1_ctaOverlay h2').fadeTo(250,0, function(){
                    // change html
                    $(this).find('.centerContent')
                        .html(self.$mod.find("li.modMh_item_1.active h2.cta:first").html())
                        .parent().fadeTo(500,1);
                });

                self._lastDirection = _dir;

                /* reshuffle z-index */
                setTimeout(function () {
                    /* bring previous tile back to top for rollover effects */
                    self.$mod.find('li.modMh_item_1.prev').css('z-index', (self._config.zIndexBase + 3));
                    if (asc) {
                        /*lastActTile.addClass('prev').css('z-index', self._config.zIndexBase + 2);
                        lastNxtTile.css('z-index', self._config.zIndexBase);
                        lastPrevTile.css('z-index', self._config.zIndexBase - 1);
                        newTile.css('z-index', self._config.zIndexBase);*/
                        lastActTile.prevAll().last().appendTo(self.$mod.find('ul.mmScrollItems').first());
                    } else {
                       /* lastActTile.addClass('next').css('z-index', self._config.zIndexBase + 2);
                        lastNxtTile.css('z-index', self._config.zIndexBase - 1);
                        lastPrevTile.css('z-index', self._config.zIndexBase);
                        newTile.css('z-index', self._config.zIndexBase + 1);*/
                        newTile.nextAll().last().prependTo(self.$mod.find('ul.mmScrollItems').first());
                    }
                    self._isAnimating = false;
                    self.resetLeftPositions(false, 1000);
                    self.$mod.find('li.modMh_item_1.active div.legal').show();
                    self.prepareHiddenVideos();
                }, 1250);
            },
        	resetLeftPositions: function (_setEasing, _animTiming, _bypassSetCSS ) {
                var self = mrm.cmp.mh_scroller_1.scrollerType2,
                width = $(window).width(),
                nxtTile = self.$mod.find('li.modMh_item_1.next'),
                actTile = self.$mod.find('li.modMh_item_1.active'),
                prevTile = self.$mod.find('li.modMh_item_1.prev'),
                cta = $('#modMh_1_ctaOverlay h2'),
                legal = actTile.find('div.legal'),
                easing = (_setEasing) ? 'easeOutExpo' : 'easeInOutExpo';
                var overlapAdjust = 100;
                var leftOffset = ((width - self._config.imageWidth) / 2) + (overlapAdjust/2);
                self._lefts.active = leftOffset;
                self._lefts.next = self._config.imageWidth - self._config.angleLength + leftOffset-overlapAdjust,
                self._lefts.prev = -(self._config.imageWidth - (self._config.angleLength + leftOffset));
                self._lefts.cta = leftOffset;

                if (width < self._config.width) {
                    self._screenCompressed = true;
                    var _leftOffset2 = (width - self._config.width)/2;
                   // self._lefts.next += _leftOffset2;
                   // self._lefts.prev -= _leftOffset2;
                   // self._lefts.cta -= _leftOffset2;
                } else if (width >= self._config.width) {
                    self._screenCompressed = false;
                }

                if (!_bypassSetCSS) {
                    actTile.css('left', leftOffset);
                    nxtTile.stop().css('left', self._lefts.next);
                    prevTile.stop().css('left', self._lefts.prev);
                    cta.stop().css('right', self._lefts.cta);
                }
            },
            resetCta:function() {
                $('#modMh_1_ctaOverlay').stop().fadeTo(100, 1);
                $('.mmScrollPaginationWrp').stop().fadeTo(100, 1);
                $('li.modMh_item_1.active .legal').stop().fadeTo(100, 1);
            },
            hideCta:function() {
                $('#modMh_1_ctaOverlay').hide();
                $('.mmScrollPaginationWrp').hide();
                $('li.modMh_item_1.active .legal').hide();
            },
            resetHiddenVideos:function() {
                /* clear all hidden videos */
                var $hiddenVideo = this.$mod.find('div.video');
                if (!$hiddenVideo.length) return;

                $hiddenVideo.each(function () {
                    $(this).trigger('videoClear');
                    $(this).removeAttr('style');
                });

                if ($('#mastheadVideo').length) {
                    $('#mastheadVideo').fadeTo(1000, 0, function() {
                        $(this).remove();
                    })
                    .find('div.video').trigger('videoClear');
                }
            },
            prepareHiddenVideos: function () {
                var self = this,
                    isActivated = false;

                /* clear everything */
                self.resetHiddenVideos();

              /*   remove inline width/height added by global video js since masthead restructuring, which affects chevrolet2013 masthead videos
                if($('div.modMh_1 div.modMh_scroller_1 div.mmScroll li.modMh_item_1 div.video').length) {
					$('div.modMh_1 div.modMh_scroller_1 div.mmScroll li.modMh_item_1 div.video').removeAttr('style');
				}

				if($('div#modMh_1_ctaOverlay h2.cta span.centerContent div.video').length) {
					$('div#modMh_1_ctaOverlay h2.cta span.centerContent div.video').removeAttr('style');
				}*/

                /* prepare the new one */
                var $activeHiddenVideo = self.$mod.find('li.modMh_item_1.active div.video:first');
                if ($activeHiddenVideo.length) {
                    if (!$('#mastheadVideo').length) {
                        $('body').prepend($('<div id="mastheadVideo" style="position:absolute;top:0;left:0;width:100%;height:' + $("div.modMh_1").height() + 'px;z-index:45;background:black;display:none;"/>'));
                    }
                    var $mastheadVideo = $('#mastheadVideo');
                    $mastheadVideo.html($activeHiddenVideo.clone()).append('<a href="#" class="close"></a>');
                    var mastheadConfig = mrm.conf.cmp.mh_1.hiddenVideoJWOptions;
                    mastheadConfig.height = self._config.height;
                    if (!mrm.util.flash()) delete mastheadConfig.skin;
                    var $videoContainer = $mastheadVideo.find('div.video');
                        $videoContainer.css('height', mastheadConfig.height)
                        .empty()
                        .hiddenVideo({},mastheadConfig)
                        .trigger('videoPrepare')
                        .getHiddenVideoPlayerObject()
                        .onBeforePlay(function() {
                            /* set fullscreen for touch devices */
                            if (mrm.util.touchDevice()) {
                                var $vid = $("#" + this.id + "_video:first");
                                if ($vid.length) {
                                    var vidElem = $vid.get(0);
                                    if (vidElem.webkitSupportsFullscreen) {
                                        vidElem.webkitEnterFullscreen();
                                    }
                                }
                            }
                        })
                        .onComplete(function() {
                            $("div.modMh_1").css({'height':'551px','margin-top':'0px'});
                            $mastheadVideo.fadeTo(1000,0, function() {
                                $(this).find('div.video')
                                .trigger('videoClear')
                                .trigger('videoPrepare');
                                $(this).hide();
                            });
                            self.resetCta();
                        });

                    /* clean up for touch devices */
                    if (mrm.util.touchDevice()) {
                        self.$mod.find('li.modMh_item_1.active div.video:first').off('click')
                            .on('touchend', function (event) {
                                event.preventDefault();
                                if (self._isAnimating) return;
                                if (isActivated) {
                                    $(this).getHiddenVideoPlayerObject().play();
                                } else {
                                    $(this).trigger('videoActivate');
                                    isActivated = true;
                                }
                            });
                    }

                 }
            },
            autoAnimate:function() {
                var self = this;
                var $container = $('div.ui-scroller-type2');
                if ($container.data('cfgAutoscroll')) {
                    self._autoAnimateInterval = setInterval(function () {
                        if (!self._autoAnimatePaused) {
                            self.animate("next")
                        }
                    }, 6000);

                    }
            },
            clearAutoAnimate:function() {
                var self = this;
                clearInterval(self._autoAnimateInterval);
            },
            autoHideArrows: function() {
                if (this._parentConfig.animateControls) {
                    var self = this,
                        controlsVisible = true,
                        inactivityTimer,
                        controlsAnimation,
                        $list = self.$mod.find('.mmScroll > ul.mmScrollItems'),
                        cfg = self._parentConfig,
                        $mmScrollBtns = self.$mmScrollBtns;

                    function controlsHandler(delay) {
                         delay |= 5000;

                        if (!controlsVisible) {
                            $list.trigger('showControls');
                            controlsVisible = true;
                        }
                        window.clearTimeout(inactivityTimer);
                        inactivityTimer = window.setTimeout(function () {
                            controlsVisible = false;
                            $list.trigger('hideControls');
                        }, delay);
                    }
                    controlsAnimation = function ($mmScrollBtns, show) {
                        $mmScrollBtns.stop(true, true);

                        if (cfg.animateControls.fx === 'slide') {
                            $mmScrollBtns.filter('.prev').animate({
                                left: !show ? btnPrevLeft : '0'
                            }, cfg.animateControls.speed);

                            $mmScrollBtns.filter('.next').animate({
                                right: !show ? btnNextRight : '0'
                            }, cfg.animateControls.speed);
                        } else if (cfg.animateControls.fx === 'fade'){
                            // fade animation
                            $mmScrollBtns[show ? 'fadeIn' : 'fadeOut'](cfg.animateControls.speed);
                        } else {
                            $mmScrollBtns[show ? 'show' : 'hide'](cfg.animateControls.speed);
                        }
                    }

                    var btnPrevLeft = '-' + self.$mmScrollBtns.filter('.prev').outerWidth() + 'px',
                        btnNextRight = '-' + self.$mmScrollBtns.filter('.next').outerWidth() + 'px';

                    self.$mmScrollBtns.on('mouseenter', function(e) {
                        window.clearTimeout(inactivityTimer);
                    }).on('mouseleave', function(e) {
                        controlsHandler();
                    });
                    $list.on('mousemove.mmScroll', function (e) {
                        controlsHandler(cfg.animateControls.inactivityTimeout);
                    }).on('hideControls.mmScroll', function (e) {
                        $list.addClass('mmScrollControlsHidden');
                        controlsAnimation(self.$mmScrollBtns, false);
                    }).on('showControls.mmScroll', function (e) {
                        $list.removeClass('mmScrollControlsHidden');
                        controlsAnimation(self.$mmScrollBtns, true);
                    });
                    controlsHandler(cfg.animateControls.loadTimeout);
                }

            },
            colorizer: function($newPath) {
                var self = this;
                if (!self._isColorizing) {
                    self._isColorizing = true;
                    self.$mod.find('div.mmScroll li.modMh_item_1').each(function (_index) {
                        var imgSrc = $newPath + $(this).data('colorpath').split('/').pop();
                        var $polyImg = $('<img src="#" orig-src="' + imgSrc + '" width="' + self._config.imageWidth + '" height="' + self._config.height + '" border="0" style="visibility:hidden" />');
                        $(this).find('canvas:first').after($polyImg);
                        self.drawCanvasImages($polyImg);
                    });
                }
            },
            setBindings: function () {
                /* polymasking bindings only */
                var self = this;
                var touchOrClick = (mrm.util.touchDevice()) ? 'touchend' : 'click';

                var prevSelectors = 'div.modMh_1 div.mmScroll.ui-scroller-type2 li.modMh_item_1.prev, div.modMh_1 div.mmScroll.ui-scroller-type2 span.mmScrollBtn.prev';
                var nextSelectors = 'div.modMh_1 div.mmScroll.ui-scroller-type2 li.modMh_item_1.next, div.modMh_1 div.mmScroll.ui-scroller-type2 span.mmScrollBtn.next';
                var activeSelectors = 'div.modMh_1 div.mmScroll.ui-scroller-type2 li.modMh_item_1.active';
                /* CTA video click */
                $(document).on(touchOrClick, '#modMh_1_ctaOverlay h2.cta, div.modMh_1 div.mmScroll.ui-scroller-type2 li.modMh_item_1.active > div.video:first', function (e) {

                    var $hiddenVideo = $('#mastheadVideo div.video:first');
                    if ($hiddenVideo.length) {
                        self.clearAutoAnimate();
                        $('#mastheadVideo').fadeTo(1000,1);
                        $('div.modMh_1').css({'height':'750px','margin-top':'50px'});
                        $('#mastheadVideo').css({'height':'750px','margin-top':'38px'});
                        $('.videoContainer').css('height', '100%');
                        $('#mastheadVideo a.close').css('top', '27px');

                        //move video up and keep close button in view for 1024 resolution
                        if($(window).width()<=1024) {
							$('#mastheadVideo').css('top','-100px');
							$('#mastheadVideo a.close').css('top', '125px');
						}

                        self.hideCta();
                        $hiddenVideo.trigger('videoActivate');
                        $('#mastheadVideo').resize();
                    }
                });

                /* previous/next */
                $(document).on(touchOrClick, prevSelectors, function (e) {
                    self.clearAutoAnimate();
                    self.animate('prev');
                    self.clearAutoAnimate();
                    self.autoAnimate();
                });

                $(document).on(touchOrClick, nextSelectors, function (e) {
                    self.animate('next');
                    self.clearAutoAnimate();
                    self.autoAnimate();
                });
                /* masthead video close close button */
                $(document).on(touchOrClick, '#mastheadVideo a.close', function(e) {
                    $("div.modMh_1").css({'height':'551px','margin-top':'0px'});
                    e.preventDefault();
                    $('#mastheadVideo div.video:first').trigger('videoClear').trigger('videoPrepare');
                    $(this).parent().fadeTo(1000, 0, function() {
                        $(this).hide();
                    });
                    self.resetCta();
                });

                if (!mrm.util.touchDevice()) {
                    /* previous/next hover */
                    $(document)
                        .on('mouseenter', prevSelectors,
                            function () {
                                if (!self._isAnimating) {
                                    self.$mod.find('li.modMh_item_1.prev').stop().animate({
                                        left: self._lefts.prev + 15
                                    }, 100);
                                }
                                self._autoAnimatePaused = true;
                            })
                        .on('mouseleave', prevSelectors,
                            function () {
                                if (!self._isAnimating) {
                                    self.$mod.find('li.modMh_item_1.prev').stop().animate({
                                        left: self._lefts.prev
                                    }, 100);
                                }
                                self._autoAnimatePaused = false;
                            })
                        .on('mouseenter', nextSelectors,
                            function () {
                                if (!self._isAnimating) {
                                    self.$mod.find('li.modMh_item_1.next').stop().animate({
                                        left: self._lefts.next - 15
                                    }, 100);
                                }
                                self._autoAnimatePaused = true;
                            })
                        .on('mouseleave', nextSelectors,
                            function () {
                                if (!self._isAnimating) {
                                    self.$mod.find('li.modMh_item_1.next').stop().animate({
                                        left: self._lefts.next
                                    }, 100);
                                }
                                self._autoAnimatePaused = false;
                            })
                        .on('mouseenter', activeSelectors + ', #modMh_1_ctaOverlay h2',
                            function () {
                                self._autoAnimatePaused = true;
                            })
                        .on('mouseleave', activeSelectors + ', #modMh_1_ctaOverlay h2',
                            function () {
                                self._autoAnimatePaused = false;
                        });

                }
                /* resizing listeners adjust */
                $(window).resize(function () {
                    if (!self._isAnimating) {
                         self.resetLeftPositions(true);

                        var $mastheadVideo = $('#mastheadVideo');
                        if ($mastheadVideo.length) {
                            var $vidContainer = $mastheadVideo.find('div.video');
                            var newWidth = $(window).width();
                            $vidContainer.css({width:newWidth})
                                .children(0).css({width:newWidth});
                            if ($vidContainer.getHiddenVideoPlayerObject()) {
                                $vidContainer.getHiddenVideoPlayerObject().resize(newWidth, $("div.modMh_1").height());
                            }
                        }
                    }
                });

                /* touch device swiping */
                if (mrm.util.touchDevice()) {
                    /* swipe next */
                    $('div.modMh_1 div.mmScroll.ui-scroller-type2 ul.mmScrollItems').touchwipe({
                        wipeLeft:function() {
                            self.animate('next');
                        },
                        wipeRight:function() {
                            self.animate('prev');
                        },
                        min_move_x:20,
                        preventDefaultEvents:false
                    });
                }
            }
        }
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		mh_scroller_1: {
			initTrack: function($mod, section){
				clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				
				// previous button tracking
				$mod.find(".mmScrollBtn.prev").on(clickOrTouch, function(){
					$mod.find("ul.mmScrollItems").trigger("onAfter", function($oldItem, $newItem) {
						var imageName = $("li.ui-helper-visible").find("img").attr("src");
						if (typeof(imageName) !== "undefined") {
							imageName = imageName.substr( imageName.lastIndexOf('/') + 1 );
						}
						mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "arrow:prev:" + imageName});
					});
				});

				// next button tracking
				$mod.find(".mmScrollBtn.next").on(clickOrTouch, function(){
					$mod.find("ul.mmScrollItems").trigger("onAfter", function($oldItem, $newItem) {
						var imageName = $("li.ui-helper-visible").find("img").attr("src");
						if (typeof(imageName) !== "undefined") {
							imageName = imageName.substr( imageName.lastIndexOf('/') + 1 );
						}
						mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "arrow:next:" + imageName});
					});
				});

				//pagination dot tracking
				$mod.on(clickOrTouch, ".mmScrollPagination li", function(){
					$mod.find("ul.mmScrollItems").trigger("onAfter", function($oldItem, $newItem) {
						var imageName = $("li.ui-helper-visible").find("img").attr("src");
						if (typeof(imageName) !== "undefined") {
							imageName = imageName.substr( imageName.lastIndexOf('/') + 1 );
						}
						mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "dots:" + imageName}); 
					});	
				});	
				
				//Home page masthead tracking
 				$mod.on(clickOrTouch, ".mmScrollItems li.modMm_hotspot_1 div.simpleHotSpot map area", function(){
						var imageName = $(this).attr('href').split('/').pop();
 						mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "image:" + imageName}); 
 				});
			}
		}
	});
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		mh_storydetails_1: {
			tpl: ["12"],
			init: function(c) {
				mrm.util.log('[mh_storydetails_1] Context: ' + c);

				// Events.
				this.attachEvents();

			},

			attachEvents: function() {
				var self = this;
				var $mod = $('.modMh_storydetails_1');
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				// Link tracking

				$mod.find(".ln.mh_caret").removeAttr("onclick");
				$mod.find(".ln.mh_caret").on(clickOrTouch, function(event){
					self.callOmnitureTracking ($mod, $(this), 'storyDetails');
				});
			},


			callOmnitureTracking: function( $mod, $obj, trackingType ) {
				if (typeof(Omniture_s) === 'undefined') { return; }
				var brand = Omniture_s.eVar18.toLowerCase(),
					pageName = Omniture_s.pageName;

				switch( trackingType ) {
					case 'storyDetails':
						mrm.util.tagging.omniture_tl (
							$obj, $obj.html(), 'o', 'storyDetails',
							{
								'pageName':pageName,
								'prop27':'masthead',
								'prop32':'masthead:link:' + $obj.attr('href')
							}
						);
					break;

				}
			},
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Mh_tablay_1 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;
			if (mrm.util.ie6()) return;

			var $tabs = self.$ctx.tabs({
					select: function(event, ui) {
						// mark active tab-panel as selected
						self.markVisible($(ui.panel));
					}
				});

			// fix the classes for moving the nav to the bottom 
			self.$ctx.find(".ui-tabs-nav, .ui-tabs-nav > *")
				.removeClass("ui-corner-all ui-corner-top")
				.addClass("ui-corner-bottom");

			// move the nav to the bottom
			$tabs.find(".ui-tabs-nav").appendTo(self.$ctx);
			
			// clean the whitespace between li
			$tabs.find('.ui-tabs-nav').contents().filter(function () { return this.nodeType === 3; }).remove();

			// #GMDSSDS-7630 putting a check in the head section to trap for the presence of
			// a querystring can allow the browser to try and deep dive to a section after
			// the hashtag reference in browser already is handled
			var hashTag = mrm.util.getHash();
			if (hashTag !== "" && mrm.util.exists(hashTag)) {
				// now get the element's offset relative to the document 
				var offsetTop = $(hashTag).offset().top;
				// and finally, scroll the document to that offset 
				$(document).scrollTop(offsetTop);
			}
		},

		/**
		 * Ads class 'ui-helper-visible' to the active layer for easier selection from outside
		 * @param $layer active/visible layer
		 */
		markVisible: function($layer) {
			$layer.addClass('ui-helper-visible').siblings('.ui-tabs-panel').removeClass('ui-helper-visible');
		},

		// used by deeplinking.js
		switchToContent: function($content) {
			var self = this;
			if ($content.length === 0) return;
			var $layer = $content.closest('.ui-tabs-panel');
			var id = $layer.attr('id');
			if (id) {
                self.$ctx.tabs();
				self.$ctx.tabs('option', 'active', id);
            }
		}

	});
})(mrm.$);(function ($) {
    mrm.mod.Mh_title_1 = mrm.mod.AbstractMod.extend({
        prepare: function(){
			// Check for Image map in the title componet.
			if (this.$ctx.children('map').length){
				var image = this.$ctx.children('img');
				var area = image.siblings('map').children('area');
				var speed = (image.data('use').style === "fadeIn" || image.data('use').style === 'slideDown') ? 200 : 400;
				var options = $.extend({}, mrm.conf.plugin.cluetip || {}, {
					prepareTitleAttr: true,
					activation: image.data('use').event,
					fx: {
						open: image.data('use').style,
						openSpeed: speed
					},
					arrows: false,
					liveLeftOffset: image.data('use').x,
					liveTopOffset: image.data('use').y,
					newPosition: true
				});
				area.cluetipWrap(options);
			} 
		}
    });
})(mrm.$);/*
 Christian Zindel, Namics Deutschland
 */
(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		mm_1: {
			/**
			 * JS for component mm_1
			 *
			 * @param {String} c DOM Context
			 */
			jwpOptions: $.extend(true, {}, mrm.conf.cmp.mm_1.jwpOptions),
			initMod: function($mod) {
				mrm.util.log('[mrm.cmp.mm_1] Context: ' + $mod);
				var self = this,
					readyClass = 'jsReady',
					elementsClass = "ifrm_ipad";


				// iFrame shouldn't be included on page load, as modern browsers would even already load it's content even if hidden - but an anchor tag, that get's converted to an iFrame on iPads
				if ($.os.name === "ipad") {
					$mod.find('object a.' + elementsClass).replaceWith(function() {
						return $('<iframe></iframe>')
							.addClass(elementsClass)
							.attr('src', $(this).attr('href'))
							.attr('width', $(this).data('ifrm-width'))
							.attr('height', $(this).data('ifrm-height'))
							.attr('frameborder', '0');
					});
				}

				// init scroller

				var $mm1 = $mod;

				var zIndexBase;
				// Special handling of mm_1 when they appear in jQuery dialogs
				if ($mod.closest(".ui-dialog").length) {
					zIndexBase = 1003;
					$mod.closest(".ui-dialog").addClass("mm-content");
				} else {
					zIndexBase = 0;
				}

				$mod.data("indexBase", zIndexBase);

				var $mmScroll = $mm1.find('.mm_scroll, .mmScroll').first().addClass('mmScroll'),
					$items = $mmScroll.children('ul').children('li'),
					$videoLayer = $mm1.find(".video-layer");

				// no scroller, activate video directly
				if ($mmScroll.length === 0)
					mrm.corcmp.mmVideo.activateVideo($mm1);

				if ($items.length <= 0)
					return; // stop if list is empty
				$mmScroll.children('span.prev, span.next').addClass('mmScrollBtn');

				// make sure $mmScroll is visible, otherwise mmScroll() will fail
				if ($mmScroll.is(':hidden')) {
					return;
				}

				var options = {
					height: 'variable',
					onCreate: function($items) {
						self._activateScrollerVideo($mm1);
					},
					scroll: {
						noWipeDirection: 'vertical',
						onBefore: function($oldItem, $newItem, newSize, duration) {
							if ($videoLayer.length > 0) {
								$videoLayer.css("z-index", $mod.data("indexBase") - 1);
							}

							if ($mm1.find(".thumbnails-scroller").length > 0) {

								// keep thumbnail scroll in sync with main mmScroll
								var $thumbnailScroller = $mm1.find(".thumbnails-scroller ul");
								$thumbnailScroller.find("li").removeClass("active");
								var currentPosition = $mmScroll.find("ul").triggerHandler('currentPosition');
								var $targetThumbnail = $mm1.find(".thumbnail-item-" + currentPosition).addClass("active");
								$mm1.find(".thumbnails-scroller ul").trigger('slideTo', $targetThumbnail);
							}

							/* create canvas transition with some visually trickery. */
							if (typeof (mrm.cmp.mm_1.canvasTransition) === 'object') {
								mrm.cmp.mm_1.canvasTransition.slide($oldItem, $newItem);
							}

						},
						onAfter: function($oldItem, $newItem, newSize, duration) {
							self._activateScrollerVideo($mm1);
							mrm.corcmp.mmVideo.deactivateVideo($oldItem, $videoLayer, true);

							// remove player so the previous poster is not seen GMDSUSSPT-37386
							if ($videoLayer.length > 0) {
								$videoLayer.find('div').empty();
							}
						}
					}
				};

				// add config options
				options = $.extend(true, options, mrm.conf.cmp.mm_1 || {});

				if ($mmScroll.hasClass('disable-looping')) {
					options.circular = false;
					options.infinite = false;
				}

				// TODO: This lightbox approach is deprecated.
				// Should be pulling in from a t17d according to the specs
				if ($mmScroll.hasClass('use-lightbox')) {
					self._setupLightbox($mmScroll, options);
				}

				$mmScroll.mmScroll(options);

				if (typeof (self.canvasTransition) !== 'undefined') {
					self.canvasTransition.initMod($mmScroll);
				}
				if (typeof (self.fullWidth) !== 'undefined') {
					self.fullWidth.initMod($mmScroll);
				}

				// Setup thumbnail scroller of thumbnails have been enabled
				if ($mm1.find(".thumbnails-scroller").length > 0) {
					self._setupThumbnailScroller($mm1, $mmScroll);
				}
				$mm1.addClass(readyClass);

				// Ensure dialog is centered after JS has finished execution
				if ($mod.closest(".ui-dialog").length) {
					$mod.closest(".dialog-container").dialog('option', 'position', 'center');
				}

				this._setupLazyLoad($mmScroll);

			},
			_setupLazyLoad: function($mmScroll){
				/// hide scroll button until all images have been loaded
				//  first check to make sure they are being lazy loaded.
				if ($mmScroll.find('img[data-'+mrm.ui.image_loader.src_attribute+']').length) {
					/// if in a light box then call load image manually
					if($mmScroll.closest('.lightbox_container').length){
						mrm.ui.image_loader.load_images($mmScroll.find('img.onload'));
					}
					// listen for the image laod event and check to see if all the images have been loaded.
					var listener = $.eventDispatcher.on('image_loaded', function() {
						if ($mmScroll.find('img.' + mrm.ui.image_loader.loaded_class).length === $mmScroll.find('img[data-'+mrm.ui.image_loader.src_attribute+']').not('.' + mrm.ui.image_loader.onscroll_class).length) {
							// get the buttons remove the hidden class and fade them in
							var buttons = $mmScroll.find('.mmScrollBtn');
							// remove listener
							$.eventDispatcher.off(listener);
						}
					});
				}
			},
			_setupLightbox: function($mmScroll, options) {
				var self = this;
				self.open = true;
				var fancyConf = mrm.$.extend({}, mrm.conf.plugin.fancybox);
				var galleryItems = $mmScroll.find("ul").find('figure>.lightbox').toArray(); // fancybox only accepts an array no jquery object
				var $lbConfig = $mmScroll.find("ul");

				fancyConf = $.extend(fancyConf, {
					cyclic: !$lbConfig.hasClass('disable_looping'),
					showNavArrows: !$lbConfig.hasClass('hide_arrows'),
					scrolling: 'no',
					titlePosition: 'outside',
					onStart: function(items, index, obj) {
						// sync the scroller on the page with the lightbox
						// uncomment the rest of the line below to remove the transition when fancy box moves to a new image.
						$mmScroll.find("ul").trigger('slideTo', [index /*, 0, true, {fx:'none'}*/]);

						// if video change out the poster frame for the larger image.
						if ($(items[index]).is('.video')) {
							var $vid = $(items[index]).clone(false).attr('id', mrm.util.getRandomString('vid')); /// cloned so not changed in the scroller on the page

							// replace the image
							$vid.find('>img').removeAttr('height width');
							$vid.find('>img').attr('src', $vid.data('posterimage'));

							// set container to the width and height for the video
							$vid.width($vid.data('width')).height($vid.data('height'));

							// html with new poster frame into the contents of the lightbox
							var html = $vid.get(0).outerHTML;
							if($(items[index]).siblings('.end_frame_wrap').length){
								var $end_frame = $(items[index]).siblings('.end_frame_wrap')
								$end_frame.find('.video').each(function(){
									this.id = mrm.util.getRandomString('end_frame_vid')
								})
								html += $end_frame.get(0).outerHTML;
							}
							this.content = html;
						}

						// set the caption
						this.title = $(items[index]).next('figcaption').html();
					},
					onComplete: function(items, index, obj) {

						// if it's a video activate it.
						if ($(items[index]).is('.video')) {

							// IE8 Changing out the poster frame and inserting the html
							try {
								if (mrm.util.ie8()) {
									var $vid = $(items[index]).clone(false).attr('id', mrm.util.getRandomString('vid'));

									// replace the image
									$vid.find('>img').removeAttr('height width')
									$vid.find('>img').attr('src', $vid.data('posterimage'));

									// set container to the width and height for the video
									$vid.width($vid.data('width')).height($vid.data('height'));

									// html with new poster frame into the contents of the lightbox
									var html = $vid.get(0).outerHTML;
									$('#fancybox-content').html(html);
									if($(items[index]).siblings('.end_frame_wrap').length){
										var $end_frame = $(items[index]).siblings('.end_frame_wrap')
										$end_frame.find('.video').each(function() {
											this.id = mrm.util.getRandomString('end_frame_vid')
										})
										$('#fancybox-content').append($end_frame.clone());
									}
								}

								// find the video and activate it.
								var $vid = $('#fancybox-content').find('.video.lightbox');
								mrm.util.doInitVideo($vid, self.jwpOptions);

								//make sure the video is sized correctly and centered
//								$('#fancybox-wrap, #fancybox-content').width($vid.data('width'));
//								$.fancybox.center();

							} catch (e) {
								mrm.util.log(e);
							}
						}else{ // if image
							$('#fancybox-content').find('img').attr('alt', $(items[index]).data('alt'));
						}
						self.open = false;
					},
					onCleanup: function(items, index, obj) {
						if ($(items[index]).is('.video')) {
							try {
								var $vid = $('#fancybox-content').find('.video');
								jwplayer().stop();
								$vid.remove();
							} catch (e) {
								mrm.util.log(e);
							}

						}
					}
				});

				if ($lbConfig.hasClass('ui_navigation_numbers'))
				{
					$.extend(fancyConf, {titleFormat: $.proxy(this._titleFormatNumbers, this)});
				}
				else if ($lbConfig.hasClass('ui_navigation_dots'))
				{
					$.extend(fancyConf, {titleFormat: $.proxy(this._titleFormatDots, this)});
				}

				$('#fancybox-title ol.indicator_dot a').live('click', function(event) {
					event.preventDefault();
					$.fancybox.pos($(event.target).attr('href').replace(/^#/, ''));

				});

				$mmScroll.on('click', 'figure > a, figure > div.lightbox', function(e) {
					e.stopPropagation();
					e.preventDefault();
					self.open = true;
					fancyConf.index = $mmScroll.find("ul").triggerHandler('currentPosition');
					$.fancybox(galleryItems, fancyConf);

					// Give the wrapper a class to make it unique.
					$('#fancybox-wrap').addClass('fancybox_mm_1');
				})



			},
			_titleFormatDots: function(title, currentArray, currentIndex, currentOpts)
			{
				var tx = this._getCaptionText(currentArray[currentIndex], title);

				if (currentArray.length < 2)
					return tx;

				tx += '<ol class="indicator_dot">';

				$.each(currentArray, function(i, value) {

					if (i === currentIndex)
					{
						tx += '<li class="active">' + (i + 1) + '</li>';
					}
					else
					{
						tx += '<li><a href="#' + i + '">' + (i + 1) + '</a></li>';
					}
				});
				tx += '</ol>';

				return tx;
			},
			_titleFormatNumbers: function(title, currentArray, currentIndex, currentOpts)
			{
				var tx = this._getCaptionText(currentArray[currentIndex], title);

				if (currentArray.length < 2)
					return tx;

				tx += '<p class="indicator_number">';
				tx += (currentIndex + 1) + '/' + currentArray.length;
				tx += '</p>';

				return tx;
			},
			_getCaptionText: function(item, title)
			{
				var $caption = $(item).next('figcaption').find('.txtWrp');
				if ($caption.length)
				{
					return $caption.html();
				}
				else {
					return (title && title.length ? '<p>' + title + '</p>' : '');
				}
			},
			_setupThumbnailScroller: function($mm1, $mmScroll) {
				var self = this;

				var $thumbnailScroll = $mm1.find(".thumbnails-scroller").addClass('mmScroll');
				$thumbnailScroll.children('span.prev, span.next').addClass('mmScrollBtn');
				var $thumbnailItems = $thumbnailScroll.find("li");
				var scale = mrm.conf.cmp.mm_1.thumbnails_scroller_multiplier;
				var scrollerWidth = $mm1.find(".mm_scroll").first().find("img, object").first().width(); //GMDSUSSPT-44025 look for flash objects too
				//console.log(scrollerWidth);

				if (scale != 1) {
					var scrollerOffset = 1 - scale;
					$thumbnailScroll.css('margin-left', scrollerOffset * scrollerWidth * .5)
					scrollerWidth *= scale;
				}

				// Setup classes used for communication between large mmScroll and thumbnail mmScroll
				$thumbnailItems.first().addClass("active");
				$thumbnailItems.each(function(i, val) {
					$(this).addClass("thumbnail-item-" + i);
				});

				// mmScroll for thumbnails differs considerably from other mmScroll setups
				var thumbCfg = mrm.conf.cmp.mm_1.thumbnail_scroller_config || {};
				var thumbnailOptions = $.extend(true, {
					width: scrollerWidth,
					height: "auto",
					scroll: {},
					auto: false,
					items: {
						visible: "variable"
					},
					infinite: false,
					circular: false,
					animateControls: {
						fx: "none"
					}
				}, thumbCfg);

				$thumbnailItems.on("click", function() {
					var $currentItem = $(this);
					var visiblePosition;
					$thumbnailItems.removeClass("activated-item");
					$currentItem.addClass("activated-item");

					// Keep large mmScroll and thumbnail mmScroll in sync
					var firstVisiblePosition = $currentItem.parent().triggerHandler('currentPosition');
					var visibleItems = $currentItem.parent().triggerHandler('currentVisible');
					visibleItems.each(function(i, val) {
						if ($(val).hasClass("activated-item"))
							visiblePosition = i;
					});
					var itemPosition = visiblePosition + firstVisiblePosition;

					$mmScroll.find("ul").trigger('slideTo', itemPosition);

				});

				$thumbnailScroll.mmScroll(thumbnailOptions);
			},
			_activateScrollerVideo: function($container) {
				var self = this;

				if (!$container || $container.length == 0)
					return;
				// find the deepest visible content-module
				var $deepest = mrm.util.deepest('.ui-helper-visible', $container);
				var $videoLayer = $container.find(".video-layer");
				var $video = $deepest.find("div.video");

				// make sure there is a expander button on the videos with lightbox
				if($video.hasClass('lightbox') && $video.find('#galleryEnlargeIcon').length === 0){
					$video.append("<div id='galleryEnlargeIcon'></div>");
				}

				// if light box don't go any further
				if($video.hasClass('lightbox')) return;

				mrm.util.doInitVideo($deepest, true, $videoLayer, self.jwpOptions);
				if ($deepest.find("div.video").data("posterclick") === false) {
					$videoLayer.css("z-index", $container.data("indexBase") + 1);
				} else {
					$video.on("click", function() {
						$videoLayer.css("z-index", $container.data("indexBase") + 1);
					});
				}

				// reset any current liseteners to avoid multiple calls
				$videoLayer.closest('.mod').off('mmVideoComplete');

				// set a listener for video complete
				$videoLayer.closest('.mod').on('mmVideoComplete', function(event) {
					// reset the z-index to below the scroller item
					$videoLayer.css("z-index", $container.data("indexBase") - 1);
				});
			},
			// used by deeplinking.js
			switchToContent: function($content) {
				$content.closest('.mod').find('.caroufredsel_wrapper > ul').trigger("slideTo", $content);
			},
			fullWidth: {
				config: $.extend(mrm.conf.cmp.mm_3 || {}, {
					maxWidth: 1920
				}),
				init: function($mod) {
					//console.log('fullWidth setup');
				},
				initMod: function($mod) {
					if ($mod.attr('data-cfg-full-width') === '1') {
						//  find the original width and height and save them to data
						$mod.find('img.mm').each(function() {
							var $this = $(this);
							$this.data('origSize', {height: $this.height(), width: $this.width()});
							// set css width and remove the width and height attributes
							$this.css({width: $this.attr('width')});
							$this.removeAttr('height width');
						});

						// set current height, max-width and overflow on the scroller
						$mod.css({height: $mod.height(), maxWidth: this.config.maxWidth, overflow: 'hidden'});
						$mod.parent('.mod.modMm_1').css({'overflow': 'visible', 'padding-left': 0, 'padding-right': 0});

						// event listener for window resize
						$(window).resize($.proxy(function() {
							this.resize($mod);
						}, this));

						// initial call
						this.resize($mod);
					}
				},
				resize: function($mod) {
					var pageWidth = $(window).width(),
						containerWidth = $('.mds-area-content:eq(0)').width();

					$mod.closest('.modMm_1').css({marginLeft: 0, marginRight: 0});

					var nMargin = (containerWidth - pageWidth) * .5;
					nMargin = nMargin > 0 ? 0 : nMargin;

					// size the mod first it's the outter most
					$mod.css({'margin-left': nMargin, 'margin-right': nMargin});

					// find the top image
					var $topImage = $mod.find('img.mm:eq(0)'),
						modWidth = $mod.width();

					// size the carousel second
					$mod.find('.caroufredsel_wrapper').width(modWidth);

					// if larger then original size then set all images to width and
					// calculate the top negitive margin for centering the image vertically.
					if($topImage.length){
						if (modWidth >= $topImage.data('origSize').width) {
							var $allImages = $mod.find('img.mm');
							var topMargin = Math.floor(((($topImage.data('origSize').width * $topImage.data('origSize').height) / modWidth) - $topImage.data('origSize').height) * .5);
							$allImages.css({'margin-top': topMargin, 'width': modWidth});
							$mod.find('.caroufredsel_wrapper > ul').css({'margin-left': 0});
						} else {
							var leftMargin = (modWidth - $topImage.data('origSize').width) * .5;
							$mod.find('.caroufredsel_wrapper > ul').css({'margin-left': leftMargin});
						}

						//center if over maxWidth
						if (pageWidth > this.config.maxWidth) {
							$mod.css('left', (pageWidth - this.config.maxWidth) * .5);
						} else {
							$mod.css('left', 0);
						}
					}
				}
			}
		}
	});
}(mrm.$));(function($) {

	$.extend(mrm.cmp.mm_1, {
		canvasTransition: {
			config: {
				duration: 800,
				easing: 'easeInCubic',
				angleInDegrees: 64,
				fps: mrm.util.iOS() ? 40 : 60
			},
			init: function() {
				//console.log('overall setup');
			},
			/**
			 * Initialize the component
			 * @param {jQuery} $mod
			 * @returns {void}
			 */
			initMod: function($mod) {

				// <editor-fold desc="POLYFILL FOR requestAnimationFrame" >
				// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
				// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

				// requestAnimationFrame polyfill by Erik Mller
				// fixes from Paul Irish and Tino Zijdel

				var lastTime = 0;
				var vendors = ['ms', 'moz', 'webkit', 'o'];
				for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
					window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
					window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
						|| window[vendors[x] + 'CancelRequestAnimationFrame'];
				}

				if (!window.requestAnimationFrame)
					window.requestAnimationFrame = function(callback, element) {
						var currTime = new Date().getTime();
						var timeToCall = Math.max(0, 16 - (currTime - lastTime));
						var id = window.setTimeout(function() {
							callback(currTime + timeToCall);
						},
							timeToCall);
						lastTime = currTime + timeToCall;
						return id;
					};

				if (!window.cancelAnimationFrame)
					window.cancelAnimationFrame = function(id) {
						clearTimeout(id);
					};
				// </editor-fold>

				this.moveShare($mod, $mod.find('li:eq(0)'));

				//console.log('init for scroller');
				/* create the canvas transition layers */
				var canvas = document.createElement('canvas');

				canvas.width = $mod.width();
				canvas.height = $mod.height();

				$mod.append($(canvas).hide());
				//IE compatiblity
				//if (typeof FlashCanvas !== "undefined") {
				//	FlashCanvas.initElement(canvas);
				//}
			},
			/**
			 * Prepares for the animation
			 * @param {jQuery} $itm
			 * @param {jQuery} $itmNext
			 * @returns {void}
			 */
			slide: function($itm, $itmNext) {
				mrm.util.log('slide working');

				if ($itm.find("iframe").length > 0 || $itmNext.find("iframe").length > 0) return;

				var $scroller = $itm.closest('.mmScroll'),
					$mm1 = $itm.closest('modMm_1'),
					img = $itm.find('img.mm')[0],
					imgNext = $itmNext.find('img.mm')[0],
					imageWidth = $(imgNext).width(),
					scrollerHeight = $scroller.height(),
					scrollerWidth = $scroller.width(),
					$canvas = $scroller.children('canvas'),
					img1Num = $itm.index(),
					img2Num = $itmNext.index(),
					direction = img1Num < img2Num ? 'next' : 'prev',
					xOffset = parseInt($scroller.find('ul').css('margin-left'));

				xOffset = xOffset > 0 ? 0 : xOffset;

				$canvas.css('z-index', $mm1.data("indexBase"));
				$canvas[0].width = imageWidth;
				$canvas[0].height = scrollerHeight;

				this.moveShare($scroller, $itmNext);

				// a little trig to figure out correct offset length based on the angle given in config.
				var angleLength = Math.round(scrollerHeight / Math.tan(this.config.angleInDegrees / 180 * Math.PI));

				var polygon_arr = [
					/* X,Y coordinates */
					{x: 0, y: 0}, /* left bottom */
					{x: -angleLength, y: scrollerHeight}, /* left top */
					{x: scrollerWidth, y: scrollerHeight}, /* right top */
					{x: scrollerWidth + angleLength, y: 0}]/*right bottom*/;

				// check if png then assume it's transparent
				var transparent = false;
				if ($.os.name === "ipad" || typeof img !== 'undefined') {
					if(/\.png$/.test(img.src)){
						$scroller.find('img.mm').hide();
						transparent = true;
					}
				}

				var theImages = {img: img, img2:imgNext, x: xOffset, y: parseInt($(imgNext).css('margin-top')), w: imageWidth, h: imgNext.height};

				this.drawImages({ctx: $canvas[0].getContext('2d'), direction: direction, polygon_arr: polygon_arr, images: theImages, angleLength: angleLength, transparent: transparent});
			},
			/**
			 *
			 * @param {jQuery} $scroller
			 * @param {jQuery} $item
			 * @returns {void}
			 */
			moveShare: function($scroller, $item) {
				$scroller.children('div#captionHolder').remove();
				var $caption = $item.find('figcaption.tx_cap').hide(0);
				var $clone = $caption.clone(1);
				$scroller.append($('<div id="captionHolder" />').append($clone.show(0)));
				$scroller.find('#captionHolder').find('a.ln.disclaimer_1').unbind();
				var config = $.extend(true, {}, mrm.conf.plugin.cluetip, mrm.conf.cmp.disclaimer_1.cluetip);
				$scroller.find('#captionHolder').find('a.ln.disclaimer_1').cluetipWrap(config);
			},
			/**
			 * Controls starts animation and controls frame rate
			 * @param {object} options
			 * @returns {void}
			 */
			drawImages: function(options) {
				var self = this;

				// reset the animation
				cancelAnimationFrame(self.animationId);

				// make canvas visible
				$(options.ctx.canvas).show();

				var startTime = new Date().getTime(),
					lastExec = startTime,
					firstTime = true;

				// start things
				(function canvasAnimate() {
					var now = new Date().getTime(),
						t = now - startTime,
						b = 0,
						c = options.polygon_arr[3].x,
						d = self.config.duration,
						p = $.easing[self.config.easing](null, t,b,c,d);

					options._offset = (options.direction === 'next') ? p*-1 : p;

					// calculate if its time to display the next frame based on the fps
					if ((now - lastExec) > (1000 / self.config.fps) || firstTime) {
						firstTime = false;
						lastExec = new Date().getTime();
						self.wipeAnimation(options);
					}

					if (t <= d+15) {
						self.animationId = requestAnimationFrame(canvasAnimate);
					} else {
						//options.ctx.clearRect(0, 0, options.ctx.canvas.width, options.ctx.canvas.height);
						if (!options.transparent)
							$(options.ctx.canvas).hide(0);
					}
				})();// call it
			},
			/**
			 * Draws the images on the canvas
			 * @param {object} options
			 * @returns {Boolean}
			 */
			wipeAnimation: function(options) {
				var self = mrm.cmp.mm_1.canvasTransition;
				var ctx = options.ctx;
				var _offset = options._offset;


				// clear the whole canvas
				ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

				var theImage = options.images;

				if (options.transparent) {
					ctx.beginPath();
					if (options.direction === 'next') {
						ctx.moveTo(parseInt(options.polygon_arr[2].x) + _offset, parseInt(options.polygon_arr[2].y));
						ctx.lineTo(parseInt(options.polygon_arr[3].x) + _offset, parseInt(options.polygon_arr[3].y));
						ctx.lineTo(parseInt(options.polygon_arr[3].x) + theImage.w, parseInt(options.polygon_arr[3].y));
						ctx.lineTo(parseInt(options.polygon_arr[2].x) + theImage.w, parseInt(options.polygon_arr[2].y));
					} else {
						ctx.moveTo(parseInt(options.polygon_arr[0].x) + _offset, parseInt(options.polygon_arr[0].y));
						ctx.lineTo(parseInt(options.polygon_arr[1].x) + _offset, parseInt(options.polygon_arr[1].y));
						ctx.lineTo(parseInt(options.polygon_arr[1].x) - theImage.w, parseInt(options.polygon_arr[1].y));
						ctx.lineTo(parseInt(options.polygon_arr[0].x) - theImage.w, parseInt(options.polygon_arr[0].y));
					}

					ctx.closePath();
					ctx.save();
					ctx.clip();

					(function drawVideo() { // GMDSUSSPT-44426
						try {
							ctx.drawImage(theImage.img2, theImage.x, theImage.y, theImage.w, theImage.h);
						} catch (e) {
							if (e.name == "NS_ERROR_NOT_AVAILABLE") {
							  setTimeout(drawVideo, 100);
							} else {
							  throw e;
							}
						}
					})();

					ctx.restore();
				}

				// draw the masked image
				ctx.beginPath();
				for (var i = 0; i < (options.polygon_arr.length); i++) {

					var x = parseInt(options.polygon_arr[i].x) + _offset;
					var y = parseInt(options.polygon_arr[i].y);


					if (i === 0)
						ctx.moveTo(x, y);
					else
						ctx.lineTo(x, y);
				}
				ctx.closePath();

				/* draw shadow - not used in IOS for performance reasons  */
				if (!mrm.util.iOS() && !options.transparent) {
					ctx.shadowColor = "rgba(0, 0, 0, .5)";
					ctx.shadowBlur = 10;
					ctx.shadowOffsetX = (options.direction === 'next') ? 10 : -10;
					ctx.shadowOffsetY = 0;
					ctx.fillStyle = "black";
					ctx.fill();
				}

				ctx.save();
				ctx.clip(); // Clip to whatever path is on the context

				if ($.os.name === "ipad" || typeof theImage.img !== 'undefined') {
					ctx.drawImage(theImage.img, theImage.x, theImage.y, theImage.w, theImage.h);
				}
				ctx.restore();
			}
		}

	});
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		mm_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				
				// Suppress inline tracking
				//$mod.find('a').removeAttr('onclick');				

				// Promo tile tracking
				$mod.find("a > img.mm").on("click", function(){
					var photoname = $(this).attr("src");
					if (typeof(photoname) !== "undefined") {
						photoname = photoname.substr( photoname.lastIndexOf('/') + 1 );
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'image:' + photoname});
				});

				// Pagination dot tracking
				$mod.find(".mmScrollPagination li a").on(clickOrTouch, function(){
					var move_dot = $(this).text() - $mod.find(".mmScrollPagination li.selected a").html();
					var photoname = $mod.find(".mm_mos_1_item").nextAll().andSelf().slice(move_dot).find("img").attr("src");
					if (typeof(photoname) !== "undefined") {
						photoname = photoname.substr(photoname.lastIndexOf("/") + 1)
					}
					mrm.util.trackEvent("click_cta", {section : section, linkname : "dots:" + photoname});
				});

				// Previous button tracking
				$mod.find(".mmScrollBtn.prev").on(clickOrTouch, function(){
						var photoname = $(this).next().find('li.ui-helper-visible').prev().find("img").attr("src");
						if (typeof(photoname) !== "undefined") {
							photoname = photoname.substr( photoname.lastIndexOf('/') + 1 );
						}
					if ($(this).parent().hasClass("thumbnails-scroller")) {
						mrm.util.trackEvent("click_cta", {section: section, linkname: 'thumb:arrow:prev'});
						}
						else
						{
						mrm.util.trackEvent("click_cta", {section: section, linkname: 'arrow:prev:' + photoname});
						}
				});

				// Next button tracking
				$mod.find(".mmScrollBtn.next").on(clickOrTouch, function(){
						var photoname = $(this).prevAll().find('li.ui-helper-visible').next().find("img").attr("src");
						if (typeof(photoname) !== "undefined") {
							photoname = photoname.substr( photoname.lastIndexOf('/') + 1 );
						}
					if ($(this).parent().hasClass("thumbnails-scroller")) {
						mrm.util.trackEvent("click_cta", {section: section, linkname: 'thumb:arrow:next'});
						}
						else
						{
						mrm.util.trackEvent("click_cta", {section: section, linkname: 'arrow:next:' + photoname});
						}
				});
				
				// Thumbnail tracking
				$mod.on(clickOrTouch, ".thumbnails-scroller li", function(){
					var linkname = $(this).find('h2').text();
					if (linkname == false) {
						linkname = $(this).find('img').attr('src');
						if (typeof(linkname) !== "undefined") {
							linkname = linkname.substr( linkname.lastIndexOf('/') + 1);
						}
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'thumb:' + linkname});	
				});

			}
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Mm_3 = mrm.mod.AbstractMod.extend({
		
		cfg: {
			maxWidth: 1920
		},

		prepare: function() {
			var self = this;

			var $inner = self.$ctx.find('.inner');
			if (self.$ctx.attr('data-cfg-full-width') === '1' || $inner.attr('data-cfg-full-width') === '1') {
				// set current height, max-width and overflow on the scroller
				self.$ctx.css({'overflow': 'visible', 'padding-left': 0, 'padding-right': 0, maxWidth: self.cfg.maxWidth, height: self.$ctx.height()});
				$inner.css({'overflow': 'hidden', 'padding-left': 0, 'padding-right': 0, marginLeft: 0, marginRight: 0, height: $inner.height()});

				//	find the original width and height and save them to data
				var $img = self.$ctx.find('img.mm');
				$img.data('origSize', {height: $img.height(), width: $img.width()});
				// set css width and remove the width and height attributes
				$img.css({width: $img.attr('width')});
				$img.removeAttr('height width');

				// event listener for window resize
				$(window).resize($.proxy(self.onResize, self));

				// initial call
				// TODO: now working when maximized
				self.onResize();
			}
		},

		onResize: function() {
			var self = this;
			var pageWidth = $(window).width();
			var containerWidth = $('.mds-area-content:eq(0)').width();

			var nMargin = (containerWidth - pageWidth) * 0.5;
			nMargin = nMargin > 0 ? 0 : nMargin;
			self.$ctx.css({'margin-left': nMargin, 'margin-right': nMargin});
			
			// center if over maxWidth
			if (pageWidth > self.cfg.maxWidth) {
				self.$ctx.css('left', (pageWidth - self.config.maxWidth) * 0.5);
			} else {
				self.$ctx.css('left', 0);
			}

			// size the mod first it's the outter most

			// find the top image
			var $img = self.$ctx.find('img.mm:eq(0)');
			var modWidth = self.$ctx.width();
			self.$ctx.find('.inner').width(modWidth);

			// if larger then original size then set all images to width and
			// calculate the top negitive margin for centering the image vertically.
			if (modWidth >= $img.data('origSize').width) {
				var topMargin = Math.floor(((($img.data('origSize').width * $img.data('origSize').height) / modWidth) - $img.data('origSize').height) * 0.5);
				$img.css({'margin-top': topMargin, 'width': modWidth});
			} else {
				$img.css({'width': $img.data('origSize').width});
			}
		}

	});
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		mm_3: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				
				// Suppress inline tracking
				//$mod.find('a').removeAttr('onclick');				

				// Promo tile tracking
				$mod.find("a img").on("click", function(){
					var photoname = $(this).attr("src");
					if (typeof(photoname) !== "undefined") {
						photoname = photoname.substr( photoname.lastIndexOf('/') + 1 );
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'image:' + photoname});
				});

			}
		}
	});
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		mm_anim_1: {
		   /**
			* JS for component mm_1
			*
			* @param {String} c DOM Context
			*/
			tpl: ["06"],
				config: {
					maxWidth:1920
				},
				$container: null,
				$topStart: null,
				$midStart: null,
				$bottomStart: null,
				$topStop: null,
				$midStop: null,
				$bottomStop: null,
				$obj_start: {},
				$obj_stop: {},

				initMod: function($mod) {
					var self = this;
					if ($mod.find('.anim_holder').hasClass('full_width')) {
						self.resize($mod);
						//on browser resize adjust for the mod
						$(window).resize( $.proxy(function() {
							this.resize($mod);
						}, this));
					}
					if (mrm.util.touchDevice()) {
						var that = $mod.find('.anim_holder');
						var iOS_img = that.data('fallimage');
						that.prepend('<img src="' +iOS_img+'" />');
						that.addClass('touchPad');
						that.removeAttr('style');
						that.children('.modMm_animitem_1').remove();
						return;
					}
					self.bindEvents($mod);

					/* add z-index */
					var $items = $mod.find('.anim_holder').children('.modMm_animitem_1');
					if ($items.length > 1) {
						$mod.addClass('mult'); // makes full width items css positioned absolute for proper x-indexing
						$items.each( function(i) {
							var $this = $(this);
							// var count = $items.length;
							// $this.css('z-index', Number(count - i));
							$this.css('z-index', Number( i + 1 ));
						});
					}
					if ($mod.find('.anim_holder').hasClass('viewport')) {
						self.viewPort($mod);
					}
				},

				setVariables: function($mod) {
					var self = this;
					self.$container = $mod.find('.anim_holder');
					self.$topStart = self.$container.hasClass('top_start');
					self.$midStart = self.$container.hasClass('mid_start');
					self.$bottomStart = self.$container.hasClass('bottom_start');
					self.$topStop = self.$container.hasClass('top_stop');
					self.$midStop = self.$container.hasClass('mid_stop');
					self.$bottomStop = self.$container.hasClass('bottom_stop');

					var bottom_of_object = self.$container.offset().top + self.$container.height(),
						top_of_object = self.$container.offset().top,
						mid_of_object = self.$container.offset().top + (self.$container.height()/2);

					if (self.$topStart) {
						self.$obj_start = top_of_object;
					} else if (self.$midStart){
						self.$obj_start = mid_of_object;
					} else if (self.$bottomStart){
						self.$obj_start = bottom_of_object;
					}
					if (self.$topStop) {
						self.$obj_stop = top_of_object;
					} else if (self.$midStop){
						self.$obj_stop = mid_of_object;
					} else if (self.$bottomStop){
						self.$obj_stop = bottom_of_object;
					}
				},

				bindEvents: function($mod) {
					var self = this;
					self.setVariables($mod);
					self.$container.data(
						'startStop',
						{
							'point_start': self.$obj_start,
							'point_stop': self.$obj_stop
						});

					$(window).scroll( function() {
						// reset variables to track settings like scrollTop() in case
						// page has changed since init
						self.setVariables($mod);

						// copy to local variables so don't have to prefix with 'self.'
						var $obj_start = self.$obj_start;
						var $obj_stop = self.$obj_stop;

						var top_of_window = $(window).scrollTop();
						var bottom_of_window = $(window).scrollTop() + $(window).height();

						var percent_along_full_shown = 0;
						var percent_along_shown = 0;
						var percent_not_full_shown = 0;

						/* If the object is completely visible in the window */
						if ( $obj_start <= bottom_of_window && top_of_window <= $obj_stop) {
							percent_not_full_shown = 100;

							var touches_top = $obj_stop;
							var touches_bottom = $obj_start - $(window).height();
							percent_along_full_shown = parseInt(100 - ((($(window).scrollTop() - touches_top)/(touches_bottom - touches_top)) * 100), 10);
						} else {
							if ($obj_stop <= bottom_of_window && $obj_start >= top_of_window) {
								if ($obj_start <= bottom_of_window) {
									percent_not_full_shown = parseInt((1-(top_of_window - $obj_stop)/self.$container.outerHeight())*100, 10);
								} else {
									percent_not_full_shown = parseInt((1-($obj_start - bottom_of_window)/self.$container.outerHeight())*100, 10);
								}
							} else {
								percent_not_full_shown = 0;
							}
							if (bottom_of_window > $obj_start) {
								percent_along_full_shown = 100;
							}
						}
						var exit_top = $obj_stop - $(window).height();
						var enter_bottom = $obj_start;
							percent_along_shown = parseInt((($(window).scrollTop() - exit_top)/(enter_bottom - exit_top)) * 100, 10);

						if (percent_along_shown > 100) { percent_along_shown = 100;}
						if (percent_along_shown < 0) { percent_along_shown = 0;}
						self.$container.data(
							'scrollpos',
							{
								'percent_along_full_shown': percent_along_full_shown,
								'percent_not_full_shown': percent_not_full_shown,
								'percent_along_shown': percent_along_shown
							});
					}); //end of holder scroll function
				},

				viewPort: function($mod) {
					$mod.find('.anim_holder.viewport').each( function() {
						var $this = $(this);
						var bg = $this.css('background-image').replace(/"/g,"").replace(/url\(|\)$/ig, "");
						var bgImage = new Image();
						bgImage.onload = function() {
							$this.data('scrolldata', {'range' : 'on', 'size' : [bgImage.width,bgImage.height], 'dir' : 'up'});
							if (mrm.util.touchDevice()) {
								$mod.find('.anim_holder').height( bgImage.height );
							}
						}
						bgImage.src = bg;
					});

					$(window).scroll( function() {
						$mod.find('.anim_holder.viewport').each( function() {
							var $this = $(this);
							var scrolldata = $this.data('scrolldata');
							var scrollpos = $this.data('scrollpos');
							var scaled_image_height = $this.outerWidth() * (scrolldata['size'][1]/scrolldata['size'][0]);
							var scale_bg_offset = (scaled_image_height < $this.height()) ? 0 : scaled_image_height - $this.height();
							// adapable for future development for reverse panning.
							var _pos = (scrolldata['range'] == 'on') ? scrollpos['percent_along_full_shown'] : scrollpos['percent_along_shown'];
							if (scrolldata['dir'] == 'up') {
								$this.css('background-position', 'center ' + (0 - (scale_bg_offset * (_pos/100))) + 'px');
							} else {
								$this.css('background-position', 'center ' + (0 - scale_bg_offset + (scale_bg_offset * (_pos/100))) + 'px');
							}

						});
					});
				},

				resize: function( $mod ) {
					var browser_width = parseInt($(window).width()),
						holder_max_width = this.config.maxWidth, 			  // 1920px is width before css centering kicks in
						holder_min_width = $('div[id|="mds-tpl"]').width(),   // 996px main content area width
						override_max_width = parseInt($mod.css('max-width')); // if theme has max-width set

					if (holder_max_width !== override_max_width) { // if theme-applied max-width is other than 1920px
						holder_max_width = override_max_width;
					}

					// resize $mod that are full width to fill browser width up to max and no smaller than holder_min_width
					if (browser_width <= holder_max_width) { 		// 1920px > w | browser less than max width
						if (browser_width <= holder_min_width) { 	// w < 996px | browser less than mds content area
							$mod.css('width', holder_min_width); 	// set static (996px) //
						} else { 									// 1920px > w < 996px | browser is currently in between widths of max and min widths
							$mod.css('width', browser_width); 		// set to browser_width fluid //
						}

					} else { 										// w > 1920px browser currently is wider than max width
						$mod.css('width', holder_max_width); 		// set static (1920px) //
					}

					// center if over maxWidth
					var nMargin = parseInt((holder_min_width - browser_width) * 0.5); // margin value
					nMargin = nMargin > 0 ? 0 : nMargin; // never more than zero

					$mod.css( {'margin-left': nMargin+'px', 'margin-right':nMargin+'px'} );

					// adjust margins
					if (browser_width > holder_max_width) { // once the css centering kicks in
						$mod.css( {
							'margin-left': holder_max_width * -0.5+'px',
							'margin-right': 'auto'
						} ).addClass('maxWidth');
					} else { // window is less than 1920px
						$mod.css('left', 0).removeClass('maxWidth');
					}

				}
			}
	});
})(mrm.$);(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		mm_animitem_1: {
			/**
			 * JS for component mm_1
			 *
			 * @param {String} c DOM Context
			 */
			tpl: ['06'],
				initMod: function($mod) {
					if ( mrm.util.touchDevice() ) { return; }
					var self = this,
						$modParent = $mod.parents('.anim_holder');
					// animitems that have a full width parent add centered_frame wrapper container so when Liquid Width Background is
					// selected, positioned items will still be based off of the content area (996px) instead of the liquid width area.
					if ( $modParent.hasClass('full_width') && !$mod.hasClass('full_width') && !$mod.hasClass('full_img') ) {
						$mod.wrap('<div style="z-index:'+$mod.css('z-index')+';" class="centered_frame">');
					}
					if ($mod.hasClass('activeFade')) {
						self.imgFade($mod);
					}
					if ($mod.hasClass('xymove')) {
						self.xyPosition($mod);
					}
					if ($mod.hasClass('sequence')) {
						self.imgSequence(self,$mod);
					}
				},

				preLoadImg: function($mod) {
					var $this = $mod;
					var scrollseq = $this.data('sequence');
					var img_count = scrollseq['images'].length;
					$(document.createElement('div'))
						.addClass('preLoadImg')
						.css('display','none')
						.insertAfter($mod);
					for (var i = 0; i < img_count; i++) {
						var imgPath = scrollseq['images'][i];
						$('<img />').attr('src',imgPath).appendTo( $mod.next('.preLoadImg') );
					}
				},

				imgFade: function($mod) {
					var manyItems = $mod.parents('.anim_holder').children('.modMm_animitem_1');
					if ( manyItems.length === 1 ) {
						$mod.each( function() {
							var bg = $mod.css('background-image');
							if (bg && bg !== 'none') { // run only if there is a bg image
								var img = new Image(),
								bgImgHeight;
								$(img).load( function() {
									bgImgHeight = img.height;
									$mod.height(bgImgHeight);
								});
								// setting the img source needs to be last for ie and firefox to work
								img.src = $mod.css('background-image').replace(/url\(|\)$/ig, "").replace(/"/g, "");
							}
						});
					}
					var that = $mod.parents('.anim_holder');
					var _starting_at = parseInt($mod.data('fader')['fadeIn'], 10);
					var _mid_at = parseInt($mod.data('fader')['fadeMid'], 10);
					var _end_at =  parseInt($mod.data('fader')['fadeOut'], 10);

					$(window).scroll( function () {
						$mod.each( function() {
							var scrollPer = that.data('scrollpos')['percent_along_full_shown'];
							if (scrollPer <= 50) {
								var _diff  = _mid_at - _starting_at;
								var _change = _diff * ((scrollPer/100)*2);
								$mod.css('opacity', (_starting_at +_change)/100);
							} else {
								var _diff = _end_at  - _mid_at;
								var _change = _diff * (((scrollPer-50)*2)/100);
								$mod.css('opacity', (_mid_at + _change)/100);
							}

						});
					});
				},

				imgSequence: function(self, $mod) {
					var that = $mod.parents('.anim_holder');
					var current_frame = {};
					var scrollseq = $mod.data('sequence');
					var img_count = scrollseq['images'].length - 1;
					var oldTop;
					var scrollRemainder = 0;
					var currentFrame = 0;
					var _img = scrollseq['images'][0];

					self.preLoadImg($mod);

					$(window).scroll( function() {
						$mod.each( function() {
							var windowTop = $(window).scrollTop();
							var $this = $(this);
							var scrollseq = $this.data('sequence');
							var scrollpos = that.data('scrollpos');
							var loop = parseInt($this.data('looper'),10);
							var _pos = (scrollseq['range'] == 'on') ? scrollpos['percent_along_full_shown'] : scrollpos['percent_along_shown'];

							if ( $mod.hasClass('looper') ){
								if ( _pos > 0 && _pos < 100) {
									if (oldTop !== undefined && scrollRemainder !== undefined) {
										var windowDiff = windowTop - oldTop;
										var totalDiff = windowDiff + scrollRemainder;
										if ( totalDiff >= 0) {
											var totalFrames = Math.floor(totalDiff / loop);
											var newFrame = currentFrame + totalFrames;
											while (newFrame > img_count) {
												newFrame = newFrame - (img_count + 1);
											}
											var _img = scrollseq['images'][newFrame];
											currentFrame = newFrame;
										} else {
											var totalFrames = Math.ceil(totalDiff / loop);
											var newFrame = currentFrame - Math.abs(totalFrames);
											while (newFrame < 0) {
												newFrame = newFrame + (img_count + 1);
											}
											var _img = scrollseq['images'][newFrame];
											currentFrame = newFrame;
										}
										scrollRemainder = totalDiff % loop;
									}
									oldTop = windowTop;
								}
							} else {
								var _img = scrollseq['images'][Math.round((scrollseq['images'].length-1) * (_pos/100))];
							}
							if (scrollseq['type'] == 'bg') {
								// Resolves that terrible chattering issue if bg image is to be used in the future
								$this.css('background-image', $($(this).find('.inner')[0]).css('background-image'));
								$this.find('.inner').css('background-image', 'url("'+_img+'")');
							} else if (scrollseq['type'] == 'img') {
								if ( $this.children('img').attr('src') !== _img ) {
									$this.children('img').attr('src', _img); // call only if different
								}
							}
						});
					});

				},

				xyPosition: function($mod) {
					var scrolldata = $mod.data('scrolldata');
					if (scrolldata.xpoints == undefined || scrolldata.ypoints == undefined) { return; } // prevent errors because both x and y start and end points must be defined
					$mod.css('top', scrolldata['ypoints'][0]).css('left', scrolldata['xpoints'][0]); // set position on load before scroll event

					$(window).scroll( function() {
						$this = $mod.closest('.anim_holder');
						var scrolldata = $mod.data('scrolldata');
						var scrollpos = $this.data('scrollpos');
						var _pos = (scrolldata['range'] == 'on') ? scrollpos['percent_along_full_shown'] : scrollpos['percent_along_shown'];

						$mod.css( 'top',  (scrolldata['ypoints'][0] + ((scrolldata['ypoints'][1] - scrolldata['ypoints'][0]) * (_pos/100))) + 'px');
						$mod.css( 'left', (scrolldata['xpoints'][0] + ((scrolldata['xpoints'][1] - scrolldata['xpoints'][0]) * (_pos/100))) + 'px');
					});
				}
		}
	});
})(mrm.$);
(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		mm_colorizer: {
			/**
			 * JS for component mm_1
			 *
			 * @param {String} c DOM Context
			 */
			tpl: ['01', '02','03','04','05','06','08','12','13','14'],
			$colorizerModules:null,
			clickOrTouch:null,
			
			init: function(c) {
				var self = this;
				self.clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				
				self.setBindings();
			},
			
			initMod: function($mod) {
				var self = this;
				
				if ( !$mod.length ) {
					return;
				}

				var $scrollContainer = $mod.closest('div.mmScroll'),
					$fadeOutPerScrollerItem = $scrollContainer.find('li.colorizer_view').find('figcaption.legal'),
					$currentScrollerItem = $(),
					fxCfg = mrm.conf.corcmp.mm_scroller || {},
					modCfg = $.extend({
						animateColorizerItems: true,
						animateControlsForTouch:true
					}, mrm.conf.cmp.colorizer || {});

				fxCfg = fxCfg.animateControls || {};
				fxCfg.speed = fxCfg.speed || 300;

				
				var $colorizer = $mod,
					$colorLinks = $('ul.colors > li > a', $colorizer),
					colorizerId = $colorizer.attr('id'), //mm_colorizer_c1
					$colorizerViews      = $scrollContainer.find('li.colorizer_view.' + colorizerId),
					$colorizerImages     = $colorizerViews.find('figure > img'),
					$colorizerLegalTexts = $colorizerViews.find('figcaption'),
					colorizerCfg = mrm.conf.cmp.colorizer || {},
					cluetipCfg = $.extend({}, mrm.conf.plugin.cluetip, {prepareTitleAttr: true});
					$colorLinks.first().closest("li").addClass("active");

				self.updateCenter($colorizer);
				
				var fadeOutTimeout;
				
				// bind colorchanger events for the current colorizer
				$colorLinks.on(self.clickOrTouch, function(e, eventParams) {
					var $currentLi = $(this).closest('li'),
					activeClass = 'active';
					e.preventDefault();
					$currentLi.addClass(activeClass).siblings('.' + activeClass).removeClass(activeClass);
					$colorizerImages.attr('src', function(i, oldSrc) {
						return $currentLi.data('colorpath') + oldSrc.split('/').pop();
					});
					
					$colorizerLegalTexts.html($currentLi.data('text'));
					$colorizerLegalTexts.trigger('initTooltip');
				});

				if (colorizerCfg.useColorTip) {
					$colorLinks.on('mouseover', function(e) {
						clearTimeout(fadeOutTimeout);
						fadeOutTimeout = setTimeout(function() {
							$("#cluetip").fadeOut(1000);
						}, 4500);
					});
					($colorLinks).cluetipWrap(cluetipCfg);
				}
				
				modCfg.animateColorizerItems && $mod.closest('div.mmScroll').on('showControls hideControls', function(e) {
					if (!mrm.util.touchDevice() || (modCfg.animateControlsForTouch && mrm.util.touchDevice())) {
						var isShow = e.type === 'showControls';
						$mod.filter(function () {
							return $(this).data('activeColorizer') === true;
						}).stop(true, true)[isShow ? 'slideDown' :  'slideUp'](fxCfg.speed);

						$currentScrollerItem.find($fadeOutPerScrollerItem).animate({opacity: isShow ? 1 : 0}, fxCfg.speed);
					}
				});
			},
			
			updateCenter: function($mod) {
				// center colorlinks in container
				
				if($('html').attr('dir') == 'rtl'){
					$mod.css('margin-left', '0'); // previous (big) margin influences width of ul.colors for calculations
					var parentWidth = $mod.parent().width();
					var modWidth = $mod.outerWidth();
					var colorsWidth = $mod.find('ul.colors').width();
					var colorMarginLeft = (parentWidth - colorsWidth) / 2 - parseFloat($mod.css('padding-left'));
					
					if(modWidth+colorMarginLeft > parentWidth){
						$mod.css('margin-left', 0).css('float', 'right');
					} else {
						$mod.css('margin-left', colorMarginLeft);
					}
				} else {
					$mod.css('margin-right', '0'); // previous (big) margin influences width of ul.colors for calculations
					var parentWidth = $mod.parent().width();
					var modWidth = $mod.outerWidth();
					var colorsWidth = $mod.find('ul.colors').width();
					var colorMarginRight = (parentWidth - colorsWidth) / 2 - parseFloat($mod.css('padding-right'));

					if(modWidth+colorMarginRight > parentWidth){
						$mod.css('margin-right', 0).css('float', 'left');
					} else {
						$mod.css('margin-right', colorMarginRight);
					}
				}
			},
			
			setBindings: function() {
				
				$.eventDispatcher.on('HMC_load_colorizer', $.proxy(function(event, data){
					this.initMod(data.colorizer);
				}, this));
				
				$.eventDispatcher.on('HMC_show_colorizer', $.proxy(function(event, data){
					this.updateCenter(data.colorizer);
				}, this));
				
			}
		}
	});
}(mrm.$));(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        mm_flash_1: {
            /**
            * JS for component mm_flash_1
            *
            * @param {String} c DOM Context
            */
            initMod: function($mod) {
                var self        = this,
                    readyClass  = 'jsReady',
                    elementsClass = "ifrm_ipad";


                // iFrame shouldn't be included on page load, as modern browsers would even already load it's content even if hidden - but an anchor tag, that get's converted to an iFrame on iPads
                if($.os.name === "ipad") {
                	var $iframe = $mod.find('> figure object a.' + elementsClass);
                	if($iframe.length){
                		$mod.find("> figure object img.mm").hide();
						$iframe.replaceWith(function() {
							return $('<iframe></iframe>')
									.addClass(elementsClass)
									.attr('src', $(this).attr('href'))
									.attr('width', $(this).data('ifrm-width'))
									.attr('height', $(this).data('ifrm-height'))
									.attr('frameborder', '0');
						});
                    }
                }
            }
        }
    });
}(mrm.$));
/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		mm_gal360_1_rtt_ng: {          
			/**
			 * JS for component mm_gal360_1-rtt_ng
			 * 
			 * @param {String} c DOM Context
			 */
			 
			tpl: ['07'],
			
			conf : {},
			
			dataInit : false,
			swfInit : false,
			
			rtt : null,
			$mm_gal360 : null,
				
				
			init: function(c) {    
				mrm.util.log('[mrm.cmp.mm_gal360_1_rtt_ng] Context: ' + c);
				
				this.$mm_gal360 = $('div.mm_gal360_1');
				
				// stop if mm_gal is not present 				
				if( !this.$mm_gal360.length || !this.$mm_gal360.find('#mds-rtt-flash').length ) return;
				$(document).on( 'init.rtt', $.proxy(this.swfReady, this) );
				
			},
			
			dataReady : function(conf){
				this.dataInit = true;
				this.conf = conf;
				
				this.initRtt();
			},
			
			swfReady : function(e, x){
				this.swfInit = true;
				
				this.initRtt();
			},
			
			initRtt : function(){
				
				if( this.dataInit && (this.swfInit || mrm.flash.initRtt) )
				{
					this.rtt = new mrm.cmp.rtt(this.conf);

					var extConf = this.$mm_gal360.find('.exterior li:first a').attr('rel');
					var intConf = this.$mm_gal360.find('.interior li:first a').attr('rel');
					this.rtt.setExtConf(extConf);
					this.rtt.setIntConf(intConf);
					this.rtt.onConfigChange(null, this.rtt.TYPE_EXTERIOR);
					
					this.$mm_gal360.find('.content .interior').on('click', {viewType:this.rtt.TYPE_INTERIOR}, $.proxy(this.onConfigChange, this) );
					this.$mm_gal360.find('.content .exterior').on('click', {viewType:this.rtt.TYPE_EXTERIOR}, $.proxy(this.onConfigChange, this) );
				}
			},
			
			onConfigChange : function(event){
				
				var viewType = event.data.viewType;
				var $target = $(event.target).closest('a');
				var conf = $target.attr('rel');
				
				$target.closest('.gallery').find('li.active').removeClass('active');
				$target.parent('li').addClass('active');
				
				if(viewType == this.rtt.TYPE_EXTERIOR){
					this.rtt.setExtConf(conf);
				}
				else{
					this.rtt.setIntConf(conf);
				}

        // calling the function to update the color/interior label
        var label = $target.find('img').attr('alt');
        this.updateLabel(viewType.toLowerCase(), label);

        $(document).trigger('config.rtt', [viewType]);
      },
      // function to update the color/interior label
      updateLabel: function(target, wording) {
        mrm.util.log('[mrm.cmp.mm_gal360_1.updateLabel] - target: ' + target + ' - wording: ' + wording);

        this.$mm_gal360.find('div.content div.' + target + ' h2 span').text(wording);
      }
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Mm_gal_1 = mrm.mod.AbstractMod.extend({

		events: {
			"click div.stage": "onClickControls",
			"click ul.gallery": "onClickGallery",
			"submit form.download": "onDownload"
		},

		options: {
			idPrefix: mrm.util.getRenamedIdPrefix()
		},

		prepare: function() {
			var self = this;

			var $firstElement = self.$ctx.find('.stage > dl > dt:first');
			var idToStartWith = '#' + $firstElement.attr('id');
			mrm.util.sharing.enableShare2Autorender($firstElement.next('dd'));

			if(!self.cfg.jumpToAnchors) {
				// rewrite the IDs to prevent jump to anchors
				self.$ctx.find('.stage dt').attr('id', function(i, id) {
					return self.options.idPrefix + id;
				});
			}
			self.setActiveItem(idToStartWith);

			if ($.browser.opera || $.browser.mozilla) {
				// compensate the displacement of the inner container, which is caused by the initial jump to the hastag-id
				self.$ctx.find('.stage dl').scrollTop(0);
				// if hash is set the page jump down, this function moves it back to top
				$('html, body').scrollTop(0);
			}

			this.wipeSupport();
		},

		wipeSupport: function() {
			var self = this;
			self.$ctx.find('div.stage').touchwipe({
				wipeLeft: function() {
					self.$ctx.find('dd.controls:not(.ui-helper-hidden-accessible)').find('.next').trigger('click');
				},
				wipeRight: function() {
					self.$ctx.find('dd.controls:not(.ui-helper-hidden-accessible)').find('.prev').trigger('click');
				},
				preventDefaultEvents: false
			});
		},

		setActiveItem: function(id) {
			var self = this;
			self.$ctx.find('ul.gallery li.active').removeClass('active');
			self.$ctx.find('ul.gallery li > a[href=' + id + ']').closest('li').addClass('active');

			if (!self.cfg.jumpToAnchors) {
				id = id.replace(/^#/, '#' + self.options.idPrefix);
			}

			self.$ctx.find('.stage > dl > dt:not(.ui-helper-hidden-accessible)')
				.addClass('ui-helper-hidden-accessible')
				.next('dd').addClass('ui-helper-hidden-accessible');

			var $container = self.$ctx.find(id).removeClass('ui-helper-hidden-accessible')
				.next('dd').removeClass('ui-helper-hidden-accessible');

			$container.trigger('renderShare2');
		},

		// used by deeplinking.js
		switchToContent: function($content) {
			var self = this;
			var hash = '#' + $content.attr('id');
			if (!self.cfg.jumpToAnchors) {
				hash = hash.replace('#' + self.options.idPrefix, '#');
			}
			self.setActiveItem(hash);
		},

		onDownload: function(event) {
			var self = this;
			event.preventDefault();
			var url = self.$ctx.find('dd.controls:not(.ui-helper-hidden-accessible) :selected').val();
			if (url !== 'none') window.open(url, 'download_wallpaper', 'fullscree=true');
		},

		onClickControls: function(event) {
			var self = this;
			var $target = $(event.target);
			if ($target.hasClass('prev') || $target.hasClass('next')) {
				self.setActiveItem($target.attr('href'));
			}
			if ($target.hasClass('zoom')) {
				event.preventDefault();
				window.open($target.attr('href'), 'enlarge_image', 'fullscree=true');
			}
		},

		onClickGallery: function(event){
			var self = this;
			var $target = $(event.target);

			if (!$target.is('ul')) {
				var $item = $target.is('li') ? $target : $target.parents('li:first');
				var href = $item.find('a').attr('href');
				self.setActiveItem(href);
			}
		}

	});
})(mrm.$);(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		mm_gal_lq: {
			/**
			 * JS for component mm_gal_1
			 *
			 * @param {String} c DOM Context
			 */
			tpl: ['07'],
			cfg: {
				aSizePostfixes: [
					// note the ascending order of resolutions/qualities
					{
						width: 1366,
						postfix: '_4'
					},
					{
						width: 1024,
						postfix: '_3'
					},
					{
						width: 1280,
						postfix: '_2'
					},
					{
						width: 1600,
						postfix: '_1'
					},
					{
						width: 1920,
						postfix: '_0'
					}
				]
			},
			maxCachedImgQuality: 0, // holds the index (in aSizePostfixes) of the best quality we already loaded
			$modContainer: $(),
			$galScroller: $(),
			$galScrollerButtons: $(),
			$stageContainer: $(),
			$stagePlayBtn: $(),
			$panelContainer: $(),
			$panelContent: $(),
			$galImg: $(),
			itemCount: 0,
			resizeTimerId: 0,
			panelSliderTimerId: 0,
			activeClass: 'active',
			isVideoGallery: false,
			isLiquidGallery: $('html').hasClass('liquid'), // galleries may be liquid or fixed (-width)
			options: {
				enableKeyboardNav:true,
				topOffset:0
			},

			init: function(c) {
				
				// call resizeHandler whenever the following events are triggered:
				$('.modMm_gal_lq').on('embed.video', function(){
					self.resizeHandler();
					//alert('embed video');
				});
				$('.modMm_gal_lq').on('mmVideoPlay', function(){
					self.resizeHandler();
					//alert('mm video play');
				});
				$('.modMm_gal_lq').on('videoActivate', function(){
					self.resizeHandler();
					//alert('mm video activate');
				});

				mrm.util.log('[mrm.cmp.mm_gal_lq] Context: ' + c);

				var $ctx = $('div.modMm_gal_lq');

				// exit if component isn't available on the page
				if (!$ctx.length) return;

				var self = this,
					tooltipConfig = $.extend({}, mrm.conf.plugin.cluetip, {prepareTitleAttr: true});

				/* At this point in time, Chevy needs to preserve old gallery layouts */
				if ( $ctx.find('.nav_extended_1').hasClass('nav-left') && ( typeof( mrm.cmp.mm_gal_lq.gal_nav_left ) !== 'undefined' ) ) {
					this.gal_nav_left.initMod( $ctx );
				}
				$.extend(true, self.options, mrm.conf.cmp.mm_gal_lq || {});// GMDSPLM-17886

				self.$modContainer = $ctx;
				self.isVideoGallery = self.$modContainer.hasClass('video');
				self.$galScroller = $('ul.mmScrollItems', self.$modContainer);
				self.$galItems = self.$galScroller.children('li');
				self.$galImg = $('figure img.mm', self.$galScroller);
				self.itemCount = self.$galScroller.children().length;
				self.$stageContainer = self.$galScroller.closest('div.stage');
				self.$galScrollerButtons = $('span.mmScrollBtn', self.$stageContainer);
				self.$panelContainer = self.$modContainer.children('div.panelWrp').children('div.inner');
				self.$panelCaption = self.$panelContainer.children('div.caption');
				self.$panelContent = self.$panelContainer.find('div.content');
				self.$thumbnails = self.$panelContent.find('ul.thumbnails > li:not(.placeholder)').slice(0, self.itemCount);

				self.$modContainer.children('div.mmScroll').mmScroll({
					responsive: true,
					items: {
						visible: 1
					},
					pagination: {
						// override default config - we'll create our own pagination
						container: false,
						anchorBuilder: false
					},
					scroll: {
						wipe: true,
						noWipeDirection: 'vertical',
						onBefore: function($oldItem, $newItem, newSize, duration) {
							$.proxy(self.updatePanel($newItem, $oldItem), self);
							$($newItem[0]).find('.hidden-video').trigger('videoPrepare');
						},
						onAfter: function($oldItem, $newItem, newSize, duration) {
							$($oldItem[0]).find('.hidden-video').trigger('videoClear');
							try {
								var newImage = $newItem.find('img').attr('src');
								newImage = newImage.substr( newImage.lastIndexOf('/') + 1 );
							} catch (e) { }
						}
					},
					onCreate: function($newItem) {
						$newItem.find('figure > img').one('load', function() {
							/*
								need to make sure the image is loaded before setting the sizes,
								otherwise the carousel height sometimes calculates to 0 (at least in chrome)
								because the image height is 'auto' in liquid mode
							*/
							self.$galScroller.trigger('updateSizes');
							if (self.isLiquidGallery) {
								$.proxy(self.resizeHandler(), self);
							}
						});
						$.proxy(self.updatePanel($newItem), self);

						if (self.isVideoGallery) {
							// get the correct height of the panel to determine the position of the controlbar
							// $('.panelWrp .inner .content').css({'visibility':'hidden','display':'block'});
							var controlbarMargin = 0;
							if (self.options.preventPanelToggle) {
								controlbarMargin = $('.panelWrp').outerHeight() + 10;
							} else {
								controlbarMargin = $('.panelWrp .inner .caption.tx_cap').outerHeight() +
									$('.panelWrp .inner .modNav_extended_1').outerHeight() + 20;
							}
							// $('.panelWrp .inner .content').css({'visibility':'visible','display':'none'});

							$('.hidden-video', self.$modContainer).hiddenVideo({
								targetElement: '.modMm_gal_lq.video > .stage',
								overrideHeight: '100%',
								overrideWidth: '100%'
							}, $.extend({}, mrm.conf.corcmp.mmVideo.jwpDefaults, {
								'controlbar.position': 'bottom',// GMDSPLM-17886
								'controlbar.margin': 40,// GMDSPLM-17886
								stretching: 'exactfit',
								events: {
									onComplete: function() {
										mrm.cmp.mm_gal_lq.endVideo();
									}
								}
							}));

							$($newItem[0]).find('.hidden-video').trigger('videoPrepare');
						}

						// make share_2 initially renderable
						mrm.util.sharing.enableShare2Autorender(self.$panelCaption);
					}
				});

				// Set up thumbnail scroller if configured.
				if (self.options.thumbnailScroller){
					var $thumbs = self.$panelContent.find('ul.thumbnails');
					self.$panelContent.addClass('scrolling');
					if (self.options.thumbnailHinting){
						self.$panelContent.addClass('thumbnail_hinting');
					}

					// add scroll buttons
					$thumbs.before($('<div class="thumbScrollBtn prev" />')).after($('<div class="thumbScrollBtn next"><div class="line"/></div>'));					

					// these are the default thumbnail options
					var thumbnailOptions = {
						auto: false,
						//width: '100px',// it resizes onload before displaying so any value works
						scroll: {
							items: 5
						},
						items: {
							visible: '+1'
						},
						align: 'left',
						infinite: false,
						circular: false,
						swipe: true,
						prev: {
							button: function() {
								return $(this).parent().prev(".prev");
							},
							onEnd: function(){
								$thumbs.trigger("configuration", {
									align: "left",
									reInit: true
								});
							}	
						},
						next: {
							button: function() {
								return $(this).parent().next(".next");
							},
							onEnd: function(){
								$thumbs.trigger("configuration", {
									align: "right",
									reInit: true
								});
							}
						},
					};

					// GMDSPLM-17886
					if (self.options.thumbnailScrollerContinuous) {
						self.$panelContent.addClass('continuous-scroll');
						thumbnailOptions.circular = true;
					}

					// create the thumbnail carousel
					$thumbs.mrmCarousel(thumbnailOptions);

					// GMDSPLM-17886
					// if liquid thumbnails container
					if (self.options.thumbnailScrollerLiquid) {
						$(window).on('resize', _.throttle(function(){
							if ( $('#container').width() > self.options.thumbnailScrollerLiquidMinWidth ) {
								$thumbs.trigger("configuration", {
									width: $('#container').width() - self.options.thumbnailScrollerLiquidMargins,
									reInit: true
								})
								//console.log('big');
							} else {
								$thumbs.trigger("configuration", {
									width: self.options.thumbnailScrollerLiquidMinWidthMinusArrows,
									reInit: true
								});
								//console.log('small');
							}
							// to prevent that issue where the .thumbScrollBtn disappear
							// and the caroufredsel_wrapper becomes too short
							$('.thumbScrollBtn').css('display','block');

							// GMDSSDS-61835 
							// In certain edge cases, a fraction of the last thumbnail is cut off,
							// But the arrows aren't shown because of the visible property below.
							// This calculates the need for arrows

							totalThumbsWidth = $thumbs.find("li").eq(0).outerWidth(true)*$thumbs.find("li").length;
							thumbsSpace = self.$panelContent.find(".caroufredsel_wrapper").width();
							if(totalThumbsWidth > thumbsSpace) /*console.log("need arrows");*/
								self.$panelContent.find(".thumbScrollBtn").removeClass("hidden").addClass("doNotHide");
							else 
								self.$panelContent.find(".thumbScrollBtn").removeClass("doNotHide").addClass("hidden");
						}));

						// GMDSPLM-17886
						// these two on click event listenter fix the issue with caroufredsel
						// where if caroufredsel_wrapper shows all items but
						// if the first or last item if cutoff, it simply wont scroll
						// that half-item or so length
						// A worse solution for this issue would be to set
						// thumbnailOptions.items.visible = false; but that would leave a small gap
						// on either side because it makes it show the all full items only
						// Keep in mind that when the caroufredsel_wrapper is not in this specific width
						// that caroufredsel overrides the .thumbScrollBtn event click function
						$('.thumbScrollBtn.next').on('click', function(){
							$thumbs.trigger("configuration", {
								align: 'right'
							});
							$('.thumbScrollBtn').css('display','block');
						});
						$('.thumbScrollBtn.prev').on('click', function(){
							$thumbs.trigger("configuration", {
								align: 'left'
							});
							$('.thumbScrollBtn').css('display','block');
						});
					} // end self.options.thumbnailScrollerLiquid
				} // end self.options.thumbnailScroller


				// Set up thumbnail scroller with pagination if configured.
				if (self.options.thumbnailScrollerPagination) {
					var self = this;
					var carousel = $ctx.find('ul.thumbnails');

					carousel
						.addClass('mmScroll')
						.before($('<div class="thumbScrollBtn prev prev-thumb" />'))
						.after($('<div class="thumbScrollBtn next next-thumb" />'));

					var options = {
						slideToPage: {
							page: null
						},
						auto: false,
						progress: true,
						// direction: 'right',
						// height: 'variable',
						// width: 900,
						infinite: false,
						circular: false,
						prev: '.prev-thumb',
						next: '.next-thumb',
						items: {
							visible: 8
						},
						pagination: {
							container: function(){
								return $('<div class="pager_wrap"><span class="pager_prevpage" id="pager_prevpage">&lt;</span><span class="pager"></span><span class="pager_nextpage" id="pager_nextpage">&gt;</span></div>')
									.appendTo( $ctx.find('.panelWrp .content') )
									.children('.pager');
							},
							anchorBuilder: function(nr) {
								// [1][2][3]...
								return ' <a href="#" id="page_'+nr+'" class="page"><span>'+nr+'</span></a>';
							}
						},
						scroll: {
							onAfter: function($oldItem, $newItem, newSize, duration){
								$(this).css('left', '0');
								// self.loadImage($newItem.prev());  // LazyLoad images on scroller after scroll.
						},
						wipe: true
					},

					// pagination creation
					onCreate: function($oldItem, $newItem, newSize, duration) {
						// Google like pagination creation
						var _bulletsCenter = 7; // number of bullets in the middle, should always be an odd number
						var _bulletsSide = 0; // number of bullets left and right
						var _maxPagesDisplay = 10;
						// self.loadImage($oldItem); //onload lazyLoad Scrollers

						var ancestorDiv = $(this).closest('.content');
						var _itemsTotal = $(this).children().length;
						var numPages = Math.ceil(_itemsTotal / options.items.visible);

						var _pagesCurrent, currentPage;

						$ctx.find('.mmScrollBtn.next').on('click', function(event) {
							var	current = carousel.find('.active');
							var currentIdx = carousel.find('li').index(current);
							if ( currentIdx >= options.items.visible ) {
								carousel.trigger('slideTo', current);
							}
						});
						$ctx.find('.mmScrollBtn.prev').on('click', function(event) {
							var	current = carousel.find('.active');
							var currentIdx = carousel.find('li').index(current);
							if (currentIdx === (_itemsTotal - 1)) {
								carousel.trigger('prev');
								carousel.trigger('slideTo', current);
							}
						});

						$(this).bind('updatePageStatus.cfs', function() {
							_pagesCurrent = $(this).triggerHandler('currentPosition') + 1; // (current position just to the left out of scroll) + 1
							currentPage = Math.ceil( _pagesCurrent / options.items.visible );

							// pagination is a bit buggy in some cases when _pagesCurrent is within the first page bounds and near the last page bounds
							if ( _pagesCurrent < options.items.visible && _pagesCurrent > 1 ) {
								currentPage = 2;
								$('#page_1').removeClass('selected');
								$('#page_2').addClass('selected');
							} else if ( parseInt( $ctx.find('.pager a.selected').attr("id").replace(/\D/g,'') ) === numPages ) {
								currentPage = numPages;
							}

							// gray out prev/next arrows if on first/last page
							var $prevarrow = ancestorDiv.find(".prev-thumb");
							var $nextarrow = ancestorDiv.find(".next-thumb");

							currentPage === 1 ? $prevarrow.css("opacity",".5") : $prevarrow.css("opacity","1");
							currentPage === numPages ? $nextarrow.css("opacity",".5") : $nextarrow.css("opacity","1");

							if (ancestorDiv.find('.pager_wrap .pager a.page').length > _maxPagesDisplay) {
								if (currentPage <= Math.ceil(_maxPagesDisplay / 2)) {
									// ex: [1][2][3][4][5][6][7] - page 1-4 selected
									$(".page").show();
									for (var i=_maxPagesDisplay + 1; i<=numPages; i++) {
										$("#page_" + i).hide();
									}
								}
								else if (currentPage > numPages - Math.ceil(_maxPagesDisplay / 2) ) {
									// ex: [6][7][8][9][10][11][12] - 12 total pages, 9-12 selected
									$(".page").hide();
									for (var i=numPages - Math.floor(_maxPagesDisplay-1); i<=numPages; i++) {
										$("#page_" + i).show();
									}
								}
								else {
									// ex: [5][6][7][8][9][10][11] - 12 total pages, 5-8 selected
									// console.log(Math.floor(_maxPagesDisplay / 2))
									$(".page").hide();
									for (var i = currentPage - Math.floor(_maxPagesDisplay / 2); i<=currentPage + Math.floor(_maxPagesDisplay / 2); i++) {
										// console.log(i); // get's not whole numbers??
										$("#page_" + i).show();
									}
								}
							}
							else {
								ancestorDiv.find(".pager_prevpage").hide();
								ancestorDiv.find(".pager_nextpage").hide();
							}

						});


					} // oncreate end
				},

				cfg = $.extend(true, {}, options ), // extended to use touchwipe for touch devices.

				wipeConfig = {
					min_move_x: 30,
					min_move_y: 30,
					preventDefaultEventsHorizontal: (!cfg.scroll.noWipeDirection || cfg.scroll.noWipeDirection !== 'horizontal'),
					preventDefaultEventsVertical: (!cfg.scroll.noWipeDirection || cfg.scroll.noWipeDirection !== 'vertical'),
					wipeLeft:  function (e) { carousel.trigger('next'); },
					wipeRight: function (e) { carousel.trigger('prev'); }
				};
				// end of variables ^^

				if ($.fn.touchwipe && cfg.scroll.wipe) {
					carousel.touchwipe(wipeConfig); // additional support for touch devices.
					cfg.scroll.wipe = false; // keep caroufredsel from using it's built-in touchwipe support
				}
				carousel.carouFredSel( cfg ).css('left', '0'); // Create the carousel and overwrite left align.

				// $ctx.find('.story_list.nonScroll').addClass('jsReady');

				} //end self.options.thumbnailScrollerPagination

				if (self.options.floatThumbnails){
					var $win = $(window),
						$topSlide = self.$stageContainer.find('.mmScrollItems').find('li:first-child'),
						$panel = self.$panelContainer.parent(),
						$inner = (self.options.floatThumbnailsUseParent) ? $panel : self.$panelContainer,
						panelHeight = $inner.height(),
						margin = parseInt($panel.css('margin-top'), 10);

					$panel.css('height', $inner.height());

					$win.on('scroll', function() {
						// console.count('gallery scroll');
						var galleryHeight = $topSlide.outerHeight(true),
							winBottom = $win.height() + $win.scrollTop(),
							galleryBottom = galleryHeight + $topSlide.offset().top;

						self.panelScroll($panel, $inner, galleryBottom, panelHeight, margin, winBottom, self.isVideoGallery);


					});
					$win.on('resize', function() {
//						$thumbs.find('ul:eq(0)').trigger('configuration', {'width': $('.panelWrp').find('.caroufredsel_wrapper').width(), reInit: true});

						setTimeout(function(){$win.triggerHandler('scroll')}, 200);
						$win.scroll();
					});
					$win.scroll();
				}

				// GMDSSDS-42381 - Fixes images downsizes after loading
				if (mrm.util.ie8()) {
					$(".modMm_gal_lq .stage figure img.mm").css("width",$(window).width() + "px");
					$(window).resize(function() {
						$(".modMm_gal_lq .stage figure img.mm").css("width",$(window).width() + "px");
					});
				}
				if (!self.isVideoGallery) {
					if (!mrm.util.touchDevice()) {
						self.$thumbnails.children('a[title]').cluetipWrap(tooltipConfig);
					}
				} else {
					if (self.options.showVideoToolTipOverride && !mrm.util.touchDevice()) {
						self.$thumbnails.children('a[title]').cluetipWrap(tooltipConfig);
						if ( !mrm.util.ie8() ) {
							self.$thumbnails.wrapInner('<figure></figure>');
						}
					}
					//self.$stageContainer.add( self.$thumbnails.find('figure > a') ).append('<div class="playButton" />');
					// Bug 72333: adding playbutton back, but only to video area, not thumbnails, as the prev commented line above does
					self.$stageContainer.append('<div class="playButton" />');
					self.$stagePlayBtn = self.$stageContainer.children('div.playButton');
				}

				self.bindEvents();
			},
			panelScroll: function($panel, $inner, galleryBottom, panelHeight, margin, winBottom, isVideoGallery) {

				if (galleryBottom + panelHeight + margin > winBottom) {
							$panel.addClass('float');
                            $inner.css({'bottom': galleryBottom + panelHeight + margin - winBottom});
						} else {
							$panel.removeClass('float');
							$inner.css('bottom', '0');
						}

			},
			bindEvents: function() {
				var self = this;

				if (self.isLiquidGallery) {
					$(window).on('load resize', $.proxy(self.resizeHandler, self));
					//drops thumbnail panel down after 5 seconds on page load
					self.hidePanel(5000);
				}

				// bind pagination thumbnails
				self.$thumbnails.on('click', function(e) {
					var $currentLi = $(this),
						itemIndex = self.$thumbnails.index(this);
					e.preventDefault();
					self.$galScroller.trigger('slideTo', itemIndex);
					self.setActiveClass($currentLi, self.$thumbnails);
					if (self.isVideoGallery) {
						self.playVideo(self.$galItems.eq(itemIndex));
					}
					
					// GMDSPLM-17886
					// now resize BC for VIDEOS only there is no cutoff point at the top of the page
					// so the entire video is being stretched to available space
					self.resizeHandler();
				});

				if (self.isVideoGallery) {
					self.$galScroller.add(self.$stagePlayBtn).on('click', function(e) {
						self.playVideo(self.$galScroller.triggerHandler('currentVisible'));
					});

					self.$galItems.on('videoClear', function(e) {
						self.$stagePlayBtn.show();
					});
				}

				if (mrm.util.touchDevice()) {
					// bind slideOpen/Close panel for touch devices
					if (self.isLiquidGallery) {
						self.$panelContainer.children().on('click', function(e) {
							var $target = $(e.target);
							if (!$target.closest('div.content, div.mod', self.$panelContainer[0]).length) {
								self.$panelContent.slideToggle();
							}
						});
					}
					return;
				}

				/* ############# Bindings For Non Touch Devices Only  ############ */

				if (self.isLiquidGallery) {
					// bind slideOpen/Close panel
					self.$panelContainer.children().on('mouseenter', function(e) {
						self.showPanel(200);
					});

					self.$panelContainer.children().on('mouseleave', function(e) {
						self.hidePanel(1000);
					});

					// exclude areas from mouseover
					$('.modShare_2, .ull', self.$panelContainer).on('mouseenter', function(e) {
						window.clearTimeout(self.panelSliderTimerId);
					}).on('mouseleave', function(e) {
						self.$panelContainer.children().trigger('mouseenter');
					});
				}

				/* Enable keyboard navigation */
				if (self.options.enableKeyboardNav) {
					$(document).bind('keyup', function(e) {
						e.preventDefault();
						switch(e.which) {
							case 37: // left keypress
								$('div.modMm_gal_lq span.mmScrollBtn.prev').trigger('click');
								break;
							case 39: // right keypress
								$('div.modMm_gal_lq span.mmScrollBtn.next').trigger('click');
								break;
						}

					});
				}


			},
			
			resizeHandler: function() {
				
				onVideoTab = $('.modMm_gal_lq.video').length >= 1;
				if (onVideoTab) {
					this.resizeHandlerVideoTab();
					return;
				}

				var self = this,
					vH = $(window).height() - self.options.topOffset,
					newHeight = Math.min(vH, self.$galScroller.find('figure').first().height());

				// force scroller to be the height of the asset
				if(self.options.forceToImageSize){
					newHeight = self.$galScroller.find('figure').first().height();
				}
				
				// min-height for image gallery
				if (newHeight < 400) {
					newHeight = 400;
				}

				// the first part is executed each time the resize event fires (could be continously)
				$.each([self.$stageContainer, self.$stageContainer.children('.caroufredsel_wrapper'), self.$galScroller, self.$galItems], function() {
					this.height(newHeight);
				});

				// set up 'eased' resize
				window.clearTimeout(self.resizeTimerId);
				self.resizeTimerId = window.setTimeout(function(){
					// All code in here will be executed only if the
					// handler hasn't been called within the last 300ms
					// (which in most cases means the resize is done)
					self.imageRefreshHandler();
				}, 300);

				if (!self.isVideoGallery) { return; }


			},
			
			resizeHandlerVideoTab: function() {
				var self = this;

				var videoTopBottomSpacing = self.options.videoTopBottomSpacing;
				
				if ($('html').hasClass('ipad')) {
					videoTopBottomSpacing += 20;
				}

				if ($('html').hasClass('firefox')) {
					videoTopBottomSpacing += 11;
				}

				if ($('html').hasClass('msie9')) {
					videoTopBottomSpacing += 11;
				}

				var self = this,
					vH = $(window).height() - videoTopBottomSpacing,//self.options.videoTopBottomSpacing, // 800px
					vW = $(window).width(); // 1600px

				// min-width for videos
				if ($(window).width() < self.options.windowMinimumWidth) {
					vW = self.options.windowMinimumWidth;
				}
				
				// min-height for videos
				if ($(window).height() < self.options.windowMinimumHeight) {
					vH = self.options.windowMinimumHeight - videoTopBottomSpacing;
				}
				
				var ratioHeight = vW * 0.5625; // 900px
				var ratioWidth = vH / 0.5625;  // 1422px

				if (ratioWidth > vW) {
					var newHeight = ratioHeight;
					var newWidth = vW;
					var mt = 100;
					var mt = (( $(window).height() - (newHeight + videoTopBottomSpacing) ) / 2 ) + 1;
				} else {
					var newHeight = vH;
					var newWidth = ratioWidth;
					var mt = 0;
				}
				
				// the first part is executed each time the resize event fires (could be continously)
				$.each([self.$stageContainer, self.$stageContainer.children('.stage > .caroufredsel_wrapper').eq(0),  self.$galScroller, self.$galItems], function() {
					this.height(newHeight);
					this.width(newWidth);
				});

				// letterbox/pillarbox combination
				$('.modMm_gal_lq div[id*="hiddenvideo-container_"].hidden-video').css('height', newHeight);
				$('.modMm_gal_lq div[id*="hiddenvideo-container_"].hidden-video').css('width', newWidth);
				$('.modMm_gal_lq div[id*="hiddenvideo-container_"].hidden-video > div object').css('margin-top', mt);
				$('.modMm_gal_lq div[id*="hiddenvideo-container_"].hidden-video .end_frame_wrap').css('margin-top', mt);

				// also resize stage height in addition to the video object height
				// this is necessary in order to enforce a min height for the entire window
				var stageHeight = $(window).height() - videoTopBottomSpacing;
				// enforce min height
				if (stageHeight < self.options.videoMinimumHeight) {
					stageHeight = self.options.videoMinimumHeight;
				}
				$('.modMm_gal_lq .stage').css('height', stageHeight);

				// set up 'eased' resize
				window.clearTimeout(self.resizeTimerId);
				self.resizeTimerId = window.setTimeout(function(){
					// All code in here will be executed only if the
					// handler hasn't been called within the last 300ms
					// (which in most cases means the resize is done)
					self.imageRefreshHandler();
				}, 300);

				if (!self.isVideoGallery) { return; }
			},

			imageRefreshHandler: function() {
				var self = this,
					qualityLevel = self.getQualityLevel();

				if (qualityLevel <= self.maxCachedImgQuality) {
					return false;
				}

				self.maxCachedImgQuality = qualityLevel;

				// updateGalleryImages selection (automatically created posterframes only have one quality level can not be refreshed)
				self.$galImg.not('.automatic').each(function(i, img) {
					var $currentImg = $(img),
						currentSrc = $currentImg.attr('src'),
						newSrc = currentSrc.replace(/_\d+(\.[a-z]{3,4})$/, self.cfg.aSizePostfixes[qualityLevel].postfix + '$1'),
						$newImg = $currentImg.clone();

					$newImg.on('load', function(e) {
						self.switchImages($currentImg, $newImg);
					});
					$newImg.attr('src', newSrc);
				});
			},

			getQualityLevel: function() {
				var vpWidth = $(window).width(),
					qualityLevel = 0;

				$.each(this.cfg.aSizePostfixes, function(idx, resolutionData) {
					qualityLevel = idx;
					if (vpWidth <= resolutionData.width) {
						return false;
					}
				});

				return qualityLevel;
			},

			getImageSize: function() {
				var vpWidth = $(window).width(),
					lastCheckedWidth, nextWidth, qualityLevel = 0;

				$.each(this.cfg.sizePostfixes, function(imgWidth, postfix) {
					qualityLevel++;
					lastCheckedWidth = imgWidth;
					if (!nextWidth && vpWidth <= imgWidth) {
						nextWidth = imgWidth;
						return false;
					}
				});

				if ( qualityLevel == self.maxCachedImgQuality ) {
					return false;
				}
				return !nextWidth ? lastCheckedWidth : nextWidth;
			},

			switchImages: function($currentImg, $newImg) {
				$currentImg.attr('src', $newImg.attr('src'));
			},

			updatePanel: function($newItem, $oldItem) {
				$oldItem = $oldItem || $();

				if ($oldItem.length) {
					$oldItem.find('figcaption').append(this.$panelCaption.contents());
				} else {
					this.$panelCaption.empty();
				}
				this.$panelCaption.append( $newItem.find('figcaption').contents() );
				// this.$panelCaption.html( $newItem.find('figcaption').html());  //Reverted change from r21751 for GMDSSDS-60823
				// set active thumbail to current item
				this.setActiveClass(this.$thumbnails.eq(this.$galItems.index($newItem)), this.$thumbnails);
				var items = this.$panelContent.find('ul.thumbnails').triggerHandler("currentVisible");
				items = items ? items.length : 0;
				var page = Math.floor(this.$galItems.index($newItem) / items);

				if (this.options.thumbnailScroller) {
					/* Move the thumbnail to the right page */
					//this.$thumbnails.trigger('slideToPage', page); GMDSSDS-62245 - DONT EVEN NEED TO DO THIS
				}


				// Need to add this number to the count container
				if (this.options.showCount){
					if (!$('.modNav_extended_1').find('#itemCount').length){
						$('.modNav_extended_1').find('ul').after('<span id="itemCount"></div>');
					}
					$('.modNav_extended_1').find('#itemCount').text((this.$galItems.index($newItem)+1)+'/'+this.$thumbnails.length)
					//console.log((this.$galItems.index($newItem)+1)+'/'+this.$thumbnails.length);
				}

				// render share-buttons
				this.$panelCaption.trigger('renderShare2');
			},

			// core method used to show/hide the thumbnail panel
			togglePanel: function(action, timeout) {
				var self = this,
					method = (action=='hide') ? 'slideUp' : 'slideDown';
				timeout = parseInt(timeout, 10) || 0;
				window.clearTimeout(self.panelSliderTimerId);
				self.panelSliderTimerId = window.setTimeout(function(){
					self.$panelContent[method]();

					// TODO: hide/show the player controls depending on the panel
					if(method == 'slideUp') {
						//alert('show player controls');
					} else {
						//alert('hide player controls');
					}
				}, timeout);
			},

			showPanel: function(timeout) {
				if(!this.options.preventPanelToggle)
					this.togglePanel('show', timeout);
			},

			hidePanel: function(timeout) {
				if(!this.options.preventPanelToggle)
					this.togglePanel('hide', timeout);
			},

			hideScrollerControls: function() {
				this.$galScrollerButtons.fadeOut();
			},

			showScrollerControls: function() {
				this.$galScrollerButtons.fadeIn();
			},

			setActiveClass: function($element, $collection) {
				var $collection = $collection || $element.siblings();
				$collection.filter('.' + this.activeClass).removeClass(this.activeClass);
				$element.addClass(this.activeClass);
			},

			playVideo: function($scrollerItem) {
				// TODO: start the video for $scrollerItem when this method is called

				this.$stagePlayBtn.hide();
				// Bug 72333: don't hide controls when video plays
				//this.hideScrollerControls();
				//this.hidePanel();

				$scrollerItem.find('.hidden-video').trigger('videoActivate');

			},

			endVideo: function() {

				this.$stagePlayBtn.show();
				// Bug 72333: no need to show, since we didn't hide
				//this.showScrollerControls();
				//this.showPanel();

			},

			// used by deeplinking.js
			switchToContent: function($content) {
				this.$galScroller.trigger("slideTo", $content);
			}
		}
	});
}(mrm.$));(function($) {
	mrm.cmp.mm_gal_lq = mrm.cmp.mm_gal_lq || {};
	mrm.cmp.mm_gal_lq.gal_nav_left = {

		initMod: function( $mod ) {
			var self = this;
			mrm.conf.cmp.mm_gal_lq = mrm.conf.cmp.mm_gal_lq || {};
			var options = $.extend( mrm.conf.cmp.mm_gal_lq || {}, {
				thumbnailScroller: false,
				thumbnailScrollerPagination: true,
				thumbnailHinting: true,
				preventPanelToggle: true,
				showCount: false,
				forceToImageSize: false,
				floatThumbnails: true,
				floatThumbnailsUseParent: true,
				showVideoToolTipOverride: true
			});

			if (mrm.util.touchDevice()){
				$mod.find('.panelWrp').css('margin-top','0px');
			}
			
			$('figcaption').each( function() { // wrap caption to horiz center text block
				$( this ).wrapInner('<div class="capWrp"></div>');
			});
			
			$( document ).ready( function() {
				$('<div class="panelWrpBg"></div>').prependTo( $mod.find('.panelWrp') ); // white background
				$mod.find('.panelWrp').prepend( $mod.find('.inner > .tx_cap') ); // pull caption out of panel to make width 100%
				if ( $mod.find('ul.thumbnails li').length < 9 ) {
					$mod.find('#itemCount').hide();
				}
			});
		}
	};
})(mrm.$);



(function($) {
    mrm.track = mrm.track || {};
    $.extend(mrm.track, {
        mm_gal_lq: {
            initTrack: function($mod, section) {
                var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

                //tracking for gallery previous btn
                $mod.find("span.mmScrollBtn.prev").on(clickOrTouch, function() {
                    var photoname = $('.thumbnails .active a img').attr('src');

                    if (typeof(photoname) !== "undefined") {
                        photoname = photoname.substr(photoname.lastIndexOf('/') + 1);
                    }

                    mrm.util.trackEvent("click_cta", {
                        section: section,
                        linkname: 'arrow:prev:' + photoname
                    });
                });

                //tracking for gallery next btn
                $mod.find("span.mmScrollBtn.next").on(clickOrTouch, function() {
                    var photoname = $('.thumbnails .active a img').attr('src');

                    if (typeof(photoname) !== "undefined") {
                        photoname = photoname.substr(photoname.lastIndexOf('/') + 1);
                    }

                    mrm.util.trackEvent("click_cta", {
                        section: section,
                        linkname: 'arrow:next:' + photoname
                    });
                });

                //tracking for thumbnail previouos btn 
                $mod.find(".thumbScrollBtn.prev").on(clickOrTouch, function() {
                    mrm.util.trackEvent("click_cta", {
                        section: section,
                        linkname: 'thumb:arrow:prev'
                    });
                });

                //tracking for thumbnail next btn 
                $mod.find(".thumbScrollBtn.next").on(clickOrTouch, function() {
                    mrm.util.trackEvent("click_cta", {
                        section: section,
                        linkname: 'thumb:arrow:next'
                    });
                });

                //tracking for thumbnail img links
                $mod.find(".thumbnails li").on(clickOrTouch, function() {
                    var photoname = $(this).find("img").attr("src");

                    if (typeof(photoname) !== "undefined") {
                        photoname = photoname.substr(photoname.lastIndexOf('/') + 1);
                    }

                    mrm.util.trackEvent("click_cta", {
                        section: section,
                        linkname: 'thumb:' + photoname
                    });
                });

                //tracking for download link
                $mod.find(".caption.tx_cap .ull a").on(clickOrTouch, function() {
                    var linkText = $(this).text();
                    var hrefSeg = $(this).attr("href");

                    if (typeof(hrefSeg) !== "undefined") {
                        hrefSeg = hrefSeg.substr(hrefSeg.lastIndexOf('/') + 1);
                    }

                    mrm.util.trackEvent("click_cta", {
                        section: section,
                        linkname: 'link:' + linkText + ":" + hrefSeg
                    });
                });
            }
        }
    });
}(mrm.$));
/*   Cluetip does not support HTML image maps, so a custom caption implmentation exists
 *   within this component. The markup for this caption was mirrored off of Cluetip's
 *   markup, so styling the caption should be as simple as applying the same styling
 *   to the similarly named classes. For this version, there exists three classes.
 *   They are "captiontip", "captiontip-inner", and "captiontip-outer". They are related
 *   to "cluetip", "cluetip-inner", and "cluetip-outer".
 */
(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        mm_hotspot_1: {
            captionSpacing: 10,
            initMod: function($mod) {
                var self = this;

                /*  Split simple and advanced setups immediately since the markup
                    and functionality are completley different for the two configurations */

                if ($mod.find(".simpleHotSpot").length > 0) {
                    self.setupSimpleEvents($mod);
                } else if ($mod.find(".advancedHotSpot").length > 0) {
                    self.setupAdvancedEvents($mod);
                }
            },
            setupSimpleEvents: function($mod) {
                var self = this;
                var modData = $mod.find(".simpleHotSpot").data();
                var eventTrigger = modData.trigger;
                // Determin whether captions are triggered by mouseover or click
                if (eventTrigger === "mouseover" && mrm.util.touchDevice() === false) {
                    $mod.find("area").each(function() {

                        var $currentMap = $(this);
                        if ($currentMap.data().caption !== undefined) {
                            $currentMap.on("mouseover", function(){
                                var areaBounds = self.findAreaBounds($mod, $currentMap);
                                self.setupSimpleHotSpots($mod, $currentMap, areaBounds);

                            });
                            $currentMap.on("mouseout", function(){
                                $("#container").find(".captiontip").remove();
                            });
                        }
                    });
                } else {
                    $mod.find("area").each(function() {

                        var $currentMap = $(this);

                        if ($currentMap.data().caption !== undefined) {
                            $currentMap.on("click", function(){
                                if ($currentMap.hasClass("active")) {
                                    $mod.find("area").removeClass("active");
                                    $("#container").find(".captiontip").remove();

                                } else {
                                    $mod.find("area").removeClass("active");
                                    $("#container").find(".captiontip").remove();
                                    var areaBounds = self.findAreaBounds($mod, $currentMap);
                                    $currentMap.addClass("active");
                                    self.setupSimpleHotSpots($mod, $currentMap, areaBounds);
                                    // Prevent link from firing, but only when caption isn't shown
                                    return false;
                                }

                            });

                        }
                    });
                    // Close any open captions when clicking away from the caption
                    $(document).on("click", function(){
                        $("#container").find(".captiontip").remove();
                        $mod.find("area").removeClass("active");
                    });
                }
            },
            setupSimpleHotSpots: function($mod, $currentMap, areaBounds) {
                var self = this;
                var modData = $mod.find(".simpleHotSpot").data();
                var captionText = $currentMap.data().caption;


                var captionConfig = {
                    top: areaBounds.top,
                    right: areaBounds.right,
                    bottom: areaBounds.bottom,
                    left: areaBounds.left,
                    transition: modData.transition,
                    xlocation: modData.xlocation,
                    ylocation: modData.ylocation,
                    trigger: modData.trigger,
                    text: captionText
                };

                self.createCaptionTip($mod, $currentMap, captionConfig);

            },
            findAreaBounds: function($mod, $currentMap) {
                if ($currentMap.attr("shape") === "rect") {
                    var rectCoords = $currentMap.attr("coords").split(",");
                    var leftCoord = parseInt(rectCoords[0], 10), topCoord = parseInt(rectCoords[1], 10),
                    rightCoord = parseInt(rectCoords[2], 10), bottomCoord = parseInt(rectCoords[3], 10);

                    return {top: topCoord, right: rightCoord, bottom: bottomCoord, left: leftCoord};

                } else if ($currentMap.attr("shape") === "circle") {

                    var circleCoords = $currentMap.attr("coords").split(",");
                    var centerX = parseInt(circleCoords[0], 10);
                    var centerY = parseInt(circleCoords[1], 10);
                    var radius = parseInt(circleCoords[2], 10);

                    // Find topmost bound
                    var circleTop = centerY - radius;

                    // Find rightmost bound
                    var circleRight = centerX + radius;

                    // Find bottommost bound
                    var circleBottom = centerY + radius;

                    // Find leftmost bound
                    var circleLeft = centerX - radius;

                    return {top: circleTop, right: circleRight, bottom: circleBottom, left: circleLeft};

                } else if ($currentMap.attr("shape") === "polygon") {
                    var polyCoords = $currentMap.attr("coords").split(",");
                    var xCoords = [];
                    var yCoords = [];
                    var polyTop;
                    var polyBottom;
                    var polyLeft;
                    var polyRight;

                    // Split Coords array into X values and Y Values
                    for (var i = 0; i < polyCoords.length; i = i+1) {
                        if ((i % 2) === 0) {
                            xCoords.push(parseInt(polyCoords[i], 10));
                        } else {
                            yCoords.push(parseInt(polyCoords[i], 10));
                        }
                    }

                    // Find high and low values for Y values array
                    for (var i = 0; i < yCoords.length; i = i+1) {
                        if (yCoords[i] < polyTop || polyTop === undefined) {
                            // Find topmost bound
                            polyTop = yCoords[i];
                        }
                        if (yCoords[i] > polyBottom || polyBottom === undefined) {
                            // Find bottommost bound
                            polyBottom = yCoords[i];
                        }
                    }

                    // Find high and low values for X values array
                    for (var i = 0; i < xCoords.length; i = i+1) {
                        if (xCoords[i] > polyRight || polyRight === undefined) {
                            // Find rightmost bound
                            polyRight = xCoords[i];
                        }
                        if (xCoords[i] < polyLeft || polyLeft === undefined) {
                            // Find leftmost bound
                            polyLeft = xCoords[i];
                        }
                    }
                    return {top: polyTop, right: polyRight, bottom: polyBottom, left: polyLeft};
                }
            },
            setupAdvancedEvents: function($mod) {
                var self = this;
                var modData = $mod.find(".advancedHotSpot").data();
                var eventTrigger = modData.trigger;
                // Determin whether captions are triggered by mouseover or click

                if (eventTrigger === "mouseover" && mrm.util.touchDevice() === false) {
                    $mod.find(".hotspot-item").each(function() {

                        var $currentSpot = $(this);
                        if ($currentSpot.data().caption !== undefined) {
                            $currentSpot.on("mouseover", function(){
                                var itemBounds = self.findItemBounds($mod, $currentSpot);
                                self.setupAdvancedHotSpots($mod, $currentSpot, itemBounds);
                                if ( mrm.util.ie8() ) {
                                    $(".captiontip-inner").css("background-color","#000");
                                }
                            });
                            $currentSpot.on("mouseout", function(){
                                $("#container").find(".captiontip").remove();
                            });
                        }

                    });
                } else {
                    $mod.find(".hotspot-item").each(function() {

                        var $currentSpot = $(this);

                        if ($currentSpot.data().caption !== undefined) {
                            $currentSpot.on("click", function() {
                                if ($currentSpot.hasClass("active")) {
                                    $mod.find(".hotspot-item").removeClass("active");
                                    $("#container").find(".captiontip").remove();
                                } else {
                                    $mod.find(".hotspot-item").removeClass("active");
                                    $("#container").find(".captiontip").remove();
                                    var itemBounds = self.findItemBounds($mod, $currentSpot);
                                    $currentSpot.addClass("active");
                                    self.setupAdvancedHotSpots($mod, $currentSpot, itemBounds);
                                    // Prevent link only when caption isn't showing
                                    return false;
                                }
                            });

                        }
                    });
                    // Close any open captions when clicking away from the caption
                    $(document).on("click", function(){
                        $("#container").find(".captiontip").remove();
                        $mod.find(".hotspot-item").removeClass("active");
                    });
                }
            },
            setupAdvancedHotSpots: function($mod, $currentSpot, itemBounds) {
                var self = this;
                var modData = $mod.find(".advancedHotSpot").data();
                var captionText = $currentSpot.data().caption;
                var itemData = $currentSpot.data();


                var captionConfig = {
                    top: itemBounds.top,
                    right: itemBounds.right,
                    bottom: itemBounds.bottom,
                    left: itemBounds.left,
                    transition: modData.transition,
                    xlocation: itemData.xlocation,
                    ylocation: itemData.ylocation,
                    trigger: modData.trigger,
                    text: captionText
                };

                self.createCaptionTip($mod, $currentSpot, captionConfig);
            },
            findItemBounds: function($mod, $currentSpot) {
                var modOffsetTop = $mod.offset().top;
                var modOffsetLeft = $mod.offset().left;
                var itemOffsetTop = $currentSpot.offset().top;
                var itemOffsetLeft = $currentSpot.offset().left;

                var itemWidth = $currentSpot.width();
                var itemHeight = $currentSpot.height();

                var topEdge = itemOffsetTop - modOffsetTop;
                var rightEdge = itemOffsetLeft - modOffsetLeft + itemWidth;
                var bottomEdge = itemOffsetTop - modOffsetTop + itemHeight;
                var leftEdge = itemOffsetLeft - modOffsetLeft


                return {top: topEdge, right: rightEdge, bottom: bottomEdge, left: leftEdge};
            },
            createCaptionTip: function($mod, $target, config) {

                // Create caption HTML and insert it into the DOM
                var self = this;
                var topPosition, leftPosition;
                var $hotspotContainer = $mod.children("div:first-child");
                var modOffsetTop = $mod.offset().top - $("#container").offset().top;
                var modOffsetLeft = $mod.offset().left - $("#container").offset().left;

                // "visibility:hidden" needed to hide caption but to allow detection of height and width later on
                var $captionDiv = $("<div>").addClass("captiontip").css("visibility", "hidden");
                var $captionOuter = $("<div>").addClass("captiontip-outer");
                var $captionInner = $("<div>").addClass("captiontip-inner");
                $captionInner.html(config.text);
                $captionOuter.append($captionInner);
                $captionDiv.append($captionOuter);
                $("#container").append($captionDiv);

                // Find the size of the hidden caption
                var $hiddenCaption = $("#container").find(".captiontip");
                var captionHeight = $hiddenCaption.outerHeight();
                var captionWidth = $hiddenCaption.outerWidth();



                // Find left placement position
                if (config.xlocation === "left") {
                    leftPosition = modOffsetLeft + config.left - captionWidth - self.captionSpacing;

                // Find right placement position
                } else if (config.xlocation === "right") {
                    leftPosition = modOffsetLeft + config.right + self.captionSpacing;

                // Find horizontal center placement position
                } else if (config.xlocation === "center") {
                    leftPosition = modOffsetLeft + ((config.left + config.right) / 2) - (captionWidth / 2);
                }



                // Find top placement position
                if (config.ylocation === "top") {
                    topPosition = modOffsetTop + config.top - captionHeight - self.captionSpacing;

                // Find bottom placement position
                } else if (config.ylocation === "bottom") {
                    topPosition = modOffsetTop + config.bottom + self.captionSpacing;


                // Find vertical center placement position
                } else if (config.ylocation === "center") {
                    topPosition = modOffsetTop + ((config.bottom + config.top) / 2) - (captionHeight / 2);
                }

                // Set the position of the captiontip

                $hiddenCaption.css({"top": topPosition, "left": leftPosition});

                // Setup display transitions
                self.displayCaptionTip($captionDiv, config);

            },
            displayCaptionTip: function($captionDiv, config) {
                var $captionOuter = $captionDiv.find(".captiontip-outer");
                var $captionInner = $captionDiv.find(".captiontip-inner");
                var outerHeight = $captionOuter.height();
                var outerWidth = $captionOuter.width();
                var innerHeight = $captionInner.height();
                var innerWidth = $captionInner.width();
                var outerMargin = outerWidth / 2;

                // Remove "visibility:hidden" and set to "display:none" for jQuery effects
                $captionDiv.css({"display": "none", "visibility": ""});

                if (config.transition === "none") {
                    $captionDiv.show();
                } else if (config.transition === "fade-in") {
                    $captionDiv.fadeIn();
                } else if (config.transition === "expand") {
                    outerWidth += 1; // ie fix - so doesn't wrap to second line
                    innerWidth += 1; // ie fix - so doesn't wrap to second line
                    $captionInner.css({"width": innerWidth, "height": innerHeight});
                    $captionDiv.show();
                    $captionOuter.css({"width": 0, "margin-left": outerMargin}).animate({"width": outerWidth, "margin-left": 0});
                }

            }
        }
    });
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		mm_hotspot_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';						
				
				//$mod.find('a').removeAttr('onclick');
				$mod.find('a img').on(clickOrTouch, function(){
					var linkname = $(this).parents("a").attr("href");
					linkname = linkname.substr( linkname.lastIndexOf('/') + 1 );
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'hotspot:' + linkname});
				});		
			}				
		}
	});
}(mrm.$));(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        mm_imagevideo_1: {
            init: function(c) {
				var self = this;
                mrm.util.log("[mrm.cmp.mm_imagevideo_1] Context: " + c);

                var $mods = $('.modMm_imagevideo_1');
                if ($mods.length == 0) return;

                $mods.each(function() {
                    var $this = $(this);

                    // check responibility for initializing video
                    mrm.util.doInitVideo($this);
                    self.fullWidth.initMod($this);

                    // GMDSSDS-58246 - keep figcaption within 980 zone
                    // IE8 doesn't recognize figcaption selector in CSS
                    if (mrm.util.ie8() ) {
                        if ($this.parents(".mm_scroll").hasClass("fullwidth")) {
                            var newMarginLeft = ($this.find("img.mm").width() - 980)/2;
                            $this.find('figcaption div:first').before($('<div class="figcaption_contents"></div>'));
                            $this.find(".modShare_2").detach().appendTo($this.find('.figcaption_contents'));
                            $this.find(".txtWrp").detach().appendTo($this.find('.figcaption_contents'));
                            $this.find(".figcaption_contents").css("margin-left", newMarginLeft + "px");
                            $this.find(".figcaption_contents").css("width","980px");
                            $this.find(".figcaption_contents").css("left","50%");
                        }
                    }
                });
            },
			fullWidth: {
				config: $.extend(mrm.conf.cmp.mm_imagevideo_1 || {}, {
					maxWidth: 1920
				}),
				init: function($mod) {
					//console.log('fullWidth setup');
				},
				initMod: function($mod) {
					var $figure = $mod.find('figure');
					if ($figure.attr('data-cfg-full-width') === '1' && !$figure.closest('.mm_scroll').length) {
						// set current height, max-width and overflow on the scroller
						$mod.css({'overflow': 'visible', 'padding-left': 0, 'padding-right': 0, maxWidth: this.config.maxWidth, height: $mod.height()});
						$figure.css({'overflow': 'hidden', 'padding-left': 0, 'padding-right': 0, marginLeft: 0, marginRight: 0, height: $figure.height()});

						//	find the original width and height and save them to data
						var $img = $mod.find('img.mm');
						var $video = $mod.find('div.video');

						$img.data('origSize', {height: $img.height(), width: $img.width()});

						// set css width and remove the width and height attributes
						$img.css({width: $img.attr('width')});
						$img.removeAttr('height width');
						//$video.removeAttr('height width');

						$figure.find('.tx_cap').wrap('<div class="captionHolder" />')


						// event listener for window resize
						$(window).resize($.proxy(function(e) {
							this.resize($mod);
						}, this));

						// initial call
						this.resize($mod);
					}
				},
				resize: function($mod) {
					var pageWidth = $(window).width(),
						containerWidth = $('.mds-area-content:eq(0)').width();

					var nMargin = (containerWidth - pageWidth) * .5;
					nMargin = nMargin > 0 ? 0 : nMargin;
					$mod.css({'margin-left': nMargin, 'margin-right': nMargin});
					//center if over maxWidth
					if (pageWidth > this.config.maxWidth) {
						$mod.css('left', (pageWidth - this.config.maxWidth) * .5);
					} else {
						$mod.css('left', 0);
					}

					// size the mod first it's the outter most

					// find the top image
					var $img = $mod.find('img.mm:eq(0)'),
						modWidth = $mod.width(),
						$video = $mod.find('div.video');

					$mod.find('.figure').width(modWidth);

					// if larger then original size then set all images to width and
					// calculate the top negitive margin for centering the image vertically.
					if (modWidth >= $img.data('origSize').width) {
						var topMargin = Math.floor(((($img.data('origSize').width * $img.data('origSize').height) / modWidth) - $img.data('origSize').height) * .5);
						$img.css({'margin-top': topMargin, 'width': modWidth});
//						$video.attr('height', $img.height()).attr('width', $img.width());
					}else{
						var leftMargin = (modWidth - $img.data('origSize').width) *.5;
						$mod.find('figure').css({'margin-left': leftMargin});
						$mod.find('.captionHolder').css({'margin-left': (leftMargin*-1)});
					}

					//center if over maxWidth
					if(pageWidth > this.config.maxWidth){
						$mod.css('left', (pageWidth-this.config.maxWidth)*.5);
					}else{
						$mod.css('left', 0);
					}
				}
			}
        }
    });
}(mrm.$));/** MRMVideo Plugin
 * 	This video player can be targeted using the following:
 *  $(selector).data('mrmvideo').propertyOrMethod();
 *  
 *  JWPlayer targeting
 *  All JWPlayer Javascript API calls are available to the 'player' object in the code below:
 *  $(selector).data('mrmvideo').player.javascriptAPIPropertyOrMethod();
 *  See http://www.longtailvideo.com/support/jw-player/jw-player-for-flash-v5/12540/javascript-api-reference
 *	for full reference.
 **/

(function($) {
   var _defaultOptions = {
	  // Public Options
	  width: null, // width of video player
	  height: null, // height of video player
	  flashplayer: "/static/cms/all/swf/player.swf",
	  skin: null,
	  autostart: false, // lhiggins - setting this to false, it causes a load error race condition with Chrome
	  initPlayerOnLoad: false, // auto load jwplayer and skip posterframe
	  controlbar:'over',
	  customEmbedParams:{allowfullscreen:'true', allowscriptaccess:'always', wmode: 'opaque'}, // custom embeds on the embed parameters
	  customObjectAttr:{id:null, name:null}, // custom attributes on the flash object tag
	  customVideoTagAttr:null, // custom video tags
	  events: {onBeforePlay:null} // custom jwplayer events.
   };
   
   /**
	* Function: Constructor, Prototype & Options Setup
	**/
   $.mrmvideo = function(target, options) { // if this contructor wasn't newed, then new it
	  if (this == window) {
		 return new $.mrmvideo(target, (options || {}));
	  } else {
		 this.init(target, options);
	  }
   };
   $.mrmvideo.prototype = {
	  // properties
	  _pluginName:'mrmvideo',
	  _target: null,
	  _videoCont: null,
	  _posterCont: null,
	  _customEmbedsSet:false,
	  playerId: null,
	  posterId: null,
	  player: null,
	  //methods
	  init: function(target, options) {
		 var self = this;
		 // store the basics
		 self._target = $(target);
		 self.options = new $.mrmvideo.options(options);
		 if(self.options.bind !== undefined) delete self.options.bind;

		 self._target.addClass(self._pluginName);

		 // don't rerun the plugin if it is already present
		 if (self._target.data(self._pluginName)) {
			return;
		 }

		 // register this controlset with the element
		 self._target.data(self._pluginName, this);

		 // set default width/height
		 if (self.options.width == null) self.options.width = self._target.width();
		 if (self.options.height == null) self.options.height = self._target.height();

		 self.playerId = (self.options.playerId == null) ? 'vp' + (new Date().getTime()) + /* Math.floor replaced by */~~((Math.random()*1000)+1) : self.options.playerId;
		 
		 // check if there is a posterframe
		 if (self.options.image == '' || self.options.image == undefined) {
		 	if(self.options.image == undefined) self.options.image = '';
			self.options.initPlayerOnLoad = true;
			self.options.autostart = false;
		 }
		 
		 // set player skin
		 self.skin = self.options.skin;
		 
		 self.build();
		 self.createEventListeners();
	  },

	  /**
	   * Build HTML
	   **/
	  build: function() {
		 var self = this;
		 
		 //Set container div width/height
		 self._target.css({'width':self.options.width,'height':self.options.height});
		 
		 var html = '<div class="player" id="' + self.playerId + '"></div><div class="posterframe"><a href="#"><img src="' + self.options.image + '" border="0" width="' + self.options.width + '" height="' + self.options.height + '" /></a></div>';
		 self._target.append(html);
		 self._videoCont = self._target.children("div.player");
		 self._posterCont = self._target.children("div.posterframe");
		 if (self.options.initPlayerOnLoad) {
			self._posterCont.hide();
			self.buildPlayer();
		 }
	  },

	  /**
	   * Build the JW Player
	   **/
	  buildPlayer: function() {
		 var self = this;
		 
		 /* load up jwplayer */
		 // pause all other video players
		 self.stopAllPlayers();
		 
		 self._posterCont.hide();			   
		 self.player = jwplayer(self.playerId);			   
		 // detect if flash is enabled
		 var hasFlash = false;
		 try {
		  var fo = new ActiveXObject('ShockwaveFlash.ShockwaveFlash');
		  if(fo) hasFlash = true;
		 }catch(e){
		  if(navigator.mimeTypes ["application/x-shockwave-flash"] != undefined) hasFlash = true;
		 }

		 if (hasFlash && $("object#" + self.playerId).length > 0) {
         	self.player.play();
         	return
         } else if (!hasFlash && $("#" + self.playerId).children().length > 0) {
         	self.player.play();
         	return
         }

		 if (hasFlash) {
		   // build swf object version if flash
		   self.options.customObjectAttr.id = self.options.customObjectAttr.name = self.playerId;				
		   swfobject.embedSWF(self.options.flashplayer,self.playerId,self.options.width,self.options.height,'9.0.115','false',
		 	self.options, self.options.customEmbedParams, self.options.customObjectAttr);
		 } else {
		   // build html5 video version if mobile
		   var html =  '<video ' + 
		 			  '	 src="' + self.options.file + '"' + 
		 			  '	 id="' + self.playerId + '"' + 
		 			  '	 poster="' + self.options.image + '"' + 
		 			  '	 width="' + self.options.width + '" autoplay="' + self.options.autostart + '" height="'  + self.options.height + '"';
		  
		   html += '></video>';
		   self._videoCont.append(html);
		   self.options.events.onBeforePlay = function() {
		 	 var vidTag = $('video#' + self.playerId + '_video');
		 	 if (vidTag.length > 0) {
		 		for (var attr in self.options.customVideoTagAttr) {
		 		   vidTag.attr(attr, self.options.customVideoTagAttr[attr]);							  
		 		}
		 	 }
		 	 delete vidTag;
		   }
		   self.player.setup(self.options);				 
		 }			   
		 self.setPlayerEvents();
	  },

	  /**
	   * Quick play control functions
	   **/
	  play: function() {
		 var self = this;
		 player.play();
	  },
	  stop: function() {
		 var self = this;
		 player.stop();
	  },
	  pause: function() {
		 var self = this;
		 player.pause();
	  },
	  createEventListeners: function() {
		 var self = this;
		 self._target.find('div.posterframe a').live('click', function(e) {
			e.preventDefault();
			// build player
			self.buildPlayer();
			// tracking
		 });
	  },
	  
	  stopAllPlayers: function() {
	  	var self = this;
	  	// pause all other video players
		$('div.'+self._pluginName).each(function() {
			if ($(this).data('mrmvideo').player != null && $(this).find('object').attr('id') !== self.playerId) {
				var playerState = $(this).data(self._pluginName).player.getState();
				if ((playerState == 'PLAYING') || (playerState == 'BUFFERING')) $(this).data(self._pluginName).player.pause();
			}
		});
	  },

	  /**
	   * Player Tracking Events
	   **/
	  setPlayerEvents: function() {
		 var self = this;
		 var currentComplete = 0;
		 var videoName;
		 
		 self.player.onTime(function(time) {
			var percentComplete = (time.position / time.duration);
			switch (true) {
			   // tracking for 75% second complete
			case ((percentComplete >= .75) && (currentComplete < 4)):
			   //console.log(percentComplete + ' complete');
			   currentComplete = 4;
			   self.clickTrack('video_75',videoName);
			   break;
			   // tracking for 50% complete
			case ((percentComplete >= .5) && (currentComplete < 3)):
			   //console.log(percentComplete + ' complete');
			   currentComplete = 3;
			   self.clickTrack('video_50',videoName);
			   break;
			   // tracking for 25% complete
			case ((percentComplete >= .25) && (currentComplete < 2)):
			   //console.log(percentComplete + ' complete');
			   currentComplete = 2;
			   self.clickTrack('video_25',videoName);
			   break;
			   // tracking for .5 second complete
			case ((time.position >= .5) && (currentComplete < 1)):
			   //console.log(percentComplete + ' complete');
			   currentComplete = 1;
			   break;
			}
		 });
		 // tracking for 100% complete
		 self.player.onComplete(function() {
			//console.log('complete');
			currentComplete = 0;
			// destroy on complete
			if (!self.options.initPlayerOnLoad) {				 
				self._posterCont.fadeIn();
			}
			self.clickTrack('video_100',videoName);
		 });
		 // tracking event for fullscreen
		 self.player.onFullscreen(function() {
			if (self.player.getFullscreen()) {
			   //console.log('open fullscreen');
			} else {
			   //console.log('close fullscreen');
			}
		 });
		 // tracking event for player start
		 self.player.onPlay(function() {
		 	videoName = self.player.getPlaylistItem().title;
			if(currentComplete < 0.1) {
				//console.log("play");
				self.clickTrack('video_start',videoName);
			} else {
				//console.log("not playing from beginning");
				self.stopAllPlayers();
			}
		 });
	  },
	  /**
	   * Destroy this object
	   **/
	  destroy: function() {
		 var self = this;
		 self.target.removeData(self._pluginName);
		 self.target.removeClass(self._pluginName);
		 self.target.empty();
		 delete this;
	  },
	  
	  /**
	   * Check if empty super function
	   **/
	  _is_empty: function(mixed_var) {
		 var key;
		 if (mixed_var === "" || mixed_var === 0 || mixed_var === "0" || mixed_var === null || mixed_var === false || typeof mixed_var === 'undefined') {
			return true;
		 }
		 if (typeof mixed_var == 'object') {
			for (key in mixed_var) {
			   return false;
			}
			return true;
		 }
		 return false;
	  }
   };
   /**
	* Options Setup
	**/
   $.mrmvideo.options = function(options) {
	  $.extend(true, this, $.mrmvideo.options, options);	  
   };
   $.mrmvideo.options.prototype = _defaultOptions;
   /**
	* Set as JQuery Plugin
	**/
   $.fn.mrmvideo = function(options) {
	  return this.each(function() {
		 new $.mrmvideo(this, options);
	  });
   };
})(jQuery);;(function($) {
	mrm.mod.Mm_mos_1 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;
			self.initCarousel();
		},

		initCarousel: function() {
			var self = this;
			var readyClass = 'jsReady';
			var prefix = 'mm_mos_1-';
			var index = self.id;
			var $list = self.$ctx.find('> ul');
			var $items = $list.find('> li');
			
			// stop if list is empty
			if ($items.length <= 0) return;
				
			var startIndex = 0;
			var nextId = prefix + 'next-' + index;
			var prevId = prefix + 'prev-' + index;
			var paginationId = prefix + 'pagination-' + index;
			
			self.$ctx.find('> span.next').attr('id', nextId);
			self.$ctx.find('> span.prev').attr('id', prevId);
			self.$ctx.append('<ol id="' + paginationId + '"></ol>');

			if (mrm.util.isRtl()) {
				startIndex = $items.length - 1;
				self.reverseListItems($list);
			}

			self.adjustCarousel($list, $items);
		
			var options = {
				auto: {
					play: false
				},
				scroll: {
					pauseOnHover: true,
					wipe: false,
					onBefore: function($oldItem, $newItem, newSize, duration) {
						self.$ctx.find('.caroufredsel_wrapper').scrollLeft(0);
					}
				},
				circular: true,
				infinite: true,
				height: 'auto',
				items: {
					visible: 1,
					start: startIndex
				},
				prev: {
					button: '#' + prevId
				},
				next: {
					button: '#' + nextId
				},
				pagination: {
					container: '#' + paginationId,
					anchorBuilder: function (nr) {
						if (mrm.util.isRtl()) {
							nr = $items.length - (nr-1);
						}
						return '<li><a href="#scroller-item_' + nr + '">' + nr + '</a></li>';
					}
				}
			};
			
			var wipeConfig = {
				min_move_x: 30,
				min_move_y: 30,
				preventDefaultEvents: false,
				preventDefaultEventsHorizontal: false,
				preventDefaultEventsVertical: false,
				wipeLeft:  function (e) {
					$list.trigger('next');
				},
				wipeRight: function (e) {
					$list.trigger('prev');
				}
			};
			
			var listClasses = $list.attr('class');
			var autoscrollRegex = /(autoscroll_[\w]*)/;
			if (autoscrollRegex.test(listClasses)) {
				options.auto = {
					play: true,
					pauseDuration: self.cfg[listClasses.match(autoscrollRegex)[1]]
				};
			}
			
			$list.mrmCarousel(options);
			if ($.fn.touchwipe) {
				$list.touchwipe(wipeConfig);
			}
			
			self.$ctx.addClass(readyClass);
		},

		adjustCarousel : function($list, $items){
        	if( $items.find('.has4elements').length > 0) {
            	var $ctx = this.$ctx;
                $ctx.addClass("wide-carousel");
                var height = $items.first().height();
                $.each([$list, $ctx, $ctx.children('.next'), $ctx.children('.prev'), $ctx.children('.caroufredsel_wrapper')], function() {
                	this.height(height);
                });
                $ctx.children('.caroufredsel_wrapper').width(1000);
                $ctx.parents(".catwalk").width(1060);
            }
        },
		
		reverseListItems : function($list){
			var $items = $list.children('li');
			var length = $items.length;
			for (var i=0; i < length; i++) {
				$items.eq(i).prependTo($list);
			}
		},

		// used by deeplinking.js
		switchToContent: function($content) {
			var self = this;
			self.$ctx.find('.caroufredsel_wrapper > ul').trigger("slideTo", $content);
		}

	});
})(mrm.$);;(function($) {
	mrm.mod.Mm_mos_1 = mrm.mod.Mm_mos_1.extend({

		after: function() {

			if ((mrm.util.curTemplate() === "06") && this.$ctx.find('div[class*="modTs_ln_"]').length > 0) {
				this.$ctx.find('> span, > div > ul > li .section').equalHeights();
				$('#mm_mos_1-pagination-1').insertBefore('#mm_mos_1-prev-1');
			} else {
				this.$ctx.find('> span, > div > ul').equalHeights();
			}

		}

	});

})(mrm.$);/*
    2013 by Steve Conroy, MRM Worldwide
*/
(function($) {

	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		mm_slidetext_1: {
			/**
			 * JS for component mm_slidetext_1
			 */
			
			initMod: function ($mod) {
			    var self = this;
			    
			    self._initVideoLinks($mod);
			},
			
			// initVideoLinks looks for anchors which are set to start playing a mm_imagevideo_1 video
			_initVideoLinks: function($mod) {
			    var $link = $mod.find('a.link-video'),
			        $imageVideoMod = $($mod.closest('.modMm_imagevideo_1'));
			    
			    // reset any existing click action to avoid duplicate function calls and memory leaks
			    $link.off('click');  
			    
			    // on click of the link-video, start playing the video
                $link.on('click', function(e){
                    var $video = $($imageVideoMod.find('.video'));

                    if($video.length > 0){
                        //  ignore whatever href value the anchor has (in case author added a link value in addition to checking the Video Box)
                        e.preventDefault();
                        
                        // if the player is not in a scroller, hide the slidetext until the video is done playing
                        // if the player is in a scroller, the hide/show of the slidetext is handled within the scroller (z-index of player)
                        // don't hide for the scroller because if a user scrolls before the video is done, slidetext is never shown again
                        if($mod.parents('.mmScroll').length <= 0) $mod.hide();
                        
                        
                        if($video.data('posterclick')){
                            jQuery($video.find('img')).click();  // use the existing play functionity of the posterframe to start the video
                        }else{
                            // find the jwPlayer instance and call the play method to begin the video
                            var players = mrm.corcmp.mmVideo.getJWPlayers($imageVideoMod);
                            
                            // only start one player (there shouldn't be more than one, but to be safe
                            if(players.length > 0){
                                try{
                                    players[0].play();
                                }catch(e){
                                    // something other than a jwplayer was returned with no play() function
                                }
                            }
                        }
                    }
                });
                
                // listen for the video to end and then show the textslide content again
                $imageVideoMod.on('mmVideoComplete', function(event) {
                        $mod.show();
                });
			} // End _initVideoLinks
		}// End mm_slidetext_1 object
	});
}(mrm.$));;(function($) {
	mrm.mod.Mm_video_1 = mrm.mod.AbstractMod.extend({

		events: {
			"click ul.gallery > li": "clickOnList",
			"click ul.functions": "clickOnFunction"
		},

		player: null,
		$gallery: $(),
		$items: $(),
		amountOfItems: 0,
		dataAttribute: 'rel',
		trackingFunc: null,
		isInitialized: false,
		initialVideoIndex: 0,
		idPrefix: mrm.util.getRenamedIdPrefix(),
		docTitle: document.title,

		prepare: function() {
			var self = this;
			self.$gallery = self.$ctx.find('ul.gallery');

			// rename item-ids to avoid browser-scrolling on location-change
			self.$gallery.children('li').attr('id', function(i, id) {
				return self.idPrefix + id;
			});

			if (self.$ctx.children('div.stage').hasClass('youtube')) {
				self.player = $('#youtubePlayer')[0];
				self.playVideo = self.playYoutubeVideo;
				self.dataAttribute = 'href';
				self.isInitialized= true;
				self.initGallery();
			} else {
				mrm.util.doInitVideo(self.$ctx);
				var playerId = self.$ctx.find('> .stage > .video').attr('id');
				self.player = jwplayer('jwPlayerTarget_' + playerId);
				self.playVideo = self.playJWflvVideo;
				self.dataAttribute = 'rel';
			}

			// wait for player got embedded
			self.$ctx.on('embed.video', function(event) {
				self.playerReady();
			});
		},

		playerReady: function() {
			var self = this;
			self.isInitialized = true;
			self.playVideo = self.playJWflvVideo;
			self.dataAttribute = 'rel';
			self.initGallery();
		},
		
		initGallery: function() {
			var self = this;
			self.$items	= self.$gallery.children('li');
			self.amountOfItems = self.$items.length;
			self.wipeSupport();
			self.triggerNextVideo(self.initialVideoIndex, true);
		},

		wipeSupport: function() {
			var self = this;
			var player = self.player;
			var $stage = self.$ctx.find('div.stage');
			$stage.touchwipe({
				wipeLeft: function() {
					if(!$stage.hasClass('youtube')) {
						if (player.getState() !== "BUFFERING" && player.getState() !== "PLAYING" ) self.$ctx.find('ul.functions .next').trigger('click');
					}
				},
				wipeRight: function() {
					if(!$stage.hasClass('youtube')) {
						if (player.getState() !== "BUFFERING" && player.getState() !== "PLAYING" ) self.$ctx.find('ul.functions .prev').trigger('click');
					}
				},
				preventDefaultEvents: false
			});
		},

		clickOnList: function(event, triggered){
			var self = this;
			event.preventDefault();

			var $item = $(event.currentTarget);
			var video = $item.find('a:first').attr(self.dataAttribute);
			
			self.$gallery.children('li.active').removeClass('active');
			$item.addClass('active');
			if (!triggered) $(location).attr('hash', '#' + $item.attr('id').replace(self.idPrefix, ''));
			
			// enable share2
			var $li = self.$ctx.find('ul.functions li.sharing-container');
			var $share2 = $li.find('.modShare_2').eq($item.index());
			if ($share2.length) {
				$li.find('.modShare_2:visible').css('display', 'none');
				$share2.css('display', 'block');
				mrm.util.sharing.enableShare2Autorender($share2);
				$li.trigger('renderShare2');
			}

			self.playVideo(video);
		},

		clickOnFunction: function(event) {
			var self = this;
			var $target = $(event.target);
			if ($target.hasClass('prev') || $target.hasClass('next')) {
				event.preventDefault();
				var currentClass = $target.hasClass('prev') ? 'prev' : 'next';
				self.triggerNextVideo(currentClass);
			}
		},

		triggerNextVideo: function(step, triggered) {
			var self = this;
			var index = self.$gallery.children('li.active').index();
			if (step === 'next') {
				index = (index == self.amountOfItems - 1) ? 0 : index + 1;
			} else if (step === 'prev') {
				index = (index === 0) ? self.amountOfItems - 1 : index - 1;
			} else if (typeof(step) === 'number') {
				index = step;
			}
			
			if (self.isInitialized) {
				self.$items.eq(index).find('a:first').trigger('click', triggered);
			} else {
				self.initialVideoIndex = index;
			}
		},

		playJWflvVideo: function(video) {
			var self = this;
			if (typeof self.player !== "undefined") {
                // If the Player was not fully initialized, please reload! Bug occured in Safari 5.0
				if(!self.player.config){
					var playerId = self.$ctx.find('> .stage > .video').attr('id');
					self.player = jwplayer('jwPlayerTarget_' + playerId);
				}
				// autostart:true hack for html5 when going through the playlist (onError evt)
				self.player.load(video).onReady(function(c){
					self.player.stop().play();
				})
				.onPause(function (c) {
					if(mrm.util.ie()){
						var hash = self.$gallery.children("li.active").attr("id").replace(that.idPrefix, "");
						$(document).attr('title', self.docTitle + '#' + hash);
					}
				})
				.onError(function(evt){
					self.onError(null);
					self.play();
				});
			}
		},

		playYoutubeVideo: function(video) {
			var self = this;
			$(self.player).attr('src', video);
		},

		// used by deeplinking.js
		switchToContent: function($content) {
			var self = this;
			var id = $content.attr('id').replace(self.idPrefix, '');
			// if same video again, leave
			if (self.isInitialized && self.$gallery.length > 0 && self.$gallery.children('li.active').attr('id') === id) return;

			var index = self.$gallery.children('#' + self.idPrefix + id).index();
			self.triggerNextVideo(index);
		}

	});
})(mrm.$);;(function($) {
	mrm.mod.Mm_video_shared_module_1 = mrm.mod.AbstractMod.extend({

		events: {
			"click ul.gallery > li": "clickOnList",
			"click ul.functions": "clickOnFunction"
		},

		player: null,
		$gallery: $(),
		$items: $(),
		amountOfItems: 0,
		dataAttribute: 'rel',
		trackingFunc: null,
		isInitialized: false,
		initialVideoIndex: 0,
		idPrefix: mrm.util.getRenamedIdPrefix(),
		docTitle: document.title,

		prepare: function() {
			var self = this;
			self.$gallery = self.$ctx.find('ul.gallery');

			// rename item-ids to avoid browser-scrolling on location-change
			self.$gallery.children('li').attr('id', function(i, id) {
				return self.idPrefix + id;
			});

			if (self.$ctx.children('div.stage').hasClass('youtube')) {
				self.player = $('#youtubePlayer')[0];
				self.playVideo = self.playYoutubeVideo;
				self.dataAttribute = 'href';
				self.isInitialized= true;
				self.initGallery();
			} else {
				mrm.util.doInitVideo(self.$ctx);
				var playerId = self.$ctx.find('> .stage > .video').attr('id');
				self.player = jwplayer('jwPlayerTarget_' + playerId);
				self.playVideo = self.playJWflvVideo;
				self.dataAttribute = 'rel';
			}

			// wait for player got embedded
			self.$ctx.on('embed.video', function(event) {
				self.playerReady();
			});
		},

		playerReady: function() {
			var self = this;
			self.isInitialized = true;
			self.playVideo = self.playJWflvVideo;
			self.dataAttribute = 'rel';
			self.initGallery();
		},
		
		initGallery: function() {
			var self = this;
			self.$items	= self.$gallery.children('li');
			self.amountOfItems = self.$items.length;
			self.wipeSupport();
			self.triggerNextVideo(self.initialVideoIndex, true);
		},

		wipeSupport: function() {
			var self = this;
			var player = self.player;
			var $stage = self.$ctx.find('div.stage');
			$stage.touchwipe({
				wipeLeft: function() {
					if(!$stage.hasClass('youtube')) {
						if (player.getState() !== "BUFFERING" && player.getState() !== "PLAYING" ) self.$ctx.find('ul.functions .next').trigger('click');
					}
				},
				wipeRight: function() {
					if(!$stage.hasClass('youtube')) {
						if (player.getState() !== "BUFFERING" && player.getState() !== "PLAYING" ) self.$ctx.find('ul.functions .prev').trigger('click');
					}
				},
				preventDefaultEvents: false
			});
		},

		clickOnList: function(event, triggered){
			var self = this;
			event.preventDefault();

			var $item = $(event.currentTarget);
			var video = $item.find('a:first').attr(self.dataAttribute);
			var $short_desc = $item.find('p.desc').text();
			var $long_desc = $item.find('p.long_desc').text();
			
			self.$gallery.children('li.active').removeClass('active');
			$item.addClass('active');
			if (!triggered) $(location).attr('hash', '#' + $item.attr('id').replace(self.idPrefix, ''));
			self.$ctx.find('.video_desc').text($short_desc);
			self.$ctx.find('.video_long_desc').text($long_desc);
			// enable share2
			/*var $li = self.$ctx.find('ul.functions li.sharing-container');
			var $share2 = $li.find('.modShare_2').eq($item.index());
			if ($share2.length) {
				$li.find('.modShare_2:visible').css('display', 'none');
				$share2.css('display', 'block');
				mrm.util.sharing.enableShare2Autorender($share2);
				$li.trigger('renderShare2');
			}*/


			self.playVideo(video);
		},

		clickOnFunction: function(event) {
			var self = this;
			var $target = $(event.target);
			if ($target.hasClass('prev') || $target.hasClass('next')) {
				event.preventDefault();
				var currentClass = $target.hasClass('prev') ? 'prev' : 'next';
				self.triggerNextVideo(currentClass);
			}
		},

		triggerNextVideo: function(step, triggered) {
			var self = this;
			var index = self.$gallery.children('li.active').index();
			if (step === 'next') {
				index = (index == self.amountOfItems - 1) ? 0 : index + 1;
			} else if (step === 'prev') {
				index = (index === 0) ? self.amountOfItems - 1 : index - 1;
			} else if (typeof(step) === 'number') {
				index = step;
			}
			
			if (self.isInitialized) {
				self.$items.eq(index).find('a:first').trigger('click', triggered);
			} else {
				self.initialVideoIndex = index;
			}
		},

		playJWflvVideo: function(video) {
			var self = this;
			if (typeof self.player !== "undefined") {
                // If the Player was not fully initialized, please reload! Bug occured in Safari 5.0
				if(!self.player.config){
					var playerId = self.$ctx.find('> .stage > .video').attr('id');
					self.player = jwplayer('jwPlayerTarget_' + playerId);
				}
				// autostart:true hack for html5 when going through the playlist (onError evt)
				self.player.load(video).onReady(function(c){
					self.player.stop().play();
				})
				.onPause(function (c) {
					if(mrm.util.ie()){
						var hash = self.$gallery.children("li.active").attr("id").replace(that.idPrefix, "");
						$(document).attr('title', self.docTitle + '#' + hash);
					}
				})
				.onError(function(evt){
					self.onError(null);
					self.play();
				});
			}
		},

		playYoutubeVideo: function(video) {
			var self = this;
			$(self.player).attr('src', video);
		},

		// used by deeplinking.js
		switchToContent: function($content) {
			var self = this;
			var id = $content.attr('id').replace(self.idPrefix, '');
			// if same video again, leave
			if (self.isInitialized && self.$gallery.length > 0 && self.$gallery.children('li.active').attr('id') === id) return;

			var index = self.$gallery.children('#' + self.idPrefix + id).index();
			self.triggerNextVideo(index);
		}

	});
})(mrm.$);(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        mm_visualizer_1: {
            tpl: ["06", "10", "16"],
            modCfg: null,
            ctgLastClicked: null,
            vehicleInfo: {},
            resultDetails: '',
            centerDiff: null,
            mode: 'standard',
            activeModeNoExtPreference: false,
            activeModeNoIntPreference: false,
            vehicleConfig: null,
            disabledChipClsss: 'hide', //can be disabled which shows chips and adds a class
            toggle_top: '',
            saveConfigOnce: true,
            trimOrder: [],
            lazyLoadComplete: false,
            initMod: function($mod) {
                var self = this;
                self.modCfg = mrm.conf.cmp.mm_visualizer_1 || {};
                self.vehicleConfig = mrm.conf.util.vehicleConfig || {};
                if (self.modCfg.scrollerSettings.doInlineMargins){
                    $('.masthead, .mod.modMh_1 ').css('max-width', '1480px'); // needs to be chevy specific
                }

                self.setupTrimOrder($mod);
                self.mode = $mod.hasClass('mode_configure') ? 'config' : self.mode;
                self.mode = $mod.hasClass('mode_active') ? 'active' : self.mode;

                var configTitle = $('.list_wrap.bodyStyles li a');
                // handle fluid display image sizes
                var cgiData = $mod.find('.scroll_template_holder').data();
                if (cgiData.cgiType == "fluid"){
                    if (cgiData.cgiSmallestSize != cgiData.cgiLargestSize && screen.width > cgiData.cgiMinimumWidth){
                        $mod.find('.viz_scroller li img').each(function(i, el){
							var $el = $(el), src = $(el).attr('src');
                            src = src.replace(cgiData.cgiSmallestSize, cgiData.cgiLargestSize);
                            $el.attr('src', src);
							// in case of lazy loading
							if($el.is('img[data-orig-src]')){
								src = $el.data('orig-src');
								src = src.replace(cgiData.cgiSmallestSize, cgiData.cgiLargestSize);
								$el.data('orig-src', src);
							}
                        })
                    }
                }

                $.each(configTitle, function (){
                    $(this).data('title', $(this).attr('title'));
                });

                if (self.vehicleConfig.enabled){
                    // instead of loading up on our mod load, wait for the vehicle_config even to be called
                    $.eventDispatcher.on('vehicle_config_load', function(e){
                        if (self.mode == 'config') mrm.util.vehicleConfig.setConfigured();
                        else if (self.mode == 'active') {
                            self.activeModeNoExtPreference = true;
                            self.activeModeNoIntPreference = true;
                        }
                        // only do this once
                        self.runInitFunctions($mod)
                    });
                } else {
                    self.runInitFunctions($mod);
                }
                // run convertible top toggle to determine if it should be shown or hidden
                if ($mod.find('.topToggleBtn').length && ($mod.find('.topToggleBtn').hasClass('onlyInt') || $mod.find('.topToggleBtn').hasClass('onlyExt')) ){
                    self.triggerTopToggleHide($mod);
                }

				// only Canada has dynamic prices by region
				if (mrm.util.locale.getCountry().toLowerCase()==="ca") {
					var callPath = "/apps/servlets/bbcdataseries.json?segment=true&priceOnly&year="+$('meta[name="year"]').attr('content')+"&carline="+$('meta[name="carline"]').attr('content')+"&bodystyle="+$('meta[name="bodystyle"]').attr('content')+"&path="+$('meta[name="contentpath"]').attr('content');
					$.ajax({
						url: callPath,
						dataType: 'json',
						async: false,
						success: function(data) {
							$("div.trims.mmScroll div ul.itemScroll").data("Regions", data[$('meta[name="year"]').attr('content')+"_"+$('meta[name="carline"]').attr('content')+"_"+$('meta[name="bodystyle"]').attr('content')]);
							$("div.trims.mmScroll div ul.itemScroll").addClass("caData").addClass("dynPriceEh");
						}
					});
					//$.getJSON( "/apps/servlets/bbcdataseries.json?segment=true&priceOnly&year="+$('meta[name="year"]').attr('content')+"&carline="+$('meta[name="carline"]').attr('content')+"&bodystyle="+$('meta[name="bodystyle"]').attr('content')+"&path="+$('meta[name="contentpath"]').attr('content'), function(data) {
					//	$("div.trims.mmScroll div ul.itemScroll").data("Regions", data[$('meta[name="year"]').attr('content')+"_"+$('meta[name="carline"]').attr('content')+"_"+$('meta[name="bodystyle"]').attr('content')]);
					//	$("div.trims.mmScroll div ul.itemScroll").addClass("caData").addClass("dynPriceEh");
					//});
				}
            },
            runInitFunctions: function($mod) {
                var self = this;
                self.setupLazyloading($mod);
                self.setDefaultVehicle($mod);
                self.setBYOlink($mod);
                self.validateSwatches($mod);
                self.setupTrims($mod);
                self.setupMMC($mod);
                self.updateVehicleCaption($mod);
                self.setupToggleButtons($mod);
                self.clearResults($mod);
                self.setActiveItems($mod);
                self.setListeners($mod);
                //load scrollers after images load
                self.handleDefaultView($mod);
            },
            // track initial trim order
            setupTrimOrder: function($mod) {
                var self = this;
                $mod.find(".trims li").each(function(k,v) {
                    self.trimOrder.push($(v).data("peg"));
                });
                self.trimOrder = _.uniq(self.trimOrder);
            },
            arrayEq : function(a, b) {
                return _.all(_.zip(a, b), function(x) {
                    return x[0] === x[1];
                });
            },
            // Prevents trims from appearing out of order
            sortTrims: function($mod) {
                var self = this;
                var aryTrims = [];
                $mod.find(".trims li:visible").each(function(k,v) {
                    aryTrims.push($(v).data("peg"));
                });
                aryTrims = _.uniq(aryTrims);
                var i = 0;
                // moves last visible trim to beginning of list until order matches initial order
                // this will iterate a maximum of 10 times to prevent infinite looping if no match found
                while (!self.arrayEq(aryTrims,self.trimOrder) && i < 10) {
                    aryTrims = [];
                    var firstLI = $mod.find(".trims li:visible:last");
                    firstLI.parent().prepend(firstLI);
                    $mod.find(".trims li:visible").each(function(k,v) {
                        aryTrims.push($(v).data("peg"));
                    });
                    aryTrims = _.uniq(aryTrims);
                    i++;
                }
            },
            activateZoom: function($mod){
                // pull values from scoll template
                var zoomString = $mod.find('.scroll_template_holder').attr('data-cgi-zoom-size');
                if (zoomString) {
                    $mod.find('.viz_scroller').addClass('zoom');

                    if ($('html').hasClass('no-touch')){
                        // set up zoom for Browser w/ Mouse
                        $mod.find('.viz_scroller img.mm').click( function(e){
                            zoomIn($mod);
                        });
                    } else {
                        // set up zoom for Tablet Devices w/ Touch
                        $mod.find('.clickToZoom').addClass('zoomActive');
                        setupZoomButton($mod);
                    }
                }

                function setupZoomButton($mod){
                    // logic to keep zoom Button Centered above image pagination
                    $mod.find('.clickToZoom a').on('touchend', function(e){
                        e.preventDefault();
                        zoomIn($mod);
                    });
                }

                function zoomIn($mod){
                    // start byo_load animation
                    mrm.$.eventDispatcher.trigger('byo_load', {load: 'start'});

					// additional event for tracking
                    $(this).trigger('onZoomClick');


                    var $this = $mod.find('.viz_scroller.zoom.activeView .ui-helper-visible img.mm');

                    // zoomArea div html
                    var zoomHTML = '<div class="zoomArea"><img class="zoomImg" src=""/><div class="zoomClose"></div></div>';
                    $this.parent().append(zoomHTML);

                    // takes src from selected image and gives it to the zoomIn
                    var $src = $this.attr('src');

                    // make sure scroll template available
                    if (!$mod.find('.scroll_template_holder').length){ return; }

                    // pull values from scoll template
                    //var zoomString = $mod.find('.scroll_template_holder').attr('data-cgi-zoom-size');
                    //if (zoomString){ return; }

                    var zoomSize = zoomString.split('|')[0];
                    var zoomDim = zoomString.split('|')[1];
                    var zoomWidth = zoomDim.split("x")[0];
                    var zoomHeight = zoomDim.split("x")[1];

                    // set default zoomSize if none are provided
                    if (!zoomSize){
                        zoomSize = 'gmds9';
                        zoomWidth = '1920';
                        zoomHeight = '714';
                    }

                    // logic to update URL with zoom image
                    $src = $src.replace(/gmds.\./, zoomSize + '.');
                    $this.parent().find('.zoomArea .zoomImg').attr('src', $src);

                    // gets mod / header dimensions
                    var modWidth = $mod.width();
                    var modHeight = $mod.height();
                    var headerHeight = $('#mds-area-header').height();

                    // calculates margins
                    var margLeft = (modWidth - zoomWidth) / 2;
                    var margTop = (modHeight - zoomHeight - headerHeight) / 2;

                    // sets margin
                    $this.parent().find('.zoomArea .zoomImg').css('margin-left', margLeft).css('margin-top', margTop);

                    // when image fails to load, fall back
                    $this.parent().find('.zoomArea .zoomImg').error( function (){
                        mrm.$.eventDispatcher.trigger('byo_load', {load: 'stop'});
                    });

                    // when image finishes loading, launch modal
                    $this.parent().find('.zoomArea .zoomImg').load( function (){
                        // initiates transition to display ZoomArea
                        mrm.$.eventDispatcher.trigger('byo_load', {load: 'stop'});

                        $(this).parent().fadeIn('fast');

                        var modLeft = $mod.find('.activeView .cgiScroller').css('left').replace('px','');
                        if (modLeft < 0){
                            $mod.find('.zoomClose').css('right', modLeft * -1);
                        }

                        // Make Pagination Not Visible
                        $mod.find('.mmScrollBtn:not(".hidden")').hide();
                        $mod.find('.mmScrollPaginationWrp').hide();
                        $mod.find('.clickToZoom.zoomActive').hide();

                        // sets up zoomImage to move with mouse movement
                        $this.parent().find('.zoomArea').on('touchmove mousemove', function (e){
                            e.stopPropagation();
                            e.preventDefault();

                            var imgX, imgY;
                            if (e.type == 'mousemove' && $('html.no-touch').length > 0){
                                var mouseX = e.clientX;
                                var mouseY = e.clientY - headerHeight;
                                imgX = (mouseX / modWidth) * (modWidth - zoomWidth);
                                imgY = (mouseY / modHeight) * (modHeight - zoomHeight - headerHeight);
                            } else {
                                var touchX = e.originalEvent.changedTouches[0].clientX;
                                var touchY = e.originalEvent.changedTouches[0].clientY;

                                imgX = (touchX / modWidth) * (modWidth - zoomWidth);
                                imgY = (touchY / modHeight) * (modHeight - zoomHeight - headerHeight);

                                imgX = (modWidth - zoomWidth) - imgX;
                                imgY = (modHeight - zoomHeight - headerHeight) - imgY;
                            }
                            $(this).find('.zoomImg').css('margin-left', imgX).css('margin-top', imgY);
                        });

                        bodyCloseListener();

                        // function for closing the zoomArea. first click / touchend on body after zoom is initiated will close zoomArea.
                        function bodyCloseListener(){
                            $('body').one('click touchend', function (e){

                                if ($('html').hasClass('touch')){
                                    var target = $(e.target);

                                    if (target.hasClass('zoomImg')){

                                        bodyCloseListener();
                                        return;
                                    }
                                }

								// added event for tracking
								$(this).trigger('onZoomClose');

                                // transition to remove zoomArea
                                $this.parent().find('.zoomArea').fadeOut('fast', function(){
                                    $(this).remove();
                                });

                                // Make Pagination Visible // Added Timeout to avoid click event hitting next btn mmScrollBtn
                                e.preventDefault();
                                $mod.find('.mmScrollBtn:not(".hidden")').show();
                                $mod.find('.mmScrollPaginationWrp').show();
                                $mod.find('.clickToZoom.zoomActive').show();
                            });
                        }
                    });
                }
            },
            handleDefaultAngle: function($mod){
                var rpo = mrm.util.vehicleConfig.getSelectedRpo();
                if (rpo == null){ return;}
                var view = mrm.util.vehicleConfig.getView();

                // logic to change view on load when needed
            },
            setDefaultVehicle: function($mod){
                var self = this;
                var defaultVehicle = $mod.find('.scroll_template_holder').data('default');

                self.vehicleInfo["current-mmc"] = defaultVehicle.mmc;
                self.vehicleInfo["current-peg"] = defaultVehicle.peg;
                self.vehicleInfo["current-intColor"] = defaultVehicle.intColor;
                self.vehicleInfo["current-extColor"] = defaultVehicle.extColor;
                self.vehicleInfo["current-wheel"] = defaultVehicle.wheel;
                self.vehicleInfo["current-cabStyle"] =  defaultVehicle.cabType;
                self.vehicleInfo["current-boxStyle"] =  defaultVehicle.boxType;
                self.vehicleInfo["current-options"] = [];

                self.vehicleInfo["change-mmc"] = defaultVehicle.mmc;
                self.vehicleInfo["change-peg"] = defaultVehicle.peg;
                self.vehicleInfo["change-intColor"] = defaultVehicle.intColor;
                self.vehicleInfo["change-extColor"] = defaultVehicle.extColor;
                self.vehicleInfo["change-wheel"] = defaultVehicle.wheel;
                self.vehicleInfo["change-cabStyle"] =  defaultVehicle.cabType;
                self.vehicleInfo["change-boxStyle"] =  defaultVehicle.boxType;
                self.vehicleInfo["change-options"] = [];
                self.vehicleInfo["changeType"] = "";

                self.vehicleInfo["prev-mmc"] = "";
                self.vehicleInfo["prev-peg"] = "";
                self.vehicleInfo["prev-intColor"] = "";
                self.vehicleInfo["prev-extColor"] = "";
                self.vehicleInfo["prev-wheel"] = "";
                self.vehicleInfo["prev-cabStyle"] = "";
                self.vehicleInfo["prev-boxStyle"] = "";
                self.vehicleInfo["prev-options"] = [];
            },
            setBYOlink: function($mod){
                var self = this;
                var link = $mod.find('.shppngLnk');
                var linkHref = link.attr('href');
                if (link.length > 0) {
                    if (linkHref.indexOf('?x-series=') > -1) {
                        var split = linkHref.split('?');
                        linkHref = split[0];
                    }
                    linkHref += '?x-series=' + self.vehicleInfo['current-mmc'] + '_' +self.vehicleInfo['current-peg'];
                    link.attr('href', linkHref ); //set the link
                    link.attr('onclick', "if(typeof(Omniture_s) != 'undefined'){mrm.util.tagging.omniture_tl(this, this.href, 'o', undefined, {'prop27':'contentarea','pageName':'ch:no:US:en:index:chevy-performance:2014-corvette-coupe:model-overview','prop32':'contentarea:Build & Price'});}return validateCookie(this,'"+ linkHref+ "', 'byo16', true);");
                }
            },
            handleDefaultView: function($mod) {
                var self = this;
                switch(self.mode){
                case 'config':
                    // listens for object from BYO to update the display
                    break;
                default:
                    if (mrm.util.vehicleConfig.isConfigured() && mrm.util.vehicleConfig.hasAllConfigurationValues()){
                        // once the visualizer is fully enabled, draw the configured vechile
                        $.eventDispatcher.on('visualizer_initialized', function(e){
                                self.redrawConfiguredVehicle($mod);
                        });
                    } else {
                        $.eventDispatcher.on('visualizer_initialized', function(e){
                            self.drawPreferredVehicle($mod);
                            if(self.mode == "active"){
                                self.updateAvailableSwatches($mod);
                            }
                        });
                    }
                }
            },
            validateSwatches: function($mod) {
                // make sure all displayed options have JSON data to prevent errors
                var self = this;

                // get array of all rpo codes in JSON
                var aryJSON = _.union(mmcPegData,vehicleExtData,vehicleIntData,vehicleWheData);
                var aryRPOs = [];
                $.each(aryJSON, function(i,curRPO){
                    var subarray = curRPO.split("_");
                    $.each(subarray,function(i,curRPO_split){
                        aryRPOs.push(curRPO_split);
                    });
                });

                // need to add the no preference color chip (exterior & interior) when in active mode
                if (self.mode == 'active'){
                    aryRPOs.push('noExtPrefs');
                    aryRPOs.push('noIntPrefs');
                }

                aryRPOs = _.uniq(aryRPOs);

                // validate each rpo against JSON
                $mod.find(".list_wrap").each(function(k,curCategory){
                    $(curCategory).find("ul.itemScroll li a[data-category]").each(function(k,curAnchor){
                        var rpo = $(curAnchor).data("id")+"";
                        var subarray = rpo.split("_");
                        $.each(subarray,function(i,curRPO){
                            if (aryRPOs.indexOf(curRPO) === -1) {
                                // rpo missing from JSON data - remove
                                $("#" + curRPO).parent("li").remove();
                            }
                        });
                    });
                });

                // add alt text to swatches - Nathan 4-13-2015
                $mod.find(".list_wrap").each(function(k, curCategory) {
                    $(curCategory).find("ul.itemScroll li a[data-category]").each(function(k,curAnchor) {
                        var colorTitle = $(curAnchor).attr("title");
                        $(curAnchor).find("img").attr("alt", colorTitle);
                    })
                });
            },
            updateAvailableSwatches: function($mod){
                var self = this;
                if (typeof(visualizerColorList) != 'undefined'){
                    var list = visualizerColorList;
                    // add noExtPrefs and noIntPregs to lists;
                    list.exteriorColorCodes.push('noExtPrefs');
                    list.interiorColorCodes.push('noIntPrefs');
                    self.disableColorList(list.exteriorColorCodes, 'colors', self.disabledChipClsss);
                    self.disableColorList(list.interiorColorCodes, 'interiors', self.disabledChipClsss);
                }
            },
            // on init and swatch click, reset list of visible bodystyle to current trim choice
            setupMMC: function($mod){
                if ($mod.find('div.scroll_template_holder').hasClass('hasMmc')) {
                    var self = this;
                    var aryPeg = [];
                    var aryMMC = [];
                    var aryTitle = [];
                    var finalMap = {};

                    var currentTitle = $('#' + self.vehicleInfo['current-mmc']).parent('li').attr('config-code');
                    var currentMMC = self.vehicleInfo['current-mmc'];
                    var currentPEG = self.vehicleInfo['current-peg'];
                    // sets up new arrays
                    $.each($('.list_wrap.bodyStyles li'), function(){ // includes 'grouping' <li>
                        var title = $(this).attr('config-code');
                        var peg = $(this).data('peg');
                        var mmc = $(this).data('mmc');
                        aryTitle.push(title);
                        aryMMC.push(mmc);
                        aryPeg.push(peg);
                    });
                    var merge = _.zip(aryTitle, aryMMC, aryPeg);
                    aryTitle = _.uniq(aryTitle);
                    $.each(aryTitle, function (k ,v){
                        if ( v != undefined || v != '' || v != null || v != 'null'){
                            finalMap[v + '-mmc'] = '';
                            finalMap[v + '-peg'] = '';
                        }
                    });
                    $mod.find('.list_wrap.bodyStyles li').hide();
                    $mod.find('.list_wrap.bodyStyles li.grouping').show();

                    //set current bodystyle
                    finalMap[currentTitle+ '-mmc'] = currentMMC;
                    finalMap[currentTitle + '-peg'] = currentPEG;

                    //figure out other stuff
                    $.each(aryTitle, function (k,v){
                        if ( v != undefined || v != '' || v != null || v != 'null'){
                            if (finalMap[v+"-mmc"] == '' && finalMap[v+"-peg"] == ''){
                                $.each(merge, function (key,val){
                                    if (v==val[0] && currentPEG == val[2]){
                                        finalMap[v + '-mmc'] = val[1];
                                        finalMap[v + '-peg'] = val[2];
                                    }
                                });
                            }
                        }
                    });

                    //doesn't exist as a default option
                    $.each(aryTitle, function (k,v){
                        if ( v != undefined || v != '' || v != null || v != 'null'){
                            if (finalMap[v+"-mmc"] == '' && finalMap[v+"-peg"] == ''){
                                $.each(merge, function (key,val){
                                    if (v==val[0]){
                                        finalMap[v+ '-mmc'] = val[1];
                                        finalMap[v + '-peg'] = val[2];
                                    }
                                });
                            }
                        }
                    });

                    //loop through the map and enable li
                    $.each(aryTitle, function (k,v){
                        if ( v != undefined || v != '' || v != null || v != 'null'){
                            if (finalMap[v +"-mmc"] !== '' && finalMap[v +"-peg"] != undefined) {
                                $mod.find(".bodyStyles li[data-peg='" + finalMap[v+"-peg"] + "'] a[data-id='" + finalMap[v+"-mmc"] + "']").parent("li").show();
                            }
                        }
                    });
                }
            },
            // on init and swatch click, reset list of visible trims to current MMC choice
            setupTrims: function($mod){
                var self = this;
                if ($mod.find('div.scroll_template_holder').hasClass('hasMmc')) {
                    var configdata = [];
                    var box = self.vehicleInfo['current-boxStyle'];
                    var cab = self.vehicleInfo['current-cabStyle'];
                    $.each(mmcPegConfigData, function (k, v){
                        configdata.push(v.split("|"));
                    });
                    // build array of all unique trims
                    var aryTrims = [];
                    $.each(mmcPegData, function (k,v){
                        aryTrims.push(v.split('_').pop());
                    });
                    aryTrims = _.uniq(aryTrims);

                    // hide all trims
                    $mod.find('.list_wrap.trims li').hide();
                    $.each(aryTrims, function (mmcIndex,curTrim){
                        if (mmcPegData.indexOf(self.vehicleInfo["current-mmc"]+"_"+curTrim) > -1) {
                            // trim found for current MMC - make visible
                            //$('#' + self.vehicleInfo["current-mmc"] + "_" + curTrim).parent('li').show();
                            $mod.find("a[data-id='" + self.vehicleInfo["current-mmc"] + "_" + curTrim + "']").parent('li').show();
                        } else{
                            // trim does not exist for current MMC - find first MMC that supports this trim
                            $.each(mmcPegData, function (eachIndex, mmcPeg) {
                                if (mmcPeg.indexOf('_'+curTrim) > -1) {
                                    var curMMC = mmcPeg.split("_");
                                    $.each(configdata, function (k,v){ // compare the mmc/peg to selected bodystyle to preserve
                                        if (v[2].indexOf(mmcPeg) > -1 && v[0] == cab && v[1] == box){
                                            //$('#' + curMMC[0] + "_" + curTrim).parent('li').show();
                                            $mod.find("a[data-id='" + curMMC[0] + "_" + curTrim + "']").parent('li').show();
                                            return false;
                                        }
                                    });
                                }
                            });
                        }
                    });

                    // make sure all trims are showing for current conv/coupe if configured
                    var curConfigCode = $mod.find(".bodyStyles li[data-mmc='" + self.vehicleInfo["current-mmc"] + "']").attr("config-code");
                    $.each( $mod.find(".trims li > a").not(":visible") , function (mmcIndex,curTrimSwatch){
                        var trimTitle, configCode, peg;
                        trimTitle = $(curTrimSwatch).html();
                        configCode = $(curTrimSwatch).attr("config-code"); //conv, coupe
                        peg = $(curTrimSwatch).parent("li").data("peg");

                        if (configCode === curConfigCode) {
                            if ( $mod.find(".trims li[data-peg='" + peg + "'] a[config-code='" + configCode + "']:visible:contains('" + configCode + "')").length === 0 ) {
                                $(curTrimSwatch).parent("li").show();
                            }
                        }
                    });


                    self.sortTrims($mod);
                }
            },
            updateVehicleCaption: function($mod) {
                var self = this;
                //selected trim to populate
                var trimTitle = $mod.find('.visualizer-masthead-caption span.trimTitle');
                var defaultDrive = $mod.find('.scroll_template_holder').data('defaultdrive');
                var dataTitle = ($('#' +self.vehicleInfo['current-mmc']).data('title') !== undefined) ? $('#' +self.vehicleInfo['current-mmc']).data('title') : '';
                var newTrimTitle = $('#' +self.vehicleInfo['current-mmc'] + '_' + self.vehicleInfo['current-peg']).text() + ' ' + dataTitle +' (' + defaultDrive +') ';

                // remove line breaks
                var pattern = new RegExp(/(\r\n|\n|\r)/gm);
                while (pattern.test(newTrimTitle)) {
                    newTrimTitle = newTrimTitle.replace(pattern,"");
                }
                // remove double spaces
                while (newTrimTitle.indexOf("  ") > -1) {
                    newTrimTitle = newTrimTitle.replace("  "," ");
                }
                // fix "double terms"
                newTrimTitle = newTrimTitle.replace("Hatch Hatchback","Hatchback ")
                    .replace("Conv Convertible","Convertible ")
                    .replace("Sedan Sedan","Sedan ")
                    .replace("Coupe Coupe","Coupe ");

                trimTitle.html(newTrimTitle);

                // selected items to add to formated price
                var trim_price = parseFloat($('#' + self.vehicleInfo['current-mmc'] +'_'+ self.vehicleInfo['current-peg']).data('cost'));
                if (trim_price > 0 && trim_price !== undefined){
                    var extColor_price = ($("#" + self.vehicleInfo["current-extColor"]).length) ? parseFloat($("#" + self.vehicleInfo["current-extColor"]).data('cost')) : 0;
                    var intColor_price = ($("#" + self.vehicleInfo["current-intColor"]).length) ? parseFloat($("#" + self.vehicleInfo["current-intColor"]).data('cost')) : 0;
                    var wheel_price = ($("#" + self.vehicleInfo["current-wheel"]).length) ? parseFloat($("#" + self.vehicleInfo["current-wheel"]).data('cost')) : 0;
                    var total_price = trim_price + extColor_price + intColor_price + wheel_price;
                    total_price = self.formatPrice($mod, total_price);
                    $mod.find('.visualizer-masthead-caption span.price').html(total_price);
                    $mod.find('.visualizer-masthead-caption span.price').show();
                } else {
                    $mod.find('.visualizer-masthead-caption span.asShown').hide();
                }
            },
            setupToggleButtons: function($mod){
                var $buttons = $mod.find('.toggle_holder');
                if ($buttons.children().length < 2 && $buttons.find('.topToggleBtn').length){
                    $buttons.find('.topToggleBtn').addClass('noIntToggle');
                }
                if ($buttons.children('.int_ext_toggle').hasClass('align-with-placeholder')){
                    //replicate the toggle into all of the placeholders
                    $buttons.clone().appendTo('.viz_scroller .placeholder_c1');
                    $buttons.hide();
                }
                else {
                    $buttons.removeClass('align-with-placeholder').removeAttr('style'); // fixing inline style and un-used class
                }
            },
            toggleTop: function($mod, item){
                var self = this;
                if (item.hasClass('btnToggle')){
                    item.children().toggleClass('activeToggle');
                } else {
                    item.children().toggleClass('active');
                }
                //set global var after masthead scroller creation to img src
                self.toggle_top = (self.toggle_top !== '') ? self.toggle_top : $mod.find(".mmScroll .caroufredsel_wrapper ul li img.mm").first().attr('src');
                var img_src = self.toggle_top;

                if (self.toggle_top.indexOf('&removeCat=CONV') > -1 ){
                    self.toggle_top = img_src.replace('&removeCat=CONV', '');
                    $.each($mod.find(".mmScroll .caroufredsel_wrapper ul li img.mm"), function() {
                        var src = $(this).attr('src').replace('&removeCat=CONV', '');
                        $(this).attr('src',src);
                    });
                } else {
                    self.toggle_top = img_src + '&removeCat=CONV';
                    $.each($mod.find(".mmScroll .caroufredsel_wrapper ul li img.mm"), function() {
                        var src = $(this).attr('src') + '&removeCat=CONV';
                        $(this).attr('src', src);
                    });
                }
            },
            setListeners: function($mod){
                var self = this, isFirstEvent = true;
                if (self.mode == 'config'){
                    $.eventDispatcher.on('vehicle_config_change', function(e){
                        if (!isFirstEvent){
                            self.redrawConfiguredVehicle($mod);
                        }
                        isFirstEvent = false;
                    });

                    // listener for ext/int view toggle from BYO
                    $.eventDispatcher.on('ext_int_view_change', function(e, obj){
                        var toggleButton = $mod.find('.int_ext_toggle');
                        if ( ($('.viz_scroller.exterior').hasClass('activeView') && obj.view == 'interior' ) || ($('.viz_scroller.interior').hasClass('activeView') && obj.view == 'exterior')   ){
                            self.toggleViews($mod, toggleButton);
                        }
                    });

                    // store angle / view in local storage after every image change
                    $.eventDispatcher.on('mh_scroller_image_change', function(){
                        self.setViewAngle($mod);
                    });

					var listener = $.eventDispatcher.on('lazyload_complete', function() {
						self.redrawConfiguredVehicle($mod);
						$.eventDispatcher.off(listener);
					});

                } else if (self.mode == 'active'){
                    $.eventDispatcher.on('visualizer_change_color_list', function(e, obj){
                        // assumes the object is passed, save it to the global variable
                        visualizerColorList.exteriorColorCodes = obj.exteriorColorCodes;
                        visualizerColorList.interiorColorCodes = obj.interiorColorCodes;
                        self.updateAvailableSwatches($mod);
                    });
                }
            },
            setViewAngle: function($mod){
                var view = "ext";
                var degree = '01';

                // checks if view is interior, if not default to ext
                if ($mod.find('.viz_scroller.interior') && $mod.find('.viz_scroller.interior').hasClass('activeView')){
                    view = "int";
                }

                // get image url for parsing
                var imgSrc = $mod.find('.activeView .ui-helper-visible img.mm').attr('src');
                if (!imgSrc){ return;}

                // get the degree from the url
                var parts = imgSrc.split('&');

                for (var part in parts){
                    var value = parts[part];
                    if (value.indexOf('v=deg') != -1){
                        degree = value.replace('v=deg','');
                        break;
                    }
                }

                // set view in local Storage
                mrm.util.vehicleConfig.setView(view, degree);
            },
            redrawConfiguredVehicle: function($mod){
                var self = this;
				if(!self.lazyLoadComplete) {
                	return;
                }
                var config = mrm.util.vehicleConfig;
                self.vehicleInfo["prev-mmc"] = self.vehicleInfo["current-mmc"];
                self.vehicleInfo["prev-peg"] = self.vehicleInfo["current-peg"];
                self.vehicleInfo["prev-intColor"] = self.vehicleInfo["current-intColor"];
                self.vehicleInfo["prev-extColor"] = self.vehicleInfo["current-extColor"];
                self.vehicleInfo["prev-wheel"] = self.vehicleInfo["current-wheel"];
                self.vehicleInfo["prev-options"] = self.vehicleInfo["current-options"];
                self.vehicleInfo["prev-cabStyle"] = self.vehicleInfo["current-cabStyle"];
                self.vehicleInfo["prev-boxStyle"] = self.vehicleInfo["current-boxStyle"];

                self.vehicleInfo["change-mmc"] = config.getConfiguredMmc() ? config.getConfiguredMmc() : self.vehicleInfo["current-mmc"];
                self.vehicleInfo["change-peg"] = config.getConfiguredPeg() ? config.getConfiguredPeg() : self.vehicleInfo["current-peg"];
                self.vehicleInfo["change-intColor"] = config.getConfiguredIntColor() ? config.getConfiguredIntColor() : self.vehicleInfo["current-intColor"];
                self.vehicleInfo["change-extColor"] = config.getConfiguredColor() ? config.getConfiguredColor() : self.vehicleInfo["current-extColor"];
                self.vehicleInfo["change-wheel"] = config.getConfiguredWheel() ? config.getConfiguredWheel() : self.vehicleInfo["current-wheel"];
                self.vehicleInfo["change-options"] = config.getConfiguredOptions() ? config.getConfiguredOptions() : self.vehicleInfo["current-options"];

                //self.vehicleInfo["change-cabStyle"] = config.getConfiguredIntColor() ? config.getConfiguredIntColor() : self.vehicleInfo["current-cabStyle"];
                //self.vehicleInfo["change-boxStyle"] = config.getConfiguredColor() ? config.getConfiguredColor() : self.vehicleInfo["current-boxStyle"];

                // Assume that localStorage Item & or BYO has yielded a valid configuration
                // Because all drive types are not in the mmc_page validation set, we can't currently run validate_data
                //self.vehicleInfo = self.validate_data(self.vehicleInfo);
                self.vehicleInfo["result-mmc"] =      self.vehicleInfo["change-mmc"];
                self.vehicleInfo["result-peg"] =      self.vehicleInfo["change-peg"];
                self.vehicleInfo["result-intColor"] = self.vehicleInfo["change-intColor"];
                self.vehicleInfo["result-extColor"] = self.vehicleInfo["change-extColor"];
                self.vehicleInfo["result-wheel"] =    self.vehicleInfo["change-wheel"];
                self.vehicleInfo["result-options"] =  self.vehicleInfo["change-options"]

                self.vehicleInfo["result-cabStyle"] = self.vehicleInfo["change-cabStyle"];
                self.vehicleInfo["result-boxStyle"] = self.vehicleInfo["change-boxStyle"];

                if (self.mode == 'config'){
                    self.disableColorList(config.getConfiguredColorList(), 'colors', self.disabledChipClsss);
                    self.disableColorList(config.getConfiguredIntColorList(), 'interiors', self.disabledChipClsss);
                } else {
                    // just in case something went wrong, use the default color as the 'configured' color
                    var e = (config.getConfiguredColor() == "") ? self.vehicleInfo["current-extColor"] : config.getConfiguredColor();
                    var i = (config.getConfiguredIntColor() == "") ? self.vehicleInfo["current-intColor"] : config.getConfiguredIntColor();
                    self.disableColorList([e], 'colors', 'hide');
                    self.disableColorList([i], 'interiors', 'hide');
                    //enable the configured message cluetip
                    $('.cluetipRebuild').show();
                }

                self.changeCurrentVehicle($mod);
                self.setupTrims($mod);
                self.updateImages($mod);
                self.updateVehicleCaption($mod);
                self.setActiveItems($mod);
                self.updateAngle($mod);
            },
            drawPreferredVehicle: function($mod){
                //only do this if something in preferred is different from the default
                var self = this;
                var c = mrm.util.vehicleConfig;
                var draw_update = false;
                for (pref in obj = mrm.util.vehicleConfig.getPreferences()){
                    if (obj[pref]) draw_update = true;
                }
                if (draw_update){
                    self.vehicleInfo["prev-mmc"] = self.vehicleInfo["current-mmc"];
                    self.vehicleInfo["prev-peg"] = self.vehicleInfo["current-peg"];
                    self.vehicleInfo["prev-intColor"] = self.vehicleInfo["current-intColor"];
                    self.vehicleInfo["prev-extColor"] = self.vehicleInfo["current-extColor"];
                    self.vehicleInfo["prev-wheel"] = self.vehicleInfo["current-wheel"];
                    self.vehicleInfo["prev-options"] = self.vehicleInfo["current-options"];
                    self.vehicleInfo["prev-cabStyle"] = self.vehicleInfo["current-cabStyle"];
                    self.vehicleInfo["prev-boxStyle"] = self.vehicleInfo["current-boxStyle"];

                    self.vehicleInfo["change-mmc"] = c.getPreferredMmc() ? c.getPreferredMmc() : self.vehicleInfo["current-mmc"];
                    self.vehicleInfo["change-peg"] = c.getPreferredPeg() ? c.getPreferredPeg() : self.vehicleInfo["current-peg"];
                    self.vehicleInfo["change-intColor"] = c.getPreferredIntColor() ? c.getPreferredIntColor() : self.vehicleInfo["current-intColor"];
                    self.vehicleInfo["change-extColor"] = c.getPreferredColor() ? c.getPreferredColor() : self.vehicleInfo["current-extColor"];
                    self.vehicleInfo["change-wheel"] = c.getPreferredWheel() ? c.getPreferredWheel() : self.vehicleInfo["current-wheel"];

                    //self.vehicleInfo["change-cabStyle"] = c.getPreferredIntColor() ? c.getPreferredIntColor() : self.vehicleInfo["current-cabStyle"];
                    //self.vehicleInfo["change-boxStyle"] = c.getPreferredColor() ? c.getPreferredColor() : self.vehicleInfo["current-boxStyle"];

                    self.vehicleInfo["change-options"] = [];

                    self.vehicleInfo = self.validate_data(self.vehicleInfo);

                    self.changeCurrentVehicle($mod);
                    self.setupTrims($mod);
                    self.setupMMC($mod);
                    self.setActiveItems($mod);
                    self.updateImages($mod);
                    self.updateVehicleCaption($mod);
                }
            },
            disableColorList: function(list, list_wrap, class_name){
                var self = this,
                $list_wrap = $('.'+list_wrap),
                $ul = $list_wrap.find('ul');
                $.each($ul.find('li').not('.grouping'), function(i, li){
                    var $li = $(li);
                    var a = $li.find('a');
                    if ($.inArray(a.attr('id'), list) > -1 || $li.hasClass('label')){
                      $li.removeClass(class_name);
                    } else {
                       $li.addClass(class_name);
                    }
                });

                if (self.modCfg.scrollerSettings.itemScrollerAlign == 'right' && class_name == "hide"){
                    // redraw right offset
                    var offset = 0;
                    $.each($ul.find('li'), function(i, li){
                        if (!$(li).hasClass(class_name) && !$(li).hasClass('grouping')) offset += $(li).outerWidth(true);
                    });
                    $ul.css('left', ($list_wrap.width() - offset) + "px");
                }
            },
            formatPrice: function($mod, price){
                var self = this;
                var format_config = $mod.find('.scroll_template_holder').data('currency');
                var prefix = format_config['prefix'];
                var centsSeparator = format_config['cents'];
                var thousandsSeparator = format_config['thousand'];
                var tempstring = "d3v"; // pretty sure thats not a currency.
                if (price.toString().indexOf('.')>-1){
                    price = price.toFixed(2);
                }
                price = price.toString().replace(/\B(?=(\d{3})+(?!\d))/g, tempstring);
                price = price.replace(".", centsSeparator);
                price = price.replace(tempstring,thousandsSeparator)
				if (mrm.util.locale.getLang()==="fr") {
					return price+" "+prefix;
				} else {
					return prefix+price;
				}

            },
            clearResults: function($mod) {
                var self = this;
                self.vehicleInfo["result-mmc"] = '';
                self.vehicleInfo["result-peg"] = '';
                self.vehicleInfo["result-intColor"] = '';
                self.vehicleInfo["result-extColor"] = '';
                self.vehicleInfo["result-cabStyle"] = '';
                self.vehicleInfo["result-boxStyle"] = '';
                self.vehicleInfo["result-wheel"] = "";
                self.vehicleInfo["result-conflict"] = false;
                self.vehicleInfo["result-details"] = [];
            },
            // sets activeItem class on elements matching current selection
            setActiveItems: function($mod) {
                // sets activeItem class on elements matching current selection
                var self = this;
                var $itemCategory = $mod.find(".viz_data_holder .list_wrap li a");
                // because active mode has the ability to have noPrefernce chips set and these don't correspond to an actual CGI asset
                // we need to check for them first before blindly setting the activeItem.
                $itemCategory.removeClass('activeItem');
                var extID = (self.activeModeNoExtPreference) ? "noExtPrefs" : self.vehicleInfo["current-extColor"];
                var intID = (self.activeModeNoIntPreference) ? "noIntPrefs" : self.vehicleInfo["current-intColor"];

                // set active trim
                $mod.find(".trims li a[data-id='" + self.vehicleInfo["current-mmc"] + "_" + self.vehicleInfo["current-peg"] + "']").addClass('activeItem');

                // set active bodystyle
                $mod.find(".bodyStyles li[data-peg='" + self.vehicleInfo["current-peg"] + "'] #" + self.vehicleInfo["current-mmc"]).addClass('activeItem');

                if ($mod.find(".colors li.grouping").length && $mod.find(".colors li a[data-id='" + extID + "'][data-group='" + self.vehicleInfo["current-peg"] + "']").length !== 0) {
                    $mod.find(".colors li a[data-id='" + extID + "'][data-group='" + self.vehicleInfo["current-peg"] + "']").addClass('activeItem');
                } else {
                    $mod.find(".colors li a[data-id='" + extID + "']").addClass('activeItem');
                }

                if ($mod.find(".interiors li.grouping").length && $mod.find(".interiors li a[data-id='" + intID + "'][data-group='" + self.vehicleInfo["current-peg"] + "']").length !== 0) {
                    $mod.find(".interiors li a[data-id='" + intID + "'][data-group='" + self.vehicleInfo["current-peg"] + "']").addClass('activeItem');
                } else {
                    $mod.find(".interiors li a[data-id='" + intID + "']").addClass('activeItem');
                }

                $mod.find(".wheels li a[data-id='" + self.vehicleInfo["current-wheel"] + "']").addClass('activeItem');

                // check if conv/coupe configured?
                var curConfigCode = $mod.find(".bodyStyles li[config-code] a.activeItem").parent("li").attr("config-code");
                if (typeof curConfigCode !== 'undefined') {
                    $mod.find(".trims li a[config-code!='" + curConfigCode + "']").parent("li").hide();
                }

                var aryTrims = [];
                $.each(mmcPegData, function (k,v){
                    aryTrims.push(v.split('_').pop());
                });
                aryTrims = _.uniq(aryTrims);
                // check if there are any trims (1LT, 2LT etc) that are not visible
                $.each(aryTrims, function (mmcIndex,curTrim){
                    if ($mod.find(".trims ul li[data-peg='" + curTrim + "']:visible").length === 0) {
                        // show the first instance of this trim
                        $mod.find(".trims ul li[data-peg='" + curTrim + "']:first").show();
                    }
                });

                //$mod.find(".trims").trigger("destroy");
                self.itemScroller($mod);
                self.triggerTopToggleHide($mod);

                // set vehicle veiw image alt text - Nathan 4-13-2015
                $mod.find('.viz_scroller.exterior ul li img').attr('alt', 'Exterior view for '+$mod.find('a[data-id="'+self.vehicleInfo['current-extColor']+'"]').find('img').attr('alt'));
                $mod.find('.viz_scroller.interior ul li img').attr('alt', 'Interior view for '+$mod.find('a[data-id="'+self.vehicleInfo['current-intColor']+'"]').find('img').attr('alt'));
            },
            updateAngle: function ($mod) {
                var self = this;
                var rpo = mrm.util.vehicleConfig.getSelectedRpo();

                // exit if no RPO available
                if (rpo == null){ return; }

                // make sure viewsByOptionData is on page and authored
                if (typeof(viewsByOptionData) == "undefined"){ return; }

                var rpoData = viewsByOptionData[rpo];

                // exit if no authored data for RPO
                if (rpoData == null){ return; }

                var degree = rpoData.angle;
                var toggleButton = $mod.find('.int_ext_toggle');

                if ( (rpoData.view == "interior" && $('.viz_scroller.exterior').hasClass('activeView')) || (rpoData.view == "exterior" && $('.viz_scroller.interior').hasClass('activeView')) ){
                    self.imageToggleResize($mod, 0, degree);
                    //self.toggleViews($mod, toggleButton);
                } else {
                    // if degree < 10, formats number to single digit. E.g. 04 = 4
                    if (degree[0] == '0'){
                        degree = degree[1];
                    }

                    degree = degree - 1;

                    // if pagination slide at that degree exists, then select that slide
                    if ($(".activeView .mmScrollPagination li a")[degree]){
                        $(".activeView .mmScrollPagination li a")[degree].click();
                    }

                    var new_config = mrm.util.vehicleConfig.getConfiguration();
                    new_config.selectedRpo = null;
                    mrm.util.vehicleConfig.setConfiguration(new_config);
                }
            },

            // setup lazyloading or "selective loading" if configured
			setupLazyloading: function($mod) {
				var self = this,
					imageCount = $mod.find('img[data-' + mrm.ui.image_loader.src_attribute + '].onload').length;

				if (imageCount > 0) {
						var listener = $.eventDispatcher.on('image_loaded', function() {
						if ($mod.find('img.' + mrm.ui.image_loader.loaded_class).length >= imageCount) {
							self.completeLoad($mod);
							// remove listener
								$.eventDispatcher.off(listener);
						}
					});
				}
				else {
					self.completeLoad($mod);
				}
			},
			completeLoad: function($mod) {
				var self = this;
				self.initImages($mod, 0);
				self.handleDefaultAngle($mod);
				self.activateZoom($mod);
                self.fixImageHeights($mod);

				// fixes intermittent bug causing vehicle config to be out of sync with byo carousel images
                self.lazyLoadComplete = true;
                $.eventDispatcher.trigger('lazyload_complete');
			},
            fixImageHeights: function($mod) {
                var self = this;
                // this fixes intermittant bug primarily in chrome
                // when carousel is created before all images are loaded
                // and carousel height is 1px. fix is to update carousel
                // height after loading is complete.
                var height;
                $mod.find(".viz_data_holder .list_wrap").each(function(k,v){
                    height = $(v).find("ul a img:visible").outerHeight(true); //make sure height is found on a visible image
                    if (!isNaN(parseInt(height))) {
						var borderTop = $(v).find("ul a").css("borderTopWidth"),
                            borderBottom = $(v).find("ul a").css("borderBottomWidth"),
                            borders = parseInt(borderTop) + parseInt(borderBottom);
                        height = height + borders;
                        $(v).find(".caroufredsel_wrapper").css("height", height + "px");
                        $(v).find(".caroufredsel_wrapper ul").css("height", height + "px");

						//fix right margin issue for bodystyles (when present)
                        if($(v).hasClass("bodyStyles")) {
                            var trayLi = $(v).find("ul li"),
                                trayLiNum = trayLi.length;

                            //reset right margin to 0 on last list item, to overwrite incorrect value when scroller doesn't load right
                            trayLi.each(function(index, elem) {
                                if (index === trayLiNum-1) { //last list item
                                    //check if visible or hidden
                                    if($(elem).is(':visible')) {
                                        $(elem).css('margin-right', '0px');
                                    } else {
                                        //if hidden, move backwards to find nearest sibling that is visible
                                        $(elem).prevUntil(':visible').prev().css('margin-right', '0px');
                                    }
                                }
                            });
                        }
                    }
                });
            },
            // make sure all visualizer images are loaded before initializing carousels
            initImages: function($mod, count) {
                var self = this;
                count++; // for fallback on the complete if broken images exist.

                var allImagesLoaded = true; // default to true, set to false if any are still loading
                var $images = $mod.find("img");
                $images.each(function(){
                    if (!this.complete) {
                        allImagesLoaded = false;
                    }
                });
                if (allImagesLoaded || count >= 20) {
                    self.imagesLoaded($mod);
                }
                else {
                    // wait 1 second then callback for images if not loaded
                    window.setTimeout(function(){ self.initImages($mod, count) }, 500);
                }
            },
            imagesLoaded: function($mod) {
                var self = this;
                self.scrollSettings($mod);
                self.setDataBindings($mod);
                $.eventDispatcher.trigger('visualizer_initialized');
            },
            scrollSettings: function($mod) {
                var self = this;
                var mastheadImg = $mod.find('.viz_scroller img');
                var itemList = $mod.find('.cgiScroller').addClass('mmScroll');
                var scrollOptions = {
                    onCreate: function() {
                        setTimeout(function() {
                        $('.modMm_visualizer_1 .viz_scroller').addClass('jsReady');
                        }, 1000);
                    }
                };
                scrollOptions = $.extend(true, scrollOptions, self.modCfg.scrollerSettings || {});

                //enable each scroller on it's own to preserve the scroll Swipe settings GMDSST-49022
                //itemList.mmScroll(scrollOptions);
                $.each(itemList, function(i, el){
                    $(el).mmScroll(scrollOptions);
                });

                // temp JS for stretching carosel because of non ready assets
                //$('.scroll_template_holder .caroufredsel_wrapper').css('width', '1480px');
                // $('.scroll_template_holder .caroufredsel_wrapper').css('height', '551px');
                if (typeof(self.canvasTransition) !== 'undefined') {
                    self.canvasTransition.initMod(itemList);
                }
            },
            setDataBindings: function($mod) {
                var self = this;
                var viz_items = $mod.find('.mm_visualizer_item_1'),
                    $scrollContainer = $mod.find('.viz_scroller.cgiScroll'),
                    item_container = $mod.find('div.viz_data_holder');
                //start of active item categories
                viz_items.first().addClass('active');
                var dataItem = viz_items.first().data('item');

                $('.list_wrap[data-list="'+dataItem+'"]').addClass('activeList');
                viz_items.on('click', function() {
                    var $this = $(this);
                    self.vizItemChange($mod, $this, true); // click of the item show/hide correct list of items
                });
                if ($mod.find('.viz_scroller').hasClass('interior')) {
                    var toggleButton = $mod.find('.int_ext_toggle');
                    toggleButton.on('click', function() {
                        self.toggleViews($mod, $(this));
                    });
                }
                // top up/down toggle
                if ($mod.find('.topToggleBtn').length){
                    var toggleButton = $mod.find('.topToggleBtn');
                    toggleButton.on('click', function(){
                        self.toggleTop($mod, $(this));
                    });
                }
                //trigger click items function
                var item_list = $mod.find('.viz_data_holder .list_wrap li a');

                var touchOrClick = (mrm.util.touchDevice()) ? 'touchend' : 'click';

                item_list.on(touchOrClick, function(e) {
                    e.preventDefault();
                    if (!$(this).hasClass('details')) { // don't include details tooltip
                        var itemId = $(this).data('id');
                        self.ctgLastClicked = $(this).data('category');

                        //only allow clicks for active items
                        if (!$(this).parent().hasClass('disabled')){
                            if (self.mode == 'config'){
                                $.eventDispatcher.trigger('visualizer_color_change', {type: self.ctgLastClicked, rpo: itemId});
                                //save the current color into prev
                                self.vehicleInfo["prev-mmc"] = self.vehicleInfo["current-mmc"];
                                self.vehicleInfo["prev-peg"] = self.vehicleInfo["current-peg"];
                                self.vehicleInfo["prev-intColor"] = self.vehicleInfo["current-intColor"];
                                self.vehicleInfo["prev-extColor"] = self.vehicleInfo["current-extColor"];
                                self.vehicleInfo["prev-wheel"] = self.vehicleInfo["current-wheel"];

                                self.vehicleInfo["prev-cabStyle"] = self.vehicleInfo["current-cabStyle"];
                                self.vehicleInfo["prev-boxStyle"] = self.vehicleInfo["current-boxStyle"];
                            } else {
                                if (self.mode == 'active'){
                                    //BTL needs both interior and exterior passed each time, regardless of what was changed
                                    var e = "noExtPrefs";
                                    var i = "noIntPrefs";
                                    if (self.ctgLastClicked == "extColor"){
                                        e = itemId;
                                        i = $mod.find('.interiors .activeItem').data('id');
                                        // if a user selects no preference, don't update the display, just set the chips
                                        if (itemId == "noExtPrefs"){
                                            $mod.find('.colors li a').removeClass('activeItem');
                                            $mod.find('#noExtPrefs').addClass('activeItem');
                                        } else {
                                            self.activeModeNoExtPreference = false;
                                        }
                                        // updateActiveItems looks at the current vehicle values. Since noIntPrefs isn't an option, we have to explicity
                                        // tell the function not to update that item
                                        self.activeModeNoIntPreference = (i == "noIntPrefs") ? true: false;
                                    } else if (self.ctgLastClicked == "intColor"){
                                        e = $mod.find('.colors .activeItem').data('id');
                                        i = itemId;
                                        if (itemId == "noIntPrefs"){
                                            $mod.find('.interiors li a').removeClass('activeItem');
                                            $mod.find('#noIntPrefs').addClass('activeItem');
                                        } else {
                                            self.activeModeNoIntPreference = false;
                                        }
                                        self.activeModeNoExtPreference = (e == "noExtPrefs") ? true: false;
                                    }
                                    $.eventDispatcher.trigger('visualizer_color_change', {'exteriorColor': e, 'interiorColor': i});

                                    // if a user selects no preference, don't update the display, just set the chips
                                    if (itemId != "noExtPrefs" && itemId != "noIntPrefs"){
                                        self.swatchItemClicks($mod, $(this || e.currentTarget) );
                                    }
                                } else {
                                    self.swatchItemClicks($mod, $(this || e.currentTarget) );
                                }
                            }
                        }
                    }
                });

                self.itemScroller($mod); // Carofredsel for BYO 'swatches'
                self.extraCostTooltip($mod);
                self.colorCluTip($mod); // tooltip for items that require it
                self.detailsClue($mod); // tooltip for trim's details
                self.conflictClueTip($mod); //tooltip for conflict message
                self.rebuildClueTip($mod); //tooltip for rebuild message
                if (self.modCfg.scrollerSettings.doInlineMargins){
                    var scrollerWidth = $('.cgiScroller').first().width();
                    var itemHolderW = $('.list_wrap').first().width();
                    var difference = (scrollerWidth - itemHolderW)/2;
                }

                // Configured Vehicle Rebuid Link
                $('body').on(touchOrClick, '#visualizer_rebuild',  function(e){
                    var carline = $('meta[name="carline"]').attr('content'),
                      bodystyle = $('meta[name="bodystyle"]').attr('content'),
                      year = $('meta[name="year"]').attr('content');
                    window.location = getGmdsCmsLinks().getCmsPageURL('byo', '', carline, bodystyle, year);
                });

                // Configured Vehicle Rebuid Link
                $('body').on(touchOrClick, '#visualizer_reset',  function(e){
                    mrm.util.vehicleConfig.resetConfiguredVehicle();
                    // allow for localStorage to save
                    $.eventDispatcher.trigger('reset_application');
                    //setTimeout(function(){location.reload(true);}, 500);
                });
            },
            itemScroller: function($mod) {
                var self = this;
                var itemsInList = $mod.find('.viz_data_holder').children('div.list_wrap');
                itemsInList.addClass('mmScroll');
                var itemScrollOptions;

                itemScrollOptions = $.extend(true, {}, self.modCfg.scrollerSettings, {
                    width: 980,
                    scroll: 2000,
                    auto: false,
                    hiddenItemOverride: true,
                    items: {
                        visible: 'variable',
                    },
                    align: self.modCfg.scrollerSettings.itemScrollerAlign,
                    infinite: false,
                    circular: false,
                    pagination: false,
                    animateControls: {
                        fx: "none"
                    },
                    responsive: false
                });
                itemsInList.mmScroll(itemScrollOptions);
            },
            extraCostTooltip: function($mod){
                var self = this;
                var tips = $mod.find('.list_wrap div ul li a.tips');
                $.each(tips, function (k, v){
                    if ($(this).data('cost') != undefined){
                    v = parseFloat($(this).data('cost'));
                        if (v > 0){
                            v = self.formatPrice($mod, v);
                            var title = $(this).attr('title');
                            $(this).attr('title' , function (i, val){
								if (mrm.util.locale.getLang()==="fr"){
									return val + " (cot supplmentaire - " + v + ")";
								} else {
									return val + " (extra cost - " +v+")";
								}
                            });
                        }
                    }
                });
            },
            colorCluTip: function($mod) {
                var self = this,
                    $colorLinks = $('div.list_wrap ul > li > a.tips', $mod),
                    fadeOutTimeout,
                    cluetipCfg = $.extend({}, mrm.conf.plugin.cluetip || {}, self.modCfg.colorClueTipSettings);
                var touchOrClick = (mrm.util.touchDevice()) ? 'touchstart' : "mouseover";
                $colorLinks.on(touchOrClick, function(e) {
                    clearTimeout(fadeOutTimeout);
                    fadeOutTimeout = setTimeout(function() {
                        $("#cluetip").fadeOut(1000);
                    }, 4500);
                });
                $colorLinks.cluetipWrap(cluetipCfg);
            },
            detailsClue: function($mod) {
                var self = this;
                var thisTrimInfo;
                var clueTipper;
                var trimDetail = $mod.find('.list_wrap.trims a.details');
                $.each(trimDetail, function(k, v) {
                    var dataInfo = $(this).parent().siblings('a.main').data('info');
                    $(this).attr('data-info', '|' + dataInfo);
                    clueTipper = ($(this).data('info').match('<li>')) ? 'details' : 'noList';
                });
                var detailClutip = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
                    cluetipClass: clueTipper,
                    titleAttribute: "data-info",
                    activation: "click",
                    showTitle: false,
                    maxWidth: 400,
                    onShow: function(){
                        // additional event for tracking
                        $(this).trigger('onDetailClick');
                    }
                });
                trimDetail.cluetipWrap(detailClutip);
            },
            conflictClueTip: function($mod) {
                var self = this;
                var conflictClutip = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
                    titleAttribute: "cluetip-data",
                    activation: "click",
                    showTitle: false,
                    onShow: function(event) {
                        $("#visualizer_revert_cookie").on("click", function(e) {
                            self.revertVehicle($mod);
                        });
                        $("#visualizer_keep_cookie").on("click", function(e) {
                            $(".cluetipDetails").fadeOut();
                        });
                        $(".visualizer_conflict_info").html(self.resultDetails);
                        return true;
                    }
                });
                $('.cluetip_visualizer').cluetipWrap(conflictClutip);
            },
            rebuildClueTip: function($mod){
                var self = this;
                var rebuildClueTip = $.extend({}, mrm.conf.plugin.cluetip || {}, self.modCfg.colorClueTipSettings,  {
                    sticky: true,
                    titleAttribute: "cluetip-data",
                    activation: "click",
                    showTitle: false,
                    prepareTitleAttr: false
                });
                $('.cluetip_visualizer_rebuild_link').cluetipWrap(rebuildClueTip);
            },
            //On click event functions
            vizItemChange: function($mod, $thisItem, blnMenuClick) {
                var self = this;
                var item_container = $mod.find('div.viz_data_holder');
                var $item_list = item_container.children('.list_wrap');
                var toggleButton = $mod.find('.int_ext_toggle');
                var $caption_container = $(".visualizer-masthead-caption");
                var $mastShadow = $('#mastheadShadow');
                var viz_items = $mod.find('.mm_visualizer_item_1');

                if ($thisItem.hasClass('active')) {
                    item_container.slideToggle('fast');
                    $caption_container.animate({bottom: "37px"}, "fast");
                    $thisItem.removeClass('active');
                    return;
                }
                viz_items.removeClass('active');
                $thisItem.addClass('active');

                var currentItemData = $thisItem.data('item');
                var listDisplayed = item_container.children(".list_wrap[data-list='" + currentItemData + "']");
                item_container.slideUp("fast", function() {
                    $(this).children('.list_wrap').removeClass('activeList');
                    $(this).children(".list_wrap[data-list='" + currentItemData + "']").addClass('activeList');
                    $(this).slideDown("fast");
                    $caption_container.animate({bottom: "104px"}, "fast");
                });
                var categoryClicked = self.getCategoryByDatalist($mod, currentItemData);
                if ($mod.find('.viz_scroller').hasClass('interior')) {
                    //if (toggleButton.children('img').first().hasClass('hide_toggle')) {
                    if ($(".viz_scroller.interior").is(':visible')) {
                        if ( (categoryClicked === 'colors' || categoryClicked === 'wheels') && blnMenuClick) {
                            self.toggleViews($mod, toggleButton);
                        }
                    }
                    else if (!toggleButton.children('img').first().hasClass('hide_toggle')){
                        if ( categoryClicked === 'interiors' && blnMenuClick && $(".viz_scroller.exterior").is(':visible')) {
                            self.toggleViews($mod, toggleButton);
                        }
                    }
                }
                // make sure active item is in visible area - scroll to if necessary for future use?
                // if (currentItemData === $("." + categoryClicked).data("list")) {
                //     var itemSlideTo = $("." + categoryClicked + " li a.activeItem").parent("li");
                //     $mod.find('.mmScroll.' + categoryClicked + ' div.caroufredsel_wrapper ul').trigger("slideTo", itemSlideTo );
                // }

                // var categoryClicked = self.getCategoryByDatalist($mod, currentItemData);
                // if ($mod.find('.viz_scroller').hasClass('interior')){
                //     if (toggleButton.children('img').first().hasClass('hide_toggle')){
                //         if ( categoryClicked === 'colors' || categoryClicked === 'wheels'){
                //             self.toggleViews($mod, toggleButton);
                //         }
                //     }
                //     else if (!toggleButton.children('img').first().hasClass('hide_toggle')){
                //         if ( categoryClicked === 'interiors'){
                //             self.toggleViews($mod, toggleButton);
                //         }
                //     }
                // }
                // // make sure active item is in visible area - scroll to if necessary for future use?
                // // if (currentItemData === $("." + categoryClicked).data("list")) {
                // //     var itemSlideTo = $("." + categoryClicked + " li a.activeItem").parent("li");
                // //     $mod.find('.mmScroll.' + categoryClicked + ' div.caroufredsel_wrapper ul').trigger("slideTo", itemSlideTo );
                // // }
            },
            // returns class name of category header clicked (by matching data-list with data-item)
            getCategoryByDatalist: function($mod, datalist) {
                var self = this;
                var aryCategories = ["bodyStyles","trims","colors","wheels","interiors"];
                for (var i=0; i<aryCategories.length; i++) {
                    if ($mod.find("." + aryCategories[i]).attr("data-list") === datalist) {
                        return aryCategories[i];
                    }
                }
            },
            revertVehicle: function($mod) {
                // Reverts vehicle to previous configuration - updates images
                var self = this;

                $.each(self.vehicleInfo, function(k, v) {
                    if (k.match('prev-')) {
                        k = k.replace("prev-", "");
                        self.vehicleInfo["change-" + k] = self.vehicleInfo["prev-" + k];
                        self.vehicleInfo["current-" + k] = self.vehicleInfo["prev-" + k];
                        self.vehicleInfo["prev-" + k] = self.vehicleInfo["result-" + k];
                    }
                });
                self.vehicleInfo["result-conflict"] = false;
                self.vehicleInfo["result-details"] = [];

                self.setupTrims($mod);
                self.setupMMC($mod);
                self.setActiveItems($mod);

                self.updateImages($mod);
                self.updateVehicleCaption($mod);
                $(".cluetipDetails").fadeOut();
            },
            triggerTopToggleHide: function($mod){
                if ($mod.find('[config-code].activeItem').attr('config-code') === 'coupe'){
                    $mod.find('.topToggleBtn').addClass('hideTop');
                } else {
                    if ($mod.find('.viz_scroller.activeView').hasClass('interior') && $mod.find('.topToggleBtn').hasClass('onlyExt')) {
                        $mod.find('.topToggleBtn').addClass('hideTop');
                    } else if ($mod.find('.viz_scroller.activeView').hasClass('exterior') && $mod.find('.topToggleBtn').hasClass('onlyInt')){
                        $mod.find('.topToggleBtn').addClass('hideTop');
                    } else {
                        $mod.find('.topToggleBtn').removeClass('hideTop');
                    }
                }
            },
            imageToggleResize: function($mod, count, degree) {
                var self = this;
                count++; // for fallback on the complete if broken images exist.

                var allImagesLoaded = true; // default to true, set to false if any are still loading
                var $images = $mod.find("img.mm");
                $images.each(function(){
                    if (!this.complete) {
                        allImagesLoaded = false;
                    }
                });
                if (allImagesLoaded || count >= 20) {
                    var toggleButton = $mod.find('.int_ext_toggle');
                    self.toggleViews($mod, toggleButton);

                     // if degree < 10, formats number to single digit. E.g. 04 = 4
                    if (degree[0] == '0'){
                        degree = degree[1];
                    }

                    // if pagination slide at that degree exists, then select that slide
                    if ($(".activeView .mmScrollPagination li a")[degree]){
                        $(".activeView .mmScrollPagination li a")[degree].click();
                    }
                }
                else {
                    // wait 1 second then callback for images if not loaded
                    window.setTimeout(function(){ self.imageToggleResize($mod, count, degree) }, 200);
                }
            },
            forceToggleResize: function($mod, count) {
                var self = this;
                count++; // for fallback on the complete if broken images exist.

                var allImagesLoaded = true; // default to true, set to false if any are still loading
                var $images = $mod.find("img.mm");
                $images.each(function(){
                    if (!this.complete) {
                        allImagesLoaded = false;
                    }
                });
                if (allImagesLoaded || count >= 20) {
                    if (mrm.cmp.masthead_resize){
                        $.eventDispatcher.trigger('force_resize');
                    }
                }
                else {
                    // wait 1 second then callback for images if not loaded
                    window.setTimeout(function(){ self.forceToggleResize($mod, count) }, 200);
                }
            },
            toggleViews: function($mod, $this) {
                var self = this;
                var toggleButton = $mod.find('.int_ext_toggle');
                var toggleView = $mod.find('.viz_scroller');

                //for possible future to update toggle switch images to active slide angle

                //   var itemList = $mod.find('.cgiScroller').addClass('mmScroll');
                // if (typeof(self.canvasTransition) !== 'undefined' && Modernizr.canvas) {
                //     self.canvasTransition.initMod(itemList);
                // }
                //  var newSrc = $mod.find(".viz_scroller img:visible").attr("src").replace("gmds6","gmds3");
                // $mod.find(".int_ext_toggle img:hidden").attr("src",newSrc);
                // if(toggleButton.children('img').first().hasClass('hide_toggle')){

                // }

                // the way resize works with the opactiy of the different scrollers requires resize to be called twice when changing views
                // this allows resize to see the current height of the item and then updates that display again after we've changed views

                // force_resize
                self.forceToggleResize($mod, 0);

                //if(mrm.cmp.masthead_resize){
                //    $.eventDispatcher.trigger('force_resize');
                //}

                $mod.find('.viz_scroller').toggleClass('activeView');

                // If the convertible top toggle is present
                if ($mod.find('.topToggleBtn').length && ($mod.find('.topToggleBtn').hasClass('onlyInt') || $mod.find('.topToggleBtn').hasClass('onlyExt')) ){
                    self.triggerTopToggleHide($mod);
                }

                if ($this.hasClass('btnToggle')){
                    toggleButton.children().toggleClass('activeToggle');
                } else {
                    toggleButton.children().toggleClass('hide_toggle');
                }

                // show appropriate category based on current view of toggle switch
                var datalist, category;
                category = self.getCategoryByDatalist($mod, $(".mm_visualizer_item_1.active").data("item"))
                if ($(".viz_scroller.exterior").is(':visible') ) {
                    if ( category === 'interiors') {
                        datalist = $mod.find(".trims").attr("data-list");
                        //if there is no trims tab, this breaks.  Assume we always have colors to go back to if no trims
                        if (!datalist) datalist = $mod.find(".colors").attr("data-list");
                        self.vizItemChange($mod, $(".mm_visualizer_item_1[data-item='" + datalist + "']"),false);
                    }
                }
                else {
                    if (category !== 'interiors') {
                        datalist = $mod.find(".interiors").attr("data-list");
                        self.vizItemChange($mod, $(".mm_visualizer_item_1[data-item='" + datalist + "']"),false);
                    }
                }
                // if(mrm.cmp.masthead_resize) $.eventDispatcher.trigger('force_resize');

                self.forceToggleResize($mod, 0);
                $.eventDispatcher.trigger('mh_scroller_image_change', {duration:0,dispatcher:$mod});
            },
            swatchItemClicks: function($mod, $elClicked) {
                var self = this;
                var itemId = $elClicked.data("id").toString();
                if (! $elClicked.hasClass("activeItem")) {
                    // window.stop();
                    $(".cluetipDetails").fadeOut();

                    self.resultDetails = "";
                    self.vehicleInfo["priority-peg"] = "";
                    self.clearResults($mod);
                    // update vehicleInfo prev vehicle
                    self.vehicleInfo["prev-mmc"] = self.vehicleInfo["current-mmc"];
                    self.vehicleInfo["prev-peg"] = self.vehicleInfo["current-peg"];
                    self.vehicleInfo["prev-intColor"] = self.vehicleInfo["current-intColor"];
                    self.vehicleInfo["prev-extColor"] = self.vehicleInfo["current-extColor"];
                    self.vehicleInfo["prev-wheel"] = self.vehicleInfo["current-wheel"];
                    self.vehicleInfo["prev-options"] = self.vehicleInfo["current-options"];
                    self.vehicleInfo["prev-cabStyle"] = self.vehicleInfo["current-cabStyle"];
                    self.vehicleInfo["prev-boxStyle"] = self.vehicleInfo["current-boxStyle"];

                    if (self.ctgLastClicked === 'peg') {
                        self.vehicleInfo['change-mmc'] = $('#' + itemId).parent('li').data('mmc');
                        self.vehicleInfo["change-peg"] = itemId.split('_').pop();
                    } else if (self.ctgLastClicked === 'mmc' && $elClicked.parent("li[data-peg]").length) {
                        self.vehicleInfo["change-" + self.ctgLastClicked] = itemId;
                        self.vehicleInfo["change-peg"] = $elClicked.parent("li").attr("data-peg");
                        self.vehicleInfo["priority-peg"] = self.vehicleInfo["change-peg"];
                    } else {
                        self.vehicleInfo["change-" + self.ctgLastClicked] = itemId;
                        if (typeof $elClicked.attr("data-group") !== 'undefined' && $elClicked.attr("data-group").length) {
                            self.vehicleInfo["change-peg"] = $elClicked.attr("data-group");
                            self.vehicleInfo["priority-peg"] = $elClicked.attr("data-group");
                        }
                    }

                    // new code
                    if (self.ctgLastClicked === 'mmc') {
                        for (var i=0; i<mmcPegConfigData.length; i++) {
                            var temp = mmcPegConfigData[i].split("|");
                            var new_cab = temp[0];
                            var new_box = temp[1];
                            var new_mmc_peg = temp[2];
                            var d = new_mmc_peg.split("_");

                            if (self.vehicleInfo['change-mmc'] === d[0] ) {
                                self.vehicleInfo['change-cabStyle'] = new_cab;
                                self.vehicleInfo['change-boxStyle'] = new_box;
                                break;
                            }
                        }
                    }
                    else if (self.ctgLastClicked === 'peg') {
                        for (var i=0; i<mmcPegConfigData.length; i++) {
                            var temp = mmcPegConfigData[i].split("|");
                            var new_cab = temp[0];
                            var new_box = temp[1];
                            var new_mmc_peg = temp[2];
                            var d = new_mmc_peg.split("_");

                            if (self.vehicleInfo['change-mmc'] === d[0] && self.vehicleInfo['change-peg'] === d[1]) {
                                self.vehicleInfo['change-cabStyle'] = new_cab;
                                self.vehicleInfo['change-boxStyle'] = new_box;
                                break;
                            }
                        }
                    }

                    self.vehicleInfo["changeType"] = self.ctgLastClicked;
                    self.vehicleInfo = self.validate_data(self.vehicleInfo);

                    var prevCode;
                    $.each(self.vehicleInfo, function(k, v) {
                        if (k.match('current-')) {
                            k = k.replace("current-", "");
                            if (k != self.ctgLastClicked && v != self.vehicleInfo['result-'+k]){
                                prevCode = $('#' + self.vehicleInfo['result-mmc']).parent('li').attr('config-code');
                                if (k === 'peg'){
                                    self.vehicleInfo['result-details'].push(self.vehicleInfo['current-mmc']+'_'+v);
                                } else {
                                    if (k=== 'mmc' && $('#'+v).parent('li').attr('config-code') && $('#'+v).parent('li').attr('config-code') !== prevCode){
                                        self.vehicleInfo['result-details'].push(v);
                                    }
                                    else{
                                        if ( k==='intColor' || k==='extColor' || k==='wheel'){
                                            self.vehicleInfo['result-details'].push(v);
                                        }
                                    }
                                }
                            }
                        }
                    });
                    if (self.vehicleInfo["result-conflict"] && self.vehicleInfo["result-details"].length > 0) {
                        var aryConflictDetails = self.vehicleInfo["result-details"];
                        var isElement = false; // check to see if there is a matching RPO code and ID for it
                        $.each(aryConflictDetails, function (k,v){
                            if ($('#' + v).length ){
                                isElement = true;
                                var dataItem = $('#' + v).parents('.list_wrap').data('list');
                                var categoryLbl = $(".mm_visualizer_item_1[data-item='" + dataItem + "'] li").text();
                                var title = $('#'+v).attr('title');

                                title = (title !== undefined && title !== false) ? title.replace('|','') : $('#'+v).text();

                                if (dataItem !== undefined){
                                    self.resultDetails += categoryLbl + ": " +title + "<br />";
                                }
                            }
                        });
                        if (isElement === true){
                            $(".cluetipDetails").fadeIn();
                        }
                    }
                    self.changeCurrentVehicle($mod);
                    self.setBYOlink($mod); // change the 'finish build' button link for new params
                    self.setupTrims($mod);
                    self.setupMMC($mod);
                    self.updateImages($mod);
                    self.updateVehicleCaption($mod);
                    self.setActiveItems($mod);
                }
            },
            changeCurrentVehicle: function($mod) {
                var self = this;
                self.vehicleInfo["current-mmc"] = self.vehicleInfo["result-mmc"];
                self.vehicleInfo["current-peg"] = self.vehicleInfo["result-peg"];
                self.vehicleInfo["current-intColor"] = self.vehicleInfo["result-intColor"];
                self.vehicleInfo["current-extColor"] = self.vehicleInfo["result-extColor"];
                self.vehicleInfo["current-wheel"] = self.vehicleInfo["result-wheel"];
                self.vehicleInfo["current-options"] = self.vehicleInfo["result-options"];
                self.vehicleInfo["current-cabStyle"] = self.vehicleInfo["result-cabStyle"];
                self.vehicleInfo["current-boxStyle"] = self.vehicleInfo["result-boxStyle"];
                self.vehicleInfo["change-mmc"] = self.vehicleInfo["result-mmc"];
                self.vehicleInfo["change-peg"] = self.vehicleInfo["result-peg"];
                self.vehicleInfo["change-intColor"] = self.vehicleInfo["result-intColor"];
                self.vehicleInfo["change-extColor"] = self.vehicleInfo["result-extColor"];
                self.vehicleInfo["change-wheel"] = self.vehicleInfo["result-wheel"];
                self.vehicleInfo["change-options"] = self.vehicleInfo["result-options"];
                self.vehicleInfo["change-cabStyle"] = self.vehicleInfo["result-cabStyle"];
                self.vehicleInfo["change-boxStyle"] = self.vehicleInfo["result-boxStyle"];
            },
            //  Update the image URL to valid Combination
            updateImages: function($mod) {
                var self = this;
                self.saveConfigOnce = true;
                // http://10.192.180.63:11003/mmgdev/dynres/prove/image.gen?i=2015/1GY69/1GY69__1LT/GXH_H0Z_RT9gmds6.jpg&v=deg01&std=true&country=US
                $.each($mod.find(".mmScroll .caroufredsel_wrapper ul li img.mm"), function() {
                    self.updateThisImage($mod, $(this));
                });

                $.each($mod.find(".int_ext_toggle.cgiToggle img"), function() {
                    self.updateThisImage($mod, $(this));
                });
            },
            updateThisImage: function($mod, curImage) {
                var self = this;
                var imageURL = curImage.attr("src");
                var aryImageURL = imageURL.split("?") // splits the URL into base and querystring
                var imageQS = aryImageURL[1]; // we just want to process the querystring part of the image URL
                var aryImageQS = imageQS.split("/") // split the querystring into array split on /
                // update image string
                aryImageQS[1] = aryImageQS[1].replace(self.vehicleInfo["prev-mmc"], self.vehicleInfo["current-mmc"]); //mmc
                aryImageQS[2] = aryImageQS[2].replace(self.vehicleInfo["prev-mmc"], self.vehicleInfo["current-mmc"]); // mmc + peg
                aryImageQS[2] = aryImageQS[2].replace(self.vehicleInfo["prev-peg"], self.vehicleInfo["current-peg"]); // mmc + peg
                aryImageQS[3] = aryImageQS[3].replace(self.vehicleInfo["prev-extColor"], self.vehicleInfo["current-extColor"]); // extColor
                aryImageQS[3] = aryImageQS[3].replace(self.vehicleInfo["prev-intColor"], self.vehicleInfo["current-intColor"]); // intColor
                aryImageQS[3] = aryImageQS[3].replace(self.vehicleInfo["prev-wheel"], self.vehicleInfo["current-wheel"]); // wheel

                // remove all of the options and re-add the current options
                if (self.vehicleInfo["prev-options"] != undefined && self.vehicleInfo["prev-options"].length > 0){
                    $.each(self.vehicleInfo["prev-options"], function(i, val){
                        aryImageQS[3] = aryImageQS[3].replace("_" + val, "");
                    });
                }
                // This undefined check is due to blackbox logic not setting the curent-options correctly and will need to be changed with NEW UMD code format
                if (self.vehicleInfo["current-options"] != undefined && self.vehicleInfo["current-options"].length > 0){
                    var imageSplitIndex = aryImageQS[3].lastIndexOf("_") + 4,
                        imageQSEnd = aryImageQS[3].substr(imageSplitIndex),
                        imageQSStart = aryImageQS[3].substr(0, imageSplitIndex);
                    $.each(self.vehicleInfo["current-options"], function(i, val){
                        if (aryImageQS[3].indexOf(val) < 0){
                            imageQSStart += "_" + val;
                        }
                    });
                    aryImageQS[3] = imageQSStart.toString() + imageQSEnd.toString();
                }

                // if in a standard view, save the current config to the users preferences
                if (self.vehicleConfig.enabled && self.saveConfigOnce && (self.mode == 'standard' || self.mode == 'active')){
                    //only save preferrences when a configured vehicle does not exist
                    if (!mrm.util.vehicleConfig.isConfigured()){
                        var obj = {
                            mmc: self.vehicleInfo["current-mmc"],
                            peg: self.vehicleInfo["current-peg"], // trim
                            color: self.vehicleInfo["current-extColor"],
                            intColor: self.vehicleInfo["current-intColor"],
                            cabStyle: self.vehicleInfo["current-cabStyle"],
                            boxStyle: self.vehicleInfo["current-boxStyle"],
                            wheels: self.vehicleInfo["current-wheel"]
                        }
                        mrm.util.vehicleConfig.setPreferrences(obj);
                    }
                    // only save the configuration once instead of for each image update. performance improvement
                    self.saveConfigOnce = false;
                }

                // rebuild imageURL
                imageURL = aryImageURL[0] + "?";
                for (var i = 0; i < aryImageQS.length; i++) {
                    imageURL += aryImageQS[i] + "/";
                }
                imageURL = imageURL.slice(0, -1) // remove trailing /
               // '.ui-helper-visible'
                curImage.attr("src", imageURL);
            },
            validate_advanced_conflict: function(info){
                var mmc = info["change-mmc"];
                var peg = info["change-peg"];
                var ico = info["change-intColor"];
                var eco = info["change-extColor"];
                var wel = info["change-wheel"];
                var cabStyle = info["change-cabStyle"];
                var boxStyle = info["change-boxStyle"];
                var key1 = mmc+'_'+peg+'_???_'+ico+'_'+wel;
                var key2 = mmc+'_'+peg+'_'+eco+'_???_'+wel;
                var key3 = mmc+'_'+peg+'_'+eco+'_'+ico+'_???';
                var correctValues = "";

                var check1 = advancedConflictData.indexOf(key1);
                if (check1 > 0){
                    //found the conflict. get the correct values.
                    correctValues = advancedValidData[check1];
                    info["result-details"].push(info['current-extColor']);
                }
                var check2 = advancedConflictData.indexOf(key2);
                if (check2 > 0){
                    correctValues = advancedValidData[check2];
                    info["result-details"].push(info['current-intColor']);
                }
                var check3 = advancedConflictData.indexOf(key3);
                if (check3 > 0){
                  correctValues = advancedValidData[check3];
                  info["result-details"].push(info['current-wheel']);
                }
                var count = check1+check2+check3;
                if (count > -3){
                    info["result-conflict"] = true;
                    var newValues = correctValues.split('_');
                    if (newValues.length > 0){
                        if (newValues[0] != "" && newValues[0] != "???"){
                            info["change-mmc"] = newValues[0];
                        }
                        if (newValues[1] != "" && newValues[1] != "???"){
                            info["change-peg"] = newValues[1];
                        }
                        if (newValues[2] != "" && newValues[2] != "???"){
                            info["change-extColor"] = newValues[2];
                        }
                        if (newValues[3] != "" && newValues[3] != "???"){
                            info["change-intColor"] = newValues[3];
                        }
                        if (newValues[4] != "" && newValues[4] != "???"){
                            info["change-wheel"] = newValues[4];
                        }
                        return info;
                    }
                }
                return info;
            },
            validate_data: function(info) {
                var temp, d, objTemp, curConfigCode, key;
                var self = this,
                    changeType = info["changeType"];

                info["lookup-complete"] = false;
                info["result-details"] = [];

                // Check if there is a conflict with new configuration
                if (self.validate_config_all(info)) {
                    // no conflict
                    info["result-cabStyle"] = info["change-cabStyle"];
                    info["result-boxStyle"] = info["change-boxStyle"];
                    info["result-mmc"] = info["change-mmc"];
                    info["result-peg"] = info["change-peg"];
                    info["result-intColor"] = info["change-intColor"];
                    info["result-extColor"] = info["change-extColor"];
                    info["result-wheel"] = info["change-wheel"];
                    info["result-options"] = [];
                    info["result-conflict"] = false;
                    return info;
                } else {
                    // There was a conflict
                    info["result-conflict"] = true;

                    // Figure out new valid configuration
                    switch (changeType) {
                    case "extColor":
                        info = self.configEIW(info, vehicleExtConfigData, vehicleIntConfigData, "intColor", vehicleWheConfigData, "wheel");
                        break;
                    case "intColor":
                        info = self.configEIW(info, vehicleIntConfigData, vehicleExtConfigData, "extColor", vehicleWheConfigData, "wheel");
                        break;
                    case "wheel":
                        info = self.configEIW(info, vehicleWheConfigData, vehicleExtConfigData, "extColor", vehicleIntConfigData, "intColor");
                        break;
                    case "peg":
                        curConfigCode = $(".trims a.activeItem[config-code]").attr("config-code") || ""; //conv, coupe
                        if (!curConfigCode.length > 0) {
                            curConfigCode = "";
                        }

                        // CHECK CFG, CAB, BOX, MMC, PEG
                        key = info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + info["change-peg"];
                        if (mmcPegConfigData.indexOf(key) >= 0) {
                            info = self.updateInfo(info, info["change-cabStyle"], info["change-boxStyle"], info["change-mmc"], info["change-peg"],'');
                            info["result-options"] = [];

                            info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                            info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                            info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                        }

                        if ($(".trims li[data-mmc]").length > 0) {
                            // has data-mmc
                            if (info["lookup-complete"] === false) {
                                // CFG, CAB, MMC, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    key = info["change-cabStyle"] + '|' + objTemp.newBox + '|' + info["change-mmc"] + '_' + info["change-peg"];
                                    // check if cab|box|EIW is in JSON
                                    if (curConfigCode === objTemp.configCode && mmcPegConfigData.indexOf(key) >= 0) {
                                        info = self.updateInfo(info, info["change-cabStyle"], objTemp.newBox, info["change-mmc"], info["change-peg"], '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break; // breaks out of for loop
                                    }
                                } //for loop ends
                            }

                            if (info["lookup-complete"] === false) {
                                // No box found for current cab and selected mmc_peg
                                // Set to default config for selected mmc_peg
                                // CFG, MMC, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    // check if cab|box|EIW is in JSON
                                    if (curConfigCode === objTemp.configCode &&
                                                info["change-mmc"] === objTemp.newMMC &&
                                                info["change-peg"] === objTemp.newPeg) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, info["change-peg"], '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break;
                                    }
                                } //for loop ends
                            }

                            if (info["lookup-complete"] === false) {
                                // No box found for current cab and selected mmc_peg
                                // Set to default config for selected mmc_peg
                                // MMC, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    // check if cab|box|EIW is in JSON
                                    if (info["change-mmc"] === objTemp.newMMC &&
                                                info["change-peg"] === objTemp.newPeg) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, info["change-peg"], '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break;
                                    }
                                } //for loop ends
                            }
                        }
                        else {
                            // no data-mmc attribute
                            if (info["lookup-complete"] === false) {
                                // CFG, CAB, BOX, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    // check if cab|box|EIW is in JSON
                                    if (curConfigCode === objTemp.configCode &&
                                                info["change-cabStyle"] === objTemp.newCab &&
                                                info["change-boxStyle"] === objTemp.newBox &&
                                                info["change-peg"] === objTemp.newPeg) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, info["change-peg"], '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break;
                                    }
                                } //for loop ends
                            }

                            if (info["lookup-complete"] === false) {
                                // CFG, CAB, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    // check if cab|box|EIW is in JSON
                                    if (curConfigCode === objTemp.configCode &&
                                                info["change-cabStyle"] === objTemp.newCab &&
                                                info["change-peg"] === objTemp.newPeg) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, info["change-peg"], '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break;
                                    }
                                } //for loop ends
                            }

                            if (info["lookup-complete"] === false) {
                                // CFG, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    // check if cab|box|EIW is in JSON
                                    if (curConfigCode === objTemp.configCode &&
                                                info["change-peg"] === objTemp.newPeg) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, info["change-peg"], '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break;
                                    }
                                } //for loop ends
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // PEG
                            for (var i=0; i<mmcPegConfigData.length; i++) {
                                objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                // check if cab|box|EIW is in JSON
                                if (info["change-peg"] === objTemp.newPeg) {
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, info["change-peg"], '');

                                    // validate EIW
                                    info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                    info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                    info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                    break;
                                }
                            } //for loop ends
                        }

                        break;
                    case "mmc":
                        curConfigCode = $(".bodyStyles a[data-id='" + info["change-mmc"] + "']").parent("li[config-code]").attr("config-code") || ""; //conv, coupe
                        if (!curConfigCode.length > 0) {
                            curConfigCode = "";
                        }

                        if (info["priority-peg"].length > 0) {
                            // MMCs have data-peg attribute - use priority peg
                            // standard_cab|standard_box|1JU69_1SA
                            // CHECK CAB, BOX, MMC, PEG
                            key = info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + info["change-peg"];
                            if (mmcPegConfigData.indexOf(key) >= 0) {
                                info = self.updateInfo(info, info["change-cabStyle"], info["change-boxStyle"], info["change-mmc"], info["change-peg"], '');
                                info["result-options"] = [];
                                info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                            }
                            else {
                                // CHECK CFG, CAB, MMC, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    key = info["change-cabStyle"] + '|' + objTemp.newBox + '|' + info["change-mmc"] + '_' + info["change-peg"];
                                    if (curConfigCode === objTemp.configCode && mmcPegConfigData.indexOf(key) >= 0) {
                                        info = self.updateInfo(info, info["change-cabStyle"], objTemp.newBox, info["change-mmc"], info["change-peg"], '');
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break; // break out of for loop
                                    }
                                } //for loop ends
                            }

                            if (info["lookup-complete"] === false) {
                                // CHECK CFG, MMC, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    key = objTemp.newCab + '|' + objTemp.newBox + '|' + info["change-mmc"] + '_' + info["change-peg"];
                                    // check if cab|box|EIW is in JSON
                                    if (objTemp.configCode === curConfigCode && mmcPegConfigData.indexOf(key) >= 0) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, info["change-mmc"], info["change-peg"], '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break; // breaks out of for loop
                                    }
                                } //for loop ends
                            }

                            if (info["lookup-complete"] === false) {
                                // CHECK MMC, PEG
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    // check if cab|box|EIW is in JSON
                                    if (info["change-mmc"] === objTemp.newMMC && info["change-peg"] === objTemp.newPeg) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break;
                                    }
                                } //for loop ends
                            }
                        }
                        else {
                            // no data-peg on MMCs
                            // MMCs have data-peg attribute - use priority peg
                            // standard_cab|standard_box|1JU69_1SA

                            // CHECK CAB, BOX, MMC, PEG
                            key = info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + info["change-peg"];
                            if (mmcPegConfigData.indexOf(key) >= 0) {
                                info = self.updateInfo(info, info["change-cabStyle"], info["change-boxStyle"], info["change-mmc"], info["change-peg"], '');
                                info["result-options"] = [];
                                info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                            }
                            else {
                                // CHECK CFG, CAB, BOX, MMC
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    key = info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + objTemp.newPeg;
                                    if (objTemp.configCode === curConfigCode && mmcPegConfigData.indexOf(key) >= 0) {
                                        info = self.updateInfo(info, info["change-cabStyle"], objTemp.newBox, info["change-mmc"], objTemp.newPeg, '');
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break; // break out of for loop
                                    }
                                } //for loop ends
                            }

                            if (info["lookup-complete"] === false) {
                                // CHECK CFG, CAB, MMC
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    key = info["change-cabStyle"] + '|' + objTemp.newBox + '|' + info["change-mmc"] + '_' + objTemp.newPeg;
                                    if (objTemp.configCode === curConfigCode && mmcPegConfigData.indexOf(key) >= 0) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, info["change-mmc"], objTemp.newPeg, '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break; // breaks out of for loop
                                    }
                                } //for loop ends
                            }

                            if (info["lookup-complete"] === false) {
                                // CHECK CFG, MMC
                                for (var i=0; i<mmcPegConfigData.length; i++) {
                                    objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                    if (objTemp.configCode === curConfigCode &&
                                                info["change-mmc"] === objTemp.newMMC) {
                                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, '');

                                        // validate EIW
                                        info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                        info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                        info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                        break;
                                    }
                                } //for loop ends
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // CHECK MMC
                            for (var i=0; i<mmcPegConfigData.length; i++) {
                                objTemp = self.objTemp.updateConfigData(mmcPegConfigData[i]);
                                // check if cab|box|EIW is in JSON
                                if (info["change-mmc"] === objTemp.newMMC) {
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, '');

                                    // validate EIW
                                    info = self.validateEIW(info, vehicleExtConfigData, "extColor");
                                    info = self.validateEIW(info, vehicleIntConfigData, "intColor");
                                    info = self.validateEIW(info, vehicleWheConfigData, "wheel");
                                    break;
                                }
                            } //for loop ends
                        }
                        break;
                    default:
                        return info; // shouldn't get here
                    }
                }
                // run advanced conflict logic
                //info = self.validate_advanced_conflict(info);
                return info;
            },
            objTemp: {
                configData: [],
                newCab: "",
                newBox: "",
                newMMC: "",
                newPeg: "",
                iRPO: "",
                configCode: "",
                updateConfigData: function(configData) {
                    this.configData = configData.split("|");
                    var new_mmc_peg = this.configData[2];
                    var d = new_mmc_peg.split("_");
                    this.newCab = this.configData[0];
                    this.newBox = this.configData[1];
                    this.newMMC = d[0];
                    this.newPeg = d[1];
                    if (d.length > 1) {
                        this.iRPO = d[2];
                    }
                    // should we assume each particular mmc has 1 particular config code?
                    this.configCode = $(".bodyStyles li[data-mmc='" + this.newMMC + "']").attr("config-code") || "";
                    if (!this.configCode.length > 0) {
                        this.configCode = "";
                    }
                    return this;
                }
            },
            configEIW: function(info, vCfg, vCfg2, vCfg2_name, vCfg3, vCfg3_name) {
                var self = this;
                var changeType = info["changeType"];
                var changeEIW = info["change-" + changeType].toString();
                var curConfigCode, objTemp;
                curConfigCode = $(".trims a.activeItem[config-code]").attr("config-code") || ""; //conv, coupe
                if (!curConfigCode.length > 0) {
                    curConfigCode = "";
                }

                if (vCfg.indexOf(info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + info["change-peg"] + '_' + changeEIW) >= 0) {
                    // cab|box|mmc_peg_wel combo is VALID
                    info["result-options"] = [];
                    info = self.updateInfo(info, info["change-cabStyle"], info["change-boxStyle"], info["change-mmc"], info["change-peg"], changeEIW);

                    // validate intColor & extColor
                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                }
                else {
                    if (info["priority-peg"].length > 0) {
                        // MATCH CFG, CAB, BOX, MMC, PRIORITY-PEG, SELECTED EIW
                        for (var i=0; i<vCfg.length; i++) {
                            objTemp = self.objTemp.updateConfigData(vCfg[i]);
                            if (curConfigCode === objTemp.configCode &&
                                        info["change-cabStyle"] === objTemp.newCab &&
                                        info["change-boxStyle"] === objTemp.newBox &&
                                        info["change-mmc"] === objTemp.newMMC &&
                                        info["priority-peg"] === objTemp.newPeg &&
                                        changeEIW === objTemp.iRPO) {
                                info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);
                                // validate EIW (except changeType)
                                info = self.validateEIW(info, vCfg2, vCfg2_name);
                                info = self.validateEIW(info, vCfg3, vCfg3_name);
                                break;
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // MATCH CFG, CAB, BOX, PRIORITY-PEG, SELECTED EIW
                            for (var i=0; i<vCfg.length; i++) {
                                objTemp = self.objTemp.updateConfigData(vCfg[i]);

                                // find priority peg
                                if (curConfigCode === objTemp.configCode &&
                                            info["change-cabStyle"] === objTemp.newCab &&
                                            info["change-boxStyle"] === objTemp.newBox &&
                                            info["priority-peg"] === objTemp.newPeg &&
                                            changeEIW === objTemp.iRPO) {
                                    // get mmc
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                    // validate EIW (except changeType)
                                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                                    break;
                                }
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // MATCH CFG, CAB, PRIORITY-PEG, SELECTED EIW
                            for (var i=0; i<vCfg.length; i++) {
                                objTemp = self.objTemp.updateConfigData(vCfg[i]);

                                if (curConfigCode === objTemp.configCode &&
                                            info["change-cabStyle"] === objTemp.newCab &&
                                            objTemp.newPeg === info["priority-peg"] &&
                                            changeEIW === objTemp.iRPO) {
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                    // validate EIW (except changeType)
                                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                                    break;
                                }
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // MATCH CFG, PRIORITY-PEG, SELECTED EIW
                            for (var i=0; i<vCfg.length; i++) {
                                objTemp = self.objTemp.updateConfigData(vCfg[i]);
                                if (curConfigCode === objTemp.configCode &&
                                            info["priority-peg"] === objTemp.newPeg &&
                                            changeEIW === objTemp.iRPO) {
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                    // validate EIW (except changeType)
                                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                                    break;
                                }
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // MATCH PRIORITY-PEG, SELECTED EIW
                            for (var i=0; i<vCfg.length; i++) {
                                objTemp = self.objTemp.updateConfigData(vCfg[i]);

                                // check if cab|box|EIW is in JSON
                                if (info["priority-peg"] === objTemp.newPeg && changeEIW === objTemp.iRPO ) {
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                    // validate other EIW (except changeType)
                                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                                    break;
                                }
                            } //for loop ends
                        }
                    } // if (info["priority-peg"].length > 0)
                    else {
                        // no priority-peg configured

                        // MATCH CFG, CAB, BOX, MMC, PEG, SELECTED EIW
                        for (var i=0; i<vCfg.length; i++) {
                            objTemp = self.objTemp.updateConfigData(vCfg[i]);
                            if (curConfigCode === objTemp.configCode &&
                                        info["change-cabStyle"] === objTemp.newCab &&
                                        info["change-boxStyle"] === objTemp.newBox &&
                                        info["change-mmc"] === objTemp.newMMC &&
                                        info["change-peg"] === objTemp.newPeg &&
                                        changeEIW === objTemp.iRPO) {
                                info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);
                                // validate EIW (except changeType)
                                info = self.validateEIW(info, vCfg2, vCfg2_name);
                                info = self.validateEIW(info, vCfg3, vCfg3_name);
                                break;
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // MATCH CFG, CAB, BOX, MMC, SELECTED EIW
                            for (var i=0; i<vCfg.length; i++) {
                                objTemp = self.objTemp.updateConfigData(vCfg[i]);

                                // find priority peg
                                if (curConfigCode === objTemp.configCode &&
                                            info["change-cabStyle"] === objTemp.newCab &&
                                            info["change-boxStyle"] === objTemp.newBox &&
                                            info["change-mmc"] === objTemp.newMMC &&
                                            changeEIW === objTemp.iRPO) {
                                    // get mmc
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                    // validate EIW (except changeType)
                                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                                    break;
                                }
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // MATCH CFG, CAB, BOX, SELECTED EIW
                            for (var i=0; i<vCfg.length; i++) {
                                objTemp = self.objTemp.updateConfigData(vCfg[i]);

                                if (curConfigCode === objTemp.configCode &&
                                            info["change-cabStyle"] === objTemp.newCab &&
                                            info["change-box"] === objTemp.newBox &&
                                            changeEIW === objTemp.iRPO) {
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                    // validate EIW (except changeType)
                                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                                    break;
                                }
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // MATCH CFG, CAB, SELECTED EIW
                            for (var i=0; i<vCfg.length; i++) {
                                objTemp = self.objTemp.updateConfigData(vCfg[i]);

                                // find priority peg
                                if (curConfigCode === objTemp.configCode &&
                                            info["change-cabStyle"] === objTemp.newCab &&
                                            changeEIW === objTemp.iRPO) {
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                    // validate EIW (except changeType)
                                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                                    break;
                                }
                            }
                        }

                        if (info["lookup-complete"] === false) {
                            // MATCH CFG, SELECTED EIW
                            for (var i=0; i<vCfg.length; i++) {
                                objTemp = self.objTemp.updateConfigData(vCfg[i]);

                                // check if cab|box|EIW is in JSON
                                if (curConfigCode === objTemp.configCode && changeEIW === objTemp.iRPO ) {
                                    info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                    // validate other EIW (except changeType)
                                    info = self.validateEIW(info, vCfg2, vCfg2_name);
                                    info = self.validateEIW(info, vCfg3, vCfg3_name);
                                    break;
                                }
                            } //for loop ends
                        }
                    }

                    if (info["lookup-complete"] === false) {
                        // MATCH SELECTED EIW
                        for (var i=0; i<vCfg.length; i++) {
                            objTemp = self.objTemp.updateConfigData(vCfg[i]);

                            // check if cab|box|EIW is in JSON
                            if (changeEIW === objTemp.iRPO) {
                                info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg, changeEIW);

                                // validate other EIW (except changeType)
                                info = self.validateEIW(info, vCfg2, vCfg2_name);
                                info = self.validateEIW(info, vCfg3, vCfg3_name);
                                break;
                            }
                        } //for loop ends
                    }
                }
                return info;
            },
            updateInfo: function(info,new_cab,new_box,newMMC,newPeg,changeEIW) {
                var self = this;
                var changeType = info["changeType"];
                info["result-cabStyle"] = new_cab;
                info["result-boxStyle"] = new_box;
                info["result-mmc"] = newMMC;
                info["result-peg"] = newPeg;

                if (changeEIW.length > 0) {
                    info["result-" + changeType] = changeEIW;
                }
                info["lookup-complete"] = true;
                return info;
            },
            configLookup: function(info, key, vCfg, vCfg2, vCfg2_name, vCfg3, vCfg3_name) {
                var self = this;
                var changeType = info["changeType"];
                var objTemp;
                for (var i=0; i<vCfg.length; i++) {
                    objTemp = self.objTemp.updateConfigData(vCfg[i]);

                    // check if cab|box|EIW is in JSON
                    if (vCfg[i].indexOf(key) >= 0) {
                        info = self.updateInfo(info, objTemp.newCab, objTemp.newBox, objTemp.newMMC, objTemp.newPeg,info["change-" + changeType]);

                        // validate EIW (except changeType)
                        info = self.validateEIW(info, vCfg2, vCfg2_name);
                        info = self.validateEIW(info, vCfg3, vCfg3_name);
                        break;
                    }
                } //for loop ends
                return info;
            },
            // updates info with valid extColor, intColor or Wheel
            validateEIW: function(info, vCfg, eiw) {
                var self = this;
                if (info["change-" + eiw].length > 0 && vCfg.indexOf(info["result-cabStyle"] + '|' + info["result-boxStyle"] + '|' + info["result-mmc"] + '_' + info["result-peg"] + '_' + info["change-" + eiw]) >= 0) {
                    info["result-" + eiw] = info["change-" + eiw];
                }
                else {
                    info["result-" + eiw] = self.getDefaultEIW(info, vCfg);
                }
                return info;
            },
            // validates the entire info object
            validate_config_all: function(info) {
                if (mmcPegConfigData.indexOf(info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + info["change-peg"]) >= 0) {
                    if (vehicleExtConfigData.indexOf(info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + info["change-peg"] + '_' + info["change-extColor"]) >= 0) {
                        if (vehicleIntConfigData.indexOf(info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + info["change-peg"] + '_' + info["change-intColor"]) >= 0) {
                            if (vehicleWheConfigData.indexOf(info["change-cabStyle"] + '|' + info["change-boxStyle"] + '|' + info["change-mmc"] + '_' + info["change-peg"] + '_' + info["change-wheel"]) >= 0) {
                                return true; // no conflicts
                            }
                        }
                    }
                }
                return false; // conflict
            },
            // gets default extColor/intColor/wheel based on cab|box|mmc_peg
            // vCfg is passed in config variable to use, eg: vehicleExtConfigData, vehicleIntConfigData, vehicleWheConfigData
            getDefaultEIW: function(info,vCfg) {
                for (var i=0; i<vCfg.length; i++) {
                    var temp = vCfg[i].split("|");
                    var new_cab = temp[0];
                    var new_box = temp[1];
                    var new_mmc_peg = temp[2];
                    var d = new_mmc_peg.split("_");
                    var new_mmc = d[0];
                    var new_peg = d[1];
                    var rpoCode = d[2];
                    if (info["result-cabStyle"] === new_cab && info["result-boxStyle"] === new_box) {
                        if (info["result-mmc"] === new_mmc && info["result-peg"] === new_peg) {
                            return rpoCode;
                        }
                    }
                }
                return -1;
            }
        }
    });
})(mrm.$);
(function($) {
    $.extend(mrm.cmp.mm_visualizer_1, {
        canvasTransition: {
            config: {
                duration: 800,
                easing: 'easeInCubic',
                angleInDegrees: 64,
                fps: mrm.util.iOS() ? 40 : 60
            },
            
            initMod: function($mod) {
                // <editor-fold desc="POLYFILL FOR requestAnimationFrame" >
                // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
                // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

                // requestAnimationFrame polyfill by Erik Mller
                // fixes from Paul Irish and Tino Zijdel

                var lastTime = 0;
                var vendors = ['ms', 'moz', 'webkit', 'o'];
                for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
                    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
                        || window[vendors[x] + 'CancelRequestAnimationFrame'];
                }

                if (!window.requestAnimationFrame)
                    window.requestAnimationFrame = function(callback, element) {
                        var currTime = new Date().getTime();
                        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                        var id = window.setTimeout(function() {
                            callback(currTime + timeToCall);
                        },
                            timeToCall);
                        lastTime = currTime + timeToCall;
                        return id;
                    };

                if (!window.cancelAnimationFrame)
                    window.cancelAnimationFrame = function(id) {
                        clearTimeout(id);
                    };
                // </editor-fold>

                /* create the canvas transition layers */
                var canvas = document.createElement('canvas');

                canvas.width = $mod.width();
                canvas.height = $mod.height();

                $mod.append($(canvas).hide());
                //IE compatiblity
                //if (typeof FlashCanvas !== "undefined") {
                //  FlashCanvas.initElement(canvas);
                //}
            },
            /**
             * Prepares for the animation
             * @param {jQuery} $itm
             * @param {jQuery} $itmNext
             * @returns {void}
             */
            slide: function($itm, $itmNext) {
                mrm.util.log('slide working');
                var $scroller = $itm.closest('.mmScroll'),
                    $mm_v1 = $itm.closest('modMm_visualizer_1'),
                    img = $itm.find('img.mm')[0],
                    imgNext = $itmNext.find('img.mm')[0],
                    imageWidth = $(imgNext).width(),
                    scrollerHeight = $scroller.height(),
                    scrollerWidth = $scroller.width(),
                    $canvas = $scroller.children('canvas'),
                    img1Num = $itm.index(),
                    img2Num = $itmNext.index(),
                    direction = img1Num < img2Num ? 'next' : 'prev',
                    difference = parseInt(($(window).width() - $('.modMm_visualizer_1').outerWidth())/2);
                    //Masthead visualizer calculations for canvas transition
          		difference = difference > 0 ? 0 : difference;
            	var xOffset = difference <= -250 ? -250 : difference;

                $canvas.css('z-index', $mm_v1.data("indexBase"));
                $canvas[0].width = imageWidth;
                $canvas[0].height = scrollerHeight;

                // a little trig to figure out correct offset length based on the angle given in config.
                var angleLength = Math.round(scrollerHeight / Math.tan(this.config.angleInDegrees / 180 * Math.PI));

                var polygon_arr = [
                    /* X,Y coordinates */
                    {x: 0, y: 0}, /* left bottom */
                    {x: -angleLength, y: scrollerHeight}, /* left top */
                    {x: scrollerWidth, y: scrollerHeight}, /* right top */
                    {x: scrollerWidth + angleLength, y: 0}]/*right bottom*/;

                // check if png then assume it's transparent
                var transparent = false;
                if ($.os.name === "ipad" || typeof img !== 'undefined') {
                    if(/\.png$/.test(img.src)){
                        $scroller.find('img.mm').hide();
                        transparent = true;
                    }
                }

                var theImages = {img: img, img2:imgNext, x: xOffset, y: parseInt($(imgNext).css('margin-top')), w: imageWidth, h: imgNext.height};

                this.drawImages({ctx: $canvas[0].getContext('2d'), direction: direction, polygon_arr: polygon_arr, images: theImages, angleLength: angleLength, transparent: transparent});
            },
         
            /**
             * Controls starts animation and controls frame rate
             * @param {object} options
             * @returns {void}
             */
            drawImages: function(options) {
                var self = this;

                // reset the animation
                cancelAnimationFrame(self.animationId);

                // make canvas visible
                $(options.ctx.canvas).show();

                var startTime = new Date().getTime(),
                    lastExec = startTime,
                    firstTime = true;

                // start things
                (function canvasAnimate() {
                    var now = new Date().getTime(),
                        t = now - startTime,
                        b = 0,
                        c = options.polygon_arr[3].x,
                        d = self.config.duration,
                        p = $.easing[self.config.easing](null, t,b,c,d);

                    options._offset = (options.direction === 'next') ? p*-1 : p;

                    // calculate if its time to display the next frame based on the fps
                    if ((now - lastExec) > (1000 / self.config.fps) || firstTime) {
                        firstTime = false;
                        lastExec = new Date().getTime();
                        self.wipeAnimation(options);
                    }

                    if (t <= d+15) {
                        self.animationId = requestAnimationFrame(canvasAnimate);
                    } else {
                        //options.ctx.clearRect(0, 0, options.ctx.canvas.width, options.ctx.canvas.height);
                        if (!options.transparent)
                            $(options.ctx.canvas).hide(0);
                    }
                })();// call it
            },
            /**
             * Draws the images on the canvas
             * @param {object} options
             * @returns {Boolean}
             */
            wipeAnimation: function(options) {
                var self = mrm.cmp.mm_visualizer_1.canvasTransition;
                var ctx = options.ctx;
                var _offset = options._offset;


                // clear the whole canvas
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                var theImage = options.images;

                if(options.transparent){
                    ctx.beginPath();
                    if(options.direction === 'next'){
                        ctx.moveTo(parseInt(options.polygon_arr[2].x) + _offset, parseInt(options.polygon_arr[2].y));
                        ctx.lineTo(parseInt(options.polygon_arr[3].x) + _offset, parseInt(options.polygon_arr[3].y));
                        ctx.lineTo(parseInt(options.polygon_arr[3].x) + theImage.w, parseInt(options.polygon_arr[3].y));
                        ctx.lineTo(parseInt(options.polygon_arr[2].x) + theImage.w, parseInt(options.polygon_arr[2].y));
                    }else{
                        ctx.moveTo(parseInt(options.polygon_arr[0].x) + _offset, parseInt(options.polygon_arr[0].y));
                        ctx.lineTo(parseInt(options.polygon_arr[1].x) + _offset, parseInt(options.polygon_arr[1].y));
                        ctx.lineTo(parseInt(options.polygon_arr[1].x) - theImage.w, parseInt(options.polygon_arr[1].y));
                        ctx.lineTo(parseInt(options.polygon_arr[0].x) - theImage.w, parseInt(options.polygon_arr[0].y));
                    }

                    ctx.closePath();
                    ctx.save();
                    ctx.clip();

                    ctx.drawImage(theImage.img2, theImage.x, theImage.y, theImage.w, theImage.h);
                    ctx.restore();
                }

                // draw the masked image
                ctx.beginPath();
                for (var i = 0; i < (options.polygon_arr.length); i++) {

                    var x = parseInt(options.polygon_arr[i].x) + _offset;
                    var y = parseInt(options.polygon_arr[i].y);


                    if (i === 0)
                        ctx.moveTo(x, y);
                    else
                        ctx.lineTo(x, y);
                }
                ctx.closePath();

                /* draw shadow - not used in IOS for performance reasons  */
                if (!mrm.util.iOS() && !options.transparent) {
                    ctx.shadowColor = "rgba(0, 0, 0, .5)";
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = (options.direction === 'next') ? 10 : -10;
                    ctx.shadowOffsetY = 0;
                    ctx.fillStyle = "black";
                    ctx.fill();
                }

                ctx.save();
                ctx.clip(); // Clip to whatever path is on the context

                if ($.os.name === "ipad" || typeof theImage.img !== 'undefined') {
                    ctx.drawImage(theImage.img, theImage.x, theImage.y, theImage.w, theImage.h);
                }
                ctx.restore();
            }
        }

    });
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		mm_visualizer_1: {
			initTrack: function($mod, section){
				var self = this;
					clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				// Masthead Toggle (Interior/Exterior) - graphical
				$mod.on(clickOrTouch, ".int_ext_toggle.cgiToggle", function(){
					var linkname = $.trim($(this).find(".toggleCaption.hide_toggle").text());
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "toggle:" + linkname});
				});

				// Masthead Toggle (Interior/Exterior) - buttons
				$mod.on(clickOrTouch, ".int_ext_toggle.btnToggle", function(){
					var linkname = $.trim($(this).find("p.activeToggle").text());
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "toggle:" + linkname});
				});
				
				// Masthead Convertible Top Toggle
				$mod.on(clickOrTouch, ".topToggleBtn p", function(){
					var linkname = $.trim($(this).text());
					mrm.util.trackEvent('click_cta', {section: "masthead", linkname: "toggle:" + linkname});
				});
				
				// Masthead Left Arrow
				$mod.on(clickOrTouch, ".viz_scroller .prev", function(){
					var photoname = $(this).parent().find('.ui-helper-visible img').attr('src');
					
					if(photoname.indexOf(".gen")){
						photoname = self.getCGIName(photoname);
					}
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "arrow:prev:" + photoname});
				});
				
				// Masthead Right Arrow
				$mod.on(clickOrTouch, ".viz_scroller .next", function(){
					var photoname = $(this).parent().find('.ui-helper-visible img').attr('src');
					
					if(photoname.indexOf(".gen")){
						photoname = self.getCGIName(photoname);
					}
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "arrow:next:" + photoname});
				});
				
				// masthead_dots
				$mod.on(clickOrTouch, ".viz_scroller .mmScrollPagination li a", function(){
					var photoname = $mod.find('.ui-helper-visible img').attr('src');
					
					if(photoname.indexOf(".gen")){
						photoname = self.getCGIName(photoname);
					}
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "dots:" + photoname});
				});
				
				// masthead_cta (outside of the visualizer)
//				$mod.parent().find('.mh_overlay_links').on(clickOrTouch, "a", function(){
//					var linkname = $.trim($(this).text());
//					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "button:" + linkname});
//				});
				// masthead_cta (within cluetip visualizer)
				$('#cluetip').on(clickOrTouch, ".visualizer_cluetip_rebuild a", function(){
					var linkname = $.trim($(this).text());
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "button:" + linkname});
				});
				// masthead_cta (btn_prim)
				$mod.on(clickOrTouch, ".btn_prim", function(){
					var linkname = $.trim($(this).text());
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "button:" + linkname});
				});

				// Visualizer
				
				// visualizer category
				$mod.on(clickOrTouch, ".mm_visualizer_item_1 ul li", function () {
					var linkname = $(this).text();
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname : "visualizer:cateogry:" + linkname});
				});
				// visualizer trim
				$mod.on(clickOrTouch, ".viz_data_holder .trims .main", function () {
					var linkname = $(this).attr("id");
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "visualizer:trim:" + linkname});
				});
				// visualizer trim detail
				$mod.on('onDetailClick', ".list_wrap.trims a.details", function(){
					var linkname = $(this).closest("li").find("a.main").attr("id");
					mrm.util.trackEvent('click_cta', {section:'masthead',linkname:'visualizer:trim:' + linkname + ':detail'});
				});
				// on zoom click
				$mod.on('onZoomClick', function(){
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "zoom"});
				});
				// zoom close 
				$mod.on('onZoomClose', function(){
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname: "zoom:close"});
				});
				// visualizer exterior color
				$mod.on(clickOrTouch, ".viz_data_holder .colors a ", function () {
					var linkname = $("#cluetip-inner").text();
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname : "visualizer:color:exterior:" + linkname});
				});
				// visualizer wheels
				$mod.on(clickOrTouch, ".viz_data_holder .wheels a", function () {
					var linkname = $(this).attr("id");
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname : "visualizer:wheels:" + linkname});
				});
				// visualizer interior color
				$mod.on(clickOrTouch, ".viz_data_holder .interiors a", function () {
					var linkname = $("#cluetip-inner").text();
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname : "visualizer:color:interior:" + linkname});
				});
				// visualizer body
				$mod.on(clickOrTouch, ".viz_data_holder .bodyStyles .tips", function () {
					var linkname = $("#cluetip-inner").text();
					mrm.util.trackEvent("click_cta", {section: "masthead", linkname : "visualizer:body:" + linkname});
				});
			},
			
			getCGIName: function(photoname){
				var src_url = mrm.util.getUrlParam("i", photoname.substr(photoname.indexOf("?")) ),
					deg = mrm.util.getUrlParam("v", photoname.substr(photoname.indexOf("?")) );			
					
					return src_url.substr(src_url.lastIndexOf("/")+1) + deg;
			}
			
		}
	});
}(mrm.$));
(function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		nav_anchor_1: {

			/**
			 * JS for component nav_anchor_1
			 *
			 * @param {jQuery} $mod module context
			 */
			initMod: function($mod) {
				if ( !$mod.is('.two-column.ui_layout_vertical') ) {
					return;
				}

				// reposition the lis
				var $ul = $('> ul', $mod);
				var $li = $('> li', $ul);
				var splitIndex = /* Math.ceil replaced by */-~($li.length/2);

				var $li2ndCol = $li.filter(function(index) {
					return index >= splitIndex;
				});

				$ul.after($('<ul />').append($li2ndCol));
			}
		}
	});
}(mrm.$));
(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		nav_anchor_1: {
			tpl:['06'],
			init: function($mod){
				mrm.util.log('[mrm.cmp.nav_anchor_1] Context: ' + $mod);

				if ($("html").hasClass("firefox")) {
					$("div.modNav_anchor_1.ui_layout_horizontal_enhanced li").css("margin-top","8px");
				}

				if ($('div.modNav_anchor_1.ui_layout_horizontal_enhanced').length) {
					this.sticky_init('div.modNav_anchor_1.ui_layout_horizontal_enhanced', null, null, 1500, "easeOutExpo");
				}
			},
			checkScrollPosition_yOffset: null,
			sticky_init: function (navElement, headerElement, contentElement, scrollDuration, scrollEase) {
				var self = this;
				var $navElement = $(navElement).parent(),
					stopHeight = $(headerElement).outerHeight(),
					navOffset = $navElement.outerHeight(),
					minTop = ($navElement.offset().top + $(".mds-area-header").outerHeight(true) ) ,
					anchorList = new Array(),
					anchorIDs = new Array(),
					contentList = new Array(),
					clickTesting = false,
					scrollCount = 1,
					previousOption = "",
					pageTitle = document.title,
					navOffset = 0,
					ie = (document.all && !window.opera && window.XMLHttpRequest) ? true : false;
				// the ui_layout_horizontal class is applied to modNav_anchor_1 but
				// needs to be added to it's parent (.nav_anchor_c1) too
				$navElement.addClass("ui_layout_horizontal_enhanced");

				// set this value once on load so don't have to calculate on every scroll
				if ( $(".mds-area-header").hasClass("enhanced_navigation") ) {
					var navSecOuterHeight = $(".modNav_sec").outerHeight(false),
						navSecBorderBottom = parseInt($(".modNav_sec").css("border-bottom-width").replace("px","")),
						navElementMarginTop = parseInt($navElement.css("margin-top").replace("px","")),
						navSecBorderTop = parseInt($(".modNav_sec").css("border-top-width").replace("px",""));

					self.checkScrollPosition_yOffset = navSecOuterHeight - navSecBorderBottom - navElementMarginTop - navSecBorderTop;
				}
				else {
					self.checkScrollPosition_yOffset = $(".mds-area-header").outerHeight(true) - $navElement.css("margin-top").replace("px","");
				}

				var enabled_checkScrollPosition = true;

				$(navElement + " a").each(function (index) {
					anchorList.push($(this));
					anchorIDs.push($(this).attr('href').replace("#",""));
				});
				$(anchorIDs).each(function (index) {
					contentList.push($(".mds-cmp-content20[id='" + this + "']"));
				});
				$(window).scroll(function () {
					checkScrollPosition();
				});
				$(window).bind("touchmove", function (event) {
					checkScrollPosition();
				});
				$(document).onscroll = function () {
					checkScrollPosition();
				};
				$(document).onhashchange = function(e) {
					$(window).on("hashchange", repositionAnchor); // on hash change
				};

				function bindClicks() {
					$(anchorIDs).each(function (index) {
						$('.mds-area-content a[href="#' + this + '"]').bind("click", function (e) {
							e.preventDefault();
							doAnimate(this);
						});
					});
				}

				function doAnimate(el){
					// scroll to $(el)'s position
					enabled_checkScrollPosition = false;
					var clickedAnchor = $(el).attr("href");

					var item = $(el).attr("href");

					// calculate height of navigation
					var navAnchorHeight = parseInt($(".modNav_anchor_1").parent().outerHeight(true));
					if ( $(".mds-area-header").hasClass("enhanced_navigation") ) {
						// enhanced navigation structure
						var navSecHeight = parseInt($(".modNav_sec").outerHeight(true));
						navOffset = 0 - (navAnchorHeight + navSecHeight);
					}
					else {
						// normal (old) navigation structure
						navOffset = -83;
						var navHeaderHeight = $(".mds-area-header").outerHeight();
						navOffset = 0 - (navAnchorHeight + navHeaderHeight);
					}

					var offset = ($(item).offset().top) + navOffset;

					if ( mrm.util.iPad() ){
						jQuery.fx.interval = 26;
					}

					$("html, body").stop().animate({
						scrollTop: offset
					}, scrollDuration, scrollEase, function () {
						if ( mrm.util.iPad() ) {
							$navElement.removeClass("fixed").next();
						}
						enabled_checkScrollPosition = true;
					});
				}

				function checkScrollPosition() {
					// function runs as user scrolls window
					// will lock nav_anchor_1 in fixed position when scrolling down
					var winScroll = $(window).scrollTop();
					var yOffset = self.checkScrollPosition_yOffset; // pixels from top to fix nav_anchor_1 position
					var marginTop = $navElement.css("margin-top");
					// when component goes from position:relative to position:fixed, need
					// to keep component's height by adding it to margin in component's parent
					var compHeight = $navElement.outerHeight(true);

					if ( (winScroll + yOffset + (compHeight/2) ) > minTop) {
						$navElement.addClass("fixed").css("top", yOffset + "px");
						$navElement.parent().css("margin-bottom", compHeight + "px");
						$(".modNav_anchor_1 .backToTop").show();
					} else {
						$navElement.removeClass("fixed").css("top", "0px");
						$navElement.parent().css("margin-bottom", "0px");
						$(".modNav_anchor_1 .backToTop").hide();
					}

					if (enabled_checkScrollPosition) {
						for (var i=0; i<anchorList.length; i++) {
							if ( contentList[i].offset() !== null) {
								var topRange = contentList[i].scrollTop() + (navOffset - 5);
								var bottomRange = (topRange + contentList[i].height());
								if (winScroll < bottomRange && winScroll > topRange) {
									$(anchorList[i]).addClass("active");
								} else {
									$(anchorList[i]).removeClass("active");
								}
							}
						}
					}

					// this stuff only happens once
					if (scrollCount === 2) {
						repositionAnchor();
						scrollCount++;
					}
				}

				function repositionAnchor(){
					setTimeout(function(){
						var currentHash = window.location.hash;
						for (var i=0; i<anchorList.length; i++) {
							var iteredAnchor = anchorList[i];
							var iteredAnchorHREF = iteredAnchor.attr('href');
							if (currentHash === iteredAnchorHREF){
								var newScrollPosition = (mrm.$(iteredAnchorHREF).offset().top) - (navOffset - 2);

								$("html, body").stop().animate({
									scrollTop: newScrollPosition
								},  scrollDuration, scrollEase, function () {
									if ( mrm.util.iPad() ) $navElement.removeClass("fixed").next().css("padding-top", "1px");
								});
								return;
							}
						}
					}, 10);
				}

				bindClicks();
				checkScrollPosition(); //this forces the nav to adjust when refreshing a page that has been scrolled.  Otherwise the nav doesn't adjust until the user scrolls
			}
		}
	})
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		nav_anchor_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				// tracking for sticky nav links
				$mod.find("li a").on(clickOrTouch, function(){
					var linkname = $(this).text();
					mrm.util.trackEvent("click_cta", {section: "sticky nav", linkname: "link:" + linkname});
				});

				//tracking for features added
				$mod.find("div.wl_nav_1").on(clickOrTouch, function(){
					mrm.util.trackEvent("click_cta", {section: "sticky nav", linkname: "link:Features Added"});
				});
			}
		}
    });
}(mrm.$));;(function($) {
	mrm.mod.Nav_carlinefamily_selection_1 = mrm.mod.AbstractMod.extend({
		
		events: {
		},

		prepare: function() {
			var self = this;

			var $carlines = this.$ctx.find('ul > li > .modVi_vs_1');
			var rowLength = 5;
			var rowCount = Math.ceil($carlines.length / rowLength);
			var equalHeightElements = [$carlines.children('h3.vt')];
			var $list = this.$ctx.children('ul');

			this.$ctx.addClass('cols' + Math.min($carlines.length, rowLength));
			
			for (var i = 0; i < rowCount * rowLength; i += rowLength) {
				$.each(equalHeightElements, function() {
					$(this).slice(i, i + rowLength).equalHeights();
				});
			}

			var $scrollContainer = mrm.ui.scrollbars.applyScrollbarsTo($list, self.cfg.height);
			if ($scrollContainer.hasClass('jspScrollable')) {
				this.$ctx.addClass('hasScrollbar');
				mrm.ui.scrollbars.remove($scrollContainer);
				$scrollContainer = mrm.ui.scrollbars.applyScrollbarsTo($list);
				$scrollContainer.addClass('jspStyle2');
			}
		}
	});
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		nav_extended_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				// tracking for sticky nav links
				$mod.find("li a").on(clickOrTouch, function(){
					var linkname = $(this).text();
					mrm.util.trackEvent("click_cta", {section: "sticky nav", linkname: "link:" + linkname});
				});
			}
		}
    });
}(mrm.$));(function ($) {
    mrm.cmp = mrm.cmp || {};
        $.extend(mrm.cmp, {
            nav_footer:{

            /**
             * JS for component nav_footer
             *
             */
            init:function (c) {
            	/* hides .nav_footer_c1_row2 if it is empty */
            	var a = $('#mds-cmp-nav_footer .nav_footer_c1_row2 ul');
            	var b = $.trim( a.children('li').find('.modSnlil_2').html() ).length + $.trim( a.children('li').eq(1).find('.modSnlil_2').html() ).length;
                if ( b === 0) {
                	$('#mds-cmp-nav_footer .nav_footer_c1_row2').css('display','none');
                };
                
            }
        }
    });
}(mrm.$));(function($) {
    /**
     * Nav_glossary_1 module implementation.
     *
     * @author Deepthought\mase
     */

	$.extend(mrm.cmp, { nav_glossary_1: {
		/**
		 * JS for component nav_glossary_1
		 *
		 * @param {jQuery} $mod module context
		 */
		tpl: ['14'],
		init: function(c) {
			mrm.util.log('[mrm.cmp.seo_text] Context: ' + c);

		},

		initMod: function($mod) {

			var $scrollBox = $('.resultList', $mod);

			$scrollBox.jScrollPane({
				showArrows: false
			});

			this.bindModEvents($mod);
		},

		showSearchResults: function($mod, data){
			var self = this;

			$('.noResultInfo').addClass('ui-helper-hidden');
			$('.resultInfo').removeClass('ui-helper-hidden');
			if (data.results.length == 0) {
				$('.noResultInfo').removeClass('ui-helper-hidden');
				$('.resultInfo').addClass('ui-helper-hidden');
			}

			// add results info
			$mod.find('.resultInfo .count').html(data.results.length);
			$mod.find('.resultInfo .searchterm').html(data.searchterm);
			$mod.find('.noResultInfo .searchterm').html($('.modGlossary_control_1 form.searchform input[type=text]').val());

			// add results to list
			$mod.find('.resultList ul').empty();
			$.each(data.results, function(index, result){
				$.each($mod.data().allResults, function(){
					if ($(this).find('a').attr('href') == '#'+result){
						$mod.find('.resultList ul').append($(this));
					}
				});
			});

			self.reInitResultsPane($mod);
			self.updateDisplay($mod);
		},

		resetFilter: function($mod){
			$mod.find('.navLinks li.active').removeClass('active');
		},

		resetSearch: function(){
			$('.modGlossary_control_1 form.searchform input[name=q]').val('');
			$('.resultInfo').addClass('ui-helper-hidden');
		},

		filterResults: function($mod, e){
			var self = this;

			/*e.preventDefault();
			e.stopPropagation();*/

			// make sure to remove detail view
			self.hideDetails();

			// highlight the right filter
			$('.navLinks li.active').removeClass('active');
			$(e.target).parent().addClass('active');

			// reset search field
			this.resetSearch();

			// de-highlight any entries
			$('.modGlossary_results_1 .modCnt_glossary_1').removeClass('highlighted');

			// filter the results

			$mod.find('.resultList ul').empty();

			var resetDisplay = false;

			if ($(e.target).parent().hasClass('all')) {

				e.preventDefault();
				e.stopPropagation();

				resetDisplay = true;

				$mod.find('.resultList ul').append($mod.data().allResults);

			} else if ($(e.target).parent().hasClass('popular')) {

				e.preventDefault();
				e.stopPropagation();

				$.each($mod.data().allResults, function(){
					if ($(this).data().popular == 1){
						$mod.find('.resultList ul').append($(this));
					}
				});

			} else {
				var filterValue = $(e.target).text().toLowerCase();
				$.each($mod.data().allResults, function(){
					if (filterValue.charAt(0) == '0'){
						if ( $(this).find('a').text().charAt(0).toLowerCase() >= 0 && $(this).find('a').text().charAt(0).toLowerCase() <= 9){
							$mod.find('.resultList ul').append($(this));
						}
					} else {
						if ( $(this).find('a').text().charAt(0).toLowerCase() == filterValue ){
							$mod.find('.resultList ul').append($(this));
						}
					}
				});

			}

			self.reInitResultsPane($mod);
			self.updateDisplay($mod, resetDisplay);
		},

		updateDisplay: function($mod, resetDisplay){
			var $links = $mod.find('.resultList ul li a');

			if (resetDisplay){
				$('.modGlossary_results_1 .modCnt_glossary_1, .modGlossary_results_1 .modNav_az_item_1, .modGlossary_results_1 .cnt_anchortitle_1').removeClass('ui-helper-hidden');
			} else {
				$('.modGlossary_results_1 .modCnt_glossary_1, .modGlossary_results_1 .modNav_az_item_1').addClass('ui-helper-hidden');
				$('.modGlossary_results_1 .cnt_anchortitle_1').removeClass('ui-helper-hidden');
				$.each($links, function(){
					var target = $(this).attr('href');
					$(target).removeClass('ui-helper-hidden');
					$(target).parents('.modNav_az_item_1').removeClass('ui-helper-hidden');
					$(target).parents('.modNav_az_item_1').find('.cnt_anchortitle_1').addClass('ui-helper-hidden');
				});
			}
		},

		reInitResultsPane: function($mod){
			var pane2api = $mod.find('.resultList').data('jsp');
			//mrm.util.log(pane2api);
			pane2api.reinitialise();
		},

		showEntry: function($mod, e){
			/*e.preventDefault();
			e.stopPropagation();*/

			// make sure to remove detail view
			this.hideDetails();

			var entryHash = $(e.target).attr('href');

			$('.modGlossary_results_1 .modCnt_glossary_1, .modGlossary_results_1 .cnt_glossary_item_c1').removeClass('highlighted');
			$(entryHash).parents('.cnt_glossary_item_c1').addClass('highlighted');
		},

		showDetails: function(html){
			$('.modGlossary_results_1 .detailView').html(html).removeClass('ui-helper-hidden');
			$('.modGlossary_results_1 .modNav_az_item_1').addClass('details-active');
		},

		hideDetails: function(html){
			$('.modGlossary_results_1 .detailView').html('').addClass('ui-helper-hidden');
			$('.modGlossary_results_1 .modNav_az_item_1').removeClass('details-active');
		},

		bindModEvents: function($mod){
			var self = this;

			//store all results list in data()
			$mod.data({
				allResults: $mod.find('.resultList ul li')
			});

			$('.modGlossary_results_1 .detailView').addClass('ui-helper-hidden');

			// fix some stickybox issues by giving our results area a min-height
			$('.modGlossary_results_1').css('min-height', $('.modGlossary_control_1').outerHeight());

			$mod.find('.resultList li > a').live('click', function(e){
				self.showEntry($mod, e);
			});

			$mod.find('.navLinks li.disabled a').live('click', function(e){
				e.preventDefault();
				e.stopPropagation();
			});

			$mod.find('.navLinks li:not(.disabled) a').live('click', function(e){
				self.filterResults($mod, e);
			});

			$('.modGlossary_control_1 form.searchform').bind('submit', function(e){
				e.preventDefault();
				e.stopPropagation();

				var $form = $(this);
				var formQuery = $form.serializeArray();
				var formData = {};

				$.each(formQuery, function(i, param) {
					formData[param.name] = param.value;
				});

				$.ajax({
					url: $form.attr('action'),
					dataType: 'json',
					data: formData,
					type: $form.attr('method')
				})
				.done(function(data) {
					data.searchterm = formData.q;
					self.showSearchResults($mod, data);
					self.resetFilter($mod);
				});
			});


			// more links
			$('.modGlossary_results_1 a').live('click', function(e){

				if ($(this).data().snippet != undefined){
					e.preventDefault();
					e.stopPropagation();

					var snippetUrl = $(this).data().snippet;

					$.ajax({
						url: snippetUrl
					}).done(function(data) {
						self.showDetails(data);
					});
				}

			});

		}

	}});
}(mrm.$));
(function($) {

	// check if cadillac exist in url and trigger mask for shopping tools dropdown by appending to #containere
	var patternToSearch = /cadillac/i,
        currentURL      = $(location).attr('href');

    var isCadillac      = patternToSearch.test(currentURL);

	mrm.mod.Nav_meta = mrm.mod.AbstractMod.extend({
		$mNavJsItems: $(),

		prepare: function() {
			var self = this;

			self.$mNavJsItems = $(self.cfg.menuItemTriggerSelector)
                .on('click', function (e) {
                        e.preventDefault();
                })
            .closest(self.cfg.menuItemParentSelector);

			self.$mNavJsItems.on('click.navMeta', function (e) {
				var $activeItem = $(this);
				var $dropDown = $activeItem.find('dd.content:eq(0)');

				if ($(e.target).hasClass('ln_modal_ext')){
					return;
				} else if ( $(e.target).closest('dd.content').is($dropDown) ) {
					// exit if the inside of the dropdown was clicked
					e.stopPropagation();
					return;
				}

				if (!$activeItem.hasClass('visible')) {
					e.stopPropagation();
					self.showDropdown($dropDown, $activeItem);
				} else {
					self.hideDropdown($activeItem);
				}
			});

			$(self.$ctx).find(".modNav_tools_1 .iconlink").parent().on('mouseenter', function() {
				$(this).find('div.iconContainer .mm').css('display', 'none');
				$(this).find('div.iconContainer .mm.hover').css('display', 'block');
			});
			$(self.$ctx).find(".modNav_tools_1 .iconlink").parent().on('mouseleave', function() {
				$(this).find('div.iconContainer .mm').css('display', 'block');
				$(this).find('div.iconContainer .mm.hover').css('display', 'none');
			});
		},

		showDropdown: function($dropDown, $parent) {
			var self = this;

			if(isCadillac){
			  mrm.ui.layer.mask($("#container"), 'show', 200);
			}

			self.$mNavJsItems.not($parent).removeClass('visible');
			$parent.addClass('visible');

			$dropDown.trigger('headerFlyoutOpened');

			$('body').on('click.navMeta', function() {
				self.hideDropdown($parent);
			});

			$('#mds-area-header').on('headerFlyoutOpened.navMeta', function(e) {
				if (!$(e.target).closest('.modNav_meta').length) {
					self.hideDropdown($parent);
				}
			});

			if (self.cfg.positionDropdown) self.positionDropdown($dropDown, $parent);
		},

		hideDropdown: function($parent) {
			if(isCadillac){
            	mrm.ui.layer.mask($("#container"), 'hide', 200);
           	}

			$('body').off('click.navMeta');
			$('#mds-area-header').off('headerFlyoutOpened.navMeta');
			$parent.removeClass('visible');
		},

		positionDropdown: function($dropDown, $parent) {
			var self = this;
			$dropDown
				.width(function (i, currentWidth) { return currentWidth; })
				.position($.extend({of: $parent}, self.cfg.positionCfg));
		}

	});
})(mrm.$);( function( $ ) {
	mrm.cmp = mrm.cmp || {};
	mrm.cmp.nav_modelchanger_1 = mrm.cmp.nav_modelchanger_1 || {};
	$.extend( mrm.cmp.nav_modelchanger_1, {
		clickOrTouch: (mrm.util.touchDevice()) ? "touchstart" : "click",
		initMod: function( $mod ) {
			var self = this;

			// Model Changer can be in main body or at top of page. The 'toggle' class is added
			// by the backend to indicate that its for the top of page. Otherwise it is inline.

			if ( $mod.find( '.nav_modelchanger_menu' ).hasClass( 'toggle' ) ) {
				$mod.find( '.nav_modelchanger_1' ).addClass( 'top' );
				// add directional carets
				$( '#nav_modelchanger_tab .togon' ).append( '<div class="togarrow">&gt;</div>' );
				$( '#nav_modelchanger_tab .togoff' ).append( '<div class="togarrow">&or;</div>' );

			} else {
				$mod.find( '.nav_modelchanger_1' ).addClass( 'inline' );
			}

			// secondary button styling
			$( '.cta' ).each( function() {
				$( this ).find( 'li:not( :first ) a' ).each( function() {
					$( this ).removeClass( 'btn_prim' ).addClass( 'btn_sec' );
				});
			});


			if ( !$( '#nav_modelchanger_tab' ).hasClass( 'author_mode' ) ) {
				/* >> not in author mode >>>>> */

				if ( $mod.find( '.nav_modelchanger_menu' ).hasClass( 'toggle' ) ) {
					$mod.find( '#nav_modelchanger_tab' ).appendTo( '#mm_colorizer_c1' );
					$mod.find( '.nav_modelchanger_menu' ) // appends big flyout div to bottom of container
						.insertAfter( '.masthead' )
						.addClass( 'top' );
				}

			} else {
				/* >> in author mode >>>>> */
			}

			// $mod.css( 'visibility', 'visible' ); // prevents model changer from flashing in masthead before loading

			if ( mrm.util.iPad() ) {    // delegate mouse or touch events
				this.touchHandler();
			} else {
				this.mouseHandler();
			}
			var self = this;
			

		},
		toggleTabClick: function () {
			var that = this;
			$( '#nav_modelchanger_tab div' ).toggleClass( 'on' );
			$( '#nav_modelchanger_tab div span' ).toggle();
			$( '.nav_modelchanger_1' ).toggleClass( 'active' );
			return;
		},
		openToolTip: function ( context ) {
			this.hideAllOpen();
			var exLayer = context.find( '.exp_lyr' );

			exLayer.addClass( 'flyoutvisible' );

			// Keep flyouts within left and right sides of the mds-area-content div
			var boundL  = Math.round( $( '.mds-area-content' ).offset().left ),    // px from screen to left edge
				boundR = boundL + Math.round( $( '.mds-area-content' ).outerWidth() ),
				curposL  = Math.round( exLayer.offset().left ),                     // left-most edge of the opened flyout
				curposR  = Math.round( exLayer.offset().left + exLayer.width() );   // right-most edge of the opened flyout

				// console.log( 'curposL:' + curposL + ' boundL:' + boundL +' | ' + 'curposR:' + curposR + ' boundR:' + boundR );

			if ( curposL < boundL ) { // left exLayer appears beyond .mds-area-content
				var $this   = context.find( '.exp_lyr' ),
					adjLeft = boundL - curposL,
					osEL    = parseInt( $this.css( 'left' ) ) + adjLeft;
					osELn   = parseInt( $this.find( '.nugget' ).css( 'left' ) ) - adjLeft;

				applyOffset( osEL, osELn );

			} else if ( curposR > boundR ) { // left exLayer appears beyond .mds-area-content
				var $this   = context.find( '.exp_lyr' ),
					adjRight = curposR - boundR,
					osEL    = parseInt( $this.css( 'left' ) ) - adjRight;
					osELn   = parseInt( $this.find( '.nugget' ).css( 'left' ) ) + adjRight;

				applyOffset( osEL, osELn );
			}

			function applyOffset ( osEL, osELn ) {
				$this.css( 'left', osEL);
				$this.find( '.nugget' ).css( 'left', osELn);
				$this.find( '.nuggetshadow' ).css( 'left', osELn);
				return;
			}

			return;
		},
		hideAllOpen: function ( x ) {
			$( '.flyoutvisible' ).removeClass( 'flyoutvisible' );
			return;

		},
		mouseHandler: function () {
			var that = this;
			// attach mouseenter mouseleave event handler

			$( '#nav_modelchanger_tab' ).on( {   // model changer tab
				click: function( evt ) {
					that.toggleTabClick();
				}
			});
			$( '.nav_modelchanger_1' ).on( {    // container div
				mouseleave: function( evt ) {
					that.hideAllOpen();
				}
			});
			$( '.mcjb' ).on( {   // model changer jelly bean
				mouseenter: function( evt ) {
					that.openToolTip( $( this ) );
				},
				mouseleave: function( evt ) {
					that.hideAllOpen();
				}
			});

			// add close button
			$( '.exp_lyr_inner' ).each( function() {
				$( '<div class="close">close</div>' ).prependTo( this );
			});
			$( '.close' ).on( {
				click: function( evt ) {
					that.hideAllOpen();
				}
			});


		},

		touchHandler: function () {
			// attach touchstart touchend event handler
			var that = this;

			$( '.exp_lyr_inner' ).each( function() {
				$( '<div class="close">close</div>' ).prependTo( this );
			});
			$( '.close' ).on( {
				click: function( evt ) {
					that.hideAllOpen();
				}
			});

			$( '#nav_modelchanger_tab' ).on( {
				touchend: function() {
					that.hideAllOpen();
					that.toggleTabClick();
				}
			});
			$( '.mcjb' ).on( {
				touchend: function() {
					that.hideAllOpen();
					that.openToolTip( $( this ) );
				}

			});
		},
	});
}(mrm.$));;(function($) {
	mrm.mod.Nav_modelswitch_1 = mrm.mod.AbstractMod.extend({
		sliding: false, // boolean - true if currently in process of sliding
		events: {
		},

		prepare: function() {
			var self = this;
			var $mod = self.$ctx;

			$mod.parent().find("a.other_models").click(function(event) {
				event.preventDefault();
				self.togglePopup($mod);
			});

			// reconfigure padding based on number of items
			var numItems = $mod.find("li .modelswitch_item").length;
			switch(numItems) {
			    case 3:
			    	$mod.find(".modelswitch_item").css("padding","0 74px");
			    	break;
			    case 4:
			    	$mod.find(".modelswitch_item").css("padding","0 36px");
			    	break;
			    case 5:
			        $mod.find(".modelswitch_item").css("padding","0 13px");
			        break;
			    default:
			    	$mod.find(".modelswitch_item").css("padding","0 13px");
			    	break;
			        // 6 items - default setting - no special css required
			}


			$(".modNav_tools_1 a").on("click", function(){
				$mod.slideUp();
				mrm.ui.layer.mask($("#container"), 'hide', 200);
				$(".enhanced_navigation .modNav_sec dt a.other_models").removeClass("active");
				$('body').off('click.modelswitch');
			});
		},
		togglePopup: function($mod) {
			var self = this;
			self.sliding = true;

			cfg = $.extend({
				delayOut: 850, // unused if openOnClick is true
				delayIn: 250,  // unused if openOnClick is true
				openOnClick: false, // if true, the navigation works on click only instead of mouseenter/leave events
				followRootLevelLink: true, // should the root level links be followed when clicked?
				showMask: true, // if true, 'div.window-mask' is prepended to <body> and layered behind the modal
				maskSpeed: 200,
				maskContainer:'#container',
				enableHideAllMethod:true // used when menu content is hidden from outside methods
			}, mrm.conf.cmp.nav_prim || {} );

			$mod.slideToggle( function(){
				self.sliding = false; // sliding has finished
				
				if ($mod.is(":visible")) {
					mrm.ui.layer.mask($(cfg.maskContainer), 'show', cfg.maskSpeed);
					
					$('body').on('click.modelswitch', function(e) {
						if (self.sliding === false) {
							self.togglePopup($mod);
						}
					});
				}
				else {
					$('body').off('click.modelswitch');
					mrm.ui.layer.mask($(cfg.maskContainer), 'hide', cfg.maskSpeed);
				}
			});
		}
	});
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		nav_modelswitch_1: {
			initTrack: function($mod){
				if (!$mod.length) return;

				var self = this,
				brand = Omniture_s.eVar18.toLowerCase(),
				pageName = Omniture_s.pageName;
				//set up click tracking on ajax load of nav
				$mod.find('.modelswitch_item a').removeAttr('onclick');
				self.setupTracking($mod, brand, pageName);
			},
			setupTracking: function($mod, brand, pageName) {
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				var section = '2ndlevel-nav';			
				if ($mod.length) {
					// Other Models Link tracking
					$mod.siblings('.other_models').on(clickOrTouch, function() {
						mrm.util.tagging.omniture_tl(
							$(this), '2ndlevel-nav', 'o', '',
							{
								'pageName':pageName,
								'prop27':section,
								'prop32':section + ':' + $(this).text()
							}
						);					
					});
					// Vehicle Model tracking
					$mod.find('.modelswitch_item a').on(clickOrTouch, function(){
						var section = '2ndlevel-nav:other models';
						mrm.util.tagging.omniture_tl(
							$(this), '2ndlevel-nav', 'o', '',
							{
								'pageName':pageName,
								'prop27':section,
								'prop32':section + ':' + $(this).children('.modelswitch_item_title').text()
							}
						);
					});
				}
				
				
			}
		}
	});
			
}(mrm.$));/*
modes:
followTopLevelLink : true|false
*/

/*
	 2008 by 	Nol Bossart, namics ag
				Michael Sindlinger, Nolte & Lauth
				RTL i18n added by Ralph Brandi, MRM Worldwide
*/
(function($) {
	var timeoutIn, $firstLvlNav, $rootLvlLinks, currObj,
		cssPlacement = $("html").attr("dir") !== "rtl" ? "left" : "right",
		baseballcards = [],
		firstCardVisible = false,
		flyoutVisible = false,
		isClickNav = false,
		cfg = $.extend({
			delayOut: 850, // unused if openOnClick is true
			delayIn: 250, // unused if openOnClick is true
			openOnClick: false, // if true, the navigation works on click only instead of mouseenter/leave events
			followRootLevelLink: true, // should the root level links be followed when clicked?
			showMask: false, // if true, 'div.window-mask' is prepended to <body> and layered behind the modal
			maskSpeed: 200,
			maskContainer:'#container',
			enableHideAllMethod:true // used when menu content is hidden from outside methods
		}, mrm.conf.cmp.nav_prim || {} );
	
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		nav_prim : {
			/**
			* Init menu events
			* @name mrm.cmp.nav_prim.init(c)
			*
			* @param {String} c DOM Context
			*/

			mouseOutTimer : 0,
			$touchedOnceLinks: $(), // registry for all links with state 'touchedOnce'

			// TODO: refator class names div.baseballcard occurs twice -> std bbc + cadillac bbc
			// TODO: it would be better if "bbc_div" would be added on serverside instead of "baseballcard" see loadBBC()


			init: function(c) {
				mrm.util.log('[menu.init] Context: ' + c);

				isClickNav = cfg.openOnClick || mrm.util.touchDevice();
				$firstLvlNav = $('#mds-cmp-1stlevelnavigation').addClass("ui-widget");
				$rootLvlLinks = $('ul:first > li > a', $firstLvlNav).not('[data-link-type="simple"]');

				if (!$('.modNav_prim_2', '.modNav_prim').length ) {
					$('ul ul li:last-child', $firstLvlNav).after('<li class="last"></li>');
					$('ul ul li:first-child, ul ul .bgiframe:first-child + li', $firstLvlNav).before('<li class="first"></li>');
				}
				

				$('ul ul a + ul', $firstLvlNav).prev('a').addClass('hasChildren');

				//Mark all BBC includes
				$('a[rel]', $firstLvlNav).addClass('includeBBC');

				this.setBindings();
				
				if (isClickNav && !cfg.followRootLevelLink) {
					$rootLvlLinks.each(function() {
						if (this.onclick) {
							$(this).data('delayedOnclick',  this.onclick);
							this.onclick = $.noop;
						}
					});
				}

				// mask NGDOE compatibility
				if (typeof(MRM_EXTERNAL_DOMAIN) === 'string')  cfg.maskContainer = '#mds-container';
			},

			setBindings : function() {
				var that = this;

				if ( !isClickNav )
				{
					$rootLvlLinks
						.on('mouseenter.navPrim', $.proxy(this.onMouseEnterFirstLevel, this))
					.closest('li')
						.on('mouseleave.navPrim', $.proxy(this.onMouseLeaveNavigation, this) )
						.on('mouseenter.navPrim', $.proxy(this.onMouseEnterNavigation, this) )
						.on('mouseenter.navPrim', 'a.hasChildren, a.includeBBC, ul.dropdown > li > a', $.proxy(this.prepareNextLevel, this) );
				}
				else
				{
					$rootLvlLinks.on('click.navPrim', $.proxy(this.clickHandler, this));
					var clickednav = ( $('.modNav_prim_2', $firstLvlNav).length ) ? 'loadNodeNav' : 'click.navPrim';

					$firstLvlNav.find('a.hasChildren, a.includeBBC').not($rootLvlLinks).on(clickednav, $.proxy(this.clickHandler, this));
					$('#mds-cmp-1stlevelnavigation ul:first > li > a').on("touchstart.navPrim", $.proxy(this.onMouseEnterFirstLevel, this))
						.closest("li.hover_active")
							.on("touchstart.navPrim", $.proxy(this.onMouseLeaveNavigation, this));
					$('div.veil').on("touchstart", $.proxy(this.onMouseLeaveNavigation, this));
					
				}
			},

			onMouseLeaveNavigation : function(event) {

				if ( $('.ui-dialog').is(':visible') ) return;

				clearTimeout(timeoutIn);

				var that = this;
				if(cfg.enableHideAllMethod) this.mouseOutTimer = window.setTimeout(that.hideAll, cfg.delayOut);

				if ( mrm.util.ie() ) {
					/* As in the IE family the cursor/caret of input and textarea bleeds through (#GMDSST-5459) we take the focus off the
					*  of the form field. Prior doing so, we save were the focus was and reset the focus when exiting the menu without choosing one of its entries.
					*  HFr.
					*/
					//set back the focus to a form element
					if (currObj != null && (currObj.tagName == 'INPUT' || currObj.tagName == 'TEXTAREA')) {
						$(currObj).focus();
						currObj = null;
					}
				}
			},

			onMouseEnterNavigation : function(event) {

				window.clearTimeout(this.mouseOutTimer);
			},

			onMouseEnterFirstLevel : function(event) {
				//Clear Other Timeouts
				clearTimeout(timeoutIn);

				var that = this,
					$currentLink = $(event.target).closest('a');
				//Show First Layer of navigation with start delay
				timeoutIn = window.setTimeout(function() {
					that.cleanUpFirstLevel($currentLink);
					that.prepareNextLevel($currentLink);
				}, cfg.delayIn);
			},

			clickHandler : function(event) {
				var self = this;
				var $currentLink = $(event.target).closest('a'),
					isRootLvlLink = $currentLink.is($rootLvlLinks);
				var isEnhancedNav = ($currentLink.siblings('.modNav_prim_2').length) ? true : false;
				if ((!cfg.followRootLevelLink && isRootLvlLink) || !this.isTouchedOnceLink($currentLink))
				{
					var doFlyout = true;
					if (typeof (self.optionalFlyout) === "object") {
						var optionalFlyout = self.optionalFlyout;
						optionalFlyout.init($currentLink);
						doFlyout = optionalFlyout.doFlyout;
					}
					if (doFlyout) {
						event.preventDefault();
					}
					event.stopPropagation();
				}

				if (isRootLvlLink)
				{
					this.cleanUpFirstLevel($currentLink);
				}
				if (isEnhancedNav) {
					self.enhancedNavigation($currentLink.siblings('.modNav_prim_2'));
				}

				if ( !this.isTouchedOnceLink($currentLink) )
				{
					this.resetTouchedOnceLinks($currentLink.closest('ul')); // "un-touch" all links on/below this level
					this.addTouchedOnceLinks($currentLink); // set current link touched
					this.prepareNextLevel($currentLink);
				}
				else if (!cfg.followRootLevelLink && isRootLvlLink && cfg.enableHideAllMethod)
				{
					this.hideAll();
					return;
				}
			},
			enhancedNavigation: function(node){
				// trigger event for node to open rather than click  (messes up tracking)
				if ( !node.parent('li').hasClass('li_active') ) {
					node.find('li a').first().trigger('loadNodeNav');
					$firstLvlNav.find('a.hasChildren, a.includeBBC').not($rootLvlLinks).on('click.navPrim', $.proxy(this.clickHandler, this));
				}
			},
			/**
			* only called when first level is entered
			*/
			cleanUpFirstLevel : function($currentLink) {
				//check if current navigation already opened if not, hide complete navigation without delay
				if ( !$currentLink.parent('li').hasClass('li_active') ) 
				{
					if( cfg.enableHideAllMethod ) this.hideAll();
				} 
				else 
				{
					if ( cfg.showMask ) mrm.ui.layer.mask($(cfg.maskContainer), 'hide', cfg.maskSpeed);
				}
			},

			/**
			*
			*/
			prepareNextLevel: function(eventOrCurrentLink) {

				var $currentLink = !eventOrCurrentLink.target ? eventOrCurrentLink : $(eventOrCurrentLink.target).closest('a');

				var bbcUrl = $currentLink.attr('rel');
				if ( bbcUrl === undefined || bbcUrl == '' )
				{
					this.nextLevelReady($currentLink); // next layer is ready, no bbc to load
				}
				else
				{
					this.loadBBC(bbcUrl, $currentLink);
				}
			},

			loadBBC : function(bbcUrl, $currentLink) {
				var $placeholder = $('<div class="placeholder visible"></div>');
				if ($currentLink.hasClass('bbc2ndLevel')){
					// place further bbcs after 1stlevel bbc in DOM, not possible to store it after calling link within 1stlevel bbc
					$currentLink.closest('.baseballcard.n03').after($placeholder);
				} else {
					$currentLink.after($placeholder);
				}

				$.ajax({
					dataType		: mrm.external ? 'jsonp' : 'html',
					url				: bbcUrl,
					cache			: true,
					jsonpCallback	: $currentLink.data('ngdoeCallback'),
					jsonp			: false, // remove callback GET param
					type			: 'GET',
					success			: $.proxy(function(data, textStatus, jqXHR) {

						if ( textStatus == 'success' )
						{
							this.onBbcLoaded(data, $placeholder, $currentLink);
						}
						this.nextLevelReady($currentLink);
					}, this)
				});

				$currentLink.removeAttr('rel');
			},

			onBbcLoaded : function(data, $placeholder, $currentLink) {
				var bbcIsVisible = $placeholder.hasClass('visible'),
					newId, $bbcContainer;

				if($currentLink.hasClass('bbc2ndLevel')) {
					// connect bbc and link via unique ID, bbc can not be placed after link as usual
					newId = 'bbc_' + new Date().getTime();
					$bbcContainer = $(data).attr('id', newId);
					$currentLink.data('bbcid', newId);
					$placeholder.replaceWith($bbcContainer);
				} else {
					$placeholder.replaceWith(data);
					$bbcContainer = $currentLink.next('.baseballcard');
				}

				// TODO: it would be better if "bbc_div" would be added on serverside instead of "baseballcard"
				if ( $bbcContainer.is('ul') ) $bbcContainer.find('div.baseballcard').addClass('bbc_div');

				if ( bbcIsVisible ) $bbcContainer.addClass('visible');

				if ( !this.isOnFirstLevel($bbcContainer) ) {
					if ($currentLink.parents('.modNav_prim_2')){
						$bbcContainer.addClass('second_node_nav');
						if ($currentLink.parents('.modNav_prim_2').hasClass('grid_style')) {
							$bbcContainer.addClass('g_style');
						}
					}
					var listWidth = $currentLink.closest('ul').width();
					if ($bbcContainer.hasClass('second_node_nav')){
						cssPlacement = 'left';
						if(!cfg.useActualWidth){
							listWidth = 0;
						}
					}
					$bbcContainer.css(cssPlacement, listWidth);
				}
				$bbcContainer.trigger('loadBBC');

				// find further bbc-links in n03, set bindings
				if ($bbcContainer.hasClass('n03')) {
					$('a[rel]', $bbcContainer).addClass('includeBBC bbc2ndLevel')
						.on('click.navBBC', $.proxy(this.clickHandler, this))
					.closest('.mod').on('click.navBBC', function(){
						$(this).find('a:first').trigger('click.navBBC');
					});
				}

				// set up net pricing cluetips
				$(".n02b .modNav_carline_selection_1 > ul > li dd a[cluetip-title*=' ']:not(.cluetip_applied)").addClass("nav_prim_cluetip cluetip_applied");
				$(".n01 .modVi_1 dl dd a[cluetip-title*=' ']:not(.cluetip_applied)").addClass("cluetip_vi_1 cluetip_applied");

                var b = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
					titleAttribute: "cluetip-title",
					activation: "click",
                    disableScroll: true
				});

                // remove added class so cluetip isn't applied multiple times to same element
				$('.nav_prim_cluetip').removeClass("nav_prim_cluetip").cluetipWrap(b);
				$('.cluetip_vi_1').removeClass("cluetip_vi_1").cluetipWrap(b);

				// initialize title modules that are used in the navigation.
				if ( $(data).find('.modMh_title_1').length ){
					mrm.util.initDomContent($('.modMh_title_1'));
				}
			},

			nextLevelReady: function($currentLink) {
				var that = this,
					delayedOnclick,
					$bbc;
				that.hideAllSubLayers($currentLink.closest('ul'));
				that.setParentLiActive($currentLink);

				if ( $currentLink.hasClass('includeBBC') ) {
					$bbc = ($currentLink.hasClass('bbc2ndLevel')) ? $('#'+$currentLink.data('bbcid')) : $currentLink.next('.baseballcard');
					if ( $bbc.is('ul') ) {
						that.setBaseballCardLinks($bbc);
					}
					$bbc.addClass('visible');
				}
				else if ( $currentLink.closest('ul').hasClass('bbcNav') ) {
					$currentLink.closest('li').siblings().find('a').each(function() {
						var $link = $(this), $bbc;

						if ( $link.data('toggle') ) {
							$bbc = $( $link.data('toggle') );
							// only trigger the event for baseballcards which actually are visible (get hidden)
							$bbc.filter('.visible').removeClass('visible').trigger('bbcContentHide');
						}
					});
					$bbc = $( $currentLink.data('toggle') );
					$bbc.addClass('visible').trigger('bbcContentShow');
				}
				else {
					that.showNextLayer($currentLink);
				}

				flyoutVisible = true;
				$currentLink.trigger('headerFlyoutOpened');
				$currentLink.trigger('firstLevelNavigationNextLevelReady');
				/*$firstLvlNav.trigger({
					type: 'firstLevelNavigationNextLevelReady',
					currentElement: mrm.cmp.firstlevelnavigation.$currentLink
				});	*/

				// avoid multiple bindings by unbinding old events
				$('body').off('click.navPrim');
				$('#mds-area-header').off('headerFlyoutOpened.navPrim');

				// then rebind
				// -> hide all on Click of a non-navigation element
				$('body').on('click.navPrim', function(e) {
					if ( flyoutVisible && ($(e.target).closest('a').closest('.modNav_prim').length || !$(e.target).closest('.modNav_prim').length) && !$(e.target).closest('#cluetip').length ) {
						if ( cfg.showMask ) mrm.ui.layer.mask($(cfg.maskContainer), 'hide', cfg.maskSpeed);
						if( cfg.enableHideAllMethod ) that.hideAll();
					}
				});

				// -> hide all if another module opens a flyout (e.g. modNav_meta)
				$('#mds-area-header').on('headerFlyoutOpened.navPrim', function(e) {
					if ( flyoutVisible && !$(e.target).closest('.modNav_prim').length ) {
						if ( cfg.showMask ) mrm.ui.layer.mask($(cfg.maskContainer), 'hide', cfg.maskSpeed);
						if( cfg.enableHideAllMethod ) that.hideAll();
					}
				});

				if (isClickNav && !cfg.followRootLevelLink) {
					delayedOnclick = $currentLink.filter($rootLvlLinks).data('delayedOnclick');
					if ($.isFunction(delayedOnclick)) {
						$.proxy(delayedOnclick, $currentLink[0])();
					}
				}
			},

			/* This function shows layer of selected navigation item
			* if next layer is baseballcard, show baseballcard else show next navigation layer
			* it doesn`t matter how much layer are there, it works from 1 to n
			*  */
			showNextLayer: function(hoveredLink) {
				var $nextLevel = hoveredLink.siblings('ul:first');

				$nextLevel
					.addClass('visible')
					.children('li')
						.removeClass('li_active');

				if (mrm.util.ie()) {
					/* As in the IE family the cursor/caret of input and textarea bleeds through (#GMDSST-5459) we take the focus off the
					*  of the form field. Prior doing so, we save were the focus was and reset the focus when exiting the menu without choosing one of its entries.
					*  HFr.
					*/
					//save the active form element in currObj
					if (currObj == null) {
						currObj = document.activeElement;
						//blur the form element - if it is an input or textarea
						if (currObj.tagName === "SELECT" || currObj.tagName === "INPUT")
							$(currObj).blur();
					}
				}

				if ( !this.isOnFirstLevel(hoveredLink) ) {
					$nextLevel.css(cssPlacement, hoveredLink.closest('ul').width());
				}
				/*
				else {
					// this might be useful if we must support normal layer + fullsize bbc
					var horizontalPosition = $nextLevel.closest('li').position().left;

					if ( cssPlacement == 'right' ) {
						horizontalPosition = horizontalPosition - ($nextLevel.offsetParent().outerWidth() - $nextLevel.closest('li').outerWidth());
					}

					$nextLevel.css('left', horizontalPosition);
				}
				*/

				$nextLevel.children("li:last").width($nextLevel.children('li:last').prev().width()+1);
			},

			isOnFirstLevel : function($element) {
				return $element.closest('ul').is($firstLvlNav.children('ul'));
			},

			/* Set Baseballcard Links */
			setBaseballCardLinks: function($bbcList) {
				var that = this;
				baseballcards = [];

				//Set switch functionality to baseballcard links
				$bbcList.find('div.bbc_div').each(function(i) {
					baseballcards[i] = $(this);
					$(this).parent().find('a:first').on('mouseover', function() {
						that.showBaseballCards(i);
					});
				});

				// if first baseballcard is invisible, show it
				if ( !firstCardVisible ) {
					this.showBaseballCards(0);
				}
			},

			/* Show Baseballcards
			* Class baseballcard -> invisible
			* Class baseballcard-_active -> visible
			*  */
			showBaseballCards: function(el) {

				firstCardVisible = true;

				var i;
				for (i=0; i<baseballcards.length; i++) {
					if (mrm.util.ie6()) {
						$("div.baseballcard.bbc_div", $firstLvlNav).css('display','none');
					}
					baseballcards[i].removeClass('active');
				}
				baseballcards[el].addClass("active");
				if (mrm.util.ie6()) {
					baseballcards[el].css('display','block');
					$(".baseballcard.visible").addClass("visibleBBC");
					$("li.baseballcard > a", $firstLvlNav).addClass("linkBBC");
					$("li.baseballcard + li > a", $firstLvlNav).addClass("listLinkBBC");
					$("li.baseballcard:first-child a", $firstLvlNav).addClass("pos1");
					$("li.baseballcard + li > a", $firstLvlNav).addClass("pos2");
					$("li.baseballcard + li + li> a", $firstLvlNav).addClass("pos3");
					$("li.baseballcard + li + li + li> a", $firstLvlNav).addClass("pos4");
					$("li.baseballcard + li + li + li + li> a", $firstLvlNav).addClass("pos5");
					$("li.baseballcard + li + li + li + li + li> a", $firstLvlNav).addClass("pos6");
					$("li.baseballcard + li + li + li + li + li + li> a", $firstLvlNav).addClass("pos7");
					$("div.baseballcard div.further", $firstLvlNav).addClass("furtherBBC");
					$("div.baseballcard div.further > a span", $firstLvlNav).addClass("furtherSpanBBC");
				}
			},

			/* Function for hide complete navigation layers - initial state */
			hideAll: function() {
				
				flyoutVisible = false;

				$firstLvlNav.trigger('firstLevelNavigationHideAll');

				//Reset all active classes of navigation root childs
				$('div.modBaseballcard.visible', $firstLvlNav).trigger("firstLevelNavHideAllClosedBbc");
				$('div.visible, ul.visible', $firstLvlNav).removeClass("visible");
				$('li.li_active', $firstLvlNav).removeClass("li_active");

				firstCardVisible = false;
				//reset Delay of display first navigation layer
				if ( isClickNav ) {
					this.resetTouchedOnceLinks();
				}
				$('body').off('click.navPrim');
				$('#mds-area-header').off('headerFlyoutOpened.navPrim');
			},

			/* Function for hiding a layer */
			hideAllSubLayers: function(el) {

				el.trigger('firstLevelNavigationHideAllSubLayers');

				el.find('> li > ul').removeClass("visible");
				el.find('> li > div').removeClass("visible");
				firstCardVisible = false;
			},

			/* Set parent li-tag of a-tag active */
			setParentLiActive: function(el) {

				el.parent()
					.addClass("li_active")
					.siblings()
						.removeClass("li_active");

				if (cfg.showMask) {
					mrm.ui.layer.mask($(cfg.maskContainer), 'show', cfg.maskSpeed);
				}

			},

			isTouchedOnceLink: function($link) {
				return $link.is(this.$touchedOnceLinks);
			},

			addTouchedOnceLinks: function($links) {
				this.$touchedOnceLinks = this.$touchedOnceLinks.add($links.addClass('touchedOnce'));
			},

			resetTouchedOnceLinks: function($scope) {
				if (!this.$touchedOnceLinks.length) {
					return; // do nothing if there are no touched links
				}

				$scope = $scope || $firstLvlNav;
				var $links = (!$scope.length ? this.$touchedOnceLinks : $('a.touchedOnce', $scope));

				$links.removeClass('touchedOnce');
				this.$touchedOnceLinks = this.$touchedOnceLinks.not($links);
			}
		}
	});
}(mrm.$));
(function($){
	if(mrm.util.ie9_lt()){
		$('.modNav_prim > ul > li:last').addClass('last-childs');
	}
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		nav_prim_2: {
			initTrack: function($mod){
				if (!$mod.hasClass('grid_style')) return;

				var self = this,
				brand = Omniture_s.eVar18.toLowerCase(),
				pageName = Omniture_s.pageName;
				//set up click tracking on ajax load of nav
				$(document).ajaxSuccess(function(event, xhr, settings) {
					self.setupTracking($mod, brand, pageName);
				});
			},
			setupTracking: function($mod, brand, pageName) {
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				var section = 'global_nav:vehicles:';
				$mod.find('.modNav_vehicle_selection_1 img.mm').parent('a').removeAttr('onclick');
			
				if ($mod.length) {
					$mod.find('.modNav_vehicle_selection_1 img.mm').on(clickOrTouch, function (e) {
						mrm.util.tagging.omniture_tl (
							$(this), 'global_nav', 'o', '',
							{
								'pageName':pageName,
								'prop27':section + $mod.find('li.li_active a').first().text() + ':' + $(this).parents('.modNav_vehicle_selection_1').attr('id'),
								'prop32':section + $mod.find('li.li_active a').first().text() + ':' + $(this).parents('.modNav_vehicle_selection_1').attr('id') + $(this).parents('.modVi_8').attr('id') + ':image:'
							}
						);
					});
					$mod.find('.modNav_vehicle_selection_1 ul.ll a').removeAttr('onclick');
					$mod.find('.modNav_vehicle_selection_1 ul.ll a').on(clickOrTouch, function(){
						mrm.util.tagging.omniture_tl (
							$(this), 'global_nav', 'o', '',
							{
								'pageName':pageName,
								'prop27':section + $mod.find('li.li_active a').first().text() + ':' + $(this).parents('.modNav_vehicle_selection_1').attr('id'),
								'prop32':section + $mod.find('li.li_active a').first().text() + ':' + $(this).parents('.modNav_vehicle_selection_1').attr('id') + ':' + $(this).closest('.modVi_8').attr('id') + ':button:' + $(this).text()
							}
						);
					});
					$mod.find('.modNav_carline_selection_1 .modVi_1').on(clickOrTouch, function(){
						mrm.util.tagging.omniture_tl (
							$(this), 'global_nav', 'o', '',
							{
								'pageName':pageName,
								'prop27':section + $mod.find('li.li_active a').first().text(),
								'prop32':section + $mod.find('li.li_active a').first().text() + ':' + $.trim($(this).children('.vt').text())
							}
						);

					});
				}
				
				
			}
		}
	});
			
}(mrm.$));(function ($) {
    mrm.cmp = mrm.cmp || {};
        $.extend(mrm.cmp, {
            nav_sitemap_2:{
            init:function (c) {
            	//write dynamic tracking props for footer chat link. cannot be done on the back end because it's an external link
            	var chatOnClick = $('div.mds-area-footer div.modNav_footer_1 ul.ll a.ln_chat').attr('onclick');
            	var newChatOnClick = "if(typeof(Omniture_s) != 'undefined'){mrm.util.tagging.omniture_tl(this, this.href, 'o', undefined,{'pageName':'ch:no:US:en:index','linkname':'ch:no:US:en:index:footer:click_to_chat','prop27':'footer:click_to_chat','prop32':'ch:no:US:en:index:footer:click_to_chat'});}" + chatOnClick;
            	
            	$('div.mds-area-footer div.modNav_footer_1 ul.ll a.ln_chat').attr('onclick',newChatOnClick);
            }
        }
    });
}(mrm.$));/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
 (function($) {
	var $tabs;

	mrm.cmp = mrm.cmp || {};

	$.extend(mrm.cmp, {
		nav_tablay_1: {
			/**
			 * JS for component nav_tablay_1
			 *
			 * @param {String} c DOM Context
			 */
			config: {
				maxWidth: 1920
			},
			initMod: function($mod) {
				if (mrm.util.ie6()) return;
				var self = this;
				var clickOrTouch = (mrm.util.touchDevice()) ? "touchstart" : "click"; /*GMDSST-55116*/

				if ($mod.parents("div.cnt_tbl_fs_1").length > 0) {
					$mod = $mod.parents("div.cnt_tbl_fs_1");
				}

				var $tabs = $mod.tabs({
					select: function(event, ui) {
						// mark active tab-panel as selected
						self.markVisible($(ui.panel));
					},
					create: function(event, ui) {
						self.markVisible($mod.find('.ui-tabs-panel:first'));
					}
				});
				// clean the whitespace between li
				$tabs.find('ul.ui-tabs-nav').contents().filter(function() { return this.nodeType === 3; }).remove();

				// Run the background scroller tabs settings
				if ($mod.hasClass('ui-dynamic-scroller')) {
					self.configBgContent($mod);
				}

				// #GMDSSDS-7630 putting a check in the head section to trap for the presence of
				// a querystring can allow the browser to try and deep dive to a section after
				// the hashtag reference in browser already is handled
				var hashTag = mrm.util.getHash();
				if (hashTag !== "" && mrm.util.exists(hashTag)) {
					// now get the element's offset relative to the document
					var offsetTop = $(hashTag).offset().top;
					// and finally, scroll the document to that offset
					$(document).scrollTop(offsetTop);
				}

				if ($mod.hasClass("drop_downs")) {
					this.buildDropdowns($mod);
				}


				var that = this;

				$tabs.find('ul.ui-tabs-nav a.fsShowAll')
					.unbind('click') //unbind all Events of ui tabs
					.on(clickOrTouch,function( event ){
						event.preventDefault();
						that.showall(event.target);
					})
					.parent('li')
						.removeClass('ui-state-disabled');

				$tabs.each(function(key, item){
					var $item = $(item);

					// trigger click on the "Show all" link initially if's the selected tab as requested within ticket GMDSST-9819
					var hasActiveTab = $item.find('ul.ui-tabs-nav li.active').length;
					var indexOfShowAll = $(item).find('a.fsShowAll').closest('li').index();

					if ( hasActiveTab < 1 && indexOfShowAll === 0 ) {
						that.showall( $(item).find('> ul, > .nav_tablay_1 > ul').find('a.fsShowAll') );
					}
					// set dynamic background hover
					var buttonBackgroundColor = $tabs.find('ul.ui-tabs-nav').data('bghovercolor'),
						buttonTextColor = $tabs.find('ul.ui-tabs-nav').data('hovercolor');
					if (buttonBackgroundColor || buttonTextColor) {
						// set initial active color
						$item.find('ul.nav_layer > li.ui-state-active > a').css({backgroundColor:buttonBackgroundColor, color:buttonTextColor});
						// set click/hover colors
						$item.find('ul.nav_layer > li > a').click(function() {
							$item.find('ul.nav_layer > li > a').css({backgroundColor:'', color:''});
							$(this).css({backgroundColor:buttonBackgroundColor, color:buttonTextColor});
						});
						$item.find('ul.nav_layer > li > a').hover(function() {
							if (!$(this).parent().hasClass('ui-state-active'))
								$(this).css({backgroundColor:buttonBackgroundColor, color:buttonTextColor});
						},
						function() {
							if (!$(this).parent().hasClass('ui-state-active'))
								$(this).css({backgroundColor:'', color:''});
						});
					}
				});

				// justify the space
				var $navTabsJustified = $('ul.ui-tabs-nav.ui-tab-position-justify');

				if ($navTabsJustified.length > 0) {

					// get total width
					var iTotalTabsWidth = 0;
					$navTabsJustified.children().each(function() {
						iTotalTabsWidth += $(this).outerWidth();
					});
					var iMarginRightAdjust =
						/* Math.floor replaced by */~~(($navTabsJustified.width()-iTotalTabsWidth) /
						($navTabsJustified.children().length-1))-1;
					if (iMarginRightAdjust > 0) {
						$navTabsJustified.find('li').not(':last').each(function() {
							$(this).css('marginRight', iMarginRightAdjust);
						});
					}
				}

				$('ul.ui-tabs-nav > li > a').one(clickOrTouch, function() {
					$.event.trigger('newTabShown');
				});

				// hide any open cluetips
				$('ul.ui-tabs-nav > li > a').on(clickOrTouch, function() {
					$(document).trigger('hideCluetip');
				});

				if($.isFunction(self.brand_init)){
					self.brand_init($mod);
				}
			},
			centerBackgrounds: function($mod){
				var self = this;
				var containerWidth = $mod.width();
				var bgWidth = $mod.find('.item_bg_holder').width();
				var bgHeight = $mod.find('.item_bg_holder img.item_bg').height();
				var contentHeight = $mod.find('.item_bg_holder').parent().first().height();
				$mod.find('.item_bg_holder').height(contentHeight);
				$mod.find('.item_bg_holder').css('left',(containerWidth - bgWidth) / 2);
				$mod.find('.item_bg_holder img.item_bg').css('margin-top', (contentHeight - bgHeight) / 2);
				$mod.addClass('jsReady'); // keep mod hidded until js is almost finished
			},
			configBgContent: function($mod){
				var self = this;
				var holder = $mod.find('.item_bg_holder');
				if ($mod.attr('data-cfg-full-width') === '1') {
					self.fullWidth($mod);
				}
				if (holder.length > 0 && $mod.attr('data-cfg-full-width') === '0') {
					if ($mod.data('width') !== undefined){
						holder.width($mod.data('width'));
					} else {
						if (holder.children('img').length > 0){
							holder.width(holder.children('img').width());
						} else {
							holder.width($('.mds-area-pf1', $mod).width());
						}
					}
					self.centerBackgrounds($mod);
				}

				if ($mod.find('ul.nav_layer').children().length > 6) {
					self.configScroller($mod);
				}

				$.each(holder, function (k,v){
					self.itemConfig($(this));
				});


			},
			itemConfig: function(items) {
				var self = this;
				if (mrm.util.ie_lt(10)){
					if (items.data('fallback') !== undefined){
						items.append('<img src="' + items.data('fallback') + '" />');
					}
				}
				if (items.data('color') !== undefined) {
					var deg = "180deg",
						gradientType = 0,
						color1 = items.data('color').color1,
						color2 = items.data('color').color2;
					if (items.hasClass('topB')){
						//top to botom gradient
						deg = "180deg";
						gradientType = 0;
					}
					else { //botom to top gradient
						deg = "90deg";
						gradientType = 1;
					}
					// set gradient for all browsers
					items.css('background', 'linear-gradient(' + deg + ', ' + color1 + ', ' + color2 + ')');
					// IE8/9 filter stuff here
					if (mrm.util.ie8()) {
						items.css("filter","progid:DXImageTransform.Microsoft.gradient(GradientType=" + gradientType + ",startColorstr='" + color1 + "', endColorstr='" + color2 + "')");
						items.css("-ms-filter","progid:DXImageTransform.Microsoft.gradient(GradientType=" + gradientType + ",startColorstr='" + color1 + "', endColorstr='" + color2 + "')");
					}
					if ($.browser.msie  && parseInt($.browser.version, 10) === 9) {
						items.css("filter","progid:DXImageTransform.Microsoft.gradient(GradientType=" + gradientType + ",startColorstr='" + color1 + "', endColorstr='" + color2 + "')");
					}
				} else {
					return;
				}

			},
			configScroller: function($mod){
				var $mmScroll = $mod.find('ul.nav_layer');
				var loop = ($mod.hasClass('ui-loop-disabled')) ? false : true;
					var options = {
						items: {
							visible: 6
						},
						circular: loop,
						infinite: false,
						width: 980,
						align: 'center',
						auto: false,
						next: '#tabs_next',
						prev: '#tabs_prev',
						onCreate: function(){
							$(this).parent().css('margin', '0 auto');
						},
						scroll: {
							wipe: true
						}
					};

					var clear = '<div class="clearfix"></div>';
					var prevBtn = '<a class="prev mmScrollBtn" id="tabs_prev" href="#"><span>prev</span></a>';
					var nxtBtn = '<a class="next mmScrollBtn" id="tabs_next" href="#"><span>next</span></a>';
					options = $.extend(true, options, mrm.conf.cmp.nav_tablay_1 || {});
					$mmScroll.wrap('<div class="nav_tab_scroller"></div>');
					$mmScroll.after(clear + prevBtn + nxtBtn);
					$mmScroll.mrmCarousel(options);
			},
			tabscontent: function($mod, select_id) {

				var selectsval = $(select_id).val();
				mrm.util.log('[mrm.cmp.nav_tablay_1.tabscontent] Context: ' + select_id + ' - value: ' + selectsval);

				$mod.tabs('select', selectsval);

				this.markVisible($(selectsval));
			},
			showall: function(target) {

				$(target)
					.closest('ul.ui-tabs-nav')
						.find('li')
							.removeClass('ui-state-focus ui-tabs-selected ui-state-active')
							.find('a:not(.fsShowAll)')
								.each(function(index, item){
									$($(item).attr('href')).removeClass('ui-tabs-hide').addClass('ui-helper-visible');
								});

				$(target).closest('li').addClass('ui-state-focus ui-tabs-selected ui-state-active');
			},
			buildDropdowns : function($mod) {
				var tab_id = '';
				if (mrm.util.getHash() != -1) {
					tab_id = (mrm.util.getHash());
				}

				$mod.children("ul").each(function(i) {
					var select = document.createElement('select');
					var options = {};

					var select_id = 'ntl_dd_' + i;
					select.setAttribute('id', select_id);

					// let's get all the options by the li entries
					$(this).children('li').each(function() {
						options[$(this).children('a').attr('href')] = $(this).text();
					});

					// let's fill these options into the newly created select tag
					mrm.util.fillSelect(select, options, tab_id);

					// inserting the select field before the tabs and hiding these
					$(this).hide().before(select);

					// binding the change event on the select and also letting the tabs content for the initial select entry appear
					$(select).change(function() {
						mrm.cmp.nav_tablay_1.tabscontent($mod, '#' + select.getAttribute('id'));
					});

					mrm.cmp.nav_tablay_1.tabscontent($mod, '#' + select_id);
				});
			},

			/**
			 * Ads class 'ui-helper-visible' to the active layer for easier selection from outside
			 * @param $layer	active/visible layer
			 */
			markVisible: function($layer) {
				$layer.addClass('ui-helper-visible').siblings('.ui-tabs-panel').removeClass('ui-helper-visible');
			},
			// used by deeplinking.js
			switchToContent: function($content) {
				if ($content.length === 0) return;
				var self = this;

				var $layer = $content.closest('.ui-tabs-panel');
				var $mod = $content.closest('.modNav_tablay_1');
				var id = $layer.attr('id');
				if (id) {
					$mod.tabs('select', id);
					self.markVisible($layer);
				}

				// GMDSSDS-60251 | now the anchor linking issue is fixed
				id = $content.attr('id');

				// GMDSST-29475 | scroll the document to the element
				var offsetTop = $('#' + id).offset().top;
				$(document).scrollTop(offsetTop);
			},
			fullWidth: function($mod){
				var contentHeight = $mod.find('.item_bg_holder').parent().first().height(),
					bgHeight = $mod.find('.item_bg_holder img.item_bg').height();

				$mod.find('.item_bg_holder').height(contentHeight);
				$mod.find('.item_bg_holder img.item_bg').css('margin-top', (contentHeight - bgHeight) / 2);

				$(window).resize($.proxy(function() {
					this.resize($mod);
				}, this));
				// initial call
				this.resize($mod);
				$mod.addClass('jsReady'); // keep mod hidded until js is almost finished
			},
			resize: function($mod){
				var self = this,
					pageWidth = $(window).width(),
					containerWidth = 980;


				var nMargin = (containerWidth - pageWidth) * 0.5;
				nMargin = nMargin > 0 ? 0 : nMargin;

				// size the mod first it's the outter most
				$mod.find('.item_bg_holder').css({'margin-left': nMargin, 'margin-right': nMargin});
				$mod.find('.item_bg_holder').width(pageWidth);
				//center if over maxWidth
				if (pageWidth > this.config.maxWidth) {
					$mod.find('.item_bg_holder').css('left', (pageWidth - this.config.maxWidth) * 0.5);
				} else {
					$mod.find('.item_bg_holder').css('left', 0);
				}
			}
			

		}
	});
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		nav_tablay_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				// tracking for tabs
				$mod.find("li a").not(".btn_prim").on(clickOrTouch, function(){
					var linkname = $(this).text();
					if (linkname == false) {
						linkname = $(this).find('img').attr('src');
						if (typeof(linkname) !== "undefined") {
							linkname = linkname.substr( linkname.lastIndexOf('/') + 1);
						}
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: "tab:" + linkname});
				});
				
				// tracking for tab arrows
				$mod.find("a#tabs_prev").on(clickOrTouch, function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "tab:arrow:prev"});
				});

				$mod.find("a#tabs_next").on(clickOrTouch, function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "tab:arrow:next"});
				});
			}
		}
    });
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		nav_toolscontainer_1: {
			initMod: function($mod) {
				var self = this;
				
				//set height for borders and apply anchor links to 'ts_ln_2' div
				//these will run on load when component is authored in utility nav
				self.setHeight($mod);
				self.applyLinks($mod);
				self.bindEvents();

				//check for load of shopping tools snipplet under primary nav
				$(document).ajaxSuccess(function(event, xhr, settings) {
					if (settings.url.indexOf("shopping") > -1) {
						//set height for borders and apply anchor links to 'ts_ln_2' div
						//these will run when ajax call completes after clicking shopping tools link, when authored in primary nav
						self.setHeight($mod);
						self.applyLinks($mod);
						self.bindEvents();
					}
				});
				
				//hide utility nav arrow, make content bg transparent
				$mod.parentsUntil('dl').prev('dt').css('background', 'none');
				$mod.parentsUntil('content').parent().css('background', 'transparent');
			},
			setHeight: function($mod) {				
				var cntHeight = $mod.parents().find('.content').height();
				var navToolsMargin = $mod.parents().find('.content').find('.modNav_toolscontainer_1').css('margin-top').split('px');
				$('.modNav_toolscontainer_1 .modTs_ll_2').css('height',cntHeight-navToolsMargin[0]+7);
			},
			applyLinks: function($mod) {			
				var anchorLink;
				$('.modNav_toolscontainer_1 .modTs_ln_2').each(function() {
					var $this = $(this);
					$this.on('click', function() {
						anchorLink = $this.find('h3.tt a').attr('href');
						location.href = anchorLink;
					});
				});
			},
			bindEvents: function() {			
				//set hover color of teaser title anchor when ts_ln_2 div is hovered
				$('.modNav_toolscontainer_1 .modTs_ln_2').on('mouseenter', function() {
					$(this).find('h3.tt a').css('color', '#f4bc00');
				});
				$('.modNav_toolscontainer_1 .modTs_ln_2').on('mouseleave', function() {
					$(this).find('h3.tt a').css('color', '#414042');
				});
			}
		}
	});
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		nav_toolscontainer_1: {
			initTrack: function($mod){
				var self = this;
				brand = Omniture_s.eVar18.toLowerCase(),
				pageName = Omniture_s.pageName;
				
				//set up click tracking for nav_toolscontainer_1 when use in utility nav (static)
				self.setupTracking($mod, brand, pageName);
				
				//set up click tracking on ajax load of nav_toolscontainer_1 when used in primary nav (dynamic)
				$(document).ajaxSuccess(function(event, xhr, settings) {
					if (settings.url.indexOf("shopping") > -1) {
						self.setupTracking($mod, brand, pageName);
					}
				});
			},
			setupTracking: function($mod, brand, pageName) {
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';
				var section;
				
				//utility nav button
				if ($mod.parentsUntil('dl').prev('dt').length) {
					$mod.parentsUntil('dl').prev('dt').find('a').removeAttr('onclick'); //remove onclick omiture
					
					$mod.parentsUntil('dl').prev('dt').find('a').on(clickOrTouch, function() {
						section = 'global_nav:owners';
									
						mrm.util.tagging.omniture_tl (
							$(this), 'shopping_tools', 'o', '',
							{
								'pageName':pageName,
								'prop27':section,
								'prop32':section
							}
						);
					});
				}
				
				//ts_ln_2
				//global nav -> shopping tools
				if ($('.n03.modBaseballcard .modNav_toolscontainer_1 .modTs_ln_2').length) {
					$('.n03.modBaseballcard .modNav_toolscontainer_1 .modTs_ln_2 a').removeAttr('onclick'); //remove onclick omiture
					
					$('.n03.modBaseballcard .modNav_toolscontainer_1 .modTs_ln_2').on(clickOrTouch, function() {
						section = 'global_nav:shopping_tools';
				
						var anchorLabel = $(this).find('h3.tt a').text();
									
						mrm.util.tagging.omniture_tl (
							$(this), 'shopping_tools', 'o', '',
							{
								'pageName':pageName,
								'prop27':section,
								'prop32':section + ':' + $.trim(anchorLabel)
							}
						);
					});
				}
				
				//ts_ln_2
				//utility nav -> shopping tools
				if ($('.modNav_tools_1 .modNav_toolscontainer_1 .modTs_ln_2').length) {
					$('.modNav_tools_1 .modNav_toolscontainer_1 .modTs_ln_2 a').removeAttr('onclick'); //remove onclick omiture
					
					$('.modNav_tools_1 .modNav_toolscontainer_1 .modTs_ln_2').on(clickOrTouch, function() {
						section = 'global_nav:owners';
				
						var anchorLabel = $(this).find('h3.tt a').text();
									
						mrm.util.tagging.omniture_tl (
							$(this), 'shopping_tools', 'o', '',
							{
								'pageName':pageName,
								'prop27':section,
								'prop32':section + ':' + $.trim(anchorLabel)
							}
						);
					});
				}
				
				//ts_ll_2
				//global nav -> shopping tools
				if ($('.n03.modBaseballcard .modNav_toolscontainer_1 .modTs_ll_2').length) {
					$('.n03.modBaseballcard .modNav_toolscontainer_1 .modTs_ll_2 ul.ll li a').removeAttr('onclick'); //remove onclick omiture
					
					$('.n03.modBaseballcard .modNav_toolscontainer_1 .modTs_ll_2 ul.ll li a').on(clickOrTouch, function() {
						var section = 'global_nav:shopping_tools';
						var cat = $(this).parentsUntil('.modTs_ll_2').find('h3.tt').text() + ':';								
						var anchorLabel = $(this).text();
								
						if($(this).hasClass('btn_prim') || $(this).hasClass('btn_sec')) {
							//chat btn
							mrm.util.tagging.omniture_tl (
								$(this), 'shopping_tools', 'o', '',
								{
									'pageName':pageName,
									'prop27':section,
									//'prop32':section + cat + $.trim(anchorLabel)
									'prop32':section+':button:chat_now'
								}
							);
						}else {
							//shopping link
							mrm.util.tagging.omniture_tl (
								$(this), 'shopping_tools', 'o', '',
								{
									'pageName':pageName,
									'prop27':section,
									//'prop32':section + cat + $.trim(anchorLabel)
									'prop32':section+':'+$.trim(anchorLabel)
								}
							);
						}
						
					});
				}
				
				//ts_ll_2
				//utility nav -> shopping tools
				if ($('.modNav_tools_1 .modNav_toolscontainer_1 .modTs_ll_2').length) {
					$('.modNav_tools_1 .modNav_toolscontainer_1 .modTs_ll_2 ul.ll li a').removeAttr('onclick'); //remove onclick omiture
					
					$('.modNav_tools_1 .modNav_toolscontainer_1 .modTs_ll_2 ul.ll li a').on(clickOrTouch, function() {
						var section = 'global_nav:owners';
						var cat = $(this).parentsUntil('.modTs_ll_2').find('h3.tt').text() + ':';								
						var anchorLabel = $(this).text();
								
						if($(this).hasClass('btn_prim') || $(this).hasClass('btn_sec')) {
							//chat btn
							mrm.util.tagging.omniture_tl (
								$(this), 'shopping_tools', 'o', '',
								{
									'pageName':pageName,
									'prop27':section,
									//'prop32':section + cat + $.trim(anchorLabel)
									'prop32':section+':button:chat_now'
								}
							);
						}else {
							//shopping link
							mrm.util.tagging.omniture_tl (
								$(this), 'shopping_tools', 'o', '',
								{
									'pageName':pageName,
									'prop27':section,
									//'prop32':section + cat + $.trim(anchorLabel)
									'prop32':section+':'+$.trim(anchorLabel)
								}
							);
						}
						
					});
				}
				
			}
		}
	});
			
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		nav_top_2 : {
			/*window.onscroll = function(){
                		checkPosition();
            		};*/
			init: function($mod){
				$(window).scroll(function () {
					checkPosition()
	            });
	            $(window).bind("touchmove", function (event) {
	            	checkPosition()
	            });
	            $(document).onscroll = function () {
	            	checkPosition()
	            };
	            $(window).onscroll = function () {
	            	checkPosition()
	            };
	            
				function checkPosition(){
					var winScroll = $(window).scrollTop();
					var thisElement = $(".nav_top_2");
					if(winScroll >= 1000){
						thisElement.css("display","block");
					}
					else{
						thisElement.css("display","none");
					}
				}
				
				checkPosition();
			}
		}
	});
}(mrm.$));(function($){

if(mrm.util.ie9_lt() ){

	$('.modNav_utility_1 li').each(function(){
		if( $(this).is(':last-child') ){
			$(this).addClass('last-childs');
		}		
	});
 }

})(mrm.$);(function($) {
	mrm.cmp = mrm.cmp || {};

	var cfg = {
		openOnHover: true
	};

	mrm.cmp.nav_vehicle_selection_2 = {
			/**
			 * JS for component nav_vehicle_selection_2
			 * currently no support for more than one nav_vehicle_selection_2 per page!
			 *
			 * @param {jQuery} $mod module context
			 */

			$layerContainer: $('#container'), // also used as click container for closing layers on click outside
			$vehicleLayers: $(),
			stateIndicatorClass: 'active',
			initMod: function($mod)
			{
				this.$mod = $mod;

				var self = this,
					$carlineContainer = $mod.find('li.navCarline'),
					$triggers = $mod.find('a[data-snippet]').each(function(index) {
						$(this).data('index', index);
					}),
					$triggerContainers = $triggers.closest('li');

				if ( !$triggers.length ) {
					return;
				}

				if ( !mrm.util.touchDevice() && cfg.openOnHover ) {
					$triggerContainers.on('mouseenter', function(e) {
						var $currentContainer = $(this),
							$trigger = $currentContainer.find('a');

						self.showLayerHandler($trigger);
						$triggerContainers.removeClass(self.stateIndicatorClass);
						$currentContainer.addClass(self.stateIndicatorClass);
					}).on('mouseleave', function(e) {
						var $currentContainer = $(this),
							triggerIndex = $currentContainer.find('a').data('index');

						self.hideTimeoutId = window.setTimeout(function() {
							var $correspondingLayer = self.$vehicleLayers.filter(function() {
								return $(this).data('index') == triggerIndex;
							});
							$currentContainer.removeClass(self.stateIndicatorClass);
							self.hideLayer($correspondingLayer);
						}, 100);
					});

					self.$layerContainer.on('mouseenter', 'div.navVehicle2Layer', function(e) {
						window.clearTimeout(self.hideTimeoutId);
					}).on('mouseleave', 'div.navVehicle2Layer:not(.persistent)', function(e) {
						self.hideLayer($(this));
						$triggers.closest('li').removeClass(self.stateIndicatorClass);
					});
				} else {
					$triggerContainers.on('click', function(e) {
						var $currentContainer = $(this);

						self.showLayerHandler($currentContainer.find('a'));
						$triggerContainers.removeClass(self.stateIndicatorClass);
						$currentContainer.addClass(self.stateIndicatorClass);
						e.preventDefault();
					});

					self.$layerContainer.on('click.navVehicleSelection2', function(e) {
						var $target = $(event.target);
						if ( !$target.closest('div.navVehicle2Layer').length || $target.closest('button.close').length ) {
							$(this).off('click.navVehicleSelection2');
							self.$vehicleLayers.hide();
							$triggerContainers.removeClass(self.stateIndicatorClass);
						}
					});
				}

				if ( $triggers.closest($carlineContainer).length && mrm.util.hasFloatWrap($carlineContainer.find('li')) ) {
					self.setupListScroller($carlineContainer);
					$(window).load(function(){
						// refresh list chunks on load, because sometimes the wrap detection does not work correct on ready
						self.setupListScroller($carlineContainer, true);
					});
				}

				$('body').on('click', function(event) {
					self.hideLayer($('.navVehicle2Layer.persistent:visible'));
					$triggers.closest('li').removeClass(self.stateIndicatorClass);
				});

				$mod.find('a[data-snippet]').on('showPersistent', function(event){
					self.showPersistentLayer($(event.currentTarget));
				});
			},

			// manually trigger layer
			showPersistentLayer : function($trigger)
			{
				var self = this,
					$triggers = self.$mod.find('a[data-snippet]'),
					$triggerContainers = $triggers.closest('li'),
					$currentContainer = $trigger.closest('li');

					self.showLayerHandler($trigger, true);

					$triggerContainers.removeClass(self.stateIndicatorClass);
					$currentContainer.addClass(self.stateIndicatorClass);
			},

			// init and show layer, or just show the layer if it is already initialized
			showLayerHandler : function($trigger, persistent)
			{
				var self = this,
					url = $trigger.data('snippet'),
					$layer = self.$vehicleLayers.filter(function() {
						return $(this).data('index') === $trigger.data('index');
					});

				if ( $layer.length ) {
					self.showLayer($trigger, $layer, persistent);
					return;
				}

				$.get(url, function(html)
				{
					var $layer = $(html).filter('*').data('index', $trigger.data('index')).addClass('navVehicle2Layer');

					self.$layerContainer.append($layer);
					self.$vehicleLayers = self.$vehicleLayers.add($layer);

					$layer.find('a.close').on('click', function(event){
						self.hideLayer($layer);
						event.preventDefault();
					});

					$layer.show();
					mrm.util.initDomContent($layer);
					$layer.hide();

					if ( $trigger.closest('li').hasClass(self.stateIndicatorClass) ) {
						self.showLayer($trigger, $layer, persistent);
					}
				});
			},

			showLayer : function($trigger, $layer, persistent)
			{
				if(persistent == true){
					$layer.addClass('persistent');
				} else {
					$layer.removeClass('persistent');
				}

				var self = this;
				$layer.siblings('.navVehicle2Layer').hide();
				$layer.show();
				self.positionLayer($layer, $trigger);
			},

			positionLayer : function($layer, $trigger)
			{
				$layer.position({
					my: 'center bottom',
					at: 'center top',
					of: $trigger,
					collision: 'none',
					using: function(pos) {
						var $mod = $trigger.closest('div.mod'),
							boundaryLeft = $mod.offset().left,
							boundaryRight = $mod.offset().left + $mod.outerWidth();

					pos.left = Math.max(pos.left, boundaryLeft);
					pos.left = Math.min(pos.left, boundaryRight - $(this).outerWidth());

						$(this).offset(pos);
					}
				});

			},

			hideLayer : function($layer, $trigger)
			{
				$trigger = $trigger || $();
				$layer.hide();
				$trigger.removeClass(this.stateIndicatorClass);
			},

			/**
			 Splits a horizontal item list into chunks.
			 Each chunk represents one line of list items, so if the list items
			 wraps to n lines, n chunks will be created.
			 The last chunk is filled with as many items from the previous chunk as would
			 fit without wrapping the line.
			**/
			createListChunks : function($listItems)
			{
				var lastPos, lastIndex = 0, $wrapChunks = [];

				$listItems.each(function(itemCount) {
					var $current = $(this),
						currentPos = Math.round($current.position().top),
						isLastItem = itemCount === $listItems.length - 1,
						itemWrapped;

					if ( itemCount == 0 ) {
						lastPos = currentPos;
					}

					itemWrapped = currentPos !== lastPos;

					if ( itemWrapped ) {
						// create a slice, do not include the wrapped item
						$wrapChunks.push(
							$listItems.slice(lastIndex, itemCount)
						);
						lastIndex = itemCount;
						lastPos = currentPos;
					}

					if ( isLastItem ) {
						$wrapChunks.push(
							$listItems.slice(lastIndex)
						);
					}


				});

				if ( $wrapChunks.length < 2 ) {
					return $wrapChunks;
				}

				//if more than one chunk, fill the last chunk with  as many list items as will fit in the row
				$listItems.hide();
				var $lastChunk = $(),
					$lastTwoChunks = $($wrapChunks[$wrapChunks.length-2]).add($wrapChunks[$wrapChunks.length-1]);

				$lastTwoChunks.each(function(itemCount) {
					var currentIndex = $lastTwoChunks.length - 1 - itemCount,
						$currentSlice = $lastTwoChunks.slice(currentIndex);

					// display current item
					$lastTwoChunks.eq(currentIndex).show();

					if ( mrm.util.hasFloatWrap($currentSlice) ) {
						$currentSlice.not(':first');
						$wrapChunks[$wrapChunks.length-1] = $currentSlice.not(':first').hide();
						return false;
					}
				});

				return $wrapChunks;
			},

			setupListScroller : function($listContainer, refreshOnly)
			{
				var $wrapChunks,
					$btnNext = $listContainer.children('button.next'),
					$btnPrev = $listContainer.children('button.prev'),
					$listItems = $listContainer.children('ul').children('li');

				function showChunk(chunkIndex) {
					$listItems.hide();
					$wrapChunks[chunkIndex].show();
					$listContainer.data('visibleChunk', chunkIndex);
					$btnPrev.add($btnNext).filter(function() {
						return $(this).prop('disabled');
					}).prop('disabled', false).removeClass('disabled');

					if ( chunkIndex == 0 ) {
						$btnPrev.addClass('disabled').prop('disabled', true);
					}

					if ( chunkIndex == $wrapChunks.length - 1 ) {
						$btnNext.addClass('disabled').prop('disabled', true);
					}
				}

				if ( !refreshOnly ) {
					$btnNext = $('<button type="button" />').addClass('next').append($('<span />').text('next')).prependTo($listContainer);
					$btnPrev = $('<button type="button" />').addClass('prev').append($('<span />').text('prev')).prependTo($listContainer);
					$listContainer.addClass('jsList').data('visibleChunk', 0);
				} else {
					$listItems.show();
				}

				$wrapChunks = this.createListChunks($listItems);
				showChunk($listContainer.data('visibleChunk'));

				if ( refreshOnly ) {
					$btnPrev.add($btnNext).off('click.navList');
				}

				$btnPrev.add($btnNext).on('click.navList', function() {
					var $btn = $(this),
						visibleChunk = $listContainer.data('visibleChunk');

					if( $btn.hasClass('prev') )
					{
						visibleChunk--;
					}
					else
					{
						visibleChunk++;
					}

					if ( $btn.prop('disabled') ) {
						return;
					}
					showChunk(visibleChunk);
				});
			}

		}

}(mrm.$));;(function($) {
	mrm.mod.Nav_viewallvehicles_selection_1 = mrm.mod.AbstractMod.extend({

		events: {
		},

		prepare: function() {
			var self = this;

			var $carlines = this.$ctx.find('ul > li > .mod');
			var rowLength = 6;
			var rowCount = Math.ceil($carlines.length / rowLength);
			var equalHeightElements = [$carlines.children('h3.vt, h3.tt')];
			var $list = this.$ctx.children('ul');

			this.$ctx.addClass('cols' + Math.min($carlines.length, rowLength));
			
			for (var i = 0; i < rowCount * rowLength; i += rowLength) {
				$.each(equalHeightElements, function() {
					$(this).slice(i, i + rowLength).equalHeights();
				});
			}

			var $scrollContainer = mrm.ui.scrollbars.applyScrollbarsTo($list, self.cfg.height);
			if ($scrollContainer.hasClass('jspScrollable')) {
				this.$ctx.addClass('hasScrollbar');
				mrm.ui.scrollbars.remove($scrollContainer);
				$scrollContainer = mrm.ui.scrollbars.applyScrollbarsTo($list);
				$scrollContainer.addClass('jspStyle2');
			}
		}
	});
})(mrm.$);;(function($) {
    mrm.mod.Psw_floater_1 = mrm.mod.AbstractMod.extend({

        prepare: function() {
            var self = this;

            var pricingKey = "preferredPrice";
            var $targetOptions = self.$ctx.find(".priceoptions");

            // Find option codes from within the markup and create a cookie
            $targetOptions.each(function(count, value) {
                var optionCode = $(value).data("programCode");
                var seekParam = pricingKey + "=" + optionCode;

                if (document.location.search.match(seekParam) && optionCode.length > 0) {
                    self.targetOption = optionCode;
                    mrm.util.cookie.set("preferredPricingCookie", optionCode, {path: "/"});
                }
            });

            // Check if param has been setup
            var pricingCookie = mrm.util.cookie.get("preferredPricingCookie");
            if (typeof pricingCookie !== "undefined") {
                $targetOptions.each(function(count, value){
                    var optionCode = $(value).data("programCode");
                    if (optionCode === pricingCookie) {
                        self._setupEvents($(value));
                    }
                });
            }
        },

        _setupEvents: function($targetOption) {
            var self = this;
            $targetOption.show();
            
            var $targetModal = $targetOption.find(".floater-modal");
            self.$targetModal = $targetModal;
            var $targetLegal = $targetOption.find(".floater-disclaimer");

            // Disable and hide componenent.
            $targetModal.find("button").on("click", function(){

                mrm.util.cookie.remove("preferredPricingCookie", {path: "/"});
                $(window).trigger("removePrefPrice");
                $targetModal.dialog('close');
                $targetOption.hide();
                $.eventDispatcher.off(self.modalToken);
            });

            // Setup links to trigger modal window from within legal area
            $targetLegal.find("a").each(function(count, value){
                if ($(value).attr("href") === "#") {
                    $(value).on("click", function(event){
                        event.preventDefault();
                        self._openModal();
                    });
                }
            });

            // setup and open jQuery-UI modal dialog
            $targetOption.find("a.modal-trigger").on("click", function(event){
                event.preventDefault();
                self._openModal();
            });

            // allow modal to be opened from outside component
            self.modalToken = $.eventDispatcher.on("psw_floater_1.openModal", function(){
                self._openModal();
            });
        },

        _openModal: function() {
            var self = this;

            self.$targetModal.dialog({
                width: 600,
                resizable: false,
                modal:true,
                dialogClass: "pswFloaterModal",
                create: function(event, ui) {
                    //keep modal dialog centered even when scrolling
                    $(event.target).parent().css('position', 'fixed');
                }
            });
        }

    });
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		searchfield_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';						

				$mod.find('button').on(clickOrTouch, function(){
					var linkname = $('input.searchterm').attr("value");
					if(typeof(Omniture_s) != 'undefined'){
						mrm.util.tagging.omniture_tl(
							this,
							$mod.find('form').attr("action"),
							'o',
							undefined,
							{
								'prop27':'global nav:search',
								'prop32':'global nav:search:term:' + linkname
								}
							);
						}
					});		
				}				
			}
		});
	}(mrm.$));;(function($) {
	mrm.mod.Searchform = mrm.mod.AbstractMod.extend({

		events: {
			"submit #searchform" : "onSubmit"
		},

		prepare: function() {
			var self = this;
			self.$ctx.find('input[placeholder], textarea[placeholder]').placeholder();
		},

		onSubmit: function(e) {
			var $input = this.$ctx.find('input[name="q"]');

			/* verify if placeholder value equals input value */
			if ($input.hasClass('placeholder') && $input.val() === $input.attr('placeholder')) {
				return false;
			}
			return $input.val() ? true : false;
		}

	});
})(mrm.$); ;(function($) {
	mrm.mod.Seo_text = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;
			this.$ctx.find('dl').accordion({
				collapsible: true,
				autoHeight: false,
				active: false
			});
		}

	});
})(mrm.$);(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		share_1: {
			init: function() {
				// only for IE 8
				if (mrm.util.ie8()) {
					// listen to all click event on the body
					$(document.body).on('click.at3', function() {
						// if the addThis modal exist then set the property change event
						if ($('#at3win').length) {
							document.getElementById('at3win').onpropertychange = function(e) {
								if (event.srcElement.style.display.toLowerCase() === 'block') {
									try {
										document.getElementById('at3winshare-iframe').contentDocument.location.href = document.getElementById('at3winshare-iframe').src;
									} catch (exception) {
										// do nothing;
									}
								}
							};
							// after setting the property change event stop listening to clicks
							$(document.body).off('.at3');
						}
					});
				}
			}
		}
	});
}(mrm.$));/*
 * @author Sebastian Telschow, s.telschow@enterfra.me
*/
(function($) {
	var config = $.extend({
		/* default settings */
		lazyLoad: true
	}, mrm.conf.cmp.sharing || {} );

	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		share_2: {
			/**
			 * JS for component share_2
			 *
			 * @param {String} c DOM Context
			 *
			 * Procedure:
			 * - set the share_2 mods attribute "data-autorender" to "false", if the included provider-tags shouldnt automatically be rendered on pageload:
			 *   ex: <div class="mod modShare_2" data-autorender="false">
			 * - the provider-tag-classnames of these marked Share_2 are renamed on Share_2 init so they are hidden from the provider-scripts.
			 * - Share_2 then listens to an event "renderShare2" where it resets the provider-tag-classnames and forces the providers to rerender their buttons.
			 * - trigger this event from out of your components where the Share_2 is embedded to.
			 * - when your component initially should render an as "disabled" marked Share_2, you can make use of the convenience function "mrm.cmp.share_2.enable"
			 */

			disabledProviderTag: 'disabled-',

			initMod: function($mod) {
				var self = this;
				// handle opening the email form in a dialog
				$mod.find('li.service-mail a.lyr_email_1').on('click', function(event) {
					event.preventDefault();
					var $link = $(event.target).closest('a'),
						href = $link.attr('href'),
						linkData = $link.data();

					// normalize param name, backend expects 'x-config' instead of 'xConfig'
					linkData['x-config'] = linkData.xConfig || '';
					linkData = _.omit(linkData, 'xConfig');

					if ( (linkData['method'] || 'get') == 'post') {
						$.post(href, linkData, function(html) {
							self._loadInLayer(html, linkData);
						});
					} else {
						$.get(href, function(html) {
							self._loadInLayer(html, linkData);
						});
					}
				});

			},

			init: function(c) {
				mrm.util.log('[mrm.cmp.share_2] Context: ' + c);

				var self = this,
				    $ctx = $(".modShare_2");

				if (!$ctx.length) { return; }

				if ( mrm.conf.util.sharing.socialPrivacy ) {
					this._disableTags($(document), false);
					mrm.util.sharing.initSocialSwitches($ctx);
				} else {
					// modify the provider tags class-names so auto-rendering will not take place
					this._disableTags($(document), true);
				}

				if(config.lazyLoad){
					// call addToLazyLoad
					mrm.util.sharing.addToLazyLoad('.modShare_2');
				}

				if ( !mrm.conf.util.sharing.socialPrivacy ) {
					// Twitter
					mrm.util.sharing.loadTwitter();
					// Google
					mrm.util.sharing.loadGooglePlus();
					// Facebook
					mrm.util.sharing.loadFacebook(this.bindEventToFacebookIcons);

					// add a popup to the custom twitter-icon
					this.bindEventToTwitterIcons();
				}

				// listen to explicit loading event of share-buttons
				$(document).on('renderShare2', function(event, forceHidden) {
					self._onRenderTags(event, forceHidden);
				});
			},

			_loadInLayer: function(html, callerData) {
				var $dialog = $('<div class="dialog-container"></div>').append(
					$(html).data('callerData', callerData || {})
				).mrmDialog({
					closeOnClickOfModalLayer: false,
					initDomContent: true,
					destroyOnClose: true
				});
			},

			/*
				EVENT-HANDLER:
				event.target should be the container, that is switched into viewport and triggers the event by default.
				Share2-component sits in there.
			*/
			_onRenderTags: function(event, forceHidden) {
				var $container = $(event.target);
				if (forceHidden != true && $container.find('.modShare_2:visible').length == 0) return;

				var foundSome = this._enableTags($container);
				// force the providers to rerender their buttons
				if (foundSome) mrm.util.sharing.rerender($container[0]);
			},

			/*
				Enable provider-tags so they could be rendered
				It converts in ex. the class "disabled-twitter-share-button" to "twitter-share-button" so
				that the sharing-provider script would find the tag and rcould then render its markup into it.
				"force" forces to enable the tags even if the component is in a hidden state
			*/
			_enableTags: function($container, force /* bool */) {
				var foundSome = false,
				    disabledProviderTag = this.disabledProviderTag,
				    $share2 = $('.modShare_2' + (force ? '' : ':visible'), $container);

				if ($share2.length == 0) return;

				$share2.find('.' + disabledProviderTag + 'twitter-share-button, .' + disabledProviderTag + 'g-plusone').each(function() {
					var $tag = $(this);
					var cls = $tag.attr('class');
					$tag.attr('class', cls.replace(disabledProviderTag, ''));
					foundSome = true;
				});
				return foundSome;
			},

			/*
				Disable provider-tags so they are hidden from the the provider-scripts
				ex: converts "twitter-share-button" to "disabled-twitter-share-button"
			*/
			_disableTags: function($container, selective) {
				var selector = selective ? '.modShare_2[data-autorender="false"]' : '.modShare_2',
				    disabledProviderTag = this.disabledProviderTag;

				$(selector + ' .twitter-share-button, ' + selector + ' .g-plusone', $container).each(function(){
					var $tag = $(this);
					var cls = $tag.attr('class');
					$tag.attr('class', cls.replace(/(g-plusone|twitter-share-button)/, disabledProviderTag + "$1"));
				});
			},

			/* PUBLIC ####################################################################################### */
			bindEventToFacebookIcons: function() {
				// bind events to the facebook-buttons
				$('.modShare_2 .service-facebook a').off('click.shareIcon').on('click.shareIcon', function(event) {
					event.preventDefault();
					var obj = {
						method: 'feed',
						name: $(this).attr('data-name'),
						link: $(this).attr('data-link'),
						caption: $(this).attr('data-caption'),
						picture: $(this).attr('data-picture').replace(/%20/g, ' '),
						source: $(this).attr('data-source').replace(/%20/g, ' '),
						description: $(this).attr('data-description')
					};
					if (window['FB']) {
						window['FB'].ui(obj);
					}
				});
			},

			bindEventToTwitterIcons: function() {
				// bind events to the facebook-buttons
				$('.modShare_2 .service-twitter a.icon-twitter').off('click.shareIcon').on('click.shareIcon', function(event) {
					event.preventDefault();
					var url = $(event.currentTarget).attr('href');
					window.open(url, 'twitter', 'width=550,height=420');
				});
			}
		}
	});
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		share_2: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				$('.socialSwitch', $mod).on(clickOrTouch, function() {
					var serviceClass = $(this).parents('.socialPrivacy').attr('class').match(/service[\w\-]*\b/)[0],
					    service = serviceClass.replace('service-', ''),
					    switchState = '';

					if ( $(this).hasClass('on') ) {
						switchState = 'soc_slider_on';
					} else {
						switchState = 'soc_slider_off';
					}

					if ( window.Omniture_s ) {
						mrm.util.tagging.omniture_tl(true, 'social_switch', 'o', '', {
							prop27: 'soc_slider',
							prop32: Omniture_s.pageName + ':' + switchState + ':' + service
						});
					}
				});
			}
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Story_browser = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;
			self.teaserElements = self.$ctx.find('.modTs_story_1').toArray();

			var $active = self.$ctx.find('ul.story-selection > li.active');
			this.setTabPadding($active);
			// initial sort/filter
			this.arrangeItems($active);
			// bind events to tabs/dropdowns
			this.attachEvents();
			// carousel
			this.initCarousel();
		},

		initCarousel: function() {
			var self = this;

			// remove old pagination
			self.$ctx.find(".pager_wrap").remove();

			// carouFredSel
			var obj = {
				circular: false,
				infinite: false,
				items: {
					start: 0
				},
				scroll: {
					fx: 'scroll',
					onBefore : function(data) {
						self.$ctx.find('.mmScroll').trigger('updatePageStatus');
                    },
				},
				prev: function() {
					return self.$ctx.find(".pager_prevpage");
				},
                next: function() {
					return self.$ctx.find(".pager_nextpage");
                },
				pagination: {
					container: function () {
						return $('<div class="pager_wrap"><span class="pager_prevpage">&lt;</span><div class="pager"></div><span class="pager_nextpage">&gt;</span></div>')
							.appendTo($(this).parent().parent())
							.children('.pager');
					},
					anchorBuilder: function(nr, item) {
						return ' <a href="#" id="story_browser_page_' + nr + '" class="story_browser_page"><span>'+nr+'</span></a> ';
                    }
				},
				onCreate: function(data) {
                    var _maxPagesDisplay = 7;

                    $(this).bind('updatePageStatus', function() {
                        var ancestorDiv = self.$ctx.find(".story-stories.mmScroll");
                        if ($(ancestorDiv).find(".pager_wrap .pager a.story_browser_page").length > _maxPagesDisplay) {
                            // gets current position of carousel
                            var currentPage = parseInt($(ancestorDiv).find("ul").triggerHandler('currentPosition'), 10) + 1;
                            var numPages = $(ancestorDiv).find(".pager_wrap .pager a.story_browser_page").length;
                            var i;
                            if (currentPage <= Math.ceil(_maxPagesDisplay / 2)) {
                                // ex: [1][2][3][4][5][6][7] - page 1-4 selected
                                self.$ctx.find(".story_browser_page").show();
                                for (i=_maxPagesDisplay + 1; i<=numPages; i++) {
                                    $("#story_browser_page_" + i).hide();
                                }
                            } else if (currentPage > numPages - Math.ceil(_maxPagesDisplay / 2) ) {
                                // ex: [6][7][8][9][10][11][12] - 12 total pages, 9-12 selected
                                self.$ctx.find(".story_browser_page").hide();
                                for (i=numPages - Math.floor(_maxPagesDisplay-1); i<=numPages; i++) {
                                    $("#story_browser_page_" + i).show();
                                }
                            }
                            else {
                                // ex: [5][6][7][8][9][10][11] - 12 total pages, 5-8 selected
                                self.$ctx.find(".story_browser_page").hide();
                                for (i=currentPage-Math.floor(_maxPagesDisplay / 2); i<=currentPage+Math.floor(_maxPagesDisplay / 2); i++) {
                                    $("#story_browser_page_" + i).show();
                                }
                            }
                            // enable/disable prev/next arrows if necessary
                            if (currentPage === 1) {
								self.$ctx.find(".pager_wrap .pager_prevpage").addClass("inactive");
                            } else {
								self.$ctx.find(".pager_wrap .pager_prevpage").removeClass("inactive");
                            }
                            if (currentPage === numPages) {
								self.$ctx.find(".pager_wrap .pager_nextpage").addClass("inactive");
							} else {
								self.$ctx.find(".pager_wrap .pager_nextpage").removeClass("inactive");
							}
                        } else {
							self.$ctx.find(".pager_prevpage").hide();
							self.$ctx.find(".pager_nextpage").hide();
                        }
                    });
                }, // oncreate end
				height: "variable",
				animateControls: false
			};
			self.$ctx.find('.caroufredsel_wrapper').remove();
			self.$ctx.find('.mmScrollPaginationWrp').empty();
			
			var element = self.$ctx.find('.mmScroll').mmScroll(obj).trigger('updatePageStatus');
			$(element).find(".pager_prevpage").on("click",function(){
                if (!$(this).hasClass("inactive")) {
                    $(element).find("ul").trigger("prev").trigger('updatePageStatus');
                }
            });
            $(element).find(".pager_nextpage").on("click",function(){
                if (!$(this).hasClass("inactive")) {
                    $(element).find("ul").trigger("next").trigger('updatePageStatus');
                }
            });
			
			self.attachEvents(true);
		},

		attachEvents: function(_pagination) {
			var self = this;
			var $mod = self.$ctx;
			
			// Pagination scroll.
			if (_pagination) {
				var $circlePage = self.$ctx.find('.mmScrollPaginationWrp .mmScrollPagination li a');
				$circlePage.on('click', function(event) {
					self.callOmnitureTracking ($mod, $(this), 'casePageClick');
					event.preventDefault();
				});
				return;
			}

			var $li = self.$ctx.find('ul.story-selection > li');
			$li.on('click', function(event) {
				if ($(event.target).closest('select').length) return;
				event.preventDefault();
				
				//
				self.callOmnitureTracking ($mod, $(this), 'caseTabclick');
				
				self.$ctx.find('ul.story-selection > li.active').removeClass('active');
				$(event.currentTarget).addClass('active');
				
				self.setTabPadding(event.currentTarget);
				self.arrangeItems($(event.currentTarget));
				self.initCarousel();
			}).find('select').on('change', function(event) {
				self.arrangeItems($(event.target).closest('li'));
				self.initCarousel();
				self.callOmnitureTracking ($mod, $(this), 'caseDropdownChange');
			});
			
			// Scroll Prev/Next.
			var $prev = self.$ctx.find('.story-pagination .mmScrollBtn.prev');
			$prev.on('click', function(event) {
				self.callOmnitureTracking ($mod, $(this), 'caseScrollPrev');
				event.preventDefault();
			});
			
			var $next = self.$ctx.find('.story-pagination .mmScrollBtn.next');
			$next.on('click', function(event) {
				self.callOmnitureTracking ($mod, $(this), 'caseScrollNext');
				event.preventDefault();
			});

			//Image_link
			self.$ctx.on('click','.mod.modTs_story_1 img',function(event) {
				self.callOmnitureTracking ($mod, $(this), 'caseImage_link');
			});
			
			//Heading_link
			self.$ctx.on('click','.mod.modTs_story_1 .tt a',function(event) {
				self.callOmnitureTracking ($mod, $(this), 'caseHeading_link');
			});
			
			//Descr_link
			self.$ctx.on('click','.mod.modTs_story_1 .content .txt a',function(event) {
				self.callOmnitureTracking ($mod, $(this), 'caseDescr_link');
			});

			//Scroller Left
			self.$ctx.on('click','.pager_wrap .pager_prevpage',function(event) {
				self.callOmnitureTracking ($mod, $(this), 'caseScrollerLeft');
			});

			//Page toogle
			self.$ctx.on('click','.pager .story_browser_page',function(event) {
				self.callOmnitureTracking ($mod, $(this), 'casePageToggle');
			});

			//Scroller Right
			self.$ctx.on('click','.pager_wrap .pager_nextpage',function(event) {
				self.callOmnitureTracking ($mod, $(this), 'caseScrollerRight');
			});
		},

		callOmnitureTracking: function($mod, $obj, trackingType) {
			if (typeof(Omniture_s) === 'undefined') { return; }
			var self = this;

			var brand = Omniture_s.eVar18.toLowerCase(),
				pageName = Omniture_s.pageName;
				
			// Current section name.
			$active = self.$ctx.find('ul.story-selection .active .story-subcategory dt a');
			var $currentSection = $active.text();
			if ($active.find('span').length > 0)
				$currentSection = $active.find('span').text();

			// Category Selected (Selected category from the dropDown)
			var $cat = self.$ctx.find('ul.story-selection .active .story-subcategory').find('option:selected').text();
			
			switch (trackingType) {
				case 'caseScrollerLeft':
					mrm.util.tagging.omniture_tl (
						$obj, $obj, 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':scroller left'
						}
					);
				break;

				case 'casePageToggle':
					mrm.util.tagging.omniture_tl (
						$obj, $obj, 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':page toggle'
						}
					);
				break;

				case 'caseScrollerRight':
					mrm.util.tagging.omniture_tl (
						$obj, $obj, 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':scroller right'
						}
					);
				break;
				
				case 'caseImage_link':
					mrm.util.tagging.omniture_tl (
						$obj, $obj, 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':'+$obj.parent().attr('href')
						}
					);
				break;
				
				case 'caseHeading_link':
					mrm.util.tagging.omniture_tl (
						$obj, $obj, 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':'+$obj.attr('href')
						}
					);
				break;
				
				case 'caseDescr_link':
					mrm.util.tagging.omniture_tl (
						$obj, $obj, 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':'+$obj.attr('href')
						}
					);
				break;

				case 'caseTabclick':
					mrm.util.tagging.omniture_tl (
						$obj, $obj.find('a').html(), 'o', '',
						{
							'pageName':pageName,
							'prop27':'filter area',
							'prop32':'filter area:story sort toggle:'+$obj.find('dt').text().replace(/\s+/g, '') //strip out any spaces
						}
					);
				break;
				
				case 'caseDropdownChange':
					mrm.util.tagging.omniture_tl (
						$obj, $obj.find('option').first().text(), 'o', '',
						{
							'pageName':pageName,
							'prop27':'filter area',
							'prop32':'filter area:'+$obj.find('option:selected').text()
						}
					);
				break;
				
				case 'casePageClick':
					mrm.util.tagging.omniture_tl (
						$obj, $obj.text(), 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':'+'page toggle'
						}
					);
				break;
				
				case 'caseScrollPrev':
					mrm.util.tagging.omniture_tl (
						$obj, $obj.text(), 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':'+'scroller left'
						}
					);
				break;
				
				case 'caseScrollNext':
					mrm.util.tagging.omniture_tl (
						$obj, $obj.text(), 'o', '',
						{
							'pageName':pageName,
							'prop27':$currentSection,
							'prop32':$currentSection+':'+$cat+':'+'scroller right'
						}
					);
				break;
			}
		},

		// set padding to the ul when there is a combobox in the li
		setTabPadding: function(target) {
			var self = this;
			if (!target) return;
			var $dl = $('.story-subcategory', target);
			var height = $('dd', $dl).height() || 0;
			self.$ctx.find('ul.story-selection').css('padding-bottom', height + 'px');
		},

		arrangeItems: function($li) {
			var self = this;
			// keys
			var key_selectall = 'all'; // option value="all"

			var maxItems = self.$ctx.data('maxitems');
			var $stories = self.$ctx.find('div.story-stories');

			// tabs
			var action = $li.data('action');
			var sortBy = $li.data('sortby');
			// dropdown
			var filterVal = $('select', $li).val(); // dropdown selectedValue
			var filterLinkedTo = $('select', $li).data('linkedto'); // 'maincategory' || 'subcategories'

			//remove onclick for image_link tracking
			self.$ctx.find('.mod.modTs_story_1 > a').removeAttr('onclick');

			// sort
			this.teaserElements.sort(function(a, b) {
				var aData = $(a).data(sortBy) || 0;
				var bData = $(b).data(sortBy) || 0;
				return  aData - bData;
			});

			// filter
			var elements = [];
			var len = this.teaserElements.length;
			for (var i = len - 1; i >= 0; i--) {
				var elem = this.teaserElements[i];
				var $elem = $(elem);
				var showElem = true;

				// remove from dom
				$elem.detach();

				// tab filter
				if (action == 'filter') {
					showElem = $elem.data($li.data('linkedto')) == $li.data('filterby') ? true : false;
				}

				// dropdown filter
				var cat = $elem.data(filterLinkedTo); // string || array
				if (filterVal && showElem && filterVal != key_selectall) {
					showElem = cat == filterVal || (typeof cat == 'object' && $.inArray(filterVal, cat) != -1) ? true : false;
				}

				if (showElem) elements.push(elem);
			}

			// build lists
			var $wrapper = $('<ul class="mmScrollItems">');
			while (elements.length > 0) {
				var crop = elements.splice(0, maxItems);
				var $ul = $(crop).wrap('<li />').wrapAll('<ul />').wrap('<li />').parent().parent().parent();
				$wrapper.append($ul);
			}
			
			// remove old ul
			self.$ctx.find('.story-stories > ul').remove();

			// append the wrapper to the dom
			$stories.append($wrapper);
		}
		
	});
})(mrm.$);( function( $ ) {
	/*
	* Click tracking for the 'prev' and 'next' buttons at bottom of culture story content area
	*/
	if ( mrm.util.curTemplate() !== '13' ) { return; } // just want t13 templated pages

	if ( $('#main_page_content .story_navigator a').length ) {
		$.each( $('#main_page_content .story_navigator a'), function() {
			$(this).removeAttr('onclick'); // removing default click tracking
		});

		$('#main_page_content .story_navigator a').on('click', function () {
			var btnType = '';
			if ( $(this).hasClass('prev') ) {
				btnType = 'previous';
			}
			if ( $(this).hasClass('next') ) {
				btnType = 'next';
			}
			callOmnitureTracking( $(this), btnType, $(this).attr('href') );
		});

		function callOmnitureTracking ( $obj, btnType, btnTargetArticle ) {
			if ( typeof(Omniture_s) === 'undefined' ) { return; }

			var brand 	 = Omniture_s.eVar18.toLowerCase(),
				pageName = Omniture_s.pageName;

			mrm.util.tagging.omniture_tl ( $obj, $obj.text(), 'o', '', {
				'pageName':pageName,
				'prop27':'content-area',
				'prop32':'content-area:' + btnType + ':' + btnTargetArticle
			} )

		}

	}

}(mrm.$));(function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		story_overview: {          
			/**
			 * JS for component story_overview
			 * 
			 * @param {String} c DOM Context
			 */

			$selects: (function() {
				return $('.modStory_overview .selection select');
			})(),

			sectionsOrder: (function() {
				var arr = [];
				$('.modStory_overview > .content > .section').each(function() {
					arr.push($(this).data('sectiontitle'));
				});
				return arr.reverse();
			})(),
			// re-factored to use initMod
			initMod: function($mod) {    
				mrm.util.log('[story_overview] Context: ' + $mod);
				var self = this;				
				if ($mod.length == 0) return;
				if ($mod.hasClass('scrollerInit') && typeof(self.scrollerInit) === "object") {
					self.scrollerInit.initMod($mod);
					return; // only for new culture redesign for chevy.
				};
				// read cookie
				var mode = mrm.util.cookie.get('modStory_browser::mode') || 'ui-image-view';
				$mod.addClass(mode);
				$mod.find('> .selection > a.story-mode-' + (mode == 'ui-list-view' ? 'list' : 'image')).addClass('active');

				// inital filter & sort
				this.arrangeElements($mod);

				// bindings
				this.attachEvents($mod);
			},

			attachEvents: function($mod) {
				var that = this;
				// icons
				var $icons = $mod.find('> .selection > a[class^="story-mode-"]');
				$icons.html(''); // remove alt text
				$icons.on('click', function(event){
					event.preventDefault();
					$icons.removeClass('active');
					var $a = $(event.currentTarget);
					$a.addClass('active');
					var $div = $('.modStory_overview');
					if ($a.hasClass('story-mode-list')) {
						$mod.removeClass('ui-image-view');
						$mod.addClass('ui-list-view');
						mrm.util.cookie.set('modStory_browser::mode', 'ui-list-view');
					} else {
						$mod.removeClass('ui-list-view');
						$mod.addClass('ui-image-view');
						mrm.util.cookie.set('modStory_browser::mode', 'ui-image-view');
					}
				});

				// dropdowns
				this.$selects.on('change', function() {
					that.arrangeElements($mod);
				});
			},
				arrangeElements: function($mod) {
				var that = this;
				this.$selects.each(function() {
					var $select = $(this);
					var action = $select.data('action');
					var selectVal = $select.val();

					switch (action) {
						case 'sectionfilter':
							$mod.find('> .content > .section').each(function() {
								var $section = $(this);
								var showSection = selectVal == 'all' || $section.data('sectiontitle') == selectVal;
								// show/hide section
								$section.css('display', showSection ? 'block' : 'none');
							});
							// resort sections
							$(that.sectionsOrder).each(function() {
								var sectionId = this.toString();
								var $section = $mod.find(' > .content > .section[data-' + $select.data('filterby') + '="' + sectionId + '"]:visible');
								// place it in front
								if ($section) $mod.find(' > .content').prepend($section);
							});
						break;
						case 'filter':
							$mod.find(' > .content .modCnt_story_1').each(function() {
								var $teaser = $(this);
								var showTeaser = selectVal == 'all' || $teaser.data('carline') == selectVal;
								// show/hide li
								$teaser.parent().css('display', showTeaser ? 'list-item' : 'none');
							});
							// are there now an empty sections?
							var $emptySections = $mod.find('> .content > .section:not(:has(li:visible))');
							$emptySections.css('display', 'none');
							$mod.find(' > .content').append($emptySections);
						break;
					}
				});

				// sort teasers
				var sortBy = $mod.find('.selection select.story-sort').val() || 'publish_date';
				$mod.find(' > .content > .section:visible').each(function() {
					var that = this;
					var teasers = $('ul > li:visible', this).toArray();
					// reverse order
					teasers.sort(function(a, b) {
						var aData = $('.modCnt_story_1', a).data(sortBy) || 0;
						var bData = $('.modCnt_story_1', b).data(sortBy) || 0;
						return  aData - bData;
					});	
					// dom
					$(teasers).each(function(){
						$('> ul', that).prepend(this);
					});		
					// headline at first
					$(that).prepend($('.hl_t', that));
				});

			}
		}
	});
}(mrm.$));/* Story_Overview For Culture Redesign 2013 */
// Lou Bodde & Chad Wilson - MRM Detroit
(function($) {
    mrm.cmp.story_overview = mrm.cmp.story_overview || {};
    mrm.cmp.story_overview.scrollerInit = {
        initMod: function($mod){
            var self = this;
            self.updateSelectBox($mod);
            self.getDataViews($mod);
        },
        updateSelectBox: function($mod) {
            var self = this;
            var hash = window.location.hash.replace("#","");
            if (hash.length > 0){
                $mod.find(".story-filter-sectiontitle").val(hash);
            }
        },
        mytemp: function($mod, selector, data){
            return _.template( $(selector).html(), {result: data});
        },
        setBindings: function($mod, articles, dataURL){
            var self = this;
            //onClick of the most_popular button
            $mod.find('.btn_most_popular').on('click', function (e){
                e.preventDefault();
                // adjust button styling
                $mod.find('.btn_most_popular').addClass("btn_prim").removeClass("btn_sec");
                $mod.find('.btn_most_recent').addClass("btn_sec").removeClass("btn_prim");
                // load most_popular JSON
                var dataURL = $mod.data('url'); // get current dataURL
                if (dataURL.indexOf("most_popular") === -1) {
                    dataURL = dataURL.replace("most_recent","most_popular");
                    // self.getDataViews($mod, dataURL);
                    articles.render(dataURL);
                }
            });
            // onClick of the most_recent button
            $mod.find('.btn_most_recent').on('click', function (e){
                e.preventDefault();
                // adjust button styling
                $mod.find('.btn_most_popular').addClass("btn_sec").removeClass("btn_prim");
                $mod.find('.btn_most_recent').addClass("btn_prim").removeClass("btn_sec");
                // load most_recent JSON
                var dataURL = $mod.data('url'); // get current dataURL
                if (dataURL.indexOf("most_recent") === -1) {
                    dataURL = dataURL.replace("most_popular","most_recent");
                    // self.getDataViews($mod, dataURL);
                    articles.render(dataURL);
                }
            });
            // Category dropdown change
            $mod.find('select').on('change', function(){
                articles.render('');
                var catID = $mod.find(".story-filter-sectiontitle").val();
                if (catID.length > 0) {
                    self.updateHash($mod,catID)
                    self.updateMastheads($mod,catID);
                }
            });
            //Update hashtag in URL 
            $(window).on('hashchange',function() {
                self.updateSelectBox($mod);
                var catID = $mod.find(".story-filter-sectiontitle").val();
                if (catID.length > 0) {
                    self.updateMastheads($mod,catID);
                }
                var dataURL = $mod.data('url'); // get current dataURL
                articles.render(dataURL);
            });
            // Click article image or text
            $mod.find('.modCnt_story_1').on('click', function (e){
                // e.preventDefault();
                var $btn = $('.story-teasertext > a', this);
                document.location.href = $btn.attr('href');
            });
        },
        //possible lazy loading of carousels in future if plugin is updated to new version or added
        loadImage: function($img ) {
            $.each($img,function(k,v) {
                if (!$(v).is("img")) {
                    v = $(v).find("img");
                }
                if ( $(v).attr('src').indexOf('culture-') != -1 ) {
                    $(v).attr('src', $(v).data('original') );
                }
            });
        },
        // resetHeight: function($mod) {
        //     var height = $(".masthead .modMh_1 img:visible").height();
        //     var margin = $(".masthead .modMh_1").css("margin-top").toString().replace("px","");
        //     $(".masthead .modMh_1").css("height", (parseInt(height) + parseInt(margin)) + "px");
        //     $(".masthead .modMh_1").css("margin-bottom", 0-(parseInt(margin)) + "px");
        // },
        bindArticleClicks: function($mod) {
            $mod.find('.modCnt_story_1').on('click', function (e){
                 e.preventDefault();                        
                var $btn = $('.story-teasertext > a', this);                        
                document.location.href = $btn.attr('href');
            });
        },
        getDataViews: function($mod){
            var self = this;
            var value;
            var dataURL = $mod.data('url');
            articlesLayout = Backbone.Model.extend();
            storiesData = Backbone.Collection.extend({
                model : articlesLayout,
                url: dataURL,
            });
            var allArticles = Backbone.View.extend({
                el: $(".content", $mod),
                render: function(dataURL){
                    if (dataURL==='') {
                        dataURL = $mod.data('url');
                    }
                    $mod.data('url',dataURL);
                    value = ($mod.find('select').length) ? $mod.find('select option:selected').val() : null;
                    var that = this;
                    var data = new storiesData();
                    data.url = dataURL;
                    data.fetch({
                        success: function(collection, response){
                            if (value == 'all' || $mod.hasClass('allCulture')) {
                                that.configData(response.result); // for ALL page and all dropdown selection
                            } else {
                                that.specificView(response.result.categories); // for specific Category
                            }
						
							// Tracking callback for async content.
							/* if (typeof(mrm.track.story_overview.addTrackEvents) == 'function')
								mrm.track.story_overview.addTrackEvents($mod); */
                        }
                    });
                },
                specificView: function(cat){
                    var find;
                    if (value !== null ){ 
                        find = _.find(cat, function (id){
                            return id.catID == value;
                        });
                    } else {
                        find = cat[0];
                    }
                    var that = this;
                    // template for individual categories
                    var template = self.mytemp($mod, "#story_category", find);
                    // Load the compiled HTML into the Backbone "el"
                    that.$el.html( template );

                    if (mrm.util.ie8()) {
                        self.ie8fix($mod);
                    }
                    
                    // self.resetHeight($mod);
                    self.bindArticleClicks($mod);
                },
                configData: function(cat){
                    var that = this;
                    // Compile the template using underscore
                    var template = self.mytemp($mod, "#story_articles", cat);
                    // Load the compiled HTML into the Backbone "el"
                    that.$el.html( template );
                    cat = cat.categories; //after rendering the ALL data we only need categories
                    var options;
                    _.each(cat, function (v,k){
                        if (v.articles.length > 3) {
                            var element = $mod.find('div.section[data-sectiontitle="'+ v.catID + '"] ul');
                            options = {
                                auto    : false,
                                prev    : '#'+v.catID +'_prev',
                                next    : '#'+v.catID +'_next',
                                items: {
                                    visible: 3,
                                    start:0
                                },
                                width:980,
                                height: 'variable',
                                pagination: {
                                    container : function () {
                                        // create pagination wrapper and return .pager
                                        return $('<div class="pager_wrap"><span class="pager_prevpage" id="pager_prevpage_' + v.catID + '">&lt;</span><div class="pager"></div><span class="pager_nextpage" id="pager_nextpage_' + v.catID + '">&gt;</span></div>')
                                        .prependTo($(this).parent().parent())
                                        .children('.pager');
                                    },
                                    anchorBuilder: function(nr) {
                                        // [1][2][3]...
                                        return ' <a href="#" id="page_' + v.catID + '_' + nr + '" class="page_' + v.catID + '"><span>'+nr+'</span></a> ';
                                    }
                                },
                                scroll  : {
                                	wipe: true,
                                    items: 'page',
                                    onBefore: function(data) {
                                        self.loadImage( $(this).find("li img") );
                                    },
                                    onAfter: function(data){
                                    	if ( !mrm.util.ie8() ) {
                                            $(this).css('left','0');
                                    	    $(this).find("li").css("margin-left","3px");
                                            $(this).find("li:first").css("margin-left","0px");
                                        }
                                        else {
                                            $(this).css("left", "0");
                                            $(this).find("li:first").css("margin-left", "0px").css("margin-right","0");
                                            $(this).find("li:gt(0)").css("margin-left", "13px").css("margin-right","0");
                                        }
                                    }
                                },
                                // pagination creation
                                onCreate: function(data) {
                                    var _bulletsCenter = 7; // number of bullets in the middle, should always be an odd number
                                    var _bulletsSide = 0; // number of bullets left and right
                                    var _maxPagesDisplay = 7;
                                    // add jsReady class for scroller paddles to show.
                                    $(this).parents('.section').addClass('jsReady');
                                    self.loadImage( $(this).find("li:lt(3) img") ); //lazyLoad Scrollers
                                    $(this).bind('updatePageStatus.cfs', function() {
                                        var ancestorDiv = $(this).parent().parent();
                                        if ($(ancestorDiv).find(".pager_wrap .pager a").length > _maxPagesDisplay) {
                                            var _itemsTotal = $(this).children().length;
                                            var _pagesCurrent = $(this).triggerHandler( 'currentPosition' ); // gets current position of carousel
                                            var currentPage = (_pagesCurrent / Math.floor(_maxPagesDisplay / 2)) + 1
                                            var numPages = Math.ceil(_itemsTotal / Math.floor(_maxPagesDisplay / 2));
                                            if (currentPage <= Math.ceil(_maxPagesDisplay / 2)) {
                                                // ex: [1][2][3][4][5][6][7] - page 1-4 selected
                                                $(".page_" + v.catID).show();
                                                for (var i=_maxPagesDisplay + 1; i<=numPages; i++) {
                                                    $("#page_" + v.catID + "_" + i).hide();
                                                }
                                            }
                                            else if (currentPage > numPages - Math.ceil(_maxPagesDisplay / 2) ) {
                                                // ex: [6][7][8][9][10][11][12] - 12 total pages, 9-12 selected
                                                $(".page_" + v.catID).hide();
                                                for (var i=numPages - Math.floor(_maxPagesDisplay-1); i<=numPages; i++) {
                                                    $("#page_" + v.catID + "_" + i).show();
                                                }
                                            }
                                            else {
                                                // ex: [5][6][7][8][9][10][11] - 12 total pages, 5-8 selected
                                                $(".page_" + v.catID).hide();
                                                for (var i=currentPage-Math.floor(_maxPagesDisplay / 2); i<=currentPage+Math.floor(_maxPagesDisplay / 2); i++) {
                                                    $("#page_" + v.catID + "_" + i).show();
                                                }
                                            }
                                           
                                           // enable/disable prev/next arrows if necessary
                                            currentPage === 1 ? $(this).parents(".section").find(".pager_prevpage").addClass("inactive") : $(this).parents(".section").find(".pager_prevpage").removeClass("inactive");
                                            currentPage === numPages ? $(this).parents(".section").find(".pager_nextpage").addClass("inactive") : $(this).parents(".section").find(".pager_nextpage").removeClass("inactive");
                                        }
                                        else {
                                            ancestorDiv.find(".pager_prevpage").hide();
                                            ancestorDiv.find(".pager_nextpage").hide();
                                        }
                                    });

                                } // oncreate end
                            }; // options end

                            var cfg = $.extend(true, {}, options), // extended to use touchwipe for touch devices.                 

                            wipeConfig = {
                                min_move_x: 30,
                                min_move_y: 30,
                                preventDefaultEventsHorizontal: (!cfg.scroll.noWipeDirection || cfg.scroll.noWipeDirection !== 'horizontal'),
                                preventDefaultEventsVertical: (!cfg.scroll.noWipeDirection || cfg.scroll.noWipeDirection !== 'vertical'),
                                wipeLeft:  function (e) { element.trigger('next'); },
                                wipeRight: function (e) { element.trigger('prev'); }
                            };
                            // end of variables ^^ 

                            if ($.fn.touchwipe && cfg.scroll.wipe) {
                                element.touchwipe(wipeConfig); // additional support for touch devices.
                                cfg.scroll.wipe = false; // keep caroufredsel from using it's built-in touchwipe support
                            }
                            
                            $('<div class="clearfix"></div><a class="mmScrollBtn prev" id="' + v.catID + '_prev" href="#"><span>prev</span></a><a class="mmScrollBtn next" id="' + v.catID + '_next" href="#"><span>next</span></a>').insertAfter(element, $mod);
                            var curCarousel = element.carouFredSel(cfg).css("left","0");

                            if (mrm.util.ie8()) {
                                self.ie8fix($mod);
                            }

                            $(element).parents(".section").find(".pager_prevpage").on("click",function(){
                                if (!$(this).hasClass("inactive")) {
                                    $mod.find('div.section[data-sectiontitle="'+ v.catID + '"] ul').trigger("prev");
                                }
                            });
                            $(element).parents(".section").find(".pager_nextpage").on("click",function(){
                                if (!$(this).hasClass("inactive")) {
                                    $mod.find('div.section[data-sectiontitle="'+ v.catID + '"] ul').trigger("next");
                                }
                            });
                        }
                        else {
                            var images = $mod.find('div.section[data-sectiontitle="'+ v.catID + '"] ul li img');
                            self.loadImage(images);
                        }
                    });

                    // self.resetHeight($mod);
                    self.bindArticleClicks($mod);
                }
            });
            
            var articles = new allArticles();
            articles.render(dataURL);
            if( $mod.find('select').length > 0) {
                var catID = $mod.find(".story-filter-sectiontitle").val();
                if (catID.length > 0) {
                    self.updateMastheads($mod,catID);
                }
                else {
                    self.updateMastheads($mod,'all');
                }
            }
            else {
                self.updateMastheads($mod,'');
            }
            // OnClick of most_popular
            self.setBindings($mod, articles, dataURL);
        },
        ie8fix: function($mod) {
            $(".modStory_overview.scrollerInit > .content > .section ul > li:nth-child(3n+1)").css("margin","0 13px 8px 0");
            $(".modStory_overview.scrollerInit > .content > .section ul > li:nth-child(3n+2)").css("margin","0 13px 8px 0");
            $(".modStory_overview.scrollerInit > .content > .section ul > li:nth-child(3n+3)").css("margin","0 0 8px 0");
        },
        updateHash: function($mod, catID) {
            window.location.hash = "#" + catID;
        },
        updateMastheads: function ($mod, catID) {
            if (catID.length > 0) {
                $(".modMh_scroller_1").hide();
                $(".modMh_scroller_1[data-category='" + catID + "']").show();
            }
            $(".modMh_1").css("max-height", "604px");
        }
    }
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		story_overview: {
			section: '',
			initTrack: function($mod, section){
				this.section = section;
				this.addTrackEvents($mod);
			},

			addTrackEvents: function ($mod) {
				var self = this,
					clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				// Pager.
				$mod.on(clickOrTouch, '.pager a', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'pager');
				});

				// Pager Arrow Previous.
				$mod.on(clickOrTouch, '.pager_wrap > span.pager_prevpage', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'pager_prevpage');
				});

				// Pager Arrow Next.
				$mod.on(clickOrTouch, '.pager_wrap > span.pager_nextpage', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'pager_nextpage');
				});

				// Title.
				$mod.parent().on(clickOrTouch, '.hl_t', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'title');
				});

				// Prev arrow.
				$mod.on(clickOrTouch, '.mmScrollBtn.prev', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'scroller_left');
				});

				// Next arrow.
				$mod.on(clickOrTouch, '.mmScrollBtn.next', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'scroller_right');
				});
				
				// Article
				$mod.on(clickOrTouch, '.modCnt_story_1', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'article');
				});

				// Read article link
				$mod.on(clickOrTouch, '.story-teasertext a', function(_e) {
					_e.stopPropagation(); // Stop the onclick of the main parent ( Story click ^^ ) for seperate tracking
					self.callOmnitureTracking($mod, $(this), 'read_article');
				});

				// story-filter-sectiontitle drop down
				if ( $('.selection select').length ) {
					$mod.on('change', '.selection select', function(_e) {
						self.callOmnitureTracking($mod, $(this), 'caseDropdownChange');
					});
				}

				// 'Recent' and 'Popular' buttons
				$mod.on(clickOrTouch, '.selection a', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'caseStorySortToggle');
				});

				// Category Text Links
				$mod.on(clickOrTouch, '.content .section a h2', function(_e) {
					self.callOmnitureTracking($mod, $(this), 'caseCategoryTextLink');
				});
			},

			callOmnitureTracking: function( $mod, $obj, trackingType ) {
				var trackSection, trackValue;

				if (typeof(Omniture_s) === 'undefined') return;
				var self = this,
					brand = Omniture_s.eVar18.toLowerCase(),
					pageName = Omniture_s.pageName;


				switch( trackingType ) {
					case 'pager':
						mrm.util.tagging.omniture_tl (
							$obj, 'page_toggle', 'o', '',
							{
								'pageName':pageName,
								'prop27':$.trim($obj.parent().parent().parent().find('.hl_t').text()),
								'prop32':$.trim($obj.parent().parent().parent().find('.hl_t').text()) + ':page toggle'
							}
						);
					break;

					case 'pager_prevpage':
						mrm.util.tagging.omniture_tl (
							$obj, 'pager_prevpage', 'o', '',
							{
								'pageName':pageName,
								'prop27':$.trim($obj.parent().parent().find('.hl_t').text()),
								'prop32':$.trim($obj.parent().parent().find('.hl_t').text()) + ':page toggle:scroller left'
							}
						);
					break;

					case 'pager_nextpage':
						mrm.util.tagging.omniture_tl (
							$obj, 'pager_nextpage', 'o', '',
							{
								'pageName':pageName,
								'prop27':$.trim($obj.parent().parent().find('.hl_t').text()),
								'prop32':$.trim($obj.parent().parent().find('.hl_t').text()) + ':page toggle:scroller right'
							}
						);
					break;

					case 'title':
						mrm.util.tagging.omniture_tl (
							$obj, $obj.attr('href'), 'o', '',
							{
								'pageName':pageName,
								'prop27':'content area',
								'prop32':'content area:'+$obj.find('.hl_t').html()
							}
						);
					break;

					case 'scroller_left':
						mrm.util.tagging.omniture_tl (
							$obj, 'scroller_left', 'o', '',
							{
								'pageName':pageName,
								'prop27':$obj.parent().find(".hl_t").text(),
								'prop32':$obj.parent().find(".hl_t").text()+':scroller left'
							}
						);
					break;

					case 'scroller_right':
						mrm.util.tagging.omniture_tl (
							$obj, 'scroller_right', 'o', '',
							{
								'pageName':pageName,
								'prop27':$obj.parent().find(".hl_t").text(),
								'prop32':$obj.parent().find(".hl_t").text()+':scroller right'
							}
						);
					break;
					
					case 'article':
						trackSection = $obj.parentsUntil(".section").parent().find(".hl_t").length > 0 ? $obj.parentsUntil(".section").parent().find(".hl_t").text() : "content-area";
						trackValue = $.trim($obj.find("h3.tt").text());
						
						mrm.util.tagging.omniture_tl (
							$obj, 'article', 'o', '',
							{
								'pageName':pageName,
								'prop27':trackSection,
								'prop32':trackSection+':'+trackValue
							}
						);
					break;
					
					case 'read_article':
						trackSection = $obj.parentsUntil(".section").parent().find(".hl_t").length > 0 ? $obj.parentsUntil(".section").parent().find(".hl_t").html() : "content-area";
						trackValue = $.trim($obj.parentsUntil(".modCnt_story_1").parent().find("h3.tt").text());
						
						mrm.util.tagging.omniture_tl (
							$obj, $obj.attr('href'), 'o', '',
							{
								'pageName':pageName,
								'prop27':trackSection,
								'prop32':trackSection+":read article:"+trackValue
							}
						);
					break;

					case 'caseDropdownChange':
						mrm.util.tagging.omniture_tl (
							$obj, $obj.find('option').first().text(), 'o', '',
							{
								'pageName':pageName,
								'prop27':'filter area',
								'prop32':'filter area:'+$obj.find('option:selected').text()
							}
						);
					break;

					case 'caseStorySortToggle':
						mrm.util.tagging.omniture_tl (
							$obj, $obj.text(), 'o', '',
							{
								'pageName':pageName,
								'prop27':'filter area',
								'prop32':'filter area:story sort toggle:'+$obj.text()
							}
						);
					break;

					case 'caseCategoryTextLink':
						mrm.util.tagging.omniture_tl (
							$obj, $obj.text(), 'o', '',
							{
								'pageName':pageName,
								'prop27':'content area',
								'prop32':'content area:'+$obj.text()
							}
						);
					break;
				}
			}
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Ts_2ll_2 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;

			this.$ctx.find('.figure, .figure + div').equalHeights();

			// vertical-center of icon
			var $dd = this.$ctx.find('.figure dd');
			var $mm = $dd.find('.mm');
				
			$mm.css('margin-top', ($dd.height() - $mm.height()) / 2);
		}
	});
})(mrm.$);(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		ts_attr_1: {
			init: function(c) {
				// add net pricing cluetip
				$(".modTs_attr_1 dl dt span a[cluetip-title*=' ']").addClass("cluetip_ts_attr_1");
				var b = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
					titleAttribute: "cluetip-title",
					activation: "click"
				});
				$('.cluetip_ts_attr_1').cluetipWrap(b);
			}
		}
	});
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		ts_btn_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				// button cta and link tracking
				$mod.find("a").on(clickOrTouch, function(){
					var linkname = $(this).text();
					//if the length of linkname is 0 then this may be a picture, let's try for the filename
					if (linkname.length == 0) {
						linkname = $(this).find("img").attr("src");
						linkname = linkname.substr(linkname.lastIndexOf('/') + 1);
						mrm.util.trackEvent("click_cta", {section: section, linkname: "image:" + linkname});
					} else {
						mrm.util.trackEvent("click_cta", {section: section, linkname: "button:" + linkname});
					}
				});
			}
		}
	});
}(mrm.$));
(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, { 
        ts_expander_1 : {
            init: function(c) {
                
                // sets ts_expander_1 as an accordion
                    $(".ts_expander_1").accordion({collapsible:true,autoHeight:false,header:"> div"});

                // setting it to be open by default
                    $(".ts_expander_1 > div").click();

                // removing styles from li wrapping around ts_expander_1
                    $('.ts_ll_1 ul li > .ts_expander_1').parent().css('margin-left','0');
            }
        }
    });
}(mrm.$));
;(function($) {
	mrm.mod.Ts_ilike_btn_1 = mrm.mod.AbstractMod.extend({

		options: {
			selector: '.modTs_ilike_btn_1',
		},

		prepare: function() {
			var self = this;
			if (mrm.conf.util.sharing.socialPrivacy) {
				self.disableTags();
				mrm.util.sharing.initSocialSwitches(self.$ctx);
			}
		},

		/**
		 * Disable provider-tags so they are hidden from the the provider-scripts
		 * ex: converts "fb-like" to "disabled-fb-like"
		 */
		disableTags: function() {
			this.$ctx.find('.fb-like').each(function(i, tag) {
				var $tag = $(tag);
				var cls = $tag.attr('class');
				$tag.attr('class', cls.replace(/(fb-like)/, mrm.conf.util.sharing.disabledProviderTag + "$1"));
			});
		}

	});
})(mrm.$);
(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		ts_ilike_btn_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				$('.socialSwitch', $mod).on(clickOrTouch, function() {
					var serviceClass = $(this).parents('.socialPrivacy').attr('class').match(/service[\w\-]*\b/)[0],
					    service = serviceClass.replace('service-', ''),
					    switchState = '';

					if ( $(this).hasClass('on') ) {
						switchState = 'soc_slider_on';
					} else {
						switchState = 'soc_slider_off';
					}

					if ( window.Omniture_s ) {
						mrm.util.tagging.omniture_tl(true, 'social_switch', 'o', '', {
							prop27: 'soc_slider',
							prop32: Omniture_s.pageName + ':' + switchState + ':' + service
						});
					}
				});
			}
		}
	});
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		ts_img_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';						
				
				//Tracking for "images" on main home page	
				//$mod.find('a').removeAttr('onclick');
				$mod.find('a img').on(clickOrTouch, function(){
					var linkname = $(this).attr("src");
					if (typeof(linkname) !== "undefined") {
						linkname = linkname.substr( linkname.lastIndexOf('/') + 1 );
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'image:' + linkname});
				});		
			}				
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Ts_img_2 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;

			self.$ctx.hover(
				function() {
					if (self.$ctx.children('a').length > 0){
						self.$ctx.addClass("ui-state-hover");
					}
				},
				function() {
					self.$ctx.removeClass("ui-state-hover");
				}
			);

			mrm.util.alignTextWithinCmp(self.$ctx.children('div'));
		}
	});
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		ts_img_2: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';						
				
				//Tracking for "images" on main home page	
				//$mod.find('a').removeAttr('onclick');
				$mod.find('a img').on(clickOrTouch, function(){
					var linkname = $(this).attr("src");
					if (typeof(linkname) !== "undefined") {
						linkname = linkname.substr( linkname.lastIndexOf('/') + 1 );
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'image:' + linkname});
				});		
			}				
		}
	});
}(mrm.$));+ ( function ( $ ) {
	$.extend( mrm.cmp, {
		'ts_inventory_1' : {
			'tpl' : [ '06' ],

			'init' : function ( c ) { 

				if ($('.modTs_inventory_1').length == 0) return;

				var data = $('.modTs_inventory_1').children('.stateA').data();
				this.$inventory = $('.modTs_inventory_1');
				this.model = data['carline'];
				this.bodyStyle = data['bodyStyle'];
				this.year = data['year'];
				this.setParams({
					'url'	: data['url'],
					'data'	: {
						'x-bodystyle'	: data['bodyStyle'],
						'x-modelyear'	: data['year'],
						'x-brand'		: data['brand'],
						'x-language'	: data['lang'],
						'x-country'		: data['country'],
						'x-zipcode'		: data['zip']
					}
				});
				this.state = {
					a: this.$inventory.children('.stateA')
					, b: this.$inventory.children('.stateB')
					, c: this.$inventory.children('.stateC')
					, all: this.$inventory.children()
				};
				//this.toggle = this.toggle();
				if ( this.setZip() ) {
					this.talk();
					$(".stateB").removeClass('hidden');
					$(".stateC").addClass('hidden');
					$(".stateA").addClass('hidden');
				} else {
					$(".stateB").removeClass('hidden');
					$(".stateC").addClass('hidden');
					$(".stateA").addClass('hidden');
				}
				this.listeners();
			},

			'params' : {},

			'setParams' : function ( obj ) { for ( var param in obj ) this.params[ param ] = obj[ param ]; },

			'toggle' : function () { /* show a specific state. */
				var self = this;
				return {
					hide: function () {
						self.state['all'].addClass('hidden');
					}, show: function (s) {
						this.hide();
						self.state[s].removeClass('hidden');
					}
				};
			},

			'results' : function ( c ) { /* swap views. set count. */
				var self = this;
				if ( c === null || typeof c.count !== 'number' ) {
					$(".stateA").addClass('hidden');
					$(".stateB").addClass('hidden');
					$(".stateC").removeClass('hidden');
					return;
				}

				//check for zero inventory
				if( c.count === 0 ) {
					$(".stateA").addClass('hidden');
					$(".stateB").addClass('hidden');
					$(".stateC").removeClass('hidden');
					return;
				}

				this.$inventory.children().addClass('hidden');
				this.state['a'].find('.count').html(c.count > 100 ? '100+' : c.count);
					$(".stateA").removeClass('hidden');
					$(".stateB").addClass('hidden');
					$(".stateC").addClass('hidden');
			},

			'setZip' : function () { /* grabs / sets zipcode. */
				if ( typeof mrm.cmp.zc === 'undefined' ) return false;
				var zip = mrm.cmp.zc.cookie.get();
				if ( zip === null ) {
					zip = mrm.util.cookie.get("cookie_customer_location");
					if (zip === null) {
						return false;
					}
				}
				zip = zip.substr( zip.lastIndexOf('"zipcode":') );
				zip = zip.replace(/"/g, '').replace(/:/g, '').replace(/{/g, '').replace(/}/g, '').replace(/zipcode/g, '');
				return this.params.data['x-zipcode'] = zip;
			},

			'talk' : function () {
				var self = this;
				try {
					/* zip code is valid. set the cookie. */
					mrm.cmp.zc.validate(self.params.data['x-zipcode'], function(){}, false);
				} catch (e) {
					/* zip code is invalid. */
					$(".stateA").addClass('hidden');
					$(".stateB").addClass('hidden');
					$(".stateC").removeClass('hidden');
					return;
				}
				self.state['c'].find('dd').html('(ZIP code '+self.params.data['x-zipcode']+')');
				$.ajax({
					'type'		: 'GET',
					'url'		: self.params.url,
					'data'		: self.params.data,
					'dataType'	: 'json',
					'cache'		: false,
					'success'	: function ( res ) { self.results( res ); },
					'error'		: function ( ) {
						$(".stateA").addClass('hidden');
						$(".stateB").addClass('hidden');
						$(".stateC").removeClass('hidden');
					}
				});
			},

			'listeners' : function () {
				var self = this;
				self.state['a'].find('a').on('click', function (e) {
					e.preventDefault();
					var openCmsPage = getGmdsCmsLinks();
					openCmsPage.openCmsPage(GmdsCmsLinks.SEARCH_INVENTORY, 'x-zipcode='+self.params.data['x-zipcode'], self.model, self.bodyStyle, self.year.toString());
				});
				self.state['b'].find('form').on('submit', function (e) { /* search by enter key. */
					e.preventDefault();
					self.params.data['x-zipcode'] = self.state['b'].find('input').val();
					self.talk();
				});
				self.state['b'].find('.ull a').on('click', function (e) { /* search by click. */
					e.preventDefault();
					self.state['b'].find('form').trigger('submit');
				});
				self.state['c'].find('.ull a').on('click', function (e) { /* show search. */
					e.preventDefault();
					$(".stateA").addClass('hidden');
					$(".stateB").removeClass('hidden');
					$(".stateC").addClass('hidden');
				});
			}
		}
	});
}) ( mrm.$ );mrm.track.ts_ln_1 = function ($) {

    function initTrack($mod, section) {

        $mod.children("a").on("click", function(){
 			var linkname = $(this).find("img").attr("src");
			if (typeof(linkname) !== "undefined") {
				linkname = linkname.substr(linkname.lastIndexOf('/') + 1);
			}
			mrm.util.trackEvent("click_cta", {section: section, linkname: 'image:' + linkname});
        });

        $mod.find("h3 a").on("click", function(){
 			var linkname = $(this).find("img").attr("src");
			if (typeof(linkname) !== "undefined") {
				linkname = linkname.substr(linkname.lastIndexOf('/') + 1);
			}
			mrm.util.trackEvent("click_cta", {section: section, linkname: 'image:' + linkname});
		});

        $mod.find("div > a").on("click", function(){
            var linkname = $(this).text();
            mrm.util.trackEvent("click_cta", {section: section, linkname: 'link:' + linkname});
        });
    }

    return {
        initTrack: initTrack
    };

}(mrm.$);mrm.cmp.ts_prefvehicle_1 = function($) {
	var $context;
	var userVehicleData;
	var _json = {};
	function _initMod($mod) {
		$context = $mod;
		loadJson(checkState);
		$.eventDispatcher.on('vehicle_config_load', checkState);
		$.eventDispatcher.on('vehicle_config_load_empty', checkState);
		$.eventDispatcher.on('vehicle_config_change', checkState);
		checkState();
	}

	function checkState(event_name, event_data) {
		userVehicleData = mrm.util.vehicleConfig.getUserVehicle();
		if (typeof userVehicleData !== "undefined" && typeof mrm.util.vehicleConfig.isConfigured() !== "undefined") {
			if ( userVehicleData.carline === 'null' || userVehicleData.carline === null ) {
				setupDefault();
			} else if (mrm.util.vehicleConfig.isConfigured()) {
				setupBuilt();
			} else {
				setupSelected();
			}
		} else {
			setupDefault();
		}
	}

	function setupDefault() {
		$context.find(".selected, .built").hide();
		$context.find(".default").show();
	}

	function setupSelected() {
		var $selectedState = $context.find(".selected");

		insertCgiUrl($selectedState);
		updateShopLinks($selectedState);
		insertCarline($selectedState);
		insertPrice($selectedState);

		$context.find(".default, .built").hide();
		$context.find(".selected").show();
	}

	function setupBuilt() {
		var $builtState = $context.find(".built");

		insertCgiUrl($builtState);
		updateShopLinks($builtState);

		insertCarline($builtState);
		insertPrice($builtState);

		$context.find(".default, .built").hide();
		$context.find(".selected").show();
		$context.find(".default, .selected").hide();
		$builtState.show();
	}

	function insertCarline($context) {
		var car = getJson(userVehicleData.year, userVehicleData.carline, userVehicleData.bodystyle);
		if (car) {
			var carlineText = (car.carlineText || '').replace(/\<br.*\s/gi, '');
			var anchor = $context.find('div > a').clone();
			$context.find('div > a').addClass("btn_sec");
			$context.find("h3").html(anchor.removeClass('btn_sec').html(carlineText + userVehicleData.carline).get(0));
		}
	}

	function insertPrice($context) {
		var car = getJson(userVehicleData.year, userVehicleData.carline, userVehicleData.bodystyle);
		var locale = mrm.conf.locale || {};
		var price = 0;
		locale.numberFormatting.separator.decimals = $context.find('dd.tx2').data('currency-seperator') || '.'; //doesn't matter because pricing doesn't include decimals
		locale.numberFormatting.separator.thousands = $context.find('dd.tx2').data('currency-seperator') || ',';
		locale.numberFormatting.currency.before = true;
		locale.numberFormatting.currency.symbol = $context.find('dd.tx2').data('currency') || '$';
		try {
			var price = (!_.isEmpty(userVehicleData.price)) ? userVehicleData.price : car.price;
		} catch (e) {
			mrm.util.log(e)
		}

		price = (price + '').replace(/\D/g, ''); // remove non-digit characters
		if(car !== undefined && mrm.util.locale.getCountry().toLowerCase() === "ca") {
			var priceWhere = $context.find('dd.tx2');
			if(car.priceDisclaimer !== undefined && car.priceDisclaimer !== ""){
				priceWhere.html(mrm.util.numberFormat(price, 0, true).replace(' ', '') + car.priceDisclaimer).addClass("priceEh");
			} else {
				priceWhere.html(mrm.util.numberFormat(price, 0, true).replace(' ', ''));
			}

			if(car.regionalPricingString !== "") {
				priceWhere.addClass("priceEh")
				var myParent = priceWhere.parent();
				myParent.addClass("dynPriceEh");
				myParent.data(car.regionalPricingString);
			}
		} else {
			$context.find('dd.tx2').html(mrm.util.numberFormat(price, 0, true).replace(' ', ''));
		}
	}

	function insertCgiUrl($state) {
		var $image = $state.find("img.mm");
		var cgipath = $state.data('cgipath');
		var country = $state.data('country');
		var year = userVehicleData.year;
		var cgiUrl = "";
		cgiUrl += window.location.protocol;
		cgiUrl += cgipath;
		cgiUrl += '?i=' + year;
		cgiUrl += '/' + userVehicleData.mmc;
		cgiUrl += '/' + userVehicleData.mmc + '__' + userVehicleData.peg;
		cgiUrl += '/' + (userVehicleData.configState ? userVehicleData.color : userVehicleData.extColor);
		cgiUrl += 'gmds1'; // image size. can be gmds6,gmds7,gmds8,gmds9
		cgiUrl += '.jpg'; // image type
		cgiUrl += '&v=deg01'; // default image angle.
		cgiUrl += '&std=true&country='; //std is always true
		cgiUrl += country;
		$image.attr("src", cgiUrl);
	}

	function updateShopLinks($state) {
		var $anchorLinks = $state.find("a");
		var cmsLinks = new GmdsCmsLinks();
		var carline = userVehicleData.carline;
		var bodystyle = userVehicleData.bodystyle;
		var year = userVehicleData.year;
		var shopLink = cmsLinks.getCmsPageURL(GmdsCmsLinks.BUILD_YOUR_OWN, undefined, carline, bodystyle, year);
		$anchorLinks.attr("href", shopLink);
	}

	function loadJson(callback) {
		var json_data = {};
		$.getJSON('/bbcdata.json')
			.done(function(data) {
				json_data = data;

			})
			.fail(function(data) {
				mrm.util.log("error");
			}).always(function() {
			// TODO: remove the static data here.
			_json = $.extend(true, {
				"2014/verano/verano": {
					"carlineText": "<span class='Orange' style='color: #F26522;' textcolor='Orange'>2014</span>",
					"smallImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/verano/01_images/2014-buick-verano-baseball-card-carbon-black-metallic-148x83.png",
					"mediumImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/verano/01_images/2014-buick-verano-baseball-card-carbon-black-metallic-227x128.png",
					"largeImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/verano/01_images/2014-buick-verano-baseball-card-carbon-black-metallic-464x261.png"
				},
				"2014/lacrosse/lacrosse": {
					"carlineText": "<span class='Orange' style='color: #F26522;' textcolor='Orange'>2014</span>",
					"smallImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/lacrosse/01_images/2014-buick-lacrosse-baseball-card-quicksilver-metallic-148x83.png",
					"mediumImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/lacrosse/01_images/2014-buick-lacrosse-baseball-card-quicksilver-metallic-227x128.png",
					"largeImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/lacrosse/01_images/2014-buick-lacrosse-baseball-card-quicksilver-metallic-464x261.png"
				},
				"2014/encore/encore": {
					"carlineText": "<span class='Orange' style='color: #F26522;' textcolor='Orange'>2014</span>",
					"smallImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/encore/01_images/2014-buick-encore-baseball-card-cocoa-silver-148x83.png",
					"mediumImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/encore/01_images/2014-buick-encore-baseball-card-cocoa-silver-227x128.png",
					"largeImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/encore/01_images/2014-buick-encore-baseball-card-cocoa-silver-464x261.png"
				},
				"2013/verano/verano": {
					"carlineText": "<span class='Orange' style='color: #F26522;' textcolor='Orange'>2013</span>",
					"smallImage": "",
					"mediumImage": "",
					"largeImage": ""
				},
				"2013/lacrosse/lacrosse": {
					"carlineText": "<span textcolor='Orange' style='color: #F26522;' class='Orange'>2013</span>",
					"smallImage": "",
					"mediumImage": "",
					"largeImage": ""
				},
				"2013/regal/regal": {
					"carlineText": "<span textcolor='Orange' style='color: #F26522;' class='Orange'>2013</span>",
					"smallImage": "",
					"mediumImage": "",
					"largeImage": ""
				},
				"2013/encore/encore": {
					"carlineText": "<span class='Orange' style='color: #F26522;' textcolor='Orange'>2013</span>",
					"smallImage": "",
					"mediumImage": "",
					"largeImage": ""
				},
				"2013/enclave/enclave": {
					"carlineText": "<span class='Orange' style='color: #F26522;' textcolor='Orange'>2013</span>",
					"smallImage": "",
					"mediumImage": "",
					"largeImage": ""
				},
				"2014/regal/regal": {
					"carlineText": "<span class='Orange' style='color: #F26522;' textcolor='Orange'>2014</span>",
					"smallImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/regal/01_images/2014-buick-regal-baseball-card-crystal-red-tintcoat-148x83.png",
					"mediumImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/regal/01_images/2014-buick-regal-baseball-card-crystal-red-tintcoat-227x128.png",
					"largeImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/regal/01_images/2014-buick-regal-baseball-card-crystal-red-tintcoat-464x261.png"
				},
				"2014/enclave/enclave": {
					"carlineText": "<span class='Orange' style='color: #F26522;' textcolor='Orange'>2014</span>",
					"smallImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/enclave/01_images/2014-buick-enclave-baseball-card-champagne-silver-148x83.png",
					"mediumImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/enclave/01_images/2014-buick-enclave-baseball-card-champagne-silver-227x128.png",
					"largeImage": "/content/dam/Buick/north_america/usa/nscwebsite/en/home/bbc_library/2014_bbc_libary/enclave/01_images/2014-buick-enclave-baseball-card-champagne-silver-464x261.png"
				}
			}, json_data);
			if ($.isFunction(callback))
				callback()

		})
	}

	function getJson(year, carline, bodystyle) {
		var key = year + '/' + carline + '/' + bodystyle;
		return _json[key];
	}

	return {
		initMod: _initMod
	};
}(mrm.$);

	+ ( function ( $ ) {

		mrm.cmp = mrm.cmp || {};

		$.extend( mrm.cmp, {

			'ts_smf_2' : {

				'tpl' : [ '12', '13' ],

				'init' : function ( ) {

					if ( $('.modTs_smf_2').length < 1 ) return;

					var	elems = {
						'fb' : $('.modTs_smf_2').children('.service-facebook'),
						'yt' : $('.modTs_smf_2').children('.service-youtube')
					};

					if(elems.fb.length){
					  this.fb.init({
						'user' 	: elems['fb'].data('user').replace(/^.+.com\/()/i, '$1').replace(/[^a-zA-Z 0-9]+/g,''),
						'count'	: elems['fb'].data('count')
					  });
					}

					if(elems.yt.length){
					  this.yt.init({
						'user'  : elems['yt'].data('user').replace(/^.+.com\/()/i, '$1').replace(/[^a-zA-Z 0-9]+/g,''),
						'count' : elems['yt'].data('count')
					  });
					}

				},

				'social' : {

					'relative_time' : function ( date ) {

						var
							relative_to = (arguments.length > 1) ? arguments[1] : new Date(),
							delta = parseInt((relative_to.getTime() - date) / 1000, 10),
							r = delta < 1 ? 'just now' :
								delta < 60 ? delta + ' seconds ago' :
								delta < 120 ? 'about a minute ago' :
								delta < ( 45 * 60 ) ? 'about ' + ( parseInt( delta / 60, 10 ) ).toString() + ' minutes ago' :
								delta < ( 2 * 60 * 60 ) ? 'about an hour ago' :
								delta < ( 24 * 60 * 60 ) ? 'about ' + ( parseInt( delta / 3600, 10 ) ).toString() + ' hours ago' :
								delta < ( 48 * 60 * 60 ) ? 'about a day ago' :
								'about ' + ( parseInt( delta / 86400, 10 ) ).toString() + ' days ago'
						;
						return r;

					},

					'parse_date' : function ( date_str ) {

                                            var parsedDate = Date.parse(date_str.replace(/^([a-z]{3})( [a-z]{3} \d\d?)(.*)( \d{4})$/i, "$1,$2$4$3"));
                                            if(isNaN(parsedDate)){parsedDate = Date.parse(new Date(date_str.replace(/^(\d{4})-(\d{2})-(\d{2})T([\d:]*)(.*)/, "$1/$2/$3 $4$5")));}
                                            return parsedDate;

					}

				},

				'fb' : {

					'getLastFeed' : function ( ) {

						if ( typeof FB !== 'object' ) {
							window.setTimeout( function ( ) { mrm.cmp.ts_smf_2.fb.getLastFeed(); }, 500 );
							return;
						}

						var
							fb = this,
							social = mrm.cmp.ts_smf_2.social,
							template	= fb.feed.clone(),
							count 		= 1,
							templateMsg	= template.find('p'),
							container	= fb.feed.parent()
						;

						FB.api('/' + fb.user + '/?access_token=140461456010309%7CB1UHnRTl3K2zvcUPzm4QRLbBt6I', function ( me ) {
							fb.pageName = me.name;
							fb.thumbnail = (typeof(me.picture) != 'undefined') ?
								me.picture.replace(/_s.jpg/, '_q.jpg') :
								'https://graph.facebook.com/' + fb.user + '/picture';
							fb.tempThumb = template.children('.thumbnail');
							fb.tempThumb.find('a').attr('href', 'http://www.facebook.com/' + fb.user);
							$('.modTs_smf_2 .service-facebook dt a').attr('href', 'http://www.facebook.com/' + fb.user);
							fb.tempThumb.find('img').attr('src', fb.thumbnail).attr('height', 50).attr('width', 50);
						});

						FB.api('/' + fb.user + '/posts/?access_token=140461456010309%7CB1UHnRTl3K2zvcUPzm4QRLbBt6I', function ( feedsData ) {

							container.empty();

							$.each( feedsData.data, function ( i, feed ) {
								if ( feed.from.name.toLowerCase() === fb.pageName.toLowerCase() && typeof feed.message !== 'undefined' ) {
									templateMsg.html( '<a href="http://www.facebook.com/' + fb.user + '">' + fb.pageName + '</a> ' + feed.message + '<span class="time">' + social.relative_time( social.parse_date( feed.created_time ) ) + '<span>' );
									container.append( template.wrap('<p />').parent().html() );
									if ( count++ === fb.count ) return false;
								}
							});

							if ( count === 1 ) {
								templateMsg.html('Last ' + fb.pageName + ' post not retrieved.');
								container.append( template );
							}

						});

					},

					'init' : function ( obj ) {

						this.feed	= $('.modTs_smf_2').children('.service-facebook').find('.facebook-feed');
						this.user	= obj.user;
						this.count	= Math.abs( obj.count ) > 10 ? 10 : Math.abs( obj.count );

						mrm.conf.util.sharing.facebookAppId = '140461456010309';
						mrm.util.sharing.loadFacebook( mrm.cmp['ts_smf_2'].fb.getLastFeed() );

					}

				},

				'yt' : {


					'user' : '',

					'addCommas' : function ( s ) {
						s += '';
						x = s.split('.');
						x1 = x[0];
						x2 = x.length > 1 ? '.' + x[1] : '';
						var rgx = /(\d+)(\d{3})/;
						while ( rgx.test( x1 ) ) {
							x1 = x1.replace( rgx, '$1' + ',' + '$2' );
						}
						return x1 + x2;
					},

					'secondsToTime' : function ( secs ) {

						var
							hours = /* Math.floor replaced by */~~( secs / ( 60 * 60 ) ),
							divisor_for_minutes = secs % ( 60 * 60 ),
					    	minutes = /* Math.floor replaced by */~~( divisor_for_minutes / 60 ),
							divisor_for_seconds = divisor_for_minutes % 60,
					 		seconds = /* Math.ceil replaced by */-~(divisor_for_seconds),
					 		h = ( hours === 0 ) ? '' : hours + ':',
					 		m = ( minutes === 0 && hours === 0 ) ? '00:' : ( ( minutes < 10 && hours > 0 ) ? '0' + minutes : minutes ) + ':',
					 		s = ( seconds === '' ) ? '00' : ( ( seconds < 10 ) ? '0' + seconds : seconds )
					 	;
					    return h + m + s;

					},

					'loadVideo' : function ( video ) {

						if ( this.counter++ === this.count ) {
							this.elem.empty().append( this.stories );
							return;
						}

						var
							yt			= this,
						   	title 		= video.title,
						   	content 	= video.contentSnippet,
						   	link 		= video.link,
						   	id 			= video.link.split('.com/watch?v=')[1].split('&')[0]
						;

						$.ajax({
							'url' 		: '//gdata.youtube.com/feeds/api/videos/' + id + '?v=2&alt=jsonc',
							'cache' 	: false,
							'dataType' 	: 'jsonp',
							'success' 	: function ( data ) {
								yt.template.children('.thumbnail').children('a').attr( 'href', link );
								yt.template.children('.thumbnail').children('a').css( 'background-image', 'url(\'http://img.youtube.com/vi/' + id + '/2.jpg\')' );
								yt.template.children('.thumbnail').find('span').html( yt.secondsToTime( data.data.duration ) );
								yt.template.children('.feed-item').html(
									'<a href="' + link + '" target="_blank"><strong>' + title + '</strong></a><br />by ' + yt.user + '<br /><span class="video-views">' + yt.addCommas( data.data.viewCount ) + ' views</span>'
								);
								yt.stories += yt.template[0].outerHTML;
								if ( yt.counter <= yt.count ) yt.loadVideo( yt.feeds.entries[ yt.counter ] );
							}
						});

					},

					'load' : function ( ) {

						var yt = this;
						yt.template = yt.elem.clone(),
						yt.stories = '';
						yt.counter = 0;

						$.jGFeed('https://gdata.youtube.com/feeds/api/users/' + yt.user + '/uploads', function ( feeds ) {
							yt.feeds = feeds;
							yt.loadVideo( yt.feeds.entries[0] );
					 	}, yt.count );

					},

					'init' : function ( obj ) {

						/*
						 * jGFeed 1.0 - Google Feed API abstraction plugin for jQuery
						 *
						 * Copyright (c) 2009 jQuery HowTo
						 *
						 * Licensed under the GPL license:
						 *   http://www.gnu.org/licenses/gpl.html
						 *
						 * URL:
						 *   http://jquery-howto.blogspot.com
						 *
						 * Author URL:
						 *   http://me.boo.uz
						 *
						 */
						(function($){$.extend({jGFeed:function(url,fnk,num,key){if(url==null){return false;}var gurl="http://ajax.googleapis.com/ajax/services/feed/load?v=1.0&callback=?&q="+url;if(num!=null){gurl+="&num="+num;}if(key!=null){gurl+="&key="+key;}$.getJSON(gurl,function(data){if(typeof fnk=="function"){fnk.call(this,data.responseData.feed);}else{return false;}});}});})(jQuery);

						this.count = obj.count || 1;
						this.elem = $('.modTs_smf_2').children('.service-youtube').children('dd').children('div');
						this.user = obj.user || 'chevrolet';
						$('.modTs_smf_2 .service-youtube dt a').attr('href', 'http://www.youtube.com/' + this.user);
						this.load();

					}

				}

			}

		});

	}) ( mrm.$ );(function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		ts_story_1: {          
			/**
			 * JS for component story_browser
			 * 
			 * @param {String} c DOM Context
			 */

			init: function(c) {    
				mrm.util.log('[story_browser] Context: ' + c);
				
				$('.modTs_story_1 a').removeAttr('onclick');
			}
		}
	});
}(mrm.$));;(function($) {
	mrm.mod.Ut_cookie_privacy_1 = mrm.mod.AbstractMod.extend({

		events: {
			"click a.deny": "onDeny",
			"click a.allow": "onAllow",
			"click a.toggle": "onToggle"
		},

		options: {
			noUserConsentMode: false // GMDSPLM-9637 
		},

		prepare: function() {
			var self = this;
			self.options.noUserConsentMode = self.$ctx.hasClass('noUserConsent');
			if (!mrm.util.cookie.cookiesEnabled()) return;

			if (mrm.util.cookie.checkSilentConsent(self.options.noUserConsentMode)) {
				// cookie-notice was already displayed to the user
				self.$ctx.addClass('ui-state-minimized');
			}
			
			/*else if (self.options.noUserConsentMode) {
				// hide after timeout
				self.timeoutID = window.setTimeout(function() {
					self.$ctx.addClass('ui-state-minimized');
				}, self.cfg.adviceDisplayTime * 1000);
			}*/

			// tracking-provider				
			var provider = mrm.util.cookie.getConfirmedTrackingProvider();
			if (!self.options.noUserConsentMode && provider !== null) {
				if (provider.length > 0) {
					this.$ctx.addClass('ui-helper-hidden');
				} else {
					this.$ctx.addClass('ui-state-minimized');
					this.$ctx.find('a.deny').addClass('ui-state-active');
				}
			}
			
			this.$ctx.addClass('jsReady');
			mrm.util.cookie.setPrivacyShownFlag();
		},

		onDeny: function(event) {
			event.preventDefault();
			mrm.util.cookie.denyTrackingProvider();
			this.$ctx.addClass('ui-state-minimized');
			this.$ctx.find('a.deny').addClass('ui-state-active');
		},
		
		onAllow: function(event) {
			event.preventDefault();
			mrm.util.cookie.allowTrackingProvider();
			this.$ctx.addClass('ui-helper-hidden');
			this.$ctx.find('a.allow').addClass('ui-state-active');
		},

		onToggle: function(event) {
			event.preventDefault();
			this.$ctx.toggleClass('ui-state-minimized');
		}

	});
})(mrm.$);;(function($) {
	mrm.mod.Ut_ln_1 = mrm.mod.AbstractMod.extend({

		prepare: function() {
			var self = this;

			self.$ctx.find('a.print').on('click.utln1', function(e) {
				e.preventDefault();
				mrm.util.print();
			});

		}
	});
})(mrm.$);(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		ut_ln_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';						
				
				//Tracking for links
				$mod.find('a').on(clickOrTouch, function(){
					var linkname = $(this).text()
					mrm.util.trackEvent("click_cta", {section: section, linkname: linkname});
				});		
			}				
		}
	});
}(mrm.$));mrm.util.ut_postal_1 = function($) {

	// ut_postal_1 postal code processing
	_processPostal = function (postalCode) {
		if (postalCode) {
			postalCode = postalCode.toUpperCase();
			while (postalCode.length < 6) {
				postalCode += '*';
			}
			$(".postalCodeDisplay").html(postalCode);
			var newRegion = "ONTARIO";
			if (postalCode.match("^T") !== null) {
				newRegion = "ALBERTA";
			} else if (postalCode.match("^V") !== null) {
				newRegion = "BRITISH_COLUMBIA";
			} else if (postalCode.match("^R") !== null) {
				newRegion = "MANITOBA";
			} else if (postalCode.match("^E") !== null) {
				newRegion = "NEW_BRUNSWICK";
			} else if (postalCode.match("^A") !== null) {
				newRegion = "NEW_FOUNDLAND_AND_LABRADOR";
			} else if (postalCode.match("^X") !== null) {
				newRegion = "NORTHWEST_TERRITORIES";
			} else if (postalCode.match("^B") !== null) {
				newRegion = "NOVA_SCOTIA";
			} else if (postalCode.match("^X") !== null) {
				newRegion = "NUNAVUT";
			} else if (postalCode.match("^[PKLMN]") !== null) {
				newRegion = "ONTARIO";
			}else if (postalCode.match("^C") !== null) {
				newRegion = "PRINCE_EDWARD_ISLAND";
			} else if (postalCode.match("^[JGH]") !== null) {
				newRegion = "QUEBEC";
			} else if (postalCode.match("^S") !== null) {
				newRegion = "SASKATCHEWAN";
			} else if (postalCode.match("^Y") !== null) {
				newRegion = "YUKON";
			}
			mrm.util.locale.region = newRegion;

			// update any links with a postalCode parameter
			$('a[href*="postalCode"]').each(function(){
				$(this).attr('href', $(this).attr('href').replace(/postalCode=[^&]+/, 'postalCode='+postalCode.replace(/\*/g, '')));
			});

			// for ts_attr_c1 displaying a price and/or disclaimers
			$(".ts_attr_c1_dynPriceEh").each(function () {
				var self = $(this);
				var myDataEh = self.data();
				if (myDataEh != undefined && !mrm.$.isEmptyObject(myDataEh) && myDataEh[newRegion] != undefined) {
					$(".ts_attr_c1_priceEh").html(myDataEh[newRegion].formattedPrice);
					$(".feeDisclaimerText").html(myDataEh[newRegion].feeDisclaimer);
					$(".cashCreditText").html(myDataEh[newRegion].cashCreditDisclaimer);
					$(".ownerCashText").html(myDataEh[newRegion].ownerCashDisclaimer);
				}
			});

			// for components displaying a price and/or disclaimers
			$(".dynPriceEh").each(function () {
				var self = $(this);
				var myDataEh;

				// check for mod cnt_tbl_fs_1 or cnt_tbl_fs_2 because they are special...
				var fs_table_1 = self.parents(".modCnt_tbl_fs_1").length ? true : false;
				var fs_table_2 = self.parents(".modCnt_tbl_fs_2").length ? true : false;
				var visualizer = self.parents(".modMm_visualizer_1").length ? true : false;

				if (visualizer) {
					myDataEh = self.data("Regions");
					$.each(self.find("li a"), function () {
						var myself = $(this);
						var mySeries = myself.attr("id");
						if (myDataEh != undefined && !$.isEmptyObject(myDataEh) && myDataEh[mySeries] != undefined) {
							myself.attr("data-cost", myDataEh[mySeries][newRegion].unFormattedPrice);
							myself.data("cost", myDataEh[mySeries][newRegion].unFormattedPrice);
							myself.parent().find("#" + mySeries + "_price").html(myDataEh[mySeries][newRegion].formattedPrice + myDataEh[mySeries][newRegion].priceDisclaimer);
							$(".modMm_visualizer_1 .rp").html($(myDataEh[mySeries][newRegion].priceDisclaimer).html());
						}
					});
					mrm.cmp.mm_visualizer_1.updateVehicleCaption($("div.mod.modMm_visualizer_1.mode_standard"));
				} else if (fs_table_1) {
					myDataEh = $(".tbl").data();
					var mySeries = self.attr("id");
					if (myDataEh != undefined && !$.isEmptyObject(myDataEh) && myDataEh[mySeries] != undefined) {
						self.find(".priceEh").html(myDataEh[mySeries][newRegion].formattedPrice);
						self.find("#feeDisclaimer").html(myDataEh[mySeries][newRegion].feeDisclaimer);
						self.find("#cashCreditDisclaimer").html(myDataEh[mySeries][newRegion].cashCreditDisclaimer);
						self.find("#ownerCashDisclaimer").html(myDataEh[mySeries][newRegion].ownerCashDisclaimer);
					}
				} else if (fs_table_2) {
					myDataEh = $("#featuresDiv").data();
					if (myDataEh != undefined && !$.isEmptyObject(myDataEh) && myDataEh["Regions"] != undefined && !self.hasClass("ui-helper-hidden")) {
						var mySeries = self.attr("data-seriescode");
						self.find(".priceEh").html(myDataEh["Regions"][mySeries][newRegion].formattedPrice);
						self.find(".feeText").html(myDataEh["Regions"][mySeries][newRegion].feeDisclaimer);
						self.find(".cashCredit").html(myDataEh["Regions"][mySeries][newRegion].cashCreditDisclaimer);
						self.find(".ownerCash").html(myDataEh["Regions"][mySeries][newRegion].ownerCashDisclaimer);
					}
				} else {
					myDataEh = self.data();
					if (myDataEh != undefined && !$.isEmptyObject(myDataEh) && myDataEh[newRegion] != undefined) {
						self.find(".priceEh").html(myDataEh[newRegion].formattedPrice);
						self.find("#feeDisclaimer").html(myDataEh[newRegion].feeDisclaimer);
						self.find("#cashCreditDisclaimer").html(myDataEh[newRegion].cashCreditDisclaimer);
						self.find("#ownerCashDisclaimer").html(myDataEh[newRegion].ownerCashDisclaimer);
					}
				}
			});

			// for Footer
			var changeRegion = $.Event("newRegionEh", {region: newRegion});
			$("body").trigger(changeRegion);
		}
	};

	/*
	 // Trigger this event to update cms pricing, <postalCode> needs to be replaced with a valid postal code,
	 // it is also expected that the cookie_customer_location cookie has already been updated
	 var clippedChangeRegion = $.Event("newClippedRegionEh", {postalCode: <postalCode>});
	 $("body").trigger(clippedChangeRegion);
	 */
	$("body").on('newClippedRegionEh', function(e){
		var postalCode = e.postalCode;
		postalCode = postalCode.toUpperCase();
		while (postalCode.length < 6) {
			postalCode += '*';
		}
		mrm.util.ut_postal_1.processPostal(postalCode);
	});

	// ut_postal_1 postal code processing
	_init = function() {

		// only Canada has dynamic prices by region
		if (mrm.util.locale.getCountry().toLowerCase()==="ca") {
			$("body").on("click", ".postalPrompt", function (e) {
				var selfParent = $(this).parent();
				if (selfParent.find(".postalInput").is(':visible') && !$(e.target).is('.postalInput, .postalInput *')) {
					selfParent.find(".postalInput").hide();
					selfParent.find(".postalPrompt").show();
					$(document).off('mousedown.postalInput');
					$(document).off('keypress.k13');
				} else {
					selfParent.find('.postalInput').show(50, function () {
						$(document).on('click.postalCodeBlur', function (e) {
							if (selfParent.find('.postalInput').is(':visible') && !$(e.target).is('.postalInput, .postalInput *')) {
								selfParent.find('.postalInput').hide();
								selfParent.find('.postalError').hide();
								selfParent.find('.postalPrompt').show();
								$(document).off('click.postalCodeBlur');
								$(document).off('mousedown.postalInput');
								$(document).off('keypress.k13');
							}
						});
					});
					selfParent.find('.postalPrompt').hide();
					selfParent.find(".postalText").focus().val('');
				}

				selfParent.find('.postalInput').find('button').on('mousedown.postalInput', function (e) {
					var postalCode = selfParent.find('.postalText').val().toUpperCase();
					postalCode = postalCode.replace(/\s+/g, '');
					handleNewPostalCode(postalCode);
				});

				selfParent.find('.postalText').on("keypress.k13", function (event) {
					var keycode = (event.keyCode ? event.keyCode : event.which);
					if (keycode == '13') {
						var postalCode = selfParent.find('.postalText').val().toUpperCase();
						postalCode = postalCode.replace(/\s+/g, '');
						handleNewPostalCode(postalCode);
					}
				});

				function handleNewPostalCode(postalCode) {
					if (mrm.util.location.setLocation(postalCode) === false) {
						selfParent.find('.postalError').show();
					} else {
						selfParent.find('.postalInput').hide();
						selfParent.find('.postalError').hide();
						selfParent.find('.postalPrompt').show();
						$(document).off('click.postalCodeBlur');
						$(document).off('mousedown.postalInput');
						$(document).off('keypress.k13');
						mrm.util.location.setLocation(postalCode);
						while (postalCode.length < 6) {
							postalCode += '*';
						}
						mrm.util.ut_postal_1.processPostal(postalCode);
					}
				}
			});
		}

		var postalCode = mrm.util.location.getPostalCode();
		mrm.util.ut_postal_1.processPostal(postalCode);

	}

	return {
		/**
		 * Utility initialization. Checks country and language, and then searches _config
		 * for an available configuration. If one is available, the utility is setup to
		 * use that configuration. Calls private _init method directly.
		 *
		 * @public method init
		 */
		init: _init,

		/**
		 * Handles pulling postal code data from both platform cookie and Akamai cookie. Will only pull
		 * from Akamai cookie if configured to be enabled for the current market. Calls _getLocation
		 * directly.
		 *
		 * @public method getPostalCode
		 * @return {String, Boolean} Returns value as string if available. Returns false if not available.
		 */
		processPostal: _processPostal
	}
}(mrm.$);
(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        ut_zip_1 : {
            init: function(c) {

                var $ctx = $('.ut_zip_1');
                var $zipInput = $ctx.find("input");

                if (!$ctx.length) { return; };

                // remove browser validation. sepcifically removes the 'required' and 'pattern' attr's
                // from firing in browsers where validation attr's are allowed
                $ctx.find('form').attr('novalidate', 'novalidate');

                if (mrm.util.cookie.get("cookie_customer_location") !== undefined && mrm.util.cookie.get("cookie_customer_location") !== null) {
                    var postalCookie = $.parseJSON(mrm.util.cookie.get("cookie_customer_location"));
                    var postalCode = postalCookie.zipcode;
                    $zipInput.attr('value', postalCode);
                }

                mrm.cmp.ut_zip_1.listeners($zipInput);
            },

            postal_validate: function(zip) {
                var htmlLang = $('html').attr('lang');
                if  (htmlLang === 'en-US' &&  (typeof(zip * 1) === 'number')) {
                    var validate = false;
                    try {
                        mrm.cmp.zc.validate(zip , function(){}, false);
                        var validate = true;
                    } catch(err) {
                        var validate = false;
                        mrm.util.log("error "+ err.message);
                    }
                    if(validate){
                        mrm.util.cookie.set("cookie_customer_location", '{"zipcode":"' + zip +'"}', {json:true});
                    }
                }
                else {
                    mrm.util.cookie.set("cookie_customer_location", '{"zipcode":"' + zip +'"}', {json:true});
                }
            },

            listeners: function($zipInput) {
                var initialValue = $zipInput.val();
                var initialStyle = $zipInput.css('borderColor');
                $zipInput.on('focus', function(evt) {
                    var $this = $(this);
                    $this.css({'borderColor': initialStyle});
                    if ($this.val() === initialValue) {
                        $this.val('');
                    }
                }).on('blur', function(evt) {
                    var $this = $(this);
                    if ($this.val() === "") {
                        $this.val(initialValue);
                    }
                });

                $zipInput.closest('form').on('submit', function(evt) {
                    var $indexZip = $(evt.target).find('input');
                    var zip = $indexZip.val();
                    if(zip){
                        if($indexZip.attr('pattern')) {
                            var regPatt = new RegExp($indexZip.attr("pattern"));
                            if(regPatt.test(zip)) {
                                mrm.cmp.ut_zip_1.postal_validate(zip);
                                return;
                            } else {
                                evt.preventDefault();
                                $indexZip.parents('fieldset').find('label').not('.postal_error').addClass('hidden');
                                $indexZip.parents('fieldset').find('.postal_error').removeClass('hidden');
                                $indexZip.css({
                                    'borderColor': '#ff0000'
                                });
                                return;
                            }
                        }
                            mrm.cmp.ut_zip_1.postal_validate(zip);
                    } else {
                            evt.preventDefault();
                            $indexZip.parents('fieldset').find('label').not('.postal_error').addClass('hidden');
                            $indexZip.parents('fieldset').find('.postal_error').removeClass('hidden');
                            $indexZip.css({
                                'borderColor': '#ff0000'
                            });
                    }

                });
            }
        }
    });
}(mrm.$));
(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		Vi_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				//$mod.find('a').removeAttr('onclick');

				// tracking for Accessories landing page
				$mod.find("h3.vt").on(clickOrTouch, function () {
					var linkname = $.trim($(this).text());
					mrm.util.trackEvent("click_cta", {section : section, linkname : "link:" + linkname});
				});
				
				// tracking for image
				$mod.find("a > img.mm").on(clickOrTouch, function(){
					var linkname = $(this).attr("src");
					if (typeof(linkname) !== "undefined") {
						linkname = linkname.substr( linkname.lastIndexOf('/') + 1 );
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'image:' + linkname});
				});
				
				// tracking for MOV links
				$mod.find(".further a").on(clickOrTouch, function(){
					var linkname = $.trim($(this).text());
					if ($(this).hasClass("btn_prim") == true) {
						linkname = "button:" + linkname;
						} else {
						linkname = "link:" + linkname;
					}
					mrm.util.trackEvent("click_cta", {section: section, linkname: linkname});
				});

				// tracking for MOV links
				$mod.find(".further ul li a").on(clickOrTouch, function(){
					var linkname = $.trim($(this).text());
					mrm.util.trackEvent("click_cta", {section: section, linkname: "link:" + linkname});
				});

				// tracking for MOV links
				$mod.find(".ts_ln_2").on(clickOrTouch, function(){
					var linkname = $.trim($(this).text());
					mrm.util.trackEvent("click_cta", {section: section, linkname: "link:" + linkname});
				});
			}
		}
    });
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		vi_2: {
			init: function(c) {
				// add net pricing cluetip
				$(".vi_2 dl dd a[cluetip-title*=' ']").addClass("cluetip_cnt_well_1");
				var b = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
					titleAttribute: "cluetip-title",
					activation: "click"
				});
				$('.cluetip_cnt_well_1').cluetipWrap(b);
			}
		}
	});
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		vi_2: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';						
				
				//Tracking for "baseball card" BYO button	
				//$mod.find('div.further a.btn_prim.shppngLnk').removeAttr('onclick');
				$mod.find('div.further a.btn_prim.shppngLnk').on(clickOrTouch, function(){
					var linkname = $(this).text();
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'baseball card:button:' + linkname });
				});		

				//Tracking for "baseball card" links
				//$mod.find('div.further ul.ll .shppngLnk').removeAttr('onclick');
				$mod.find('div.further ul.ll .shppngLnk').on(clickOrTouch, function(){
					var linkname = $(this).text();
					mrm.util.trackEvent("click_cta", {section: section, linkname: 'baseball card:link:' + linkname });
				});		

			}				
		}
	});
}(mrm.$));(function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {           
		vi_3: {   
				/**
			 * JS for component vi_3
			 * 
			 * @param {String} c DOM Context
			 */
			initMod: function($mod) {
				
				var options = $.extend({}, mrm.conf.cmp.vi_3, { label:{} });
				if( mrm.lbl.cmp && mrm.lbl.cmp.vi_3 )
				{
					if(mrm.lbl.cmp.vi_3.textIndicator) options.label.textIndicator = mrm.lbl.cmp.vi_3.textIndicator;
					
					if(mrm.lbl.cmp.vi_3.images) options.label.images = mrm.lbl.cmp.vi_3.images;
				}
				if($mod.has('.leftColumn').length) {
					$mod.find('.leftColumn').fancyCarousel(options);
				}
				else {
					$mod.fancyCarousel(options);					
				}
				
			}
		}
	});
}(mrm.$));(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		vi_3: {
			init: function(c) {
				// add net pricing cluetip
				$(".modVi_3 div dl dd a[cluetip-title*=' ']").addClass("cluetip_vi_3");
				var b = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
					titleAttribute: "cluetip-title",
					activation: "click"
				});
				$('.cluetip_vi_3').cluetipWrap(b);
			}
		}
	});
}(mrm.$));/*
	C 2009 by Maximilian Franzke, MRM Worldwide
*/
(function($) { 
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		vi_7: {
			/**
			 * JS for component vi_7
			 * 
			 * @param {String} c DOM Context
			 */
			
			init: function(c) {

				mrm.util.log('[mrm.cmp.vi_7] Context: ' + c);

				if ($('.modVi_7').length == 0) return;

				var config = $.extend(true, {}, mrm.conf.plugin.cluetip, {
					prepareTitleAttr: true
				});

				var $imgs = $('.modTs_attr_1 > figure > .img', '.modVi_7');
				($imgs).cluetipWrap(config);

				// net pricing cluetips
				$(".modVi_7 dl dd a[cluetip-title*=' ']").addClass("cluetip_vi_7");
                var cluetipCfg = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
                    titleAttribute: "cluetip-title",
                    activation: "click"
                });
                $('.cluetip_vi_7').cluetipWrap(cluetipCfg);
			}
		}
	});
}(mrm.$));(function($){
		$('.modVi_7 .further a').each(function(){
	         if ($(this).index() > 0){
	            if( $(this).is(':last-child') ){
	                $(this).removeClass('btn_prim').addClass('btn_sec');
	              }       
	        }   
	    });
})(mrm.$);;(function($) {
	mrm.mod.Vi_complist_1 = mrm.mod.AbstractMod.extend({

		$placeholder: $(),
		$inner: $(),
		$addRemaining: $(),
		$compare: $(),
		
		listItems: [],
		slotManager: [],
		collapsed: false,
		isSticky: false,
		activeIds: null,
		entryTemplate: null,

		prepare: function() {
			var self = this;

			self.listItems = _.map(self.$ctx.find('ul > li'), function(item){
				return $(item);
			}, self);
			
			self.$inner = self.$ctx.find('.inner');
			self.$placeholder = $('<div class="placeholder"></div>');
			self.$ctx.append(self.$placeholder.hide());
			self.$addRemaining = self.$inner.find('.addRemaining');
			self.$compare = self.$inner.find('.compare');
			
			self.entryTemplate = Handlebars.compile(self.$ctx.find('script.prototype.entry').html());
			self.slotManager = new mrm.util.SlotManager(self.listItems.length);
			self.setBindings();
			
			self.updateCompareButton();
		},

		setBindings : function() {
			var self = this;
			$(window).on('scroll', _.throttle($.proxy(self.onScroll, self), 100));
			
			self.$inner.find('.toggle').on('click', $.proxy(self.toggleViewMode, self));
			
			self.$compare.on('click', $.proxy(function(event){
				event.preventDefault();
				if( self.slotManager.length() > 1 ) {
					$.eventDispatcher.trigger('HMC_changeMode', { mode:'compare'});
				}
			}, self));
			
			self.$addRemaining.on('click',  $.proxy(function(){
				$.eventDispatcher.trigger('HMC_clearAll');
				$.eventDispatcher.trigger('HMC_addItem', {
					items: self.activeIds
				});
			}, self));
			
			self.$inner.find('ul').on('click', 'a.remove', $.proxy(function(event){
				event.preventDefault();
				$.eventDispatcher.trigger('HMC_removeItem', {
					items: [$(event.target).data('id')]
				});
			}, self));
			
			$.eventDispatcher.on('HMC_changeMode', $.proxy(function(event, data){
				self.$ctx.toggle(data.mode === 'choose');
			}, self));
			
			$.eventDispatcher.on('HMC_update', $.proxy(function(event, data){
				self.onScroll();
				
				self.$addRemaining.toggle(data.activeIds.length < 4);
				self.activeIds = data.activeIds;
			}, self));
			
			$.eventDispatcher.on('HMC_addItem', $.proxy(self.onAddItem, self));
			$.eventDispatcher.on('HMC_removeItem', $.proxy(self.onRemoveItem, self));

			$.eventDispatcher.on('HMC_showList', $.proxy(function(){
				self.expand();
			}, self));
			
			$.eventDispatcher.on('HMC_clearAll', $.proxy(function(event, data){
				_.each(self.listItems, function($item){
					$item.html('');
				}, self);
				self.slotManager.clearAll();
			}, self));
		},

		onScroll: function() {
			var self = this;
			var viewportOffsetBottom = $(window).scrollTop() + $(window).height();
			if (!self.isSticky && viewportOffsetBottom < self.$ctx.offset().top) {
				self.$ctx.addClass('sticky');
				self.isSticky = true;
				self.$placeholder.css('height', self.$inner.outerHeight(true)).show();
				self.collapse();
			}
			if (self.isSticky && viewportOffsetBottom > (self.$ctx.offset().top + self.$inner.height())) {
				self.$ctx.removeClass('sticky');
				self.isSticky = false;
				self.$placeholder.hide();
				self.expand();
			}
		},
		
		onAddItem: function(event, data) {
			var self = this;
			_.each(data.items, function(item) {
				var index = self.slotManager.add(item);
				if(index >= 0) {
					var tplData = _.extend({
						id: item
					}, mrm.data.vi_complist_1[item]);
					self.listItems[index].html(self.entryTemplate(tplData));
				}
			}, self);
			
			self.updateCompareButton();
			self.expand();
			
			$(self.listItems).each(function(){
				$(self).height('auto');
			});
			$(self.listItems).equalHeights();
		},
		
		onRemoveItem: function(event, data) {
			var self = this;
			_.each(data.items, function(item) {
				var index = self.slotManager.remove(item);
				$(self.listItems[index]).html('');
			}, self);
			self.updateCompareButton();
		},
		
		toggleViewMode: function(event) {
			var self = this;
			if (event) {
				event.preventDefault();
			}
			
			if (self.collapsed) {
				self.expand();
			} else {
				self.collapse();
			}
			
			self.$placeholder.css('height', self.$inner.outerHeight(true));
		},
		
		updateCompareButton: function() {
			var self = this;
			self.$compare.toggleClass('ui-state-disabled', self.slotManager.length() < 2);
		},
		
		expand: function() {
			var self = this;
			self.collapsed = false;
			self.$ctx.removeClass('collapse');
		},
		
		collapse: function() {
			var self = this;
			self.collapsed = true;
			self.$ctx.addClass('collapse');
		}

	});
})(mrm.$);;(function($) {
	mrm.mod.Vi_group_1 = mrm.mod.AbstractMod.extend({
		prepare: function() {
			this.$ctx.find('.modVi_1 > dl.tx_price').equalHeights();
		}
	});
})(mrm.$);;(function($) {
	mrm.mod.Vi_group_selection_1 = mrm.mod.AbstractMod.extend({
		prepare: function() {
			var $listVi1 = this.$ctx.find('.modVi_1');
			for ( var i = 0; i < $listVi1.length; i+=6) {
				$listVi1.slice(i, i+6).equalHeights();
			}
		}
	});
})(mrm.$);(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		vi_hmc_1: {
			init: function(c) {
				// add net pricing cluetip
				$(".modVi_hmc_1 .content dl dd a[cluetip-title*=' ']").addClass("cluetip_vi_hmc_1");
				var b = $.extend({}, mrm.conf.plugin.cluetip || {}, {
                    sticky: true,
					titleAttribute: "cluetip-title",
					activation: "click"
				});
				$('.cluetip_vi_hmc_1').cluetipWrap(b);
			}
		}
	});

	$('.modVi_hmc_1 ul.ll li').each(function() {
		if ($(this).index() > 0){
			if( $(this).is(':last-child') ){
				$(this).children('a').removeClass('btn_prim').addClass('btn_sec');
			}
		}
	});
})(mrm.$);/*
 *  2013 by MRM Worldwide
 */
/*
 * @author Tony.Herford
 * @name wl_1.all
 */
(function($) {
	var api;
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		wl_1: {
			initMod: function($mod) {
				mrm.util.log("[mrm.cmp.search_again] Context: " + $mod);

				var $wl_1 = $('.wl_1'),
					$wl_1_AF = $wl_1.find('.avaialble-features'),
					$wl_1_FL = $wl_1_AF.find('.feature-list'),
					self = this;

				////// Bind events
				// remove feature from list
				$wl_1.find('> .feature-list').on('click', 'li a.remove-btn', function() {
					var $this = $(this);
					mrm.util.vehicleConfig.removeOption($this.parent().data('rpo'));
				});

				// add feature to list
				$wl_1_FL.find('li').on('click', function() {
					var $this = $(this);
					mrm.util.vehicleConfig.addOption($this.data('rpo'), $this.find('p').text(), $this.find('img').attr('src'));
				});

				// expand and collapse the available features panel
				$wl_1.find('.foot').on('click', function() {
					if ($wl_1_AF.is(':visible')) {
						$(this).removeClass('open');
						$wl_1_AF.stop().animate({'width': 0, 'left': 0}, 500, 'easeInCirc', function() {
							$wl_1_AF.hide();
							mrm.cmp.wl_1.equalize(true);
						});
					} else {
						$(this).addClass('open');
						$wl_1_AF.css({'left': -1, 'width': 1}).show();
						mrm.cmp.wl_1.equalize(true, function() {
							$wl_1_AF.stop().animate({'width': 700, 'left': -700}, 500, 'easeOutCirc');
						});
					}
				});
				$wl_1_AF.find('> .label').on('click', function() {
					$wl_1.find('.foot').removeClass('open');
					$wl_1_AF.stop().animate({'width': 0, 'left': 0}, 500, 'easeInCirc', function() {
						$wl_1_AF.hide();
						mrm.cmp.wl_1.equalize(true);
					});
				});

				//setup event listeners
				$.eventDispatcher.on('vehicle_option_change', this.addRemove);
				$.eventDispatcher.on('vehicle_config_load', this.render_list);
				$.eventDispatcher.on('feature_list_toggle', this.toggle_list);

			},
			getImagePath: function(rpo) {
				return $('.wl_1').find('.avaialble-features .feature-list li[data-rpo="' + rpo + '"] img').attr('src');
			},
			render_list: function(name, data) {
				var $list = $('.wl_1').find('> .feature-list'),
					options = mrm.util.vehicleConfig.getCurrentOptions();

				// available options to store in localstorage if not already there
				if(!mrm.util.vehicleConfig.getAvailableOptions().length){
					var list = $('.wl_1').find('.avaialble-features').find('.feature-list').find('li[data-rpo]').map(function(i, el){
						var $this = $(this);
						return {rpo: $this.data('rpo'), description:$this.find('.name').text(), imagePath: $this.find('img').attr('src')};
					}).get();
					mrm.util.vehicleConfig.setAvailableOptions(list);
				}

				$list.empty();
				var buttons = [];
				$.each(options, function() {
					var imagePath = this.img_path || mrm.cmp.wl_1.getImagePath(this.rpo);
					$('.wl_1').find('.avaialble-features').find('.feature-list').find('li[data-rpo="' + this.rpo + '"]').hide()
					buttons.push($('<li/>')
						.append($('<img />', {src: imagePath}))
						.append($('<p class="name" />').text(this.label))
						.append($('<a herf="#" class="remove-btn" />'))
						.attr('data-rpo', this.rpo)[0].outerHTML);
				});
				$list.html(buttons.join(''));

				mrm.cmp.wl_1.equalize();
				mrm.cmp.wl_1.updateCount();
			},
			addRemove: function(name, data) {
				var $list = $('.wl_1').find('> .feature-list');
				if (!$list.length)
					$list = $('.wl_1').find('> .scroll-pane .feature-list');

				var option_info = {label: data.option.label || '', rpo: data.option.rpo, img_path: data.option.img_path};
				if (data.action === 'add') {
					if (!$list.find('li[data-rpo="' + option_info.rpo + '"]').length) {
						var imagePath = this.img_path || mrm.cmp.wl_1.getImagePath(option_info.rpo);
						var $li = $('<li/>')
							.append($('<img />', {src: imagePath}))
							.append($('<p class="name" />').text(option_info.label))
							.append($('<a herf="#" class="remove-btn" />'))
							.attr('data-rpo', option_info.rpo);
						$list.append($li);
					}

					$('.wl_1').find('.avaialble-features').find('.feature-list').find('li[data-rpo="' + option_info.rpo + '"]').hide()

				} else {
					$list.find('li[data-rpo="' + option_info.rpo + '"]').remove();
					$('.wl_1').find('.avaialble-features').find('.feature-list').find('li[data-rpo="' + option_info.rpo + '"]').show()
				}

				if ($list.children().length > 6) {
					mrm.cmp.wl_1.addScrollBars();
				} else {
					mrm.cmp.wl_1.removeScrollBars();
				}

				mrm.cmp.wl_1.equalize();
				mrm.cmp.wl_1.updateCount();
			},
			addScrollBars: function() {
				if ($('.wl_1').is(':visible')) {
					var $list = $('.wl_1').find('> .feature-list');
					if (!$list.length) $list = $('.wl_1').find('> .scroll-pane .feature-list');
					var $scrollPane = {};

					if (!$('.wl_1').find('jspScrollable').length) {
						if ($list.closest('.scroll-pane').length) {
							$scrollPane = $list.closest('.scroll-pane');
						} else {
							$scrollPane = $list.wrap($('<div class="scroll-pane" />')).parent();
						}
						$scrollPane.jScrollPane({contentWidth: 225, verticalGutter: 15, autoReinitialise: true, verticalDragMaxHeight: 48});

						api = $scrollPane.data('jsp');
					} else {
						api.reinitialise();
					}
				}
//				$list = api.getContentPane().find('ul');

			},
			removeScrollBars: function() {
				if (api) {
					api.destroy();
					api = undefined;
				}
			},
			updateCount: function() {
				var $wl_1 = $('.wl_1'),
					$wl_1_AF = $wl_1.find('.avaialble-features'),
					$wl_1_FL = $wl_1_AF.find('.feature-list');

				//update the count
				var featureCount = $wl_1_FL.find('li[data-rpo]').length - mrm.util.vehicleConfig.getCurrentOptionCount();

				$wl_1_AF.find('.count').text(featureCount);
				$wl_1.find('.available-count').text(featureCount);

			},
			equalize: function(animate, callback) {
				var $availableList = $('.wl_1').find('.avaialble-features');
				var $list = $('.wl_1');
				var diff = $list.outerHeight(true) - $list.height();

				// If not animated then just set the elements heights
				if (!animate) {
					$availableList.height('auto');
					$list.height('auto');

					if ($availableList.is(':visible')) {
						if ($list.outerHeight(true) > $availableList.outerHeight(true)) {
							$availableList.height($list.outerHeight() - 1);
						} else {
							$list.height($availableList.outerHeight(true) - diff + 1);
						}
					}
				} else {
					// Get the auto height for element
					$availableList.css('height', 'auto');
					var al_out_hi = $availableList.outerHeight(true);
					$availableList.height(al_out_hi);

					// Get the auto height and auto outer height for element
					var tmpl_h = $list.height();
					$list.css('height', 'auto')
					var ls_height = $list.height();
					var ls_out_hi = $list.outerHeight(true);
					$list.height(tmpl_h);

					// find difference between height and outerheight
					diff = ls_out_hi - ls_height;

					// call the call back if one exists
					function complete() {
						if ($.isFunction(callback)) {
							callback();
						}
					}

					// Animate the list elements
					if ($availableList.is(':visible')) {
						if (ls_out_hi > al_out_hi) {
							$availableList.stop().animate({'height': ls_out_hi - 1}, 300, 'easeOutCirc', complete);
						} else {
							$list.stop().animate({'height': al_out_hi - diff + 1}, 300, 'easeOutCirc', complete);
						}
					} else {
						$list.stop().animate({'height': ls_height}, 300, 'easeInCirc', complete);
					}
				}
			},
			toggle_list: function(name, data) {
				var $list = $(".wl_1"),
					direction = 'up';

				if (data.command === 'open') {
					if (data.gap < 460)
						direction = 'down';

					$list.removeClass('up down').addClass(direction);
					// choose direction
					$list.slideDown(200, 'easeOutQuart', function() {
						var $list = $('.wl_1').find('> .feature-list');
						if (!$list.length)
							$list = $('.wl_1').find('> .scroll-pane > .feature-list');

						if ($list.children().length > 6) {
							mrm.cmp.wl_1.addScrollBars();
						}
					});

					var $win = $(window), startPos = $win.scrollTop();
					$(window).on('scroll.wl_1', function(e) {
						//console.log(e);
						if ($(e.target).is(document)) {
							if (Math.abs(startPos - $win.scrollTop()) >= 200) {
								$.eventDispatcher.trigger('feature_list_closed');
								mrm.cmp.wl_1.toggle_list('toggle_list', {command: 'close'});
								$(window).off('scroll.wl_1');
							}
						}
					});
				} else {
					$list.slideUp(200, 'easeOutQuart', function() {
						$list.find('.avaialble-features').hide();
						$list.find('.foot').removeClass('open');
						$list.height('auto');
						mrm.cmp.wl_1.removeScrollBars();

					});
				}
			}
		}
	})
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		wl_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';

				$mod.find(".btn_nba[title='Build']").on(clickOrTouch, function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "wishlist:build"});
				});

				//Only the first added feature in the wishlist should be tracked
				$mod.find(".avaialble-features ul.feature-list").one(clickOrTouch, "li", function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "wishlist:add"});
				});

				//Only the first removed feature in the wishlist should be tracked
				$mod.find("ul.feature-list").one(clickOrTouch, "li .remove-btn", function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "wishlist:remove"});
				});
			}
		}
	});
}(mrm.$));/*
 *  2013 by MRM Worldwide
 */
/*
 * @author Tony.Herford
 * @name wl_feature_1.all
 */
(function($) {
	mrm.cmp = mrm.cmp || {};
	$.extend(mrm.cmp, {
		wl_feature_1: {
			init: function(c){
				if(!$('.wl_feature_1').length) return false;

				if(mrm.util.cookie.get('wl_feature_help') !== 'true'){
					$('.modWl_feature_1 ~ .wl_feature_help').show();
				}

				mrm.util.cookie.set('wl_feature_help', 'true', {'path':'/'});


				$.eventDispatcher.on('vehicle_option_change', this.render);
				$.eventDispatcher.on('vehicle_config_load', this.render_all);
			},
            initMod: function($mod) {
                mrm.util.log("[mrm.cmp.wl_feature_1] Context: " + $mod);
				var feature_list = mrm.util.vehicleConfig;
				/// add close button to the help text box
				$mod.next('.wl_feature_help').css({top: $mod.position().top + $mod.outerHeight(true) + 10});
				var $helpBtn = $('<a herf="#" class="exit_btn" />').on('click', function(){
					/// close them all
					$('.modWl_feature_1 ~ .wl_feature_help').hide();
				});

				$mod.next('.wl_feature_help').find('div:eq(0)').after($helpBtn);

				$mod.find('.btn_nba').on('click', function(e){
					e.preventDefault();
					var $this = $(this);
					if($this.find('span:visible').hasClass('add')){
						feature_list.addOption($this.data('rpo'), $this.parent().find('.feature-description').text(),  mrm.cmp.wl_1.getImagePath($this.data('rpo')));
					}else{
						feature_list.removeOption($this.data('rpo'));
					}
				});


            },
			render:function(name, data){
				if(data.action === 'add'){
					$('.btn_nba[data-rpo = "'+data.option.rpo+'"]').addClass('remove');
				}else{
					$('.btn_nba[data-rpo = "'+data.option.rpo+'"]').removeClass('remove');
				}
			},
			render_all: function(name, data){
				$('.btn_nba[data-rpo]').each(function(){
					var $this = $(this);
					if(mrm.util.vehicleConfig.optionAdded($this.data('rpo'))){
						$this.addClass('remove');
					} else {
						$this.removeClass('remove');
					}
				});
			}
        }
    })
}(mrm.$));(function($) {
	mrm.track = mrm.track || {};
	$.extend(mrm.track, {
		wl_feature_1: {
			initTrack: function($mod, section){
				var clickOrTouch = (mrm.util.touchDevice()) ? 'touchstart' : 'click';			

				$mod.find(".btn_nba span.add").on(clickOrTouch, function(){
					mrm.util.trackEvent("click_cta", {section: section, linkname: "wishlist:add"});
				});
				$mod.find(".btn_nba span.remove").on(clickOrTouch, function() {
					mrm.util.trackEvent("click_cta", {section: section, linkname: "wishlist:remove"});
				});
			}
		}
	});
}(mrm.$));/*
 *  2013 by MRM Worldwide
 */
/*
 * @author Tony.Herford
 * @name wl_nav_1.all
 */
(function($) {
    mrm.cmp = mrm.cmp || {};
    $.extend(mrm.cmp, {
        wl_nav_1: {
            initMod: function($mod) {
                mrm.util.log("[mrm.cmp.search_again] Context: " + $mod);
				var self = this;

				$mod.on('click', self.toggle_list);
				// disable the anchor tag
				$mod.find('a').on('click', function(e){e.preventDefault()})

				$.eventDispatcher.on('vehicle_option_change', this.render_count);
				$.eventDispatcher.on('vehicle_config_load', this.render_count);
				$.eventDispatcher.on('feature_list_closed', function(){
					$mod.removeClass('open');
				});
            },
			toggle_list: function(e){
				var $this = $(this);

				if($this.hasClass('open')){
					$this.removeClass('open');
					$.eventDispatcher.trigger('feature_list_toggle', 'close');
					$(window).off('scroll.wl_1');
				}else{
					var gap = $this.offset().top - $(window).scrollTop();
					$this.addClass('open')

					$.eventDispatcher.trigger('feature_list_toggle', {command:'open', gap:gap});
				}
			},
			render_count: function(name, data){
				var $wl_nav_1 = $('.wl_nav_1', '#nav_anchor_c1_1');
				$wl_nav_1.find('p.tx').text(mrm.util.vehicleConfig.getCurrentOptionCount());
			}
        }
    })
}(mrm.$));